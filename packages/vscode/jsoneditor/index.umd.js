(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.wysiwyg = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __decorate$1(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    /**
     * A reference to globalThis, with support
     * for browsers that don't yet support the spec.
     * @public
     */
    const $global = (function () {
        if (typeof globalThis !== "undefined") {
            // We're running in a modern environment.
            return globalThis;
        }
        if (typeof global !== "undefined") {
            // We're running in NodeJS
            return global;
        }
        if (typeof self !== "undefined") {
            // We're running in a worker.
            return self;
        }
        if (typeof window !== "undefined") {
            // We're running in the browser's main thread.
            return window;
        }
        try {
            // Hopefully we never get here...
            // Not all environments allow eval and Function. Use only as a last resort:
            // eslint-disable-next-line no-new-func
            return new Function("return this")();
        }
        catch (_a) {
            // If all fails, give up and create an object.
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {};
        }
    })();
    // API-only Polyfill for trustedTypes
    if ($global.trustedTypes === void 0) {
        $global.trustedTypes = { createPolicy: (n, r) => r };
    }
    /**
     * A readonly, empty array.
     * @remarks
     * Typically returned by APIs that return arrays when there are
     * no actual items to return.
     * @internal
     */
    const emptyArray = Object.freeze([]);

    const updateQueue = [];
    /* eslint-disable */
    const fastHTMLPolicy = $global.trustedTypes.createPolicy("fast-html", {
        createHTML: html => html,
    });
    /* eslint-enable */
    let htmlPolicy = fastHTMLPolicy;
    function processQueue() {
        const capacity = 1024;
        let index = 0;
        while (index < updateQueue.length) {
            const task = updateQueue[index];
            task.call();
            index++;
            // Prevent leaking memory for long chains of recursive calls to `queueMicroTask`.
            // If we call `queueMicroTask` within a MicroTask scheduled by `queueMicroTask`, the queue will
            // grow, but to avoid an O(n) walk for every MicroTask we execute, we don't
            // shift MicroTasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 MicroTasks off the queue.
            if (index > capacity) {
                // Manually shift all values starting at the index back to the
                // beginning of the queue.
                for (let scan = 0, newLength = updateQueue.length - index; scan < newLength; scan++) {
                    updateQueue[scan] = updateQueue[scan + index];
                }
                updateQueue.length -= index;
                index = 0;
            }
        }
        updateQueue.length = 0;
    }
    const marker = `fast-${Math.random().toString(36).substring(2, 8)}`;
    /** @internal */
    const _interpolationStart = `${marker}{`;
    /** @internal */
    const _interpolationEnd = `}${marker}`;
    /**
     * Common DOM APIs.
     * @public
     */
    const DOM = Object.freeze({
        /**
         * Indicates whether the DOM supports the adoptedStyleSheets feature.
         */
        supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) &&
            "replace" in CSSStyleSheet.prototype,
        /**
         * Sets the HTML trusted types policy used by the templating engine.
         * @param policy - The policy to set for HTML.
         * @remarks
         * This API can only be called once, for security reasons. It should be
         * called by the application developer at the start of their program.
         */
        setHTMLPolicy(policy) {
            if (htmlPolicy !== fastHTMLPolicy) {
                throw new Error("The HTML policy can only be set once.");
            }
            htmlPolicy = policy;
        },
        /**
         * Turns a string into trusted HTML using the configured trusted types policy.
         * @param html - The string to turn into trusted HTML.
         * @remarks
         * Used internally by the template engine when creating templates
         * and setting innerHTML.
         */
        createHTML(html) {
            return htmlPolicy.createHTML(html);
        },
        /**
         * Determines if the provided node is a template marker used by the runtime.
         * @param node - The node to test.
         */
        isMarker(node) {
            return node && node.nodeType === 8 && node.data.startsWith(marker);
        },
        /**
         * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
         * @param node - The marker node to extract the index from.
         */
        extractDirectiveIndexFromMarker(node) {
            return parseInt(node.data.replace(`${marker}:`, ""));
        },
        /**
         * Creates a placeholder string suitable for marking out a location *within*
         * an attribute value or HTML content.
         * @param index - The directive index to create the placeholder for.
         * @remarks
         * Used internally by binding directives.
         */
        createInterpolationPlaceholder(index) {
            return `${_interpolationStart}${index}${_interpolationEnd}`;
        },
        /**
         * Creates a placeholder that manifests itself as an attribute on an
         * element.
         * @param attributeName - The name of the custom attribute.
         * @param index - The directive index to create the placeholder for.
         * @remarks
         * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
         */
        createCustomAttributePlaceholder(attributeName, index) {
            return `${attributeName}="${this.createInterpolationPlaceholder(index)}"`;
        },
        /**
         * Creates a placeholder that manifests itself as a marker within the DOM structure.
         * @param index - The directive index to create the placeholder for.
         * @remarks
         * Used internally by structural directives such as `repeat`.
         */
        createBlockPlaceholder(index) {
            return `<!--${marker}:${index}-->`;
        },
        /**
         * Schedules DOM update work in the next async batch.
         * @param callable - The callable function or object to queue.
         */
        queueUpdate(callable) {
            if (updateQueue.length < 1) {
                window.requestAnimationFrame(processQueue);
            }
            updateQueue.push(callable);
        },
        /**
         * Resolves with the next DOM update.
         */
        nextUpdate() {
            return new Promise((resolve) => {
                DOM.queueUpdate(resolve);
            });
        },
        /**
         * Sets an attribute value on an element.
         * @param element - The element to set the attribute value on.
         * @param attributeName - The attribute name to set.
         * @param value - The value of the attribute to set.
         * @remarks
         * If the value is `null` or `undefined`, the attribute is removed, otherwise
         * it is set to the provided value using the standard `setAttribute` API.
         */
        setAttribute(element, attributeName, value) {
            if (value === null || value === undefined) {
                element.removeAttribute(attributeName);
            }
            else {
                element.setAttribute(attributeName, value);
            }
        },
        /**
         * Sets a boolean attribute value.
         * @param element - The element to set the boolean attribute value on.
         * @param attributeName - The attribute name to set.
         * @param value - The value of the attribute to set.
         * @remarks
         * If the value is true, the attribute is added; otherwise it is removed.
         */
        setBooleanAttribute(element, attributeName, value) {
            value
                ? element.setAttribute(attributeName, "")
                : element.removeAttribute(attributeName);
        },
        /**
         * Removes all the child nodes of the provided parent node.
         * @param parent - The node to remove the children from.
         */
        removeChildNodes(parent) {
            for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
                parent.removeChild(child);
            }
        },
        /**
         * Creates a TreeWalker configured to walk a template fragment.
         * @param fragment - The fragment to walk.
         */
        createTemplateWalker(fragment) {
            return document.createTreeWalker(fragment, 133, // element, text, comment
            null, false);
        },
    });

    function spilloverSubscribe(subscriber) {
        const spillover = this.spillover;
        const index = spillover.indexOf(subscriber);
        if (index === -1) {
            spillover.push(subscriber);
        }
    }
    function spilloverUnsubscribe(subscriber) {
        const spillover = this.spillover;
        const index = spillover.indexOf(subscriber);
        if (index !== -1) {
            spillover.splice(index, 1);
        }
    }
    function spilloverNotifySubscribers(args) {
        const spillover = this.spillover;
        const source = this.source;
        for (let i = 0, ii = spillover.length; i < ii; ++i) {
            spillover[i].handleChange(source, args);
        }
    }
    function spilloverHas(subscriber) {
        return this.spillover.indexOf(subscriber) !== -1;
    }
    /**
     * An implementation of {@link Notifier} that efficiently keeps track of
     * subscribers interested in a specific change notification on an
     * observable source.
     *
     * @remarks
     * This set is optimized for the most common scenario of 1 or 2 subscribers.
     * With this in mind, it can store a subscriber in an internal field, allowing it to avoid Array#push operations.
     * If the set ever exceeds two subscribers, it upgrades to an array automatically.
     * @public
     */
    class SubscriberSet {
        /**
         * Creates an instance of SubscriberSet for the specified source.
         * @param source - The object source that subscribers will receive notifications from.
         * @param initialSubscriber - An initial subscriber to changes.
         */
        constructor(source, initialSubscriber) {
            this.sub1 = void 0;
            this.sub2 = void 0;
            this.spillover = void 0;
            this.source = source;
            this.sub1 = initialSubscriber;
        }
        /**
         * Checks whether the provided subscriber has been added to this set.
         * @param subscriber - The subscriber to test for inclusion in this set.
         */
        has(subscriber) {
            return this.sub1 === subscriber || this.sub2 === subscriber;
        }
        /**
         * Subscribes to notification of changes in an object's state.
         * @param subscriber - The object that is subscribing for change notification.
         */
        subscribe(subscriber) {
            if (this.has(subscriber)) {
                return;
            }
            if (this.sub1 === void 0) {
                this.sub1 = subscriber;
                return;
            }
            if (this.sub2 === void 0) {
                this.sub2 = subscriber;
                return;
            }
            this.spillover = [this.sub1, this.sub2, subscriber];
            this.subscribe = spilloverSubscribe;
            this.unsubscribe = spilloverUnsubscribe;
            this.notify = spilloverNotifySubscribers;
            this.has = spilloverHas;
            this.sub1 = void 0;
            this.sub2 = void 0;
        }
        /**
         * Unsubscribes from notification of changes in an object's state.
         * @param subscriber - The object that is unsubscribing from change notification.
         */
        unsubscribe(subscriber) {
            if (this.sub1 === subscriber) {
                this.sub1 = void 0;
            }
            else if (this.sub2 === subscriber) {
                this.sub2 = void 0;
            }
        }
        /**
         * Notifies all subscribers.
         * @param args - Data passed along to subscribers during notification.
         */
        notify(args) {
            const sub1 = this.sub1;
            const sub2 = this.sub2;
            const source = this.source;
            if (sub1 !== void 0) {
                sub1.handleChange(source, args);
            }
            if (sub2 !== void 0) {
                sub2.handleChange(source, args);
            }
        }
    }
    /**
     * An implementation of Notifier that allows subscribers to be notified
     * of individual property changes on an object.
     * @public
     */
    class PropertyChangeNotifier {
        /**
         * Creates an instance of PropertyChangeNotifier for the specified source.
         * @param source - The object source that subscribers will receive notifications from.
         */
        constructor(source) {
            this.subscribers = {};
            this.source = source;
        }
        /**
         * Notifies all subscribers, based on the specified property.
         * @param propertyName - The property name, passed along to subscribers during notification.
         */
        notify(propertyName) {
            const subscribers = this.subscribers[propertyName];
            if (subscribers !== void 0) {
                subscribers.notify(propertyName);
            }
        }
        /**
         * Subscribes to notification of changes in an object's state.
         * @param subscriber - The object that is subscribing for change notification.
         * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
         */
        subscribe(subscriber, propertyToWatch) {
            let subscribers = this.subscribers[propertyToWatch];
            if (subscribers === void 0) {
                this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
            }
            subscribers.subscribe(subscriber);
        }
        /**
         * Unsubscribes from notification of changes in an object's state.
         * @param subscriber - The object that is unsubscribing from change notification.
         * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
         */
        unsubscribe(subscriber, propertyToUnwatch) {
            const subscribers = this.subscribers[propertyToUnwatch];
            if (subscribers === void 0) {
                return;
            }
            subscribers.unsubscribe(subscriber);
        }
    }

    const volatileRegex = /(:|&&|\|\||if)/;
    const notifierLookup = new WeakMap();
    const accessorLookup = new WeakMap();
    let watcher = void 0;
    let createArrayObserver = (array) => {
        throw new Error("Must call enableArrayObservation before observing arrays.");
    };
    class DefaultObservableAccessor {
        constructor(name) {
            this.name = name;
            this.field = `_${name}`;
            this.callback = `${name}Changed`;
        }
        getValue(source) {
            if (watcher !== void 0) {
                watcher.watch(source, this.name);
            }
            return source[this.field];
        }
        setValue(source, newValue) {
            const field = this.field;
            const oldValue = source[field];
            if (oldValue !== newValue) {
                source[field] = newValue;
                const callback = source[this.callback];
                if (typeof callback === "function") {
                    callback.call(source, oldValue, newValue);
                }
                /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
                getNotifier(source).notify(this.name);
            }
        }
    }
    /**
     * Common Observable APIs.
     * @public
     */
    const Observable = Object.freeze({
        /**
         * @internal
         * @param factory - The factory used to create array observers.
         */
        setArrayObserverFactory(factory) {
            createArrayObserver = factory;
        },
        /**
         * Gets a notifier for an object or Array.
         * @param source - The object or Array to get the notifier for.
         */
        getNotifier(source) {
            let found = source.$fastController || notifierLookup.get(source);
            if (found === void 0) {
                if (Array.isArray(source)) {
                    found = createArrayObserver(source);
                }
                else {
                    notifierLookup.set(source, (found = new PropertyChangeNotifier(source)));
                }
            }
            return found;
        },
        /**
         * Records a property change for a source object.
         * @param source - The object to record the change against.
         * @param propertyName - The property to track as changed.
         */
        track(source, propertyName) {
            if (watcher !== void 0) {
                watcher.watch(source, propertyName);
            }
        },
        /**
         * Notifies watchers that the currently executing property getter or function is volatile
         * with respect to its observable dependencies.
         */
        trackVolatile() {
            if (watcher !== void 0) {
                watcher.needsRefresh = true;
            }
        },
        /**
         * Notifies subscribers of a source object of changes.
         * @param source - the object to notify of changes.
         * @param args - The change args to pass to subscribers.
         */
        notify(source, args) {
            /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
            getNotifier(source).notify(args);
        },
        /**
         * Defines an observable property on an object or prototype.
         * @param target - The target object to define the observable on.
         * @param nameOrAccessor - The name of the property to define as observable;
         * or a custom accessor that specifies the property name and accessor implementation.
         */
        defineProperty(target, nameOrAccessor) {
            if (typeof nameOrAccessor === "string") {
                nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
            }
            this.getAccessors(target).push(nameOrAccessor);
            Reflect.defineProperty(target, nameOrAccessor.name, {
                enumerable: true,
                get: function () {
                    return nameOrAccessor.getValue(this);
                },
                set: function (newValue) {
                    nameOrAccessor.setValue(this, newValue);
                },
            });
        },
        /**
         * Finds all the observable accessors defined on the target,
         * including its prototype chain.
         * @param target - The target object to search for accessor on.
         */
        getAccessors(target) {
            let accessors = accessorLookup.get(target);
            if (accessors === void 0) {
                let currentTarget = Reflect.getPrototypeOf(target);
                while (accessors === void 0 && currentTarget !== null) {
                    accessors = accessorLookup.get(currentTarget);
                    currentTarget = Reflect.getPrototypeOf(currentTarget);
                }
                if (accessors === void 0) {
                    accessors = [];
                }
                else {
                    accessors = accessors.slice(0);
                }
                accessorLookup.set(target, accessors);
            }
            return accessors;
        },
        /**
         * Creates a {@link BindingObserver} that can watch the
         * provided {@link Binding} for changes.
         * @param binding - The binding to observe.
         * @param initialSubscriber - An initial subscriber to changes in the binding value.
         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
         */
        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
            /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
            return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
        },
        /**
         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
         * on every evaluation of the value.
         * @param binding - The binding to inspect.
         */
        isVolatileBinding(binding) {
            return volatileRegex.test(binding.toString());
        },
    });
    const getNotifier = Observable.getNotifier;
    Observable.trackVolatile;
    const queueUpdate = DOM.queueUpdate;
    /**
     * Decorator: Defines an observable property on the target.
     * @param target - The target to define the observable on.
     * @param nameOrAccessor - The property name or accessor to define the observable as.
     * @public
     */
    function observable(target, nameOrAccessor) {
        Observable.defineProperty(target, nameOrAccessor);
    }
    let currentEvent = null;
    /**
     * @param event - The event to set as current for the context.
     * @internal
     */
    function setCurrentEvent(event) {
        currentEvent = event;
    }
    /**
     * Provides additional contextual information available to behaviors and expressions.
     * @public
     */
    class ExecutionContext {
        constructor() {
            /**
             * The index of the current item within a repeat context.
             */
            this.index = 0;
            /**
             * The length of the current collection within a repeat context.
             */
            this.length = 0;
            /**
             * The parent data object within a repeat context.
             */
            this.parent = null;
            /**
             * The parent execution context when in nested context scenarios.
             */
            this.parentContext = null;
        }
        /**
         * The current event within an event handler.
         */
        get event() {
            return currentEvent;
        }
        /**
         * Indicates whether the current item within a repeat context
         * has an even index.
         */
        get isEven() {
            return this.index % 2 === 0;
        }
        /**
         * Indicates whether the current item within a repeat context
         * has an odd index.
         */
        get isOdd() {
            return this.index % 2 !== 0;
        }
        /**
         * Indicates whether the current item within a repeat context
         * is the first item in the collection.
         */
        get isFirst() {
            return this.index === 0;
        }
        /**
         * Indicates whether the current item within a repeat context
         * is somewhere in the middle of the collection.
         */
        get isInMiddle() {
            return !this.isFirst && !this.isLast;
        }
        /**
         * Indicates whether the current item within a repeat context
         * is the last item in the collection.
         */
        get isLast() {
            return this.index === this.length - 1;
        }
    }
    Observable.defineProperty(ExecutionContext.prototype, "index");
    Observable.defineProperty(ExecutionContext.prototype, "length");
    /**
     * The default execution context used in binding expressions.
     * @public
     */
    const defaultExecutionContext = Object.seal(new ExecutionContext());
    class BindingObserverImplementation extends SubscriberSet {
        constructor(binding, initialSubscriber, isVolatileBinding = false) {
            super(binding, initialSubscriber);
            this.binding = binding;
            this.isVolatileBinding = isVolatileBinding;
            this.needsRefresh = true;
            this.needsQueue = true;
            this.first = this;
            this.last = null;
            this.propertySource = void 0;
            this.propertyName = void 0;
            this.notifier = void 0;
            this.next = void 0;
        }
        observe(source, context) {
            if (this.needsRefresh && this.last !== null) {
                this.disconnect();
            }
            const previousWatcher = watcher;
            watcher = this.needsRefresh ? this : void 0;
            this.needsRefresh = this.isVolatileBinding;
            const result = this.binding(source, context);
            watcher = previousWatcher;
            return result;
        }
        disconnect() {
            if (this.last !== null) {
                let current = this.first;
                while (current !== void 0) {
                    current.notifier.unsubscribe(this, current.propertyName);
                    current = current.next;
                }
                this.last = null;
                this.needsRefresh = this.needsQueue = true;
            }
        }
        /** @internal */
        watch(propertySource, propertyName) {
            const prev = this.last;
            const notifier = getNotifier(propertySource);
            const current = prev === null ? this.first : {};
            current.propertySource = propertySource;
            current.propertyName = propertyName;
            current.notifier = notifier;
            notifier.subscribe(this, propertyName);
            if (prev !== null) {
                if (!this.needsRefresh) {
                    watcher = void 0;
                    const prevValue = prev.propertySource[prev.propertyName];
                    watcher = this;
                    if (propertySource === prevValue) {
                        this.needsRefresh = true;
                    }
                }
                prev.next = current;
            }
            this.last = current;
        }
        /** @internal */
        handleChange() {
            if (this.needsQueue) {
                this.needsQueue = false;
                queueUpdate(this);
            }
        }
        /** @internal */
        call() {
            if (this.last !== null) {
                this.needsQueue = true;
                this.notify(this);
            }
        }
        records() {
            let next = this.first;
            return {
                next: () => {
                    const current = next;
                    if (current === undefined) {
                        return { value: void 0, done: true };
                    }
                    else {
                        next = next.next;
                        return {
                            value: current,
                            done: false,
                        };
                    }
                },
                [Symbol.iterator]: function () {
                    return this;
                },
            };
        }
    }

    /**
     * Instructs the template engine to apply behavior to a node.
     * @public
     */
    class HTMLDirective {
        constructor() {
            /**
             * The index of the DOM node to which the created behavior will apply.
             */
            this.targetIndex = 0;
        }
    }
    /**
     * A {@link HTMLDirective} that targets a named attribute or property on a node.
     * @public
     */
    class TargetedHTMLDirective extends HTMLDirective {
        constructor() {
            super(...arguments);
            /**
             * Creates a placeholder string based on the directive's index within the template.
             * @param index - The index of the directive within the template.
             */
            this.createPlaceholder = DOM.createInterpolationPlaceholder;
        }
    }
    /**
     * A directive that attaches special behavior to an element via a custom attribute.
     * @public
     */
    class AttachedBehaviorHTMLDirective extends HTMLDirective {
        /**
         *
         * @param name - The name of the behavior; used as a custom attribute on the element.
         * @param behavior - The behavior to instantiate and attach to the element.
         * @param options - Options to pass to the behavior during creation.
         */
        constructor(name, behavior, options) {
            super();
            this.name = name;
            this.behavior = behavior;
            this.options = options;
        }
        /**
         * Creates a placeholder string based on the directive's index within the template.
         * @param index - The index of the directive within the template.
         * @remarks
         * Creates a custom attribute placeholder.
         */
        createPlaceholder(index) {
            return DOM.createCustomAttributePlaceholder(this.name, index);
        }
        /**
         * Creates a behavior for the provided target node.
         * @param target - The node instance to create the behavior for.
         * @remarks
         * Creates an instance of the `behavior` type this directive was constructed with
         * and passes the target and options to that `behavior`'s constructor.
         */
        createBehavior(target) {
            return new this.behavior(target, this.options);
        }
    }

    function normalBind(source, context) {
        this.source = source;
        this.context = context;
        if (this.bindingObserver === null) {
            this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);
        }
        this.updateTarget(this.bindingObserver.observe(source, context));
    }
    function triggerBind(source, context) {
        this.source = source;
        this.context = context;
        this.target.addEventListener(this.targetName, this);
    }
    function normalUnbind() {
        this.bindingObserver.disconnect();
        this.source = null;
        this.context = null;
    }
    function contentUnbind() {
        this.bindingObserver.disconnect();
        this.source = null;
        this.context = null;
        const view = this.target.$fastView;
        if (view !== void 0 && view.isComposed) {
            view.unbind();
            view.needsBindOnly = true;
        }
    }
    function triggerUnbind() {
        this.target.removeEventListener(this.targetName, this);
        this.source = null;
        this.context = null;
    }
    function updateAttributeTarget(value) {
        DOM.setAttribute(this.target, this.targetName, value);
    }
    function updateBooleanAttributeTarget(value) {
        DOM.setBooleanAttribute(this.target, this.targetName, value);
    }
    function updateContentTarget(value) {
        // If there's no actual value, then this equates to the
        // empty string for the purposes of content bindings.
        if (value === null || value === undefined) {
            value = "";
        }
        // If the value has a "create" method, then it's a template-like.
        if (value.create) {
            this.target.textContent = "";
            let view = this.target.$fastView;
            // If there's no previous view that we might be able to
            // reuse then create a new view from the template.
            if (view === void 0) {
                view = value.create();
            }
            else {
                // If there is a previous view, but it wasn't created
                // from the same template as the new value, then we
                // need to remove the old view if it's still in the DOM
                // and create a new view from the template.
                if (this.target.$fastTemplate !== value) {
                    if (view.isComposed) {
                        view.remove();
                        view.unbind();
                    }
                    view = value.create();
                }
            }
            // It's possible that the value is the same as the previous template
            // and that there's actually no need to compose it.
            if (!view.isComposed) {
                view.isComposed = true;
                view.bind(this.source, this.context);
                view.insertBefore(this.target);
                this.target.$fastView = view;
                this.target.$fastTemplate = value;
            }
            else if (view.needsBindOnly) {
                view.needsBindOnly = false;
                view.bind(this.source, this.context);
            }
        }
        else {
            const view = this.target.$fastView;
            // If there is a view and it's currently composed into
            // the DOM, then we need to remove it.
            if (view !== void 0 && view.isComposed) {
                view.isComposed = false;
                view.remove();
                if (view.needsBindOnly) {
                    view.needsBindOnly = false;
                }
                else {
                    view.unbind();
                }
            }
            this.target.textContent = value;
        }
    }
    function updatePropertyTarget(value) {
        this.target[this.targetName] = value;
    }
    function updateClassTarget(value) {
        const classVersions = this.classVersions || Object.create(null);
        const target = this.target;
        let version = this.version || 0;
        // Add the classes, tracking the version at which they were added.
        if (value !== null && value !== undefined && value.length) {
            const names = value.split(/\s+/);
            for (let i = 0, ii = names.length; i < ii; ++i) {
                const currentName = names[i];
                if (currentName === "") {
                    continue;
                }
                classVersions[currentName] = version;
                target.classList.add(currentName);
            }
        }
        this.classVersions = classVersions;
        this.version = version + 1;
        // If this is the first call to add classes, there's no need to remove old ones.
        if (version === 0) {
            return;
        }
        // Remove classes from the previous version.
        version -= 1;
        for (const name in classVersions) {
            if (classVersions[name] === version) {
                target.classList.remove(name);
            }
        }
    }
    /**
     * A directive that configures data binding to element content and attributes.
     * @public
     */
    class HTMLBindingDirective extends TargetedHTMLDirective {
        /**
         * Creates an instance of BindingDirective.
         * @param binding - A binding that returns the data used to update the DOM.
         */
        constructor(binding) {
            super();
            this.binding = binding;
            this.bind = normalBind;
            this.unbind = normalUnbind;
            this.updateTarget = updateAttributeTarget;
            this.isBindingVolatile = Observable.isVolatileBinding(this.binding);
        }
        /**
         * Gets/sets the name of the attribute or property that this
         * binding is targeting.
         */
        get targetName() {
            return this.originalTargetName;
        }
        set targetName(value) {
            this.originalTargetName = value;
            if (value === void 0) {
                return;
            }
            switch (value[0]) {
                case ":":
                    this.cleanedTargetName = value.substr(1);
                    this.updateTarget = updatePropertyTarget;
                    if (this.cleanedTargetName === "innerHTML") {
                        const binding = this.binding;
                        /* eslint-disable-next-line */
                        this.binding = (s, c) => DOM.createHTML(binding(s, c));
                    }
                    break;
                case "?":
                    this.cleanedTargetName = value.substr(1);
                    this.updateTarget = updateBooleanAttributeTarget;
                    break;
                case "@":
                    this.cleanedTargetName = value.substr(1);
                    this.bind = triggerBind;
                    this.unbind = triggerUnbind;
                    break;
                default:
                    this.cleanedTargetName = value;
                    if (value === "class") {
                        this.updateTarget = updateClassTarget;
                    }
                    break;
            }
        }
        /**
         * Makes this binding target the content of an element rather than
         * a particular attribute or property.
         */
        targetAtContent() {
            this.updateTarget = updateContentTarget;
            this.unbind = contentUnbind;
        }
        /**
         * Creates the runtime BindingBehavior instance based on the configuration
         * information stored in the BindingDirective.
         * @param target - The target node that the binding behavior should attach to.
         */
        createBehavior(target) {
            /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
            return new BindingBehavior(target, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
        }
    }
    /**
     * A behavior that updates content and attributes based on a configured
     * BindingDirective.
     * @public
     */
    class BindingBehavior {
        /**
         * Creates an instance of BindingBehavior.
         * @param target - The target of the data updates.
         * @param binding - The binding that returns the latest value for an update.
         * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.
         * @param bind - The operation to perform during binding.
         * @param unbind - The operation to perform during unbinding.
         * @param updateTarget - The operation to perform when updating.
         * @param targetName - The name of the target attribute or property to update.
         */
        constructor(target, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {
            /** @internal */
            this.source = null;
            /** @internal */
            this.context = null;
            /** @internal */
            this.bindingObserver = null;
            this.target = target;
            this.binding = binding;
            this.isBindingVolatile = isBindingVolatile;
            this.bind = bind;
            this.unbind = unbind;
            this.updateTarget = updateTarget;
            this.targetName = targetName;
        }
        /** @internal */
        handleChange() {
            this.updateTarget(this.bindingObserver.observe(this.source, this.context));
        }
        /** @internal */
        handleEvent(event) {
            setCurrentEvent(event);
            const result = this.binding(this.source, this.context);
            setCurrentEvent(null);
            if (result !== true) {
                event.preventDefault();
            }
        }
    }

    let sharedContext = null;
    class CompilationContext {
        addFactory(factory) {
            factory.targetIndex = this.targetIndex;
            this.behaviorFactories.push(factory);
        }
        captureContentBinding(directive) {
            directive.targetAtContent();
            this.addFactory(directive);
        }
        reset() {
            this.behaviorFactories = [];
            this.targetIndex = -1;
        }
        release() {
            sharedContext = this;
        }
        static borrow(directives) {
            const shareable = sharedContext || new CompilationContext();
            shareable.directives = directives;
            shareable.reset();
            sharedContext = null;
            return shareable;
        }
    }
    function createAggregateBinding(parts) {
        if (parts.length === 1) {
            return parts[0];
        }
        let targetName;
        const partCount = parts.length;
        const finalParts = parts.map((x) => {
            if (typeof x === "string") {
                return () => x;
            }
            targetName = x.targetName || targetName;
            return x.binding;
        });
        const binding = (scope, context) => {
            let output = "";
            for (let i = 0; i < partCount; ++i) {
                output += finalParts[i](scope, context);
            }
            return output;
        };
        const directive = new HTMLBindingDirective(binding);
        directive.targetName = targetName;
        return directive;
    }
    const interpolationEndLength = _interpolationEnd.length;
    function parseContent(context, value) {
        const valueParts = value.split(_interpolationStart);
        if (valueParts.length === 1) {
            return null;
        }
        const bindingParts = [];
        for (let i = 0, ii = valueParts.length; i < ii; ++i) {
            const current = valueParts[i];
            const index = current.indexOf(_interpolationEnd);
            let literal;
            if (index === -1) {
                literal = current;
            }
            else {
                const directiveIndex = parseInt(current.substring(0, index));
                bindingParts.push(context.directives[directiveIndex]);
                literal = current.substring(index + interpolationEndLength);
            }
            if (literal !== "") {
                bindingParts.push(literal);
            }
        }
        return bindingParts;
    }
    function compileAttributes(context, node, includeBasicValues = false) {
        const attributes = node.attributes;
        for (let i = 0, ii = attributes.length; i < ii; ++i) {
            const attr = attributes[i];
            const attrValue = attr.value;
            const parseResult = parseContent(context, attrValue);
            let result = null;
            if (parseResult === null) {
                if (includeBasicValues) {
                    result = new HTMLBindingDirective(() => attrValue);
                    result.targetName = attr.name;
                }
            }
            else {
                result = createAggregateBinding(parseResult);
            }
            if (result !== null) {
                node.removeAttributeNode(attr);
                i--;
                ii--;
                context.addFactory(result);
            }
        }
    }
    function compileContent(context, node, walker) {
        const parseResult = parseContent(context, node.textContent);
        if (parseResult !== null) {
            let lastNode = node;
            for (let i = 0, ii = parseResult.length; i < ii; ++i) {
                const currentPart = parseResult[i];
                const currentNode = i === 0
                    ? node
                    : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
                if (typeof currentPart === "string") {
                    currentNode.textContent = currentPart;
                }
                else {
                    currentNode.textContent = " ";
                    context.captureContentBinding(currentPart);
                }
                lastNode = currentNode;
                context.targetIndex++;
                if (currentNode !== node) {
                    walker.nextNode();
                }
            }
            context.targetIndex--;
        }
    }
    /**
     * Compiles a template and associated directives into a raw compilation
     * result which include a cloneable DocumentFragment and factories capable
     * of attaching runtime behavior to nodes within the fragment.
     * @param template - The template to compile.
     * @param directives - The directives referenced by the template.
     * @remarks
     * The template that is provided for compilation is altered in-place
     * and cannot be compiled again. If the original template must be preserved,
     * it is recommended that you clone the original and pass the clone to this API.
     * @public
     */
    function compileTemplate(template, directives) {
        const fragment = template.content;
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864
        document.adoptNode(fragment);
        const context = CompilationContext.borrow(directives);
        compileAttributes(context, template, true);
        const hostBehaviorFactories = context.behaviorFactories;
        context.reset();
        const walker = DOM.createTemplateWalker(fragment);
        let node;
        while ((node = walker.nextNode())) {
            context.targetIndex++;
            switch (node.nodeType) {
                case 1: // element node
                    compileAttributes(context, node);
                    break;
                case 3: // text node
                    compileContent(context, node, walker);
                    break;
                case 8: // comment
                    if (DOM.isMarker(node)) {
                        context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);
                    }
            }
        }
        let targetOffset = 0;
        if (
        // If the first node in a fragment is a marker, that means it's an unstable first node,
        // because something like a when, repeat, etc. could add nodes before the marker.
        // To mitigate this, we insert a stable first node. However, if we insert a node,
        // that will alter the result of the TreeWalker. So, we also need to offset the target index.
        DOM.isMarker(fragment.firstChild) ||
            // Or if there is only one node and a directive, it means the template's content
            // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by
            // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.
            (fragment.childNodes.length === 1 && directives.length)) {
            fragment.insertBefore(document.createComment(""), fragment.firstChild);
            targetOffset = -1;
        }
        const viewBehaviorFactories = context.behaviorFactories;
        context.release();
        return {
            fragment,
            viewBehaviorFactories,
            hostBehaviorFactories,
            targetOffset,
        };
    }

    // A singleton Range instance used to efficiently remove ranges of DOM nodes.
    // See the implementation of HTMLView below for further details.
    const range = document.createRange();
    /**
     * The standard View implementation, which also implements ElementView and SyntheticView.
     * @public
     */
    class HTMLView {
        /**
         * Constructs an instance of HTMLView.
         * @param fragment - The html fragment that contains the nodes for this view.
         * @param behaviors - The behaviors to be applied to this view.
         */
        constructor(fragment, behaviors) {
            this.fragment = fragment;
            this.behaviors = behaviors;
            /**
             * The data that the view is bound to.
             */
            this.source = null;
            /**
             * The execution context the view is running within.
             */
            this.context = null;
            this.firstChild = fragment.firstChild;
            this.lastChild = fragment.lastChild;
        }
        /**
         * Appends the view's DOM nodes to the referenced node.
         * @param node - The parent node to append the view's DOM nodes to.
         */
        appendTo(node) {
            node.appendChild(this.fragment);
        }
        /**
         * Inserts the view's DOM nodes before the referenced node.
         * @param node - The node to insert the view's DOM before.
         */
        insertBefore(node) {
            if (this.fragment.hasChildNodes()) {
                node.parentNode.insertBefore(this.fragment, node);
            }
            else {
                const parentNode = node.parentNode;
                const end = this.lastChild;
                let current = this.firstChild;
                let next;
                while (current !== end) {
                    next = current.nextSibling;
                    parentNode.insertBefore(current, node);
                    current = next;
                }
                parentNode.insertBefore(end, node);
            }
        }
        /**
         * Removes the view's DOM nodes.
         * The nodes are not disposed and the view can later be re-inserted.
         */
        remove() {
            const fragment = this.fragment;
            const end = this.lastChild;
            let current = this.firstChild;
            let next;
            while (current !== end) {
                next = current.nextSibling;
                fragment.appendChild(current);
                current = next;
            }
            fragment.appendChild(end);
        }
        /**
         * Removes the view and unbinds its behaviors, disposing of DOM nodes afterward.
         * Once a view has been disposed, it cannot be inserted or bound again.
         */
        dispose() {
            const parent = this.firstChild.parentNode;
            const end = this.lastChild;
            let current = this.firstChild;
            let next;
            while (current !== end) {
                next = current.nextSibling;
                parent.removeChild(current);
                current = next;
            }
            parent.removeChild(end);
            const behaviors = this.behaviors;
            const oldSource = this.source;
            for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                behaviors[i].unbind(oldSource);
            }
        }
        /**
         * Binds a view's behaviors to its binding source.
         * @param source - The binding source for the view's binding behaviors.
         * @param context - The execution context to run the behaviors within.
         */
        bind(source, context) {
            const behaviors = this.behaviors;
            if (this.source === source) {
                return;
            }
            else if (this.source !== null) {
                const oldSource = this.source;
                this.source = source;
                this.context = context;
                for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                    const current = behaviors[i];
                    current.unbind(oldSource);
                    current.bind(source, context);
                }
            }
            else {
                this.source = source;
                this.context = context;
                for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                    behaviors[i].bind(source, context);
                }
            }
        }
        /**
         * Unbinds a view's behaviors from its binding source.
         */
        unbind() {
            if (this.source === null) {
                return;
            }
            const behaviors = this.behaviors;
            const oldSource = this.source;
            for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                behaviors[i].unbind(oldSource);
            }
            this.source = null;
        }
        /**
         * Efficiently disposes of a contiguous range of synthetic view instances.
         * @param views - A contiguous range of views to be disposed.
         */
        static disposeContiguousBatch(views) {
            if (views.length === 0) {
                return;
            }
            range.setStartBefore(views[0].firstChild);
            range.setEndAfter(views[views.length - 1].lastChild);
            range.deleteContents();
            for (let i = 0, ii = views.length; i < ii; ++i) {
                const view = views[i];
                const behaviors = view.behaviors;
                const oldSource = view.source;
                for (let j = 0, jj = behaviors.length; j < jj; ++j) {
                    behaviors[j].unbind(oldSource);
                }
            }
        }
    }

    /**
     * A template capable of creating HTMLView instances or rendering directly to DOM.
     * @public
     */
    class ViewTemplate {
        /**
         * Creates an instance of ViewTemplate.
         * @param html - The html representing what this template will instantiate, including placeholders for directives.
         * @param directives - The directives that will be connected to placeholders in the html.
         */
        constructor(html, directives) {
            this.behaviorCount = 0;
            this.hasHostBehaviors = false;
            this.fragment = null;
            this.targetOffset = 0;
            this.viewBehaviorFactories = null;
            this.hostBehaviorFactories = null;
            this.html = html;
            this.directives = directives;
        }
        /**
         * Creates an HTMLView instance based on this template definition.
         * @param hostBindingTarget - The element that host behaviors will be bound to.
         */
        create(hostBindingTarget) {
            if (this.fragment === null) {
                let template;
                const html = this.html;
                if (typeof html === "string") {
                    template = document.createElement("template");
                    template.innerHTML = DOM.createHTML(html);
                    const fec = template.content.firstElementChild;
                    if (fec !== null && fec.tagName === "TEMPLATE") {
                        template = fec;
                    }
                }
                else {
                    template = html;
                }
                const result = compileTemplate(template, this.directives);
                this.fragment = result.fragment;
                this.viewBehaviorFactories = result.viewBehaviorFactories;
                this.hostBehaviorFactories = result.hostBehaviorFactories;
                this.targetOffset = result.targetOffset;
                this.behaviorCount =
                    this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
                this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
            }
            const fragment = this.fragment.cloneNode(true);
            const viewFactories = this.viewBehaviorFactories;
            const behaviors = new Array(this.behaviorCount);
            const walker = DOM.createTemplateWalker(fragment);
            let behaviorIndex = 0;
            let targetIndex = this.targetOffset;
            let node = walker.nextNode();
            for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
                const factory = viewFactories[behaviorIndex];
                const factoryIndex = factory.targetIndex;
                while (node !== null) {
                    if (targetIndex === factoryIndex) {
                        behaviors[behaviorIndex] = factory.createBehavior(node);
                        break;
                    }
                    else {
                        node = walker.nextNode();
                        targetIndex++;
                    }
                }
            }
            if (this.hasHostBehaviors) {
                const hostFactories = this.hostBehaviorFactories;
                for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {
                    behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);
                }
            }
            return new HTMLView(fragment, behaviors);
        }
        /**
         * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.
         * @param source - The data source to bind the template to.
         * @param host - The Element where the template will be rendered.
         * @param hostBindingTarget - An HTML element to target the host bindings at if different from the
         * host that the template is being attached to.
         */
        render(source, host, hostBindingTarget) {
            if (typeof host === "string") {
                host = document.getElementById(host);
            }
            if (hostBindingTarget === void 0) {
                hostBindingTarget = host;
            }
            const view = this.create(hostBindingTarget);
            view.bind(source, defaultExecutionContext);
            view.appendTo(host);
            return view;
        }
    }
    // Much thanks to LitHTML for working this out!
    const lastAttributeNameRegex = 
    // eslint-disable-next-line no-control-regex
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
    /**
     * Transforms a template literal string into a renderable ViewTemplate.
     * @param strings - The string fragments that are interpolated with the values.
     * @param values - The values that are interpolated with the string fragments.
     * @remarks
     * The html helper supports interpolation of strings, numbers, binding expressions,
     * other template instances, and Directive instances.
     * @public
     */
    function html(strings, ...values) {
        const directives = [];
        let html = "";
        for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
            const currentString = strings[i];
            let value = values[i];
            html += currentString;
            if (value instanceof ViewTemplate) {
                const template = value;
                value = () => template;
            }
            if (typeof value === "function") {
                value = new HTMLBindingDirective(value);
            }
            if (value instanceof TargetedHTMLDirective) {
                const match = lastAttributeNameRegex.exec(currentString);
                if (match !== null) {
                    value.targetName = match[2];
                }
            }
            if (value instanceof HTMLDirective) {
                // Since not all values are directives, we can't use i
                // as the index for the placeholder. Instead, we need to
                // use directives.length to get the next index.
                html += value.createPlaceholder(directives.length);
                directives.push(value);
            }
            else {
                html += value;
            }
        }
        html += strings[strings.length - 1];
        return new ViewTemplate(html, directives);
    }

    /**
     * Represents styles that can be applied to a custom element.
     * @public
     */
    class ElementStyles {
        constructor() {
            this.targets = new WeakSet();
            /** @internal */
            this.behaviors = null;
        }
        /** @internal */
        addStylesTo(target) {
            this.targets.add(target);
        }
        /** @internal */
        removeStylesFrom(target) {
            this.targets.delete(target);
        }
        /** @internal */
        isAttachedTo(target) {
            return this.targets.has(target);
        }
        /**
         * Associates behaviors with this set of styles.
         * @param behaviors - The behaviors to associate.
         */
        withBehaviors(...behaviors) {
            this.behaviors =
                this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
            return this;
        }
    }
    /**
     * Create ElementStyles from ComposableStyles.
     */
    ElementStyles.create = (() => {
        if (DOM.supportsAdoptedStyleSheets) {
            const styleSheetCache = new Map();
            return (styles) => 
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            new AdoptedStyleSheetsStyles(styles, styleSheetCache);
        }
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        return (styles) => new StyleElementStyles(styles);
    })();
    function reduceStyles(styles) {
        return styles
            .map((x) => x instanceof ElementStyles ? reduceStyles(x.styles) : [x])
            .reduce((prev, curr) => prev.concat(curr), []);
    }
    function reduceBehaviors(styles) {
        return styles
            .map((x) => (x instanceof ElementStyles ? x.behaviors : null))
            .reduce((prev, curr) => {
            if (curr === null) {
                return prev;
            }
            if (prev === null) {
                prev = [];
            }
            return prev.concat(curr);
        }, null);
    }
    /**
     * https://wicg.github.io/construct-stylesheets/
     * https://developers.google.com/web/updates/2019/02/constructable-stylesheets
     *
     * @internal
     */
    class AdoptedStyleSheetsStyles extends ElementStyles {
        constructor(styles, styleSheetCache) {
            super();
            this.styles = styles;
            this.styleSheetCache = styleSheetCache;
            this._styleSheets = void 0;
            this.behaviors = reduceBehaviors(styles);
        }
        get styleSheets() {
            if (this._styleSheets === void 0) {
                const styles = this.styles;
                const styleSheetCache = this.styleSheetCache;
                this._styleSheets = reduceStyles(styles).map((x) => {
                    if (x instanceof CSSStyleSheet) {
                        return x;
                    }
                    let sheet = styleSheetCache.get(x);
                    if (sheet === void 0) {
                        sheet = new CSSStyleSheet();
                        sheet.replaceSync(x);
                        styleSheetCache.set(x, sheet);
                    }
                    return sheet;
                });
            }
            return this._styleSheets;
        }
        addStylesTo(target) {
            target.adoptedStyleSheets = [...target.adoptedStyleSheets, ...this.styleSheets];
            super.addStylesTo(target);
        }
        removeStylesFrom(target) {
            const sourceSheets = this.styleSheets;
            target.adoptedStyleSheets = target.adoptedStyleSheets.filter((x) => sourceSheets.indexOf(x) === -1);
            super.removeStylesFrom(target);
        }
    }
    let styleClassId = 0;
    function getNextStyleClass() {
        return `fast-style-class-${++styleClassId}`;
    }
    /**
     * @internal
     */
    class StyleElementStyles extends ElementStyles {
        constructor(styles) {
            super();
            this.styles = styles;
            this.behaviors = null;
            this.behaviors = reduceBehaviors(styles);
            this.styleSheets = reduceStyles(styles);
            this.styleClass = getNextStyleClass();
        }
        addStylesTo(target) {
            const styleSheets = this.styleSheets;
            const styleClass = this.styleClass;
            target = this.normalizeTarget(target);
            for (let i = styleSheets.length - 1; i > -1; --i) {
                const element = document.createElement("style");
                element.innerHTML = styleSheets[i];
                element.className = styleClass;
                target.prepend(element);
            }
            super.addStylesTo(target);
        }
        removeStylesFrom(target) {
            target = this.normalizeTarget(target);
            const styles = target.querySelectorAll(`.${this.styleClass}`);
            for (let i = 0, ii = styles.length; i < ii; ++i) {
                target.removeChild(styles[i]);
            }
            super.removeStylesFrom(target);
        }
        isAttachedTo(target) {
            return super.isAttachedTo(this.normalizeTarget(target));
        }
        normalizeTarget(target) {
            return target === document ? document.body : target;
        }
    }

    /**
     * A {@link ValueConverter} that converts to and from `boolean` values.
     * @remarks
     * Used automatically when the `boolean` {@link AttributeMode} is selected.
     * @public
     */
    const booleanConverter = {
        toView(value) {
            return value ? "true" : "false";
        },
        fromView(value) {
            if (value === null ||
                value === void 0 ||
                value === "false" ||
                value === false ||
                value === 0) {
                return false;
            }
            return true;
        },
    };
    /**
     * A {@link ValueConverter} that converts to and from `number` values.
     * @remarks
     * This converter allows for nullable numbers, returning `null` if the
     * input was `null`, `undefined`, or `NaN`.
     * @public
     */
    const nullableNumberConverter = {
        toView(value) {
            if (value === null || value === undefined) {
                return null;
            }
            const number = value * 1;
            return isNaN(number) ? null : number.toString();
        },
        fromView(value) {
            if (value === null || value === undefined) {
                return null;
            }
            const number = value * 1;
            return isNaN(number) ? null : number;
        },
    };
    /**
     * An implementation of {@link Accessor} that supports reactivity,
     * change callbacks, attribute reflection, and type conversion for
     * custom elements.
     * @public
     */
    class AttributeDefinition {
        /**
         * Creates an instance of AttributeDefinition.
         * @param Owner - The class constructor that owns this attribute.
         * @param name - The name of the property associated with the attribute.
         * @param attribute - The name of the attribute in HTML.
         * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
         * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
         * to convert values to and from a DOM string.
         */
        constructor(Owner, name, attribute = name.toLowerCase(), mode = "reflect", converter) {
            this.guards = new Set();
            this.Owner = Owner;
            this.name = name;
            this.attribute = attribute;
            this.mode = mode;
            this.converter = converter;
            this.fieldName = `_${name}`;
            this.callbackName = `${name}Changed`;
            this.hasCallback = this.callbackName in Owner.prototype;
            if (mode === "boolean" && converter === void 0) {
                this.converter = booleanConverter;
            }
        }
        /**
         * Sets the value of the attribute/property on the source element.
         * @param source - The source element to access.
         * @param value - The value to set the attribute/property to.
         */
        setValue(source, newValue) {
            const oldValue = source[this.fieldName];
            const converter = this.converter;
            if (converter !== void 0) {
                newValue = converter.fromView(newValue);
            }
            if (oldValue !== newValue) {
                source[this.fieldName] = newValue;
                this.tryReflectToAttribute(source);
                if (this.hasCallback) {
                    source[this.callbackName](oldValue, newValue);
                }
                source.$fastController.notify(this.name);
            }
        }
        /**
         * Gets the value of the attribute/property on the source element.
         * @param source - The source element to access.
         */
        getValue(source) {
            Observable.track(source, this.name);
            return source[this.fieldName];
        }
        /** @internal */
        onAttributeChangedCallback(element, value) {
            if (this.guards.has(element)) {
                return;
            }
            this.guards.add(element);
            this.setValue(element, value);
            this.guards.delete(element);
        }
        tryReflectToAttribute(element) {
            const mode = this.mode;
            const guards = this.guards;
            if (guards.has(element) || mode === "fromView") {
                return;
            }
            DOM.queueUpdate(() => {
                guards.add(element);
                const latestValue = element[this.fieldName];
                switch (mode) {
                    case "reflect":
                        const converter = this.converter;
                        DOM.setAttribute(element, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
                        break;
                    case "boolean":
                        DOM.setBooleanAttribute(element, this.attribute, latestValue);
                        break;
                }
                guards.delete(element);
            });
        }
        /**
         * Collects all attribute definitions associated with the owner.
         * @param Owner - The class constructor to collect attribute for.
         * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
         * @internal
         */
        static collect(Owner, ...attributeLists) {
            const attributes = [];
            attributeLists.push(Owner.attributes);
            for (let i = 0, ii = attributeLists.length; i < ii; ++i) {
                const list = attributeLists[i];
                if (list === void 0) {
                    continue;
                }
                for (let j = 0, jj = list.length; j < jj; ++j) {
                    const config = list[j];
                    if (typeof config === "string") {
                        attributes.push(new AttributeDefinition(Owner, config));
                    }
                    else {
                        attributes.push(new AttributeDefinition(Owner, config.property, config.attribute, config.mode, config.converter));
                    }
                }
            }
            return attributes;
        }
    }
    function attr$1(configOrTarget, prop) {
        let config;
        function decorator($target, $prop) {
            if (arguments.length > 1) {
                // Non invocation:
                // - @attr
                // Invocation with or w/o opts:
                // - @attr()
                // - @attr({...opts})
                config.property = $prop;
            }
            const attributes = $target.constructor.attributes ||
                ($target.constructor.attributes = []);
            attributes.push(config);
        }
        if (arguments.length > 1) {
            // Non invocation:
            // - @attr
            config = {};
            decorator(configOrTarget, prop);
            return;
        }
        // Invocation with or w/o opts:
        // - @attr()
        // - @attr({...opts})
        config = configOrTarget === void 0 ? {} : configOrTarget;
        return decorator;
    }

    const defaultShadowOptions = { mode: "open" };
    const defaultElementOptions = {};
    const fastDefinitions = new Map();
    /**
     * Defines metadata for a FASTElement.
     * @public
     */
    class FASTElementDefinition {
        /**
         * Creates an instance of FASTElementDefinition.
         * @param type - The type this definition is being created for.
         * @param nameOrConfig - The name of the element to define or a config object
         * that describes the element to define.
         */
        constructor(type, nameOrConfig = type.definition) {
            if (typeof nameOrConfig === "string") {
                nameOrConfig = { name: nameOrConfig };
            }
            this.type = type;
            this.name = nameOrConfig.name;
            this.template = nameOrConfig.template;
            const attributes = AttributeDefinition.collect(type, nameOrConfig.attributes);
            const observedAttributes = new Array(attributes.length);
            const propertyLookup = {};
            const attributeLookup = {};
            for (let i = 0, ii = attributes.length; i < ii; ++i) {
                const current = attributes[i];
                observedAttributes[i] = current.attribute;
                propertyLookup[current.name] = current;
                attributeLookup[current.attribute] = current;
            }
            this.attributes = attributes;
            this.observedAttributes = observedAttributes;
            this.propertyLookup = propertyLookup;
            this.attributeLookup = attributeLookup;
            this.shadowOptions =
                nameOrConfig.shadowOptions === void 0
                    ? defaultShadowOptions
                    : nameOrConfig.shadowOptions === null
                        ? void 0
                        : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
            this.elementOptions =
                nameOrConfig.elementOptions === void 0
                    ? defaultElementOptions
                    : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
            this.styles =
                nameOrConfig.styles === void 0
                    ? void 0
                    : Array.isArray(nameOrConfig.styles)
                        ? ElementStyles.create(nameOrConfig.styles)
                        : nameOrConfig.styles instanceof ElementStyles
                            ? nameOrConfig.styles
                            : ElementStyles.create([nameOrConfig.styles]);
        }
        /**
         * Defines a custom element based on this definition.
         * @param registry - The element registry to define the element in.
         */
        define(registry = customElements) {
            const type = this.type;
            if (!this.isDefined) {
                const attributes = this.attributes;
                const proto = type.prototype;
                for (let i = 0, ii = attributes.length; i < ii; ++i) {
                    Observable.defineProperty(proto, attributes[i]);
                }
                Reflect.defineProperty(type, "observedAttributes", {
                    value: this.observedAttributes,
                    enumerable: true,
                });
                fastDefinitions.set(type, this);
                this.isDefined = true;
            }
            if (!registry.get(this.name)) {
                registry.define(this.name, type, this.elementOptions);
            }
            return this;
        }
        /**
         * Gets the element definition associated with the specified type.
         * @param type - The custom element type to retrieve the definition for.
         */
        static forType(type) {
            return fastDefinitions.get(type);
        }
    }

    const shadowRoots = new WeakMap();
    const defaultEventOptions = {
        bubbles: true,
        composed: true,
        cancelable: true,
    };
    function getShadowRoot(element) {
        return element.shadowRoot || shadowRoots.get(element) || null;
    }
    /**
     * Controls the lifecycle and rendering of a `FASTElement`.
     * @public
     */
    class Controller extends PropertyChangeNotifier {
        /**
         * Creates a Controller to control the specified element.
         * @param element - The element to be controlled by this controller.
         * @param definition - The element definition metadata that instructs this
         * controller in how to handle rendering and other platform integrations.
         * @internal
         */
        constructor(element, definition) {
            super(element);
            this.boundObservables = null;
            this.behaviors = null;
            this.needsInitialization = true;
            this._template = null;
            this._styles = null;
            this._isConnected = false;
            /**
             * The view associated with the custom element.
             * @remarks
             * If `null` then the element is managing its own rendering.
             */
            this.view = null;
            this.element = element;
            this.definition = definition;
            const shadowOptions = definition.shadowOptions;
            if (shadowOptions !== void 0) {
                const shadowRoot = element.attachShadow(shadowOptions);
                if (shadowOptions.mode === "closed") {
                    shadowRoots.set(element, shadowRoot);
                }
            }
            // Capture any observable values that were set by the binding engine before
            // the browser upgraded the element. Then delete the property since it will
            // shadow the getter/setter that is required to make the observable operate.
            // Later, in the connect callback, we'll re-apply the values.
            const accessors = Observable.getAccessors(element);
            if (accessors.length > 0) {
                const boundObservables = (this.boundObservables = Object.create(null));
                for (let i = 0, ii = accessors.length; i < ii; ++i) {
                    const propertyName = accessors[i].name;
                    const value = element[propertyName];
                    if (value !== void 0) {
                        delete element[propertyName];
                        boundObservables[propertyName] = value;
                    }
                }
            }
        }
        /**
         * Indicates whether or not the custom element has been
         * connected to the document.
         */
        get isConnected() {
            Observable.track(this, "isConnected");
            return this._isConnected;
        }
        setIsConnected(value) {
            this._isConnected = value;
            Observable.notify(this, "isConnected");
        }
        /**
         * Gets/sets the template used to render the component.
         * @remarks
         * This value can only be accurately read after connect but can be set at any time.
         */
        get template() {
            return this._template;
        }
        set template(value) {
            if (this._template === value) {
                return;
            }
            this._template = value;
            if (!this.needsInitialization) {
                this.renderTemplate(value);
            }
        }
        /**
         * Gets/sets the primary styles used for the component.
         * @remarks
         * This value can only be accurately read after connect but can be set at any time.
         */
        get styles() {
            return this._styles;
        }
        set styles(value) {
            if (this._styles === value) {
                return;
            }
            if (this._styles !== null) {
                this.removeStyles(this._styles);
            }
            this._styles = value;
            if (!this.needsInitialization && value !== null) {
                this.addStyles(value);
            }
        }
        /**
         * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
         * @param styles - The styles to add.
         */
        addStyles(styles) {
            const target = getShadowRoot(this.element) ||
                this.element.getRootNode();
            if (styles instanceof HTMLStyleElement) {
                target.prepend(styles);
            }
            else if (!styles.isAttachedTo(target)) {
                const sourceBehaviors = styles.behaviors;
                styles.addStylesTo(target);
                if (sourceBehaviors !== null) {
                    this.addBehaviors(sourceBehaviors);
                }
            }
        }
        /**
         * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
         * @param styles - the styles to remove.
         */
        removeStyles(styles) {
            const target = getShadowRoot(this.element) ||
                this.element.getRootNode();
            if (styles instanceof HTMLStyleElement) {
                target.removeChild(styles);
            }
            else if (styles.isAttachedTo(target)) {
                const sourceBehaviors = styles.behaviors;
                styles.removeStylesFrom(target);
                if (sourceBehaviors !== null) {
                    this.removeBehaviors(sourceBehaviors);
                }
            }
        }
        /**
         * Adds behaviors to this element.
         * @param behaviors - The behaviors to add.
         */
        addBehaviors(behaviors) {
            const targetBehaviors = this.behaviors || (this.behaviors = new Map());
            const length = behaviors.length;
            const behaviorsToBind = [];
            for (let i = 0; i < length; ++i) {
                const behavior = behaviors[i];
                if (targetBehaviors.has(behavior)) {
                    targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
                }
                else {
                    targetBehaviors.set(behavior, 1);
                    behaviorsToBind.push(behavior);
                }
            }
            if (this._isConnected) {
                const element = this.element;
                for (let i = 0; i < behaviorsToBind.length; ++i) {
                    behaviorsToBind[i].bind(element, defaultExecutionContext);
                }
            }
        }
        /**
         * Removes behaviors from this element.
         * @param behaviors - The behaviors to remove.
         * @param force - Forces unbinding of behaviors.
         */
        removeBehaviors(behaviors, force = false) {
            const targetBehaviors = this.behaviors;
            if (targetBehaviors === null) {
                return;
            }
            const length = behaviors.length;
            const behaviorsToUnbind = [];
            for (let i = 0; i < length; ++i) {
                const behavior = behaviors[i];
                if (targetBehaviors.has(behavior)) {
                    const count = targetBehaviors.get(behavior) - 1;
                    count === 0 || force
                        ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior)
                        : targetBehaviors.set(behavior, count);
                }
            }
            if (this._isConnected) {
                const element = this.element;
                for (let i = 0; i < behaviorsToUnbind.length; ++i) {
                    behaviorsToUnbind[i].unbind(element);
                }
            }
        }
        /**
         * Runs connected lifecycle behavior on the associated element.
         */
        onConnectedCallback() {
            if (this._isConnected) {
                return;
            }
            const element = this.element;
            if (this.needsInitialization) {
                this.finishInitialization();
            }
            else if (this.view !== null) {
                this.view.bind(element, defaultExecutionContext);
            }
            const behaviors = this.behaviors;
            if (behaviors !== null) {
                for (const [behavior] of behaviors) {
                    behavior.bind(element, defaultExecutionContext);
                }
            }
            this.setIsConnected(true);
        }
        /**
         * Runs disconnected lifecycle behavior on the associated element.
         */
        onDisconnectedCallback() {
            if (!this._isConnected) {
                return;
            }
            this.setIsConnected(false);
            const view = this.view;
            if (view !== null) {
                view.unbind();
            }
            const behaviors = this.behaviors;
            if (behaviors !== null) {
                const element = this.element;
                for (const [behavior] of behaviors) {
                    behavior.unbind(element);
                }
            }
        }
        /**
         * Runs the attribute changed callback for the associated element.
         * @param name - The name of the attribute that changed.
         * @param oldValue - The previous value of the attribute.
         * @param newValue - The new value of the attribute.
         */
        onAttributeChangedCallback(name, oldValue, newValue) {
            const attrDef = this.definition.attributeLookup[name];
            if (attrDef !== void 0) {
                attrDef.onAttributeChangedCallback(this.element, newValue);
            }
        }
        /**
         * Emits a custom HTML event.
         * @param type - The type name of the event.
         * @param detail - The event detail object to send with the event.
         * @param options - The event options. By default bubbles and composed.
         * @remarks
         * Only emits events if connected.
         */
        emit(type, detail, options) {
            if (this._isConnected) {
                return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));
            }
            return false;
        }
        finishInitialization() {
            const element = this.element;
            const boundObservables = this.boundObservables;
            // If we have any observables that were bound, re-apply their values.
            if (boundObservables !== null) {
                const propertyNames = Object.keys(boundObservables);
                for (let i = 0, ii = propertyNames.length; i < ii; ++i) {
                    const propertyName = propertyNames[i];
                    element[propertyName] = boundObservables[propertyName];
                }
                this.boundObservables = null;
            }
            const definition = this.definition;
            // 1. Template overrides take top precedence.
            if (this._template === null) {
                if (this.element.resolveTemplate) {
                    // 2. Allow for element instance overrides next.
                    this._template = this.element.resolveTemplate();
                }
                else if (definition.template) {
                    // 3. Default to the static definition.
                    this._template = definition.template || null;
                }
            }
            // If we have a template after the above process, render it.
            // If there's no template, then the element author has opted into
            // custom rendering and they will managed the shadow root's content themselves.
            if (this._template !== null) {
                this.renderTemplate(this._template);
            }
            // 1. Styles overrides take top precedence.
            if (this._styles === null) {
                if (this.element.resolveStyles) {
                    // 2. Allow for element instance overrides next.
                    this._styles = this.element.resolveStyles();
                }
                else if (definition.styles) {
                    // 3. Default to the static definition.
                    this._styles = definition.styles || null;
                }
            }
            // If we have styles after the above process, add them.
            if (this._styles !== null) {
                this.addStyles(this._styles);
            }
            this.needsInitialization = false;
        }
        renderTemplate(template) {
            const element = this.element;
            // When getting the host to render to, we start by looking
            // up the shadow root. If there isn't one, then that means
            // we're doing a Light DOM render to the element's direct children.
            const host = getShadowRoot(element) || element;
            if (this.view !== null) {
                // If there's already a view, we need to unbind and remove through dispose.
                this.view.dispose();
                this.view = null;
            }
            else if (!this.needsInitialization) {
                // If there was previous custom rendering, we need to clear out the host.
                DOM.removeChildNodes(host);
            }
            if (template) {
                // If a new template was provided, render it.
                this.view = template.render(element, host, element);
            }
        }
        /**
         * Locates or creates a controller for the specified element.
         * @param element - The element to return the controller for.
         * @remarks
         * The specified element must have a {@link FASTElementDefinition}
         * registered either through the use of the {@link customElement}
         * decorator or a call to `FASTElement.define`.
         */
        static forCustomElement(element) {
            const controller = element.$fastController;
            if (controller !== void 0) {
                return controller;
            }
            const definition = FASTElementDefinition.forType(element.constructor);
            if (definition === void 0) {
                throw new Error("Missing FASTElement definition.");
            }
            return (element.$fastController = new Controller(element, definition));
        }
    }

    /* eslint-disable-next-line @typescript-eslint/explicit-function-return-type */
    function createFASTElement(BaseType) {
        return class extends BaseType {
            constructor() {
                /* eslint-disable-next-line */
                super();
                Controller.forCustomElement(this);
            }
            $emit(type, detail, options) {
                return this.$fastController.emit(type, detail, options);
            }
            connectedCallback() {
                this.$fastController.onConnectedCallback();
            }
            disconnectedCallback() {
                this.$fastController.onDisconnectedCallback();
            }
            attributeChangedCallback(name, oldValue, newValue) {
                this.$fastController.onAttributeChangedCallback(name, oldValue, newValue);
            }
        };
    }
    /**
     * A minimal base class for FASTElements that also provides
     * static helpers for working with FASTElements.
     * @public
     */
    const FASTElement = Object.assign(createFASTElement(HTMLElement), {
        /**
         * Creates a new FASTElement base class inherited from the
         * provided base type.
         * @param BaseType - The base element type to inherit from.
         */
        from(BaseType) {
            return createFASTElement(BaseType);
        },
        /**
         * Defines a platform custom element based on the provided type and definition.
         * @param type - The custom element type to define.
         * @param nameOrDef - The name of the element to define or a definition object
         * that describes the element to define.
         */
        define(type, nameOrDef) {
            return new FASTElementDefinition(type, nameOrDef).define().type;
        },
    });
    /**
     * Decorator: Defines a platform custom element based on `FASTElement`.
     * @param nameOrDef - The name of the element to define or a definition object
     * that describes the element to define.
     * @public
     */
    function customElement(nameOrDef) {
        /* eslint-disable-next-line @typescript-eslint/explicit-function-return-type */
        return function (type) {
            new FASTElementDefinition(type, nameOrDef).define();
        };
    }

    /**
     * Directive for use in {@link css}.
     *
     * @public
     */
    class CSSDirective {
        /**
         * Creates a CSS fragment to interpolate into the CSS document.
         * @returns - the string to interpolate into CSS
         */
        createCSS() {
            return "";
        }
        /**
         * Creates a behavior to bind to the host element.
         * @returns - the behavior to bind to the host element, or undefined.
         */
        createBehavior() {
            return undefined;
        }
    }

    function collectStyles(strings, values) {
        const styles = [];
        let cssString = "";
        const behaviors = [];
        for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
            cssString += strings[i];
            let value = values[i];
            if (value instanceof CSSDirective) {
                const behavior = value.createBehavior();
                value = value.createCSS();
                if (behavior) {
                    behaviors.push(behavior);
                }
            }
            if (value instanceof ElementStyles || value instanceof CSSStyleSheet) {
                if (cssString.trim() !== "") {
                    styles.push(cssString);
                    cssString = "";
                }
                styles.push(value);
            }
            else {
                cssString += value;
            }
        }
        cssString += strings[strings.length - 1];
        if (cssString.trim() !== "") {
            styles.push(cssString);
        }
        return {
            styles,
            behaviors,
        };
    }
    /**
     * Transforms a template literal string into styles.
     * @param strings - The string fragments that are interpolated with the values.
     * @param values - The values that are interpolated with the string fragments.
     * @remarks
     * The css helper supports interpolation of strings and ElementStyle instances.
     * @public
     */
    function css(strings, ...values) {
        const { styles, behaviors } = collectStyles(strings, values);
        const elementStyles = ElementStyles.create(styles);
        if (behaviors.length) {
            elementStyles.withBehaviors(...behaviors);
        }
        return elementStyles;
    }

    /**
     * The runtime behavior for template references.
     * @public
     */
    class RefBehavior {
        /**
         * Creates an instance of RefBehavior.
         * @param target - The element to reference.
         * @param propertyName - The name of the property to assign the reference to.
         */
        constructor(target, propertyName) {
            this.target = target;
            this.propertyName = propertyName;
        }
        /**
         * Bind this behavior to the source.
         * @param source - The source to bind to.
         * @param context - The execution context that the binding is operating within.
         */
        bind(source) {
            source[this.propertyName] = this.target;
        }
        /**
         * Unbinds this behavior from the source.
         * @param source - The source to unbind from.
         */
        /* eslint-disable-next-line @typescript-eslint/no-empty-function */
        unbind() { }
    }
    /**
     * A directive that observes the updates a property with a reference to the element.
     * @param propertyName - The name of the property to assign the reference to.
     * @public
     */
    function ref(propertyName) {
        return new AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
    }

    /**
     * A directive that enables basic conditional rendering in a template.
     * @param binding - The condition to test for rendering.
     * @param templateOrTemplateBinding - The template or a binding that gets
     * the template to render when the condition is true.
     * @public
     */
    function when(binding, templateOrTemplateBinding) {
        const getTemplate = typeof templateOrTemplateBinding === "function"
            ? templateOrTemplateBinding
            : () => templateOrTemplateBinding;
        return (source, context) => binding(source, context) ? getTemplate(source, context) : null;
    }

    /**
     * Creates a function that can be used to filter a Node array, selecting only elements.
     * @param selector - An optional selector to restrict the filter to.
     * @public
     */
    function elements(selector) {
        if (selector) {
            return function (value, index, array) {
                return value.nodeType === 1 && value.matches(selector);
            };
        }
        return function (value, index, array) {
            return value.nodeType === 1;
        };
    }
    /**
     * A base class for node observation.
     * @internal
     */
    class NodeObservationBehavior {
        /**
         * Creates an instance of NodeObservationBehavior.
         * @param target - The target to assign the nodes property on.
         * @param options - The options to use in configuring node observation.
         */
        constructor(target, options) {
            this.target = target;
            this.options = options;
            this.source = null;
        }
        /**
         * Bind this behavior to the source.
         * @param source - The source to bind to.
         * @param context - The execution context that the binding is operating within.
         */
        bind(source) {
            const name = this.options.property;
            this.shouldUpdate = Observable.getAccessors(source).some((x) => x.name === name);
            this.source = source;
            this.updateTarget(this.computeNodes());
            if (this.shouldUpdate) {
                this.observe();
            }
        }
        /**
         * Unbinds this behavior from the source.
         * @param source - The source to unbind from.
         */
        unbind() {
            this.updateTarget(emptyArray);
            this.source = null;
            if (this.shouldUpdate) {
                this.disconnect();
            }
        }
        /** @internal */
        handleEvent() {
            this.updateTarget(this.computeNodes());
        }
        computeNodes() {
            let nodes = this.getNodes();
            if (this.options.filter !== void 0) {
                nodes = nodes.filter(this.options.filter);
            }
            return nodes;
        }
        updateTarget(value) {
            this.source[this.options.property] = value;
        }
    }

    /**
     * The runtime behavior for slotted node observation.
     * @public
     */
    class SlottedBehavior extends NodeObservationBehavior {
        /**
         * Creates an instance of SlottedBehavior.
         * @param target - The slot element target to observe.
         * @param options - The options to use when observing the slot.
         */
        constructor(target, options) {
            super(target, options);
        }
        /**
         * Begins observation of the nodes.
         */
        observe() {
            this.target.addEventListener("slotchange", this);
        }
        /**
         * Disconnects observation of the nodes.
         */
        disconnect() {
            this.target.removeEventListener("slotchange", this);
        }
        /**
         * Retrieves the nodes that should be assigned to the target.
         */
        getNodes() {
            return this.target.assignedNodes(this.options);
        }
    }
    /**
     * A directive that observes the `assignedNodes()` of a slot and updates a property
     * whenever they change.
     * @param propertyOrOptions - The options used to configure slotted node observation.
     * @public
     */
    function slotted(propertyOrOptions) {
        if (typeof propertyOrOptions === "string") {
            propertyOrOptions = { property: propertyOrOptions };
        }
        return new AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
    }

    /**
     * The runtime behavior for child node observation.
     * @public
     */
    class ChildrenBehavior extends NodeObservationBehavior {
        /**
         * Creates an instance of ChildrenBehavior.
         * @param target - The element target to observe children on.
         * @param options - The options to use when observing the element children.
         */
        constructor(target, options) {
            super(target, options);
            this.observer = null;
            options.childList = true;
        }
        /**
         * Begins observation of the nodes.
         */
        observe() {
            if (this.observer === null) {
                this.observer = new MutationObserver(this.handleEvent.bind(this));
            }
            this.observer.observe(this.target, this.options);
        }
        /**
         * Disconnects observation of the nodes.
         */
        disconnect() {
            this.observer.disconnect();
        }
        /**
         * Retrieves the nodes that should be assigned to the target.
         */
        getNodes() {
            if ("subtree" in this.options) {
                return Array.from(this.target.querySelectorAll(this.options.selector));
            }
            return Array.from(this.target.childNodes);
        }
    }
    /**
     * A directive that observes the `childNodes` of an element and updates a property
     * whenever they change.
     * @param propertyOrOptions - The options used to configure child node observation.
     * @public
     */
    function children$1(propertyOrOptions) {
        if (typeof propertyOrOptions === "string") {
            propertyOrOptions = {
                property: propertyOrOptions,
            };
        }
        return new AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
    }

    /**
     * A mixin class implementing start and end elements.
     * These are generally used to decorate text elements with icons or other visual indicators.
     * @public
     */
    class StartEnd {
        handleStartContentChange() {
            this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0);
        }
        handleEndContentChange() {
            this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0);
        }
    }
    /**
     * The template for the end element.
     * For use with {@link StartEnd}
     *
     * @public
     */
    const endTemplate = html `
    <span part="end" ${ref("endContainer")}>
        <slot
            name="end"
            ${ref("end")}
            @slotchange="${x => x.handleEndContentChange()}"
        ></slot>
    </span>
`;
    /**
     * The template for the start element.
     * For use with {@link StartEnd}
     *
     * @public
     */
    const startTemplate = html `
    <span part="start" ${ref("startContainer")}>
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${x => x.handleStartContentChange()}"
        ></slot>
    </span>
`;

    /**
     * The template for the {@link @microsoft/fast-foundation#(AccordionItem:class)} component.
     * @public
     */
    const AccordionItemTemplate = html `
    <template
        class="${x => (x.expanded ? "expanded" : "")}"
        slot="item"
    >
        <div
            class="heading"
            part="heading"
            role="heading"
            aria-level="${x => x.headinglevel}"
        >
            <button
                class="button"
                part="button"
                ${ref("expandbutton")}
                aria-expanded="${x => x.expanded}"
                aria-controls="${x => x.id}-panel"
                id="${x => x.id}"
                @click="${(x, c) => x.clickHandler(c.event)}"
            >
                <span class="heading">
                    <slot name="heading" part="heading"></slot>
                </span>
            </button>
            ${startTemplate}
            ${endTemplate}
            <span class="icon" part="icon" aria-hidden="true">
                <slot name="expanded-icon" part="expanded-icon">
                    <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path
                            fill-rule="evenodd"
                            clip-rule="evenodd"
                            d="M3.78 3h12.44c.43 0 .78.35.78.78v12.44c0 .43-.35.78-.78.78H3.78a.78.78 0 01-.78-.78V3.78c0-.43.35-.78.78-.78zm12.44-1H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.78-.8 1.78-1.78V3.78C18 2.8 17.2 2 16.22 2zM14 9H6v2h8V9z"
                        />
                    </svg>
                </slot>
                <slot name="collapsed-icon" part="collapsed-icon">
                    <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path
                            fill-rule="evenodd"
                            clip-rule="evenodd"
                            d="M16.22 3H3.78a.78.78 0 00-.78.78v12.44c0 .43.35.78.78.78h12.44c.43 0 .78-.35.78-.78V3.78a.78.78 0 00-.78-.78zM3.78 2h12.44C17.2 2 18 2.8 18 3.78v12.44c0 .98-.8 1.78-1.78 1.78H3.78C2.8 18 2 17.2 2 16.22V3.78C2 2.8 2.8 2 3.78 2zM11 9h3v2h-3v3H9v-3H6V9h3V6h2v3z"
                        />
                    </svg>
                </slot>
            <span>
        </div>
        <div
            class="region"
            part="region"
            id="${x => x.id}-panel"
            role="region"
            aria-labelledby="${x => x.id}"
        >
            <slot></slot>
        </div>
    </template>
`;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    /**
     * Apply mixins to a constructor.
     * Sourced from {@link https://www.typescriptlang.org/docs/handbook/mixins.html | TypeScript Documentation }.
     * @public
     */
    function applyMixins(derivedCtor, ...baseCtors) {
        baseCtors.forEach(baseCtor => {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            });
            if (baseCtor.attributes) {
                const existing = derivedCtor.attributes || [];
                derivedCtor.attributes = existing.concat(baseCtor.attributes);
            }
        });
    }

    /**
     * An individual item in an {@link @microsoft/fast-foundation#(Accordion:class) }.
     * @public
     */
    class AccordionItem extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * Configures the {@link https://www.w3.org/TR/wai-aria-1.1/#aria-level | level} of the
             * heading element.
             *
             * @defaultValue 2
             * @public
             * @remarks
             * HTML attribute: heading-level
             */
            this.headinglevel = 2;
            /**
             * Expands or collapses the item.
             *
             * @public
             * @remarks
             * HTML attribute: expanded
             */
            this.expanded = false;
            /**
             * @internal
             */
            this.clickHandler = (e) => {
                this.expanded = !this.expanded;
                this.change();
            };
            this.change = () => {
                this.$emit("change");
            };
        }
    }
    __decorate([
        attr$1({
            attribute: "heading-level",
            mode: "fromView",
            converter: nullableNumberConverter,
        })
    ], AccordionItem.prototype, "headinglevel", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], AccordionItem.prototype, "expanded", void 0);
    __decorate([
        attr$1
    ], AccordionItem.prototype, "id", void 0);
    applyMixins(AccordionItem, StartEnd);

    /**
     * The template for the {@link @microsoft/fast-foundation#Accordion} component.
     * @public
     */
    const AccordionTemplate = html `
    <template>
        <slot name="item" part="item" ${slotted("accordionItems")}></slot>
    </template>
`;

    var Orientation;
    (function (Orientation) {
        Orientation["horizontal"] = "horizontal";
        Orientation["vertical"] = "vertical";
    })(Orientation || (Orientation = {}));

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$4.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$3.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? undefined : result;
      }
      return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /* Built-in method references that are verified to be native. */
    var Map$1 = getNative(root, 'Map');

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
      };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if the DOM is available to access and use
     */
    function canUseDOM() {
        return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }

    /**
     * A test that ensures that all arguments are HTML Elements
     */
    function isHTMLElement(...args) {
        return args.every((arg) => arg instanceof HTMLElement);
    }
    /**
     * Returns all displayed elements inside of a root node that match a provided selector
     */
    function getDisplayedNodes(rootNode, selector) {
        if (!isHTMLElement(rootNode)) {
            return;
        }
        const nodes = Array.from(rootNode.querySelectorAll(selector));
        // offsetParent will be null if the element isn't currently displayed,
        // so this will allow us to operate only on visible nodes
        return nodes.filter((node) => node.offsetParent !== null);
    }
    /**
     * Returns the nonce used in the page, if any.
     *
     * Based on https://github.com/cssinjs/jss/blob/master/packages/jss/src/DomRenderer.js
     */
    function getNonce() {
        const node = document.querySelector('meta[property="csp-nonce"]');
        if (node) {
            return node.getAttribute("content");
        }
        else {
            return null;
        }
    }
    /**
     * Test if the document supports :focus-visible
     */
    let _canUseFocusVisible;
    function canUseFocusVisible() {
        if (isBoolean(_canUseFocusVisible)) {
            return _canUseFocusVisible;
        }
        if (!canUseDOM()) {
            _canUseFocusVisible = false;
            return _canUseFocusVisible;
        }
        // Check to see if the document supports the focus-visible element
        const styleElement = document.createElement("style");
        // If nonces are present on the page, use it when creating the style element
        // to test focus-visible support.
        const styleNonce = getNonce();
        if (styleNonce !== null) {
            styleElement.setAttribute("nonce", styleNonce);
        }
        document.head.appendChild(styleElement);
        try {
            styleElement.sheet.insertRule("foo:focus-visible {color:inherit}", 0);
            _canUseFocusVisible = true;
        }
        catch (e) {
            _canUseFocusVisible = false;
        }
        finally {
            document.head.removeChild(styleElement);
        }
        return _canUseFocusVisible;
    }

    /*
     * Key Code values
     * @deprecated - use individual keycode exports
     */
    var KeyCodes;
    (function (KeyCodes) {
        KeyCodes[KeyCodes["alt"] = 18] = "alt";
        KeyCodes[KeyCodes["arrowDown"] = 40] = "arrowDown";
        KeyCodes[KeyCodes["arrowLeft"] = 37] = "arrowLeft";
        KeyCodes[KeyCodes["arrowRight"] = 39] = "arrowRight";
        KeyCodes[KeyCodes["arrowUp"] = 38] = "arrowUp";
        KeyCodes[KeyCodes["back"] = 8] = "back";
        KeyCodes[KeyCodes["backSlash"] = 220] = "backSlash";
        KeyCodes[KeyCodes["break"] = 19] = "break";
        KeyCodes[KeyCodes["capsLock"] = 20] = "capsLock";
        KeyCodes[KeyCodes["closeBracket"] = 221] = "closeBracket";
        KeyCodes[KeyCodes["colon"] = 186] = "colon";
        KeyCodes[KeyCodes["colon2"] = 59] = "colon2";
        KeyCodes[KeyCodes["comma"] = 188] = "comma";
        KeyCodes[KeyCodes["ctrl"] = 17] = "ctrl";
        KeyCodes[KeyCodes["delete"] = 46] = "delete";
        KeyCodes[KeyCodes["end"] = 35] = "end";
        KeyCodes[KeyCodes["enter"] = 13] = "enter";
        KeyCodes[KeyCodes["equals"] = 187] = "equals";
        KeyCodes[KeyCodes["equals2"] = 61] = "equals2";
        KeyCodes[KeyCodes["equals3"] = 107] = "equals3";
        KeyCodes[KeyCodes["escape"] = 27] = "escape";
        KeyCodes[KeyCodes["forwardSlash"] = 191] = "forwardSlash";
        KeyCodes[KeyCodes["function1"] = 112] = "function1";
        KeyCodes[KeyCodes["function10"] = 121] = "function10";
        KeyCodes[KeyCodes["function11"] = 122] = "function11";
        KeyCodes[KeyCodes["function12"] = 123] = "function12";
        KeyCodes[KeyCodes["function2"] = 113] = "function2";
        KeyCodes[KeyCodes["function3"] = 114] = "function3";
        KeyCodes[KeyCodes["function4"] = 115] = "function4";
        KeyCodes[KeyCodes["function5"] = 116] = "function5";
        KeyCodes[KeyCodes["function6"] = 117] = "function6";
        KeyCodes[KeyCodes["function7"] = 118] = "function7";
        KeyCodes[KeyCodes["function8"] = 119] = "function8";
        KeyCodes[KeyCodes["function9"] = 120] = "function9";
        KeyCodes[KeyCodes["home"] = 36] = "home";
        KeyCodes[KeyCodes["insert"] = 45] = "insert";
        KeyCodes[KeyCodes["menu"] = 93] = "menu";
        KeyCodes[KeyCodes["minus"] = 189] = "minus";
        KeyCodes[KeyCodes["minus2"] = 109] = "minus2";
        KeyCodes[KeyCodes["numLock"] = 144] = "numLock";
        KeyCodes[KeyCodes["numPad0"] = 96] = "numPad0";
        KeyCodes[KeyCodes["numPad1"] = 97] = "numPad1";
        KeyCodes[KeyCodes["numPad2"] = 98] = "numPad2";
        KeyCodes[KeyCodes["numPad3"] = 99] = "numPad3";
        KeyCodes[KeyCodes["numPad4"] = 100] = "numPad4";
        KeyCodes[KeyCodes["numPad5"] = 101] = "numPad5";
        KeyCodes[KeyCodes["numPad6"] = 102] = "numPad6";
        KeyCodes[KeyCodes["numPad7"] = 103] = "numPad7";
        KeyCodes[KeyCodes["numPad8"] = 104] = "numPad8";
        KeyCodes[KeyCodes["numPad9"] = 105] = "numPad9";
        KeyCodes[KeyCodes["numPadDivide"] = 111] = "numPadDivide";
        KeyCodes[KeyCodes["numPadDot"] = 110] = "numPadDot";
        KeyCodes[KeyCodes["numPadMinus"] = 109] = "numPadMinus";
        KeyCodes[KeyCodes["numPadMultiply"] = 106] = "numPadMultiply";
        KeyCodes[KeyCodes["numPadPlus"] = 107] = "numPadPlus";
        KeyCodes[KeyCodes["openBracket"] = 219] = "openBracket";
        KeyCodes[KeyCodes["pageDown"] = 34] = "pageDown";
        KeyCodes[KeyCodes["pageUp"] = 33] = "pageUp";
        KeyCodes[KeyCodes["period"] = 190] = "period";
        KeyCodes[KeyCodes["print"] = 44] = "print";
        KeyCodes[KeyCodes["quote"] = 222] = "quote";
        KeyCodes[KeyCodes["scrollLock"] = 145] = "scrollLock";
        KeyCodes[KeyCodes["shift"] = 16] = "shift";
        KeyCodes[KeyCodes["space"] = 32] = "space";
        KeyCodes[KeyCodes["tab"] = 9] = "tab";
        KeyCodes[KeyCodes["tilde"] = 192] = "tilde";
        KeyCodes[KeyCodes["windowsLeft"] = 91] = "windowsLeft";
        KeyCodes[KeyCodes["windowsOpera"] = 219] = "windowsOpera";
        KeyCodes[KeyCodes["windowsRight"] = 92] = "windowsRight";
    })(KeyCodes || (KeyCodes = {}));
    const keyCodeArrowDown = 40;
    const keyCodeArrowLeft = 37;
    const keyCodeArrowRight = 39;
    const keyCodeArrowUp = 38;
    const keyCodeEnd = 35;
    const keyCodeEnter = 13;
    const keyCodeHome = 36;
    const keyCodeSpace = 32;
    /**
     * String values for use with KeyboardEvent.key
     */
    const keyArrowDown = "ArrowDown";
    const keyArrowLeft = "ArrowLeft";
    const keyArrowRight = "ArrowRight";
    const keyArrowUp = "ArrowUp";
    const keyEnter = "Enter";
    const ArrowKeys = {
        ArrowDown: keyArrowDown,
        ArrowLeft: keyArrowLeft,
        ArrowRight: keyArrowRight,
        ArrowUp: keyArrowUp,
    };

    /**
     * Expose ltr and rtl strings
     */
    var Direction;
    (function (Direction) {
        Direction["ltr"] = "ltr";
        Direction["rtl"] = "rtl";
    })(Direction || (Direction = {}));

    /**
     * This method keeps a given value within the bounds of a min and max value. If the value
     * is larger than the max, the minimum value will be returned. If the value is smaller than the minimum,
     * the maximum will be returned. Otherwise, the value is returned un-changed.
     */
    function wrapInBounds(min, max, value) {
        if (value < min) {
            return max;
        }
        else if (value > max) {
            return min;
        }
        return value;
    }

    /**
     * Define system colors for use in CSS stylesheets.
     *
     * https://drafts.csswg.org/css-color/#css-system-colors
     */
    var SystemColors;
    (function (SystemColors) {
        SystemColors["Canvas"] = "Canvas";
        SystemColors["CanvasText"] = "CanvasText";
        SystemColors["LinkText"] = "LinkText";
        SystemColors["VisitedText"] = "VisitedText";
        SystemColors["ActiveText"] = "ActiveText";
        SystemColors["ButtonFace"] = "ButtonFace";
        SystemColors["ButtonText"] = "ButtonText";
        SystemColors["Field"] = "Field";
        SystemColors["FieldText"] = "FieldText";
        SystemColors["Highlight"] = "Highlight";
        SystemColors["HighlightText"] = "HighlightText";
        SystemColors["GrayText"] = "GrayText";
    })(SystemColors || (SystemColors = {}));

    /**
     * Expand mode for {@link Accordion}
     * @public
     */
    var AccordionExpandMode;
    (function (AccordionExpandMode) {
        /**
         * Designates only a single {@link @microsoft/fast-foundation#(AccordionItem:class) } can be open a time.
         */
        AccordionExpandMode["single"] = "single";
        /**
         * Designates multiple {@link @microsoft/fast-foundation#(AccordionItem:class) | AccordionItems} can be open simultaneously.
         */
        AccordionExpandMode["multi"] = "multi";
    })(AccordionExpandMode || (AccordionExpandMode = {}));
    /**
     * An Accordion Custom HTML Element
     * Implements {@link https://www.w3.org/TR/wai-aria-practices-1.1/#accordion | ARIA Accordion}.
     * @public
     *
     * @remarks
     * Designed to be used with {@link @microsoft/fast-foundation#AccordionTemplate} and {@link @microsoft/fast-foundation#(AccordionItem:class)}.
     */
    class Accordion extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * Controls the expand mode of the Accordion, either allowing
             * single or multiple item expansion.
             * @public
             *
             * @remarks
             * HTML attribute: expand-mode
             */
            this.expandmode = AccordionExpandMode.multi;
            this.activeItemIndex = 0;
            this.change = () => {
                this.$emit("change");
            };
            this.setItems = () => {
                this.accordionIds = this.getItemIds();
                this.accordionItems.forEach((item, index) => {
                    if (item instanceof AccordionItem) {
                        item.addEventListener("change", this.activeItemChange);
                        if (this.isSingleExpandMode()) {
                            this.activeItemIndex !== index
                                ? (item.expanded = false)
                                : (item.expanded = true);
                        }
                    }
                    const itemId = this.accordionIds[index];
                    item.setAttribute("id", typeof itemId !== "string" ? `accordion-${index + 1}` : itemId);
                    this.activeid = this.accordionIds[this.activeItemIndex];
                    item.addEventListener("keydown", this.handleItemKeyDown);
                    item.addEventListener("focus", this.handleItemFocus);
                });
            };
            this.removeItemListeners = (oldValue) => {
                oldValue.forEach((item, index) => {
                    item.removeEventListener("change", this.activeItemChange);
                    item.removeEventListener("keydown", this.handleItemKeyDown);
                    item.removeEventListener("focus", this.handleItemFocus);
                });
            };
            this.activeItemChange = (event) => {
                const selectedItem = event.target;
                if (this.isSingleExpandMode()) {
                    this.resetItems();
                    event.target.expanded = true;
                }
                this.activeid = event.target.getAttribute("id");
                this.activeItemIndex = Array.from(this.accordionItems).indexOf(selectedItem);
                this.change();
            };
            this.handleItemKeyDown = (event) => {
                // only handle the keydown if the event target is the accordion item
                // prevents arrow keys from moving focus to accordion headers when focus is on accordion item panel content
                if (event.target !== event.currentTarget) {
                    return;
                }
                const keyCode = event.keyCode;
                this.accordionIds = this.getItemIds();
                switch (keyCode) {
                    case keyCodeArrowUp:
                        event.preventDefault();
                        this.adjust(-1);
                        break;
                    case keyCodeArrowDown:
                        event.preventDefault();
                        this.adjust(1);
                        break;
                    case keyCodeHome:
                        this.activeItemIndex = 0;
                        this.focusItem();
                        break;
                    case keyCodeEnd:
                        this.activeItemIndex = this.accordionItems.length - 1;
                        this.focusItem();
                        break;
                }
            };
            this.handleItemFocus = (event) => {
                // update the active item index if the focus moves to an accordion item via a different method other than the up and down arrow key actions
                // only do so if the focus is actually on the accordion item and not on any of its children
                if (event.target === event.currentTarget) {
                    const focusedItem = event.target;
                    const focusedIndex = (this.activeItemIndex = Array.from(this.accordionItems).indexOf(focusedItem));
                    if (this.activeItemIndex !== focusedIndex && focusedIndex !== -1) {
                        this.activeItemIndex = focusedIndex;
                        this.activeid = this.accordionIds[this.activeItemIndex];
                    }
                }
            };
        }
        /**
         * @internal
         */
        accordionItemsChanged(oldValue, newValue) {
            if (this.$fastController.isConnected) {
                this.removeItemListeners(oldValue);
                this.accordionIds = this.getItemIds();
                this.setItems();
            }
        }
        resetItems() {
            this.accordionItems.forEach((item, index) => {
                item.expanded = false;
            });
        }
        getItemIds() {
            return this.accordionItems.map((accordionItem) => {
                return accordionItem.getAttribute("id");
            });
        }
        isSingleExpandMode() {
            return this.expandmode === AccordionExpandMode.single;
        }
        adjust(adjustment) {
            this.activeItemIndex = wrapInBounds(0, this.accordionItems.length - 1, this.activeItemIndex + adjustment);
            this.focusItem();
        }
        focusItem() {
            const element = this.accordionItems[this.activeItemIndex];
            if (element instanceof AccordionItem) {
                element.expandbutton.focus();
            }
        }
    }
    __decorate([
        attr$1({ attribute: "expand-mode" })
    ], Accordion.prototype, "expandmode", void 0);
    __decorate([
        observable
    ], Accordion.prototype, "accordionItems", void 0);

    /**
     * Some states and properties are applicable to all host language elements regardless of whether a role is applied.
     * The following global states and properties are supported by all roles and by all base markup elements.
     * {@link https://www.w3.org/TR/wai-aria-1.1/#global_states}
     *
     * This is intended to be used as a mixin. Be sure you extend FASTElement.
     *
     * @public
     */
    class ARIAGlobalStatesAndProperties {
    }
    __decorate([
        attr$1({ attribute: "aria-atomic", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaAtomic", void 0);
    __decorate([
        attr$1({ attribute: "aria-busy", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaBusy", void 0);
    __decorate([
        attr$1({ attribute: "aria-controls", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaControls", void 0);
    __decorate([
        attr$1({ attribute: "aria-current", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaCurrent", void 0);
    __decorate([
        attr$1({ attribute: "aria-describedby", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDescribedby", void 0);
    __decorate([
        attr$1({ attribute: "aria-details", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDetails", void 0);
    __decorate([
        attr$1({ attribute: "aria-disabled", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDisabled", void 0);
    __decorate([
        attr$1({ attribute: "aria-errormessage", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaErrormessage", void 0);
    __decorate([
        attr$1({ attribute: "aria-flowto", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaFlowto", void 0);
    __decorate([
        attr$1({ attribute: "aria-haspopup", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHaspopup", void 0);
    __decorate([
        attr$1({ attribute: "aria-hidden", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHidden", void 0);
    __decorate([
        attr$1({ attribute: "aria-invalid", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaInvalid", void 0);
    __decorate([
        attr$1({ attribute: "aria-keyshortcuts", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaKeyshortcuts", void 0);
    __decorate([
        attr$1({ attribute: "aria-label", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabel", void 0);
    __decorate([
        attr$1({ attribute: "aria-labelledby", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabelledby", void 0);
    __decorate([
        attr$1({ attribute: "aria-live", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLive", void 0);
    __decorate([
        attr$1({ attribute: "aria-owns", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaOwns", void 0);
    __decorate([
        attr$1({ attribute: "aria-relevant", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRelevant", void 0);
    __decorate([
        attr$1({ attribute: "aria-roledescription", mode: "fromView" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRoledescription", void 0);

    /**
     * Retrieves the "composed parent" element of a node, ignoring DOM tree boundaries.
     * When the parent of a node is a shadow-root, it will return the host
     * element of the shadow root. Otherwise it will return the parent node or null if
     * no parent node exists.
     * @param element - The element for which to retrieve the composed parent
     *
     * @public
     */
    function composedParent(element) {
        const parentNode = element.parentElement;
        if (parentNode) {
            return parentNode;
        }
        else {
            const rootNode = element.getRootNode();
            if (rootNode.host instanceof HTMLElement) {
                // this is shadow-root
                return rootNode.host;
            }
        }
        return null;
    }

    /**
     * An abstract behavior to react to media queries. Implementations should implement
     * the `constructListener` method to perform some action based on media query changes.
     *
     * @public
     */
    class MatchMediaBehavior {
        /**
         *
         * @param query - The media query to operate from.
         */
        constructor(query) {
            /**
             * The behavior needs to operate on element instances but elements might share a behavior instance.
             * To ensure proper attachment / detachment per instance, we construct a listener for
             * each bind invocation and cache the listeners by element reference.
             */
            this.listenerCache = new WeakMap();
            this.query = query;
        }
        /**
         * Binds the behavior to the element.
         * @param source - The element for which the behavior is bound.
         */
        bind(source) {
            const { query } = this;
            const listener = this.constructListener(source);
            // Invoke immediately to add if the query currently matches
            listener.bind(query)();
            query.addListener(listener);
            this.listenerCache.set(source, listener);
        }
        /**
         * Unbinds the behavior from the element.
         * @param source - The element for which the behavior is unbinding.
         */
        unbind(source) {
            const listener = this.listenerCache.get(source);
            if (listener) {
                this.query.removeListener(listener);
                this.listenerCache.delete(source);
            }
        }
    }
    /**
     * A behavior to add or remove a stylesheet from an element based on a media query. The behavior ensures that
     * styles are applied while the a query matches the environment and that styles are not applied if the query does
     * not match the environment.
     *
     * @public
     */
    class MatchMediaStyleSheetBehavior extends MatchMediaBehavior {
        /**
         * Constructs a {@link MatchMediaStyleSheetBehavior} instance.
         * @param query - The media query to operate from.
         * @param styles - The styles to coordinate with the query.
         */
        constructor(query, styles) {
            super(query);
            this.styles = styles;
        }
        /**
         * Defines a function to construct {@link MatchMediaStyleSheetBehavior | MatchMediaStyleSheetBehaviors} for
         * a provided query.
         * @param query - The media query to operate from.
         *
         * @public
         * @example
         *
         * ```ts
         * import { css } from "@microsoft/fast-element";
         * import { MatchMediaStyleSheetBehavior } from "@microsoft/fast-foundation";
         *
         * const landscapeBehavior = MatchMediaStyleSheetBehavior.with(
         *   window.matchMedia("(orientation: landscape)")
         * );
         * const styles = css`
         *   :host {
         *     width: 200px;
         *     height: 400px;
         *   }
         * `
         * .withBehaviors(landscapeBehavior(css`
         *   :host {
         *     width: 400px;
         *     height: 200px;
         *   }
         * `))
         * ```
         */
        static with(query) {
            return (styles) => {
                return new MatchMediaStyleSheetBehavior(query, styles);
            };
        }
        /**
         * Constructs a match-media listener for a provided element.
         * @param source - the element for which to attach or detach styles.
         * @internal
         */
        constructListener(source) {
            let attached = false;
            const styles = this.styles;
            return function listener() {
                const { matches } = this;
                if (matches && !attached) {
                    source.$fastController.addStyles(styles);
                    attached = matches;
                }
                else if (!matches && attached) {
                    source.$fastController.removeStyles(styles);
                    attached = matches;
                }
            };
        }
        /**
         * Unbinds the behavior from the element.
         * @param source - The element for which the behavior is unbinding.
         * @internal
         */
        unbind(source) {
            super.unbind(source);
            source.$fastController.removeStyles(this.styles);
        }
    }
    /**
     * This can be used to construct a behavior to apply a forced-colors only stylesheet.
     * @public
     */
    const forcedColorsStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(forced-colors)"));
    /**
     * This can be used to construct a behavior to apply a prefers color scheme: dark only stylesheet.
     * @public
     */
    MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: dark)"));
    /**
     * This can be used to construct a behavior to apply a prefers color scheme: light only stylesheet.
     * @public
     */
    MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: light)"));

    /**
     * A behavior to add or remove a stylesheet from an element based on a property. The behavior ensures that
     * styles are applied while the property matches and that styles are not applied if the property does
     * not match.
     *
     * @public
     */
    class PropertyStyleSheetBehavior {
        /**
         * Constructs a {@link PropertyStyleSheetBehavior} instance.
         * @param propertyName - The property name to operate from.
         * @param value - The property value to operate from.
         * @param styles - The styles to coordinate with the property.
         */
        constructor(propertyName, value, styles) {
            this.propertyName = propertyName;
            this.value = value;
            this.styles = styles;
        }
        /**
         * Binds the behavior to the element.
         * @param elementInstance - The element for which the property is applied.
         */
        bind(elementInstance) {
            Observable.getNotifier(elementInstance).subscribe(this, this.propertyName);
            this.handleChange(elementInstance, this.propertyName);
        }
        /**
         * Unbinds the behavior from the element.
         * @param source - The element for which the behavior is unbinding.
         * @internal
         */
        unbind(source) {
            Observable.getNotifier(source).unsubscribe(this, this.propertyName);
            source.$fastController.removeStyles(this.styles);
        }
        /**
         * Change event for the provided element.
         * @param source - the element for which to attach or detach styles.
         * @internal
         */
        handleChange(source, key) {
            if (source[key] === this.value) {
                source.$fastController.addStyles(this.styles);
            }
            else {
                source.$fastController.removeStyles(this.styles);
            }
        }
    }

    /**
     * The CSS value for disabled cursors.
     * @public
     */
    const disabledCursor = "not-allowed";

    /**
     * A CSS fragment to set `display: none;` when the host is hidden using the [hidden] attribute.
     * @public
     */
    const hidden = `:host([hidden]){display:none}`;
    /**
     * Applies a CSS display property.
     * Also adds CSS rules to not display the element when the [hidden] attribute is applied to the element.
     * @param display - The CSS display property value
     * @public
     */
    function display(displayValue) {
        return `${hidden}:host{display:${displayValue}}`;
    }

    /**
     * The string representing the focus selector to be used. Value
     * will be "focus-visible" when https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo
     * is supported and "focus" when it is not.
     *
     * @public
     */
    const focusVisible = canUseFocusVisible() ? "focus-visible" : "focus";

    const hostSelector = ":host{}";
    class CustomPropertyManagerBase {
        constructor() {
            /**
             * A queue of additions and deletions. Operations will be queued when customPropertyTarget is null
             */
            this.queue = new Set();
            /**
             * The CSSStyleDeclaration to which all CSS custom properties are written
             */
            this.customPropertyTarget = null;
            /**
             * The private settable owner
             */
            this._owner = null;
            /**
             * Tracks state of rAF to only invoke property writes once per animation frame
             */
            this.ticking = false;
            /**
             * Stores all CSSCustomPropertyDefinitions registered with the provider.
             */
            this.cssCustomPropertyDefinitions = new Map();
        }
        /**
         * {@inheritdoc CustomPropertyManager.owner}
         */
        get owner() {
            return this._owner;
        }
        /**
         * {@inheritdoc CustomPropertyManager.register}
         */
        register(def) {
            const cached = this.cssCustomPropertyDefinitions.get(def.name);
            if (cached) {
                cached.count += 1;
            }
            else {
                this.cssCustomPropertyDefinitions.set(def.name, Object.assign(Object.assign({}, def), { count: 1 }));
                this.set(def);
            }
        }
        /**
         * {@inheritdoc CustomPropertyManager.unregister}
         */
        unregister(name) {
            const cached = this.cssCustomPropertyDefinitions.get(name);
            if (cached) {
                cached.count -= 1;
                if (cached.count === 0) {
                    this.cssCustomPropertyDefinitions.delete(name);
                    this.remove(name);
                }
            }
        }
        /**
         * {@inheritdoc CustomPropertyManager.set}
         */
        set(definition) {
            if (this.owner) {
                this.customPropertyTarget
                    ? this.customPropertyTarget.setProperty(`--${definition.name}`, this.owner.evaluate(definition))
                    : this.queue.add(this.set.bind(this, definition));
            }
        }
        /**
         * Removes a CSS custom property from the provider.
         * @param name - the name of the property to remove
         */
        remove(name) {
            this.customPropertyTarget
                ? this.customPropertyTarget.removeProperty(`--${name}`)
                : this.queue.add(this.remove.bind(this, name));
        }
        /**
         * {@inheritdoc CustomPropertyManager.setAll}
         */
        setAll() {
            if (this.ticking) {
                return;
            }
            this.ticking = true;
            DOM.queueUpdate(() => {
                this.ticking = false;
                this.cssCustomPropertyDefinitions.forEach(def => {
                    this.set(def);
                });
            });
        }
    }
    /**
     * An implementation of {@link CustomPropertyManager} that uses the constructable CSSStyleSheet object.
     * This implementation supports multiple CustomPropertyManagerTarget subscriptions.
     *
     * @public
     */
    class ConstructableStylesCustomPropertyManager extends CustomPropertyManagerBase {
        constructor(sheet) {
            super();
            this.subscribers = new Set();
            this.sheet = sheet;
            this.styles = ElementStyles.create([sheet]);
            this.customPropertyTarget = sheet.cssRules[sheet.insertRule(hostSelector)].style;
        }
        /**
         * {@inheritdoc CustomPropertyManager.subscribe}
         */
        subscribe(client) {
            this.subscribers.add(client);
            if (this.subscribers.size === 1) {
                this._owner = client;
            }
            client.cssCustomPropertyDefinitions.forEach(def => {
                this.register(def);
            });
            client.$fastController.addStyles(this.styles);
        }
        /**
         * {@inheritdoc CustomPropertyManager.unsubscribe}
         */
        unsubscribe(client) {
            this.subscribers.delete(client);
            client.cssCustomPropertyDefinitions.forEach(def => this.unregister(def.name));
            if (this.owner === client) {
                this._owner = this.subscribers.size
                    ? this.subscribers.values().next().value
                    : null;
            }
            if (!this.sheet.ownerNode && this.styles) {
                client.$fastController.removeStyles(this.styles);
            }
        }
        /**
         * {@inheritdoc CustomPropertyManager.isSubscribed}
         */
        isSubscribed(client) {
            return this.subscribers.has(client);
        }
    }
    /**
     * An implementation of {@link CustomPropertyManager} that uses the HTMLStyleElement. This implementation
     * does not support multiple CustomPropertyManagerTarget subscriptions.
     *
     * @public
     */
    class StyleElementCustomPropertyManager extends CustomPropertyManagerBase {
        constructor(style, client) {
            super();
            this._sheet = null;
            this.handleConnection = {
                handleChange: () => {
                    var _a;
                    this._sheet = this.styles.sheet;
                    const key = this.sheet.insertRule(hostSelector);
                    this.customPropertyTarget = this.sheet.rules[key].style;
                    Observable.getNotifier((_a = this._owner) === null || _a === void 0 ? void 0 : _a.$fastController).unsubscribe(this.handleConnection, "isConnected");
                },
            };
            const controller = client.$fastController;
            // For HTMLStyleElements we need to attach the element
            // to the DOM prior to accessing the HTMLStyleElement.sheet
            // because the property evaluates null if disconnected
            controller.addStyles(style);
            this.styles = style;
            this._owner = client;
            // If the element isn't connected when the manager is created, the sheet can be null.
            // In those cases, set up notifier for when the element is connected and set up the customPropertyTarget
            // then.
            client.isConnected
                ? this.handleConnection.handleChange()
                : Observable.getNotifier(controller).subscribe(this.handleConnection, "isConnected");
            client.cssCustomPropertyDefinitions.forEach(def => {
                this.register(def);
            });
        }
        get sheet() {
            return this._sheet;
        }
        customPropertyTargetChanged(prev, next) {
            if (!prev && this.queue.size) {
                this.queue.forEach(fn => fn());
                this.queue.clear();
            }
        }
    }
    __decorate([
        observable
    ], StyleElementCustomPropertyManager.prototype, "customPropertyTarget", void 0);

    /**
     * Determines if the element is {@link DesignSystemConsumer}
     * @param element - the element to test.
     * @public
     */
    function isDesignSystemConsumer(element) {
        const provider = element.provider;
        return (provider !== null &&
            provider !== void 0 &&
            DesignSystemProvider.isDesignSystemProvider(provider));
    }
    /**
     * Behavior to connect a {@link DesignSystemConsumer} to the nearest {@link DesignSystemProvider}
     * @public
     */
    const designSystemConsumerBehavior = {
        bind(source) {
            source.provider = DesignSystemProvider.findProvider(source);
        },
        /* eslint-disable-next-line */
        unbind(source) { },
    };
    /**
     * A element to provide Design System values to consumers via CSS custom properties
     * and to resolve recipe values.
     *
     * @public
     */
    class DesignSystemProvider extends FASTElement {
        constructor() {
            super();
            /**
             * Allows other components to identify this as a provider.
             * Using instanceof DesignSystemProvider did not seem to work.
             *
             * @public
             */
            this.isDesignSystemProvider = true;
            /**
             * The design-system object.
             * This is "observable" but will notify on object mutation
             * instead of object assignment
             *
             * @public
             */
            this.designSystem = {};
            /**
             * Applies the default design-system values to the instance where properties
             * are not explicitly assigned. This is generally used to set the root design
             * system context.
             *
             * @public
             * @remarks
             * HTML Attribute: use-defaults
             */
            this.useDefaults = false;
            /**
             * The parent provider the the DesignSystemProvider instance.
             * @public
             */
            this.provider = null;
            /**
             * Stores all CSSCustomPropertyDefinitions registered with the provider.
             * @internal
             *
             */
            this.cssCustomPropertyDefinitions = new Map();
            /**
             * Handle changes to design-system-provider IDL and content attributes
             * that reflect to design-system properties.
             */
            this.attributeChangeHandler = {
                handleChange: (source, key) => {
                    const value = this[key];
                    const manager = this.customPropertyManager;
                    if (this.isValidDesignSystemValue(value)) {
                        this.designSystem[key] = value;
                        const property = this.designSystemProperties[key];
                        if (property && property.cssCustomProperty && manager) {
                            manager.set({
                                name: property.cssCustomProperty,
                                value,
                            });
                        }
                    }
                    else {
                        this.syncDesignSystemWithProvider();
                        const property = this.designSystemProperties[key].cssCustomProperty;
                        if (manager) {
                            if (typeof property === "string") {
                                manager.remove(property);
                            }
                            manager.setAll();
                        }
                    }
                },
            };
            /**
             * Handle changes to the local design-system property.
             */
            this.localDesignSystemChangeHandler = {
                handleChange: () => {
                    const manager = this.customPropertyManager;
                    if (manager && manager.owner === this) {
                        manager.setAll();
                    }
                },
            };
            /**
             * Handle changes to the upstream design-system provider
             */
            this.providerDesignSystemChangeHandler = {
                handleChange: (source, key) => {
                    if (source[key] !== this.designSystem[key] &&
                        !this.isValidDesignSystemValue(this[key])) {
                        this.designSystem[key] = source[key];
                    }
                },
            };
            // In cases where adoptedStyleSheets *is* supported, the customPropertyStyleSheet is assigned in the connectedCallback
            // to give authors opportunity to assign an initial value. In cases where adoptedStyleSheets are *un-supported*, the
            // property is assigned in the constructor to ensure the DesignSystemProvider initializes the property. The change handler
            // will then prevent any future assignment.
            if (!DOM.supportsAdoptedStyleSheets) {
                this.customPropertyManager = new StyleElementCustomPropertyManager(document.createElement("style"), this);
            }
            else {
                this.customPropertyManager = new ConstructableStylesCustomPropertyManager(new CSSStyleSheet());
            }
            if (this.designSystemProperties === undefined) {
                this.designSystemProperties = {};
            }
            this.$fastController.addBehaviors([designSystemConsumerBehavior]);
        }
        /**
         * Read all tag-names that are associated to
         * design-system-providers
         *
         * @public
         */
        static get tagNames() {
            return DesignSystemProvider._tagNames;
        }
        /**
         * Determines if an element is a DesignSystemProvider
         * @param el - The element to test
         *
         * @public
         */
        static isDesignSystemProvider(el) {
            return (el.isDesignSystemProvider ||
                DesignSystemProvider.tagNames.indexOf(el.tagName) !== -1);
        }
        /**
         * Finds the closest design-system-provider
         * to an element.
         *
         * @param el - The element from which to begin searching.
         * @public
         */
        static findProvider(el) {
            if (isDesignSystemConsumer(el)) {
                return el.provider;
            }
            let parent = composedParent(el);
            while (parent !== null) {
                if (DesignSystemProvider.isDesignSystemProvider(parent)) {
                    el.provider = parent; // Store provider on ourselves for future reference
                    return parent;
                }
                else if (isDesignSystemConsumer(parent)) {
                    el.provider = parent.provider;
                    return parent.provider;
                }
                else {
                    parent = composedParent(parent);
                }
            }
            return null;
        }
        /**
         * Registers a tag-name to be associated with
         * the design-system-provider class. All tag-names for DesignSystemProvider elements
         * must be registered for proper property resolution.
         *
         * @param tagName - the HTML Element tag name to register as a DesignSystemProvider.
         *
         * @public
         */
        static registerTagName(tagName) {
            const tagNameUpper = tagName.toUpperCase();
            if (DesignSystemProvider.tagNames.indexOf(tagNameUpper) === -1) {
                DesignSystemProvider._tagNames.push(tagNameUpper);
            }
        }
        useDefaultsChanged() {
            if (this.useDefaults) {
                const props = this.designSystemProperties;
                Object.keys(props).forEach((key) => {
                    if (this[key] === void 0) {
                        this[key] = props[key].default;
                    }
                });
            }
        }
        providerChanged(prev, next) {
            if (prev instanceof HTMLElement) {
                const notifier = Observable.getNotifier(prev.designSystem);
                Observable.getAccessors(prev.designSystem).forEach(x => {
                    notifier.unsubscribe(this.providerDesignSystemChangeHandler, x.name);
                });
            }
            if (next instanceof HTMLElement &&
                DesignSystemProvider.isDesignSystemProvider(next)) {
                const notifier = Observable.getNotifier(next.designSystem);
                const localAccessors = Observable.getAccessors(this.designSystem).reduce((prev, next) => {
                    return Object.assign(Object.assign({}, prev), { [next.name]: next });
                }, {});
                const localNotifier = Observable.getNotifier(this.designSystem);
                Observable.getAccessors(next.designSystem).forEach(x => {
                    notifier.subscribe(this.providerDesignSystemChangeHandler, x.name);
                    // Hook up parallel design system property to react to changes to this property
                    if (!localAccessors[x.name]) {
                        observable(this.designSystem, x.name);
                        localNotifier.subscribe(this.localDesignSystemChangeHandler, x.name);
                    }
                });
                this.syncDesignSystemWithProvider();
            }
        }
        customPropertyManagerChanged(prev, next) {
            if (prev && prev.unsubscribe) {
                prev.unsubscribe(this);
            }
            if (next.subscribe) {
                next.subscribe(this);
            }
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            if (this.customPropertyManager.subscribe &&
                this.customPropertyManager.isSubscribed &&
                !this.customPropertyManager.isSubscribed(this)) {
                this.customPropertyManager.subscribe(this);
            }
            const selfNotifier = Observable.getNotifier(this);
            const designSystemNotifier = Observable.getNotifier(this.designSystem);
            Object.keys(this.designSystemProperties).forEach(property => {
                observable(this.designSystem, property);
                selfNotifier.subscribe(this.attributeChangeHandler, property); // Notify ourselves when properties related to DS change
                designSystemNotifier.subscribe(this.localDesignSystemChangeHandler, property); // Notify ourselves when design system properties change
                const value = this[property];
                // If property is set then put it onto the design system
                if (this.isValidDesignSystemValue(value)) {
                    this.designSystem[property] = value;
                    const { cssCustomProperty } = this.designSystemProperties[property];
                    if (typeof cssCustomProperty === "string" &&
                        this.customPropertyManager &&
                        this.customPropertyManager.owner === this) {
                        this.customPropertyManager.set({
                            name: cssCustomProperty,
                            value: this[property],
                        });
                    }
                }
            });
            // Register all properties that may have been attached before construction
            if (Array.isArray(this.disconnectedCSSCustomPropertyRegistry)) {
                for (let i = 0; i < this.disconnectedCSSCustomPropertyRegistry.length; i++) {
                    this.registerCSSCustomProperty(this.disconnectedCSSCustomPropertyRegistry[i]);
                }
                delete this.disconnectedCSSCustomPropertyRegistry;
            }
            if (Array.isArray(this.disconnectedRegistry)) {
                for (let i = 0; i < this.disconnectedRegistry.length; i++) {
                    this.disconnectedRegistry[i](this);
                }
                delete this.disconnectedRegistry;
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            if (this.customPropertyManager.unsubscribe) {
                this.customPropertyManager.unsubscribe(this);
            }
        }
        /**
         * Register a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} with the DeignSystemProvider.
         * Registering a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} will create the CSS custom property.
         *
         * @param def - The {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} to register.
         * @public
         */
        registerCSSCustomProperty(def) {
            this.cssCustomPropertyDefinitions.set(def.name, def);
            this.customPropertyManager.register(def);
        }
        /**
         * Unregister a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} from the DeignSystemProvider.
         * If all registrations of the definition are unregistered, the CSS custom property will be removed.
         *
         * @param def - The {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} to register.
         * @public
         */
        unregisterCSSCustomProperty(def) {
            this.cssCustomPropertyDefinitions.delete(def.name);
            this.customPropertyManager.unregister(def.name);
        }
        /**
         * Evaluates a CSSCustomPropertyDefinition with the current design system.
         *
         * @public
         */
        evaluate(definition) {
            return typeof definition.value === "function"
                ? // use spread on the designSystem object to circumvent memoization
                    // done in the color recipes - we use the same *reference* in WC
                    // for performance improvements but that throws off the recipes
                    // We should look at making the recipes use simple args that
                    // we can individually memoize.
                    definition.value(Object.assign({}, this.designSystem))
                : definition.value;
        }
        /**
         * Synchronize the provider's design system with the local
         * overrides. Any value defined on the instance will take priority
         * over the value defined by the provider
         */
        syncDesignSystemWithProvider() {
            if (this.provider) {
                const localDSAccessors = Observable.getAccessors(this.designSystem).reduce((prev, next) => {
                    prev[next.name] = next;
                    return prev;
                }, {});
                Observable.getAccessors(this.provider.designSystem).forEach(x => {
                    var _a;
                    // If the property is not enumerated as a DesignSystemProperty,
                    // Or it is but the property is unset on the this provider instance,
                    // And the parent value *is* a valid value,
                    // Sync the value from the parent provider's designSystem to the local designSystem
                    if ((!this.designSystemProperties.hasOwnProperty(x.name) ||
                        !this.isValidDesignSystemValue(this[x.name])) &&
                        this.isValidDesignSystemValue((_a = this.provider) === null || _a === void 0 ? void 0 : _a.designSystem[x.name])) {
                        if (!localDSAccessors[x.name]) {
                            Observable.defineProperty(this.designSystem, x.name);
                        }
                        this.designSystem[x.name] = this.provider.designSystem[x.name];
                    }
                });
            }
        }
        isValidDesignSystemValue(value) {
            return value !== void 0 && value !== null;
        }
    }
    /**
     * Stores a list of all element tag-names that associated
     * to design-system-providers
     */
    DesignSystemProvider._tagNames = [];
    __decorate([
        attr$1({ attribute: "use-defaults", mode: "boolean" })
    ], DesignSystemProvider.prototype, "useDefaults", void 0);
    __decorate([
        observable
    ], DesignSystemProvider.prototype, "provider", void 0);
    __decorate([
        observable
    ], DesignSystemProvider.prototype, "customPropertyManager", void 0);
    /**
     * Defines a design-system-provider custom element, registering the tag-name so that the element can be property resolved by {@link DesignSystemConsumer | DesignSystemConsumers}.
     *
     * @param nameOrDef - the name or {@link @microsoft/fast-element#PartialFASTElementDefinition | element definition}
     * @public
     */
    function defineDesignSystemProvider(nameOrDef) {
        return (providerCtor) => {
            customElement(nameOrDef)(providerCtor);
            providerCtor.registerTagName(typeof nameOrDef === "string" ? nameOrDef : nameOrDef.name);
        };
    }
    /**
     * @internal
     * @deprecated - use {@link defineDesignSystemProvider}
     */
    const designSystemProvider = defineDesignSystemProvider;

    /**
     * Decorator to declare a property as a design-system property.
     * Intended to be used with the {@link @microsoft/fast-foundation#DesignSystemProvider}
     * @param config - {@link DecoratorDesignSystemPropertyConfiguration}
     *
     * @public
     */
    function designSystemProperty(config) {
        const decorator = (source, prop, config) => {
            const { cssCustomProperty, attribute } = config;
            if (!source.designSystemProperties) {
                source.designSystemProperties = {};
            }
            if (attribute === false) {
                observable(source, prop);
            }
            else {
                /**
                 * Default to fromView so we don't perform un-necessary DOM writes
                 */
                if (config.mode === void 0) {
                    config = Object.assign(Object.assign({}, config), { mode: "fromView" });
                }
                attr$1(config)(source, prop);
            }
            source.designSystemProperties[prop] = {
                cssCustomProperty: cssCustomProperty === false
                    ? false
                    : typeof cssCustomProperty === "string"
                        ? cssCustomProperty
                        : typeof attribute === "string"
                            ? attribute
                            : prop,
                default: config.default,
            };
        };
        return (source, prop) => {
            decorator(source, prop, config);
        };
    }

    /**
     * The template for the {@link @microsoft/fast-foundation#DesignSystemProvider} component.
     * @public
     */
    const DesignSystemProviderTemplate = html `
    <slot></slot>
`;

    /**
     * Behavior to conditionally apply LTR and RTL stylesheets. To determine which to apply,
     * the behavior will use the nearest DesignSystemProvider's 'direction' design system value.
     *
     * @public
     * @example
     * ```ts
     * import { css } from "@microsoft/fast-element";
     * import { DirectionalStyleSheetBehavior } from "@microsoft/fast-foundation";
     *
     * css`
     *  // ...
     * `.withBehaviors(new DirectionalStyleSheetBehavior(
     *   css`:host { content: "ltr"}`),
     *   css`:host { content: "rtl"}`),
     * )
     * ```
     */
    class DirectionalStyleSheetBehavior {
        constructor(ltr, rtl) {
            this.cache = new WeakMap();
            this.ltr = ltr;
            this.rtl = rtl;
        }
        /**
         * @internal
         */
        bind(source) {
            const provider = DesignSystemProvider.findProvider(source);
            if (provider !== null) {
                if (provider.$fastController && provider.$fastController.isConnected) {
                    this.attach(source, provider);
                }
                else {
                    if (!Array.isArray(provider.disconnectedRegistry)) {
                        provider.disconnectedRegistry = [];
                    }
                    provider.disconnectedRegistry.push(this.attach.bind(this, source));
                }
            }
        }
        /**
         * @internal
         */
        unbind(source) {
            const cache = this.cache.get(source);
            if (cache) {
                Observable.getNotifier(cache[0].designSystem).unsubscribe(cache[1]);
            }
        }
        attach(source, provider) {
            const subscriber = new DirectionalStyleSheetBehaviorSubscription(this.ltr, this.rtl, source);
            Observable.getNotifier(provider.designSystem).subscribe(subscriber, "direction");
            subscriber.attach(provider.designSystem["direction"]);
            this.cache.set(source, [provider, subscriber]);
        }
    }
    /**
     * Subscription for {@link DirectionalStyleSheetBehavior}
     */
    class DirectionalStyleSheetBehaviorSubscription {
        constructor(ltr, rtl, source) {
            this.ltr = ltr;
            this.rtl = rtl;
            this.source = source;
            this.attached = null;
        }
        handleChange(source) {
            this.attach(source.direction);
        }
        attach(direction) {
            if (this.attached !== this[direction]) {
                if (this.attached !== null) {
                    this.source.$fastController.removeStyles(this.attached);
                }
                this.attached = this[direction];
                if (this.attached !== null) {
                    this.source.$fastController.addStyles(this.attached);
                }
            }
        }
    }

    /**
     * a method to determine the current localization direction of the view
     * @param rootNode - the HTMLElement to begin the query from, usually "this" when used in a component controller
     * @public
     */
    const getDirection = (rootNode) => {
        const dirNode = rootNode.closest("[dir]");
        return dirNode !== null && dirNode.dir === "rtl" ? Direction.rtl : Direction.ltr;
    };

    /**
     * The template for the {@link @microsoft/fast-foundation#(Button:class)} component.
     * @public
     */
    const ButtonTemplate = html `
    <button
        class="control"
        part="control"
        ?autofocus="${x => x.autofocus}"
        ?disabled="${x => x.disabled}"
        form="${x => x.formId}"
        formaction="${x => x.formaction}"
        formenctype="${x => x.formenctype}"
        formmethod="${x => x.formmethod}"
        formnovalidate="${x => x.formnovalidate}"
        formtarget="${x => x.formtarget}"
        name="${x => x.name}"
        type="${x => x.type}"
        value="${x => x.value}"
        aria-atomic="${x => x.ariaAtomic}"
        aria-busy="${x => x.ariaBusy}"
        aria-controls="${x => x.ariaControls}"
        aria-current="${x => x.ariaCurrent}"
        aria-describedBy="${x => x.ariaDescribedby}"
        aria-details="${x => x.ariaDetails}"
        aria-disabled="${x => x.ariaDisabled}"
        aria-errormessage="${x => x.ariaErrormessage}"
        aria-expanded="${x => x.ariaExpanded}"
        aria-flowto="${x => x.ariaFlowto}"
        aria-haspopup="${x => x.ariaHaspopup}"
        aria-hidden="${x => x.ariaHidden}"
        aria-invalid="${x => x.ariaInvalid}"
        aria-keyshortcuts="${x => x.ariaKeyshortcuts}"
        aria-label="${x => x.ariaLabel}"
        aria-labelledby="${x => x.ariaLabelledby}"
        aria-live="${x => x.ariaLive}"
        aria-owns="${x => x.ariaOwns}"
        aria-pressed="${x => x.ariaPressed}"
        aria-relevant="${x => x.ariaRelevant}"
        aria-roledescription="${x => x.ariaRoledescription}"
        ${ref("control")}
    >
        ${startTemplate}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endTemplate}
    </button>
`;

    const proxySlotName = "form-associated-proxy";
    const ElementInternalsKey = "ElementInternals";
    /**
     * @alpha
     */
    const supportsElementInternals = ElementInternalsKey in window &&
        "setFormValue" in window[ElementInternalsKey].prototype;
    const InternalsMap = new Map();
    /**
     * Base function for providing Custom Element Form Association.
     *
     * @alpha
     */
    function FormAssociated(BaseCtor) {
        const C = class extends BaseCtor {
            constructor(...args) {
                super(...args);
                /**
                 * Track whether the value has been changed from the initial value
                 */
                this.dirtyValue = false;
                /**
                 * Sets the element's disabled state. A disabled element will not be included during form submission.
                 *
                 * @remarks
                 * HTML Attribute: disabled
                 */
                this.disabled = false;
                /**
                 * These are events that are still fired by the proxy
                 * element based on user / programmatic interaction.
                 *
                 * The proxy implementation should be transparent to
                 * the app author, so block these events from emitting.
                 */
                this.proxyEventsToBlock = ["change", "click"];
                /**
                 * Invoked when a connected component's form or fieldset has its disabled
                 * state changed.
                 * @param disabled - the disabled value of the form / fieldset
                 */
                this.formDisabledCallback = (disabled) => {
                    this.disabled = disabled;
                };
                this.formResetCallback = () => {
                    this.value = this.initialValue;
                    this.dirtyValue = false;
                };
                this.proxyInitialized = false;
                this.required = false;
                this.initialValue = this.initialValue || "";
            }
            /**
             * Must evaluate to true to enable elementInternals.
             * Feature detects API support and resolve respectively
             *
             * @internal
             */
            static get formAssociated() {
                return supportsElementInternals;
            }
            /**
             * Returns the validity state of the element
             *
             * @alpha
             */
            get validity() {
                return this.elementInternals
                    ? this.elementInternals.validity
                    : this.proxy.validity;
            }
            /**
             * Retrieve a reference to the associated form.
             * Returns null if not associated to any form.
             *
             * @alpha
             */
            get form() {
                return this.elementInternals ? this.elementInternals.form : this.proxy.form;
            }
            /**
             * Retrieve the localized validation message,
             * or custom validation message if set.
             *
             * @alpha
             */
            get validationMessage() {
                return this.elementInternals
                    ? this.elementInternals.validationMessage
                    : this.proxy.validationMessage;
            }
            /**
             * Whether the element will be validated when the
             * form is submitted
             */
            get willValidate() {
                return this.elementInternals
                    ? this.elementInternals.willValidate
                    : this.proxy.willValidate;
            }
            /**
             * A reference to all associated label elements
             */
            get labels() {
                if (this.elementInternals) {
                    return Object.freeze(Array.from(this.elementInternals.labels));
                }
                else if (this.proxy instanceof HTMLElement &&
                    this.proxy.ownerDocument &&
                    this.id) {
                    // Labels associated by wrapping the element: <label><custom-element></custom-element></label>
                    const parentLabels = this.proxy.labels;
                    // Labels associated using the `for` attribute
                    const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));
                    const labels = parentLabels
                        ? forLabels.concat(Array.from(parentLabels))
                        : forLabels;
                    return Object.freeze(labels);
                }
                else {
                    return emptyArray;
                }
            }
            /**
             * Invoked when the `value` property changes
             * @param previous - the previous value
             * @param next - the new value
             *
             * @remarks
             * If elements extending `FormAssociated` implement a `valueChanged` method
             * They must be sure to invoke `super.valueChanged(previous, next)` to ensure
             * proper functioning of `FormAssociated`
             */
            valueChanged(previous, next) {
                this.dirtyValue = true;
                if (this.proxy instanceof HTMLElement) {
                    this.proxy.value = this.value;
                }
                this.setFormValue(this.value);
                this.validate();
            }
            /**
             * Invoked when the `initialValue` property changes
             *
             * @param previous - the previous value
             * @param next - the new value
             *
             * @remarks
             * If elements extending `FormAssociated` implement a `initialValueChanged` method
             * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure
             * proper functioning of `FormAssociated`
             */
            initialValueChanged(previous, next) {
                // If the value is clean and the component is connected to the DOM
                // then set value equal to the attribute value.
                if (!this.dirtyValue) {
                    this.value = this.initialValue;
                    this.dirtyValue = false;
                }
            }
            /**
             * Invoked when the `disabled` property changes
             *
             * @param previous - the previous value
             * @param next - the new value
             *
             * @remarks
             * If elements extending `FormAssociated` implement a `disabledChanged` method
             * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure
             * proper functioning of `FormAssociated`
             */
            disabledChanged(previous, next) {
                if (this.proxy instanceof HTMLElement) {
                    this.proxy.disabled = this.disabled;
                }
                DOM.queueUpdate(() => this.classList.toggle("disabled", this.disabled));
            }
            /**
             * Invoked when the `name` property changes
             *
             * @param previous - the previous value
             * @param next - the new value
             *
             * @remarks
             * If elements extending `FormAssociated` implement a `nameChanged` method
             * They must be sure to invoke `super.nameChanged(previous, next)` to ensure
             * proper functioning of `FormAssociated`
             */
            nameChanged(previous, next) {
                if (this.proxy instanceof HTMLElement) {
                    this.proxy.name = this.name;
                }
            }
            /**
             * Invoked when the `required` property changes
             *
             * @param previous - the previous value
             * @param next - the new value
             *
             * @remarks
             * If elements extending `FormAssociated` implement a `requiredChanged` method
             * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure
             * proper functioning of `FormAssociated`
             */
            requiredChanged(prev, next) {
                if (this.proxy instanceof HTMLElement) {
                    this.proxy.required = this.required;
                }
                DOM.queueUpdate(() => this.classList.toggle("required", this.required));
                this.validate();
            }
            /**
             * The element internals object. Will only exist
             * in browsers supporting the attachInternals API
             */
            get elementInternals() {
                if (!supportsElementInternals) {
                    return null;
                }
                let internals = InternalsMap.get(this);
                if (!internals) {
                    internals = this.attachInternals();
                    InternalsMap.set(this, internals);
                }
                return internals;
            }
            /**
             * @internal
             */
            connectedCallback() {
                super.connectedCallback();
                this.addEventListener("keypress", this._keypressHandler);
                if (!this.value) {
                    this.value = this.initialValue;
                    this.dirtyValue = false;
                }
                if (!this.elementInternals) {
                    this.attachProxy();
                }
                if (this.form) {
                    this.form.addEventListener("reset", this.formResetCallback);
                }
            }
            /**
             * @internal
             */
            disconnectedCallback() {
                this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));
                if (this.form) {
                    this.form.removeEventListener("reset", this.formResetCallback);
                }
            }
            /**
             * Return the current validity of the element.
             */
            checkValidity() {
                return this.elementInternals
                    ? this.elementInternals.checkValidity()
                    : this.proxy.checkValidity();
            }
            /**
             * Return the current validity of the element.
             * If false, fires an invalid event at the element.
             */
            reportValidity() {
                return this.elementInternals
                    ? this.elementInternals.reportValidity()
                    : this.proxy.reportValidity();
            }
            /**
             * Set the validity of the control. In cases when the elementInternals object is not
             * available (and the proxy element is used to report validity), this function will
             * do nothing unless a message is provided, at which point the setCustomValidity method
             * of the proxy element will be invoked with the provided message.
             * @param flags - Validity flags
             * @param message - Optional message to supply
             * @param anchor - Optional element used by UA to display an interactive validation UI
             */
            setValidity(flags, message, anchor) {
                if (this.elementInternals) {
                    this.elementInternals.setValidity(flags, message, anchor);
                }
                else if (typeof message === "string") {
                    this.proxy.setCustomValidity(message);
                }
            }
            /**
             * Attach the proxy element to the DOM
             */
            attachProxy() {
                var _a;
                if (!this.proxyInitialized) {
                    this.proxyInitialized = true;
                    this.proxy.style.display = "none";
                    this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation));
                    // These are typically mapped to the proxy during
                    // property change callbacks, but during initialization
                    // on the initial call of the callback, the proxy is
                    // still undefined. We should find a better way to address this.
                    this.proxy.disabled = this.disabled;
                    this.proxy.required = this.required;
                    if (typeof this.name === "string") {
                        this.proxy.name = this.name;
                    }
                    if (typeof this.value === "string") {
                        this.proxy.value = this.value;
                    }
                    this.proxy.setAttribute("slot", proxySlotName);
                    this.proxySlot = document.createElement("slot");
                    this.proxySlot.setAttribute("name", proxySlotName);
                }
                (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);
                this.appendChild(this.proxy);
            }
            /**
             * Detach the proxy element from the DOM
             */
            detachProxy() {
                var _a;
                this.removeChild(this.proxy);
                (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);
            }
            /**
             * Sets the validity of the custom element. By default this uses the proxy element to determine
             * validity, but this can be extended or replaced in implementation.
             */
            validate() {
                if (this.proxy instanceof HTMLElement) {
                    this.setValidity(this.proxy.validity, this.proxy.validationMessage);
                }
            }
            /**
             * Associates the provided value (and optional state) with the parent form.
             * @param value - The value to set
             * @param state - The state object provided to during session restores and when autofilling.
             */
            setFormValue(value, state) {
                if (this.elementInternals) {
                    this.elementInternals.setFormValue(value, state || value);
                }
            }
            _keypressHandler(e) {
                switch (e.keyCode) {
                    case keyCodeEnter:
                        if (this.form instanceof HTMLFormElement) {
                            // Implicit submission
                            const defaultButton = this.form.querySelector("[type=submit]");
                            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();
                        }
                        break;
                }
            }
            /**
             * Used to stop propagation of proxy element events
             * @param e - Event object
             */
            stopPropagation(e) {
                e.stopPropagation();
            }
        };
        attr$1({ mode: "boolean" })(C.prototype, "disabled");
        attr$1({ mode: "fromView", attribute: "value" })(C.prototype, "initialValue");
        attr$1(C.prototype, "name");
        attr$1({ mode: "boolean" })(C.prototype, "required");
        observable(C.prototype, "value");
        return C;
    }

    class _Button extends FASTElement {
    }
    /**
     * A form-associated base class for the {@link @microsoft/fast-foundation#(Button:class)} component.
     *
     * @internal
     */
    class FormAssociatedButton extends FormAssociated(_Button) {
        constructor() {
            super(...arguments);
            this.proxy = document.createElement("input");
        }
    }

    /**
     * A Button Custom HTML Element.
     * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button | <button> element }.
     *
     * @public
     */
    class Button extends FormAssociatedButton {
        constructor() {
            super(...arguments);
            /**
             * Submits the parent form
             */
            this.handleSubmission = () => {
                if (!this.form) {
                    return;
                }
                const attached = this.proxy.isConnected;
                if (!attached) {
                    this.attachProxy();
                }
                // Browser support for requestSubmit is not comprehensive
                // so click the proxy if it isn't supported
                typeof this.form.requestSubmit === "function"
                    ? this.form.requestSubmit(this.proxy)
                    : this.proxy.click();
                if (!attached) {
                    this.detachProxy();
                }
            };
            /**
             * Resets the parent form
             */
            this.handleFormReset = () => {
                var _a;
                (_a = this.form) === null || _a === void 0 ? void 0 : _a.reset();
            };
        }
        formactionChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.formAction = this.formaction;
            }
        }
        formenctypeChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.formEnctype = this.formenctype;
            }
        }
        formmethodChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.formMethod = this.formmethod;
            }
        }
        formnovalidateChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.formNoValidate = this.formnovalidate;
            }
        }
        formtargetChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.formTarget = this.formtarget;
            }
        }
        typeChanged(previous, next) {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.type = this.type;
            }
            next === "submit" && this.addEventListener("click", this.handleSubmission);
            previous === "submit" && this.removeEventListener("click", this.handleSubmission);
            next === "reset" && this.addEventListener("click", this.handleFormReset);
            previous === "reset" && this.removeEventListener("click", this.handleFormReset);
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            this.proxy.setAttribute("type", this.type);
        }
        /**
         * @deprecated This API has been deprecated
         */
        get root() {
            return this.control;
        }
    }
    __decorate([
        attr$1({ mode: "boolean" })
    ], Button.prototype, "autofocus", void 0);
    __decorate([
        attr$1({ attribute: "form" })
    ], Button.prototype, "formId", void 0);
    __decorate([
        attr$1
    ], Button.prototype, "formaction", void 0);
    __decorate([
        attr$1
    ], Button.prototype, "formenctype", void 0);
    __decorate([
        attr$1
    ], Button.prototype, "formmethod", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], Button.prototype, "formnovalidate", void 0);
    __decorate([
        attr$1
    ], Button.prototype, "formtarget", void 0);
    __decorate([
        attr$1
    ], Button.prototype, "type", void 0);
    __decorate([
        observable
    ], Button.prototype, "defaultSlottedContent", void 0);
    /**
     * Includes ARIA states and properties relating to the ARIA button role
     *
     * @public
     */
    class DelegatesARIAButton {
    }
    __decorate([
        attr$1({ attribute: "aria-expanded", mode: "fromView" })
    ], DelegatesARIAButton.prototype, "ariaExpanded", void 0);
    __decorate([
        attr$1({ attribute: "aria-pressed", mode: "fromView" })
    ], DelegatesARIAButton.prototype, "ariaPressed", void 0);
    applyMixins(DelegatesARIAButton, ARIAGlobalStatesAndProperties);
    applyMixins(Button, StartEnd, DelegatesARIAButton);

    /**
     * A Behavior that will register to a {@link CSSCustomPropertyTarget} when bound.
     *
     * @public
     */
    class CSSCustomPropertyBehavior {
        /**
         *
         * @param name - The name of the custom property, without the prepended "--" required by {@link https://developer.mozilla.org/en-US/docs/Web/CSS/--* | CSS custom properties}.
         * @param value - The value of the custom property or a function that resolves the value.
         * @param host - A function that resolves the host element that will register the behavior
         */
        constructor(name, value, host) {
            this.name = name;
            this.value = value;
            this.host = host;
            this.propertyName = `--${name}`;
            this.var = `var(${this.propertyName})`;
        }
        /**
         * Binds the behavior to a source element
         * @param source - The source element being bound
         * @internal
         */
        bind(source) {
            const target = this.host(source);
            if (target !== null) {
                if (typeof target.registerCSSCustomProperty === "function") {
                    target.registerCSSCustomProperty(this);
                }
                else {
                    // There is potential for the custom property host element to not be
                    // constructed when this is run. We handle that case by accumulating
                    // the behaviors in a normal array. Behaviors associated this way will
                    // get registered when the host is connected
                    if (!Array.isArray(target.disconnectedCSSCustomPropertyRegistry)) {
                        target.disconnectedCSSCustomPropertyRegistry = [];
                    }
                    target.disconnectedCSSCustomPropertyRegistry.push(this);
                }
            }
        }
        /**
         * Unbinds the behavior from the source element.
         * @param source - The source element being unbound
         * @internal
         */
        unbind(source) {
            const target = this.host(source);
            if (target !== null && typeof target.unregisterCSSCustomProperty === "function") {
                target.unregisterCSSCustomProperty(this);
            }
        }
    }
    /**
     * Create a CSS Custom Property behavior.
     * @param name - The name of the CSS custom property
     * @param value - The value or value resolver of the custom property
     * @param host - A function to resolve the element to host the CSS custom property
     * @public
     */
    function cssCustomPropertyBehaviorFactory(name, value, host) {
        return new CSSCustomPropertyBehavior(name, value, host);
    }

    class _TextField extends FASTElement {
    }
    /**
     * A form-associated base class for the {@link @microsoft/fast-foundation#(TextField:class)} component.
     *
     * @internal
     */
    class FormAssociatedTextField extends FormAssociated(_TextField) {
        constructor() {
            super(...arguments);
            this.proxy = document.createElement("input");
        }
    }

    /**
     * Text field sub-types
     * @public
     */
    var TextFieldType;
    (function (TextFieldType) {
        /**
         * An email TextField
         */
        TextFieldType["email"] = "email";
        /**
         * A password TextField
         */
        TextFieldType["password"] = "password";
        /**
         * A telephone TextField
         */
        TextFieldType["tel"] = "tel";
        /**
         * A text TextField
         */
        TextFieldType["text"] = "text";
        /**
         * A URL TextField
         */
        TextFieldType["url"] = "url";
    })(TextFieldType || (TextFieldType = {}));

    /**
     * A Text Field Custom HTML Element.
     * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text | <input type="text" /> element }.
     *
     * @public
     */
    class TextField extends FormAssociatedTextField {
        constructor() {
            super(...arguments);
            /**
             * Allows setting a type or mode of text.
             * @public
             * @remarks
             * HTML Attribute: type
             */
            this.type = TextFieldType.text;
        }
        readOnlyChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.readOnly = this.readOnly;
                this.validate();
            }
        }
        autofocusChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.autofocus = this.autofocus;
                this.validate();
            }
        }
        placeholderChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.placeholder = this.placeholder;
            }
        }
        typeChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.type = this.type;
                this.validate();
            }
        }
        listChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.setAttribute("list", this.list);
                this.validate();
            }
        }
        maxlengthChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.maxLength = this.maxlength;
                this.validate();
            }
        }
        minlengthChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.minLength = this.minlength;
                this.validate();
            }
        }
        patternChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.pattern = this.pattern;
                this.validate();
            }
        }
        sizeChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.size = this.size;
            }
        }
        spellcheckChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.spellcheck = this.spellcheck;
            }
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            this.proxy.setAttribute("type", this.type);
            this.validate();
            if (this.autofocus) {
                DOM.queueUpdate(() => {
                    this.focus();
                });
            }
        }
        /**
         * Handles the internal control's `input` event
         * @internal
         */
        handleTextInput() {
            this.value = this.control.value;
        }
        /**
         * Change event handler for inner control.
         * @remarks
         * "Change" events are not `composable` so they will not
         * permeate the shadow DOM boundary. This fn effectively proxies
         * the change event, emitting a `change` event whenever the internal
         * control emits a `change` event
         * @internal
         */
        handleChange() {
            this.$emit("change");
        }
    }
    __decorate([
        attr$1({ attribute: "readonly", mode: "boolean" })
    ], TextField.prototype, "readOnly", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TextField.prototype, "autofocus", void 0);
    __decorate([
        attr$1
    ], TextField.prototype, "placeholder", void 0);
    __decorate([
        attr$1
    ], TextField.prototype, "type", void 0);
    __decorate([
        attr$1
    ], TextField.prototype, "list", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter })
    ], TextField.prototype, "maxlength", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter })
    ], TextField.prototype, "minlength", void 0);
    __decorate([
        attr$1
    ], TextField.prototype, "pattern", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter })
    ], TextField.prototype, "size", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TextField.prototype, "spellcheck", void 0);
    __decorate([
        observable
    ], TextField.prototype, "defaultSlottedNodes", void 0);
    /**
     * Includes ARIA states and properties relating to the ARIA textbox role
     *
     * @public
     */
    class DelegatesARIATextbox {
    }
    applyMixins(DelegatesARIATextbox, ARIAGlobalStatesAndProperties);
    applyMixins(TextField, StartEnd, DelegatesARIATextbox);

    /**
     * The template for the {@link @microsoft/fast-foundation#RadioGroup} component.
     * @public
     */
    const RadioGroupTemplate = html `
    <template
        role="radiogroup"
        aria-disabled="${x => x.disabled}"
        aria-readonly="${x => x.readOnly}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @focusout="${(x, c) => x.focusOutHandler(c.event)}"
    >
        <slot name="label"></slot>
        <div
            class="positioning-region ${x => x.orientation === Orientation.horizontal ? "horizontal" : "vertical"}"
            part="positioning-region"
        >
            <slot
                ${slotted({
    property: "slottedRadioButtons",
    filter: elements("[role=radio]"),
})}
            ></slot>
        </div>
    </template>
`;

    /**
     * An Radio Group Custom HTML Element.
     * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#radiogroup | ARIA radiogroup }.
     *
     * @public
     */
    class RadioGroup extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * The orientation of the group
             *
             * @public
             * @remarks
             * HTML Attribute: orientation
             */
            this.orientation = Orientation.horizontal;
            this.radioChangeHandler = (e) => {
                const changedRadio = e.target;
                if (changedRadio.checked) {
                    this.slottedRadioButtons.forEach((radio) => {
                        if (radio !== changedRadio) {
                            radio.checked = false;
                            if (!this.isInsideFoundationToolbar) {
                                radio.setAttribute("tabindex", "-1");
                            }
                        }
                    });
                    this.selectedRadio = changedRadio;
                    this.value = changedRadio.value;
                    changedRadio.setAttribute("tabindex", "0");
                    this.focusedRadio = changedRadio;
                }
                e.stopPropagation();
            };
            this.moveToRadioByIndex = (group, index) => {
                const radio = group[index];
                if (!this.isInsideToolbar) {
                    radio.setAttribute("tabindex", "0");
                    if (radio.readOnly) {
                        this.slottedRadioButtons.forEach((nextRadio) => {
                            if (nextRadio !== radio) {
                                nextRadio.setAttribute("tabindex", "-1");
                            }
                        });
                    }
                    else {
                        radio.checked = true;
                        this.selectedRadio = radio;
                    }
                }
                this.focusedRadio = radio;
                radio.focus();
            };
            this.moveRightOffGroup = () => {
                var _a;
                (_a = this.nextElementSibling) === null || _a === void 0 ? void 0 : _a.focus();
            };
            this.moveLeftOffGroup = () => {
                var _a;
                (_a = this.previousElementSibling) === null || _a === void 0 ? void 0 : _a.focus();
            };
            /**
             * @internal
             */
            this.focusOutHandler = (e) => {
                const group = this.slottedRadioButtons;
                const radio = e.target;
                const index = radio !== null ? group.indexOf(radio) : 0;
                const focusedIndex = this.focusedRadio
                    ? group.indexOf(this.focusedRadio)
                    : -1;
                if ((focusedIndex === 0 && index === focusedIndex) ||
                    (focusedIndex === group.length - 1 && focusedIndex === index)) {
                    if (!this.selectedRadio) {
                        this.focusedRadio = group[0];
                        this.focusedRadio.setAttribute("tabindex", "0");
                        group.forEach((nextRadio) => {
                            if (nextRadio !== this.focusedRadio) {
                                nextRadio.setAttribute("tabindex", "-1");
                            }
                        });
                    }
                    else {
                        this.focusedRadio = this.selectedRadio;
                        if (!this.isInsideFoundationToolbar) {
                            this.selectedRadio.setAttribute("tabindex", "0");
                            group.forEach((nextRadio) => {
                                if (nextRadio !== this.selectedRadio) {
                                    nextRadio.setAttribute("tabindex", "-1");
                                }
                            });
                        }
                    }
                }
                return true;
            };
            /**
             * @internal
             */
            this.clickHandler = (e) => {
                const radio = e.target;
                if (radio) {
                    const group = this.slottedRadioButtons;
                    if (radio.checked || group.indexOf(radio) === 0) {
                        radio.setAttribute("tabindex", "0");
                        this.selectedRadio = radio;
                    }
                    else {
                        radio.setAttribute("tabindex", "-1");
                        this.selectedRadio = null;
                    }
                    this.focusedRadio = radio;
                }
                e.preventDefault();
            };
            this.shouldMoveOffGroupToTheRight = (index, group, keyCode) => {
                return (index === group.length &&
                    this.isInsideToolbar &&
                    keyCode === keyCodeArrowRight);
            };
            this.shouldMoveOffGroupToTheLeft = (group, keyCode) => {
                const index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
                return index < 0 && this.isInsideToolbar && keyCode === keyCodeArrowLeft;
            };
            this.checkFocusedRadio = () => {
                if (this.focusedRadio !== null &&
                    !this.focusedRadio.readOnly &&
                    !this.focusedRadio.checked) {
                    this.focusedRadio.checked = true;
                    this.focusedRadio.setAttribute("tabindex", "0");
                    this.focusedRadio.focus();
                    this.selectedRadio = this.focusedRadio;
                }
            };
            this.moveRight = (e) => {
                const group = this.slottedRadioButtons;
                let index = 0;
                index = this.focusedRadio ? group.indexOf(this.focusedRadio) + 1 : 1;
                if (this.shouldMoveOffGroupToTheRight(index, group, e.keyCode)) {
                    this.moveRightOffGroup();
                    return;
                }
                else if (index === group.length) {
                    index = 0;
                }
                /* looping to get to next radio that is not disabled */
                /* matching native radio/radiogroup which does not select an item if there is only 1 in the group */
                while (index < group.length && group.length > 1) {
                    if (!group[index].disabled) {
                        this.moveToRadioByIndex(group, index);
                        break;
                    }
                    else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
                        break;
                    }
                    else if (index + 1 >= group.length) {
                        if (this.isInsideToolbar) {
                            break;
                        }
                        else {
                            index = 0;
                        }
                    }
                    else {
                        index += 1;
                    }
                }
            };
            this.moveLeft = (e) => {
                const group = this.slottedRadioButtons;
                let index = 0;
                index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
                index = index < 0 ? group.length - 1 : index;
                if (this.shouldMoveOffGroupToTheLeft(group, e.keyCode)) {
                    this.moveLeftOffGroup();
                    return;
                }
                /* looping to get to next radio that is not disabled */
                while (index >= 0 && group.length > 1) {
                    if (!group[index].disabled) {
                        this.moveToRadioByIndex(group, index);
                        break;
                    }
                    else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
                        break;
                    }
                    else if (index - 1 < 0) {
                        index = group.length - 1;
                    }
                    else {
                        index -= 1;
                    }
                }
            };
            /**
             * keyboard handling per https://w3c.github.io/aria-practices/#for-radio-groups-not-contained-in-a-toolbar
             * navigation is different when there is an ancestor with role='toolbar'
             *
             * @internal
             */
            this.keydownHandler = (e) => {
                const key = e.key;
                if (key in ArrowKeys && this.isInsideFoundationToolbar) {
                    return true;
                }
                switch (key) {
                    case keyEnter: {
                        this.checkFocusedRadio();
                        break;
                    }
                    case keyArrowRight:
                    case keyArrowDown: {
                        if (this.direction === Direction.ltr) {
                            this.moveRight(e);
                        }
                        else {
                            this.moveLeft(e);
                        }
                        break;
                    }
                    case keyArrowLeft:
                    case keyArrowUp: {
                        if (this.direction === Direction.ltr) {
                            this.moveLeft(e);
                        }
                        else {
                            this.moveRight(e);
                        }
                        break;
                    }
                    default: {
                        return true;
                    }
                }
            };
        }
        readOnlyChanged() {
            if (this.slottedRadioButtons !== undefined) {
                this.slottedRadioButtons.forEach((radio) => {
                    if (this.readOnly) {
                        radio.readOnly = true;
                    }
                    else {
                        radio.readOnly = false;
                    }
                });
            }
        }
        disabledChanged() {
            if (this.slottedRadioButtons !== undefined) {
                this.slottedRadioButtons.forEach((radio) => {
                    if (this.disabled) {
                        radio.disabled = true;
                    }
                    else {
                        radio.disabled = false;
                    }
                });
            }
        }
        nameChanged() {
            if (this.slottedRadioButtons) {
                this.slottedRadioButtons.forEach((radio) => {
                    radio.setAttribute("name", this.name);
                });
            }
        }
        valueChanged() {
            if (this.slottedRadioButtons) {
                this.slottedRadioButtons.forEach((radio) => {
                    if (radio.getAttribute("value") === this.value) {
                        radio.checked = true;
                        this.selectedRadio = radio;
                    }
                });
            }
            this.$emit("change");
        }
        slottedRadioButtonsChanged(oldValue, newValue) {
            if (this.slottedRadioButtons && this.slottedRadioButtons.length > 0) {
                this.setupRadioButtons();
            }
        }
        get parentToolbar() {
            return this.closest('[role="toolbar"]');
        }
        get isInsideToolbar() {
            var _a;
            return ((_a = this.parentToolbar) !== null && _a !== void 0 ? _a : false);
        }
        get isInsideFoundationToolbar() {
            var _a;
            return !!((_a = this.parentToolbar) === null || _a === void 0 ? void 0 : _a["$fastController"]);
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            this.direction = getDirection(this);
            this.setupRadioButtons();
        }
        disconnectedCallback() {
            this.slottedRadioButtons.forEach((radio) => {
                radio.removeEventListener("change", this.radioChangeHandler);
            });
        }
        setupRadioButtons() {
            const checkedRadios = this.slottedRadioButtons.filter((radio) => {
                return radio.hasAttribute("checked");
            });
            const numberOfCheckedRadios = checkedRadios ? checkedRadios.length : 0;
            if (numberOfCheckedRadios > 1) {
                const lastCheckedRadio = checkedRadios[numberOfCheckedRadios - 1];
                lastCheckedRadio.checked = true;
            }
            let foundMatchingVal = false;
            this.slottedRadioButtons.forEach((radio) => {
                if (this.name !== undefined) {
                    radio.setAttribute("name", this.name);
                }
                if (this.disabled) {
                    radio.disabled = true;
                }
                if (this.readOnly) {
                    radio.readOnly = true;
                }
                if (this.value && this.value === radio.getAttribute("value")) {
                    this.selectedRadio = radio;
                    this.focusedRadio = radio;
                    radio.checked = true;
                    radio.setAttribute("tabindex", "0");
                    foundMatchingVal = true;
                }
                else {
                    if (!this.isInsideFoundationToolbar) {
                        radio.setAttribute("tabindex", "-1");
                    }
                    radio.checked = false;
                }
                radio.addEventListener("change", this.radioChangeHandler);
            });
            if (this.value === undefined && this.slottedRadioButtons.length > 0) {
                const checkedRadios = this.slottedRadioButtons.filter((radio) => {
                    return radio.hasAttribute("checked");
                });
                const numberOfCheckedRadios = checkedRadios !== null ? checkedRadios.length : 0;
                if (numberOfCheckedRadios > 0 && !foundMatchingVal) {
                    const lastCheckedRadio = checkedRadios[numberOfCheckedRadios - 1];
                    lastCheckedRadio.checked = true;
                    this.focusedRadio = lastCheckedRadio;
                    lastCheckedRadio.setAttribute("tabindex", "0");
                }
                else {
                    this.slottedRadioButtons[0].setAttribute("tabindex", "0");
                    this.focusedRadio = this.slottedRadioButtons[0];
                }
            }
        }
    }
    __decorate([
        attr$1({ attribute: "readonly", mode: "boolean" })
    ], RadioGroup.prototype, "readOnly", void 0);
    __decorate([
        attr$1({ attribute: "disabled", mode: "boolean" })
    ], RadioGroup.prototype, "disabled", void 0);
    __decorate([
        attr$1
    ], RadioGroup.prototype, "name", void 0);
    __decorate([
        attr$1
    ], RadioGroup.prototype, "value", void 0);
    __decorate([
        attr$1
    ], RadioGroup.prototype, "orientation", void 0);
    __decorate([
        observable
    ], RadioGroup.prototype, "childItems", void 0);
    __decorate([
        observable
    ], RadioGroup.prototype, "slottedRadioButtons", void 0);

    /**
     * The template for the {@link @microsoft/fast-foundation#(Radio:class)} component.
     * @public
     */
    const RadioTemplate = html `
    <template
        role="radio"
        class="${x => (x.checked ? "checked" : "")} ${x => x.readOnly ? "readonly" : ""}"
        aria-checked="${x => x.checked}"
        aria-required="${x => x.required}"
        aria-disabled="${x => x.disabled}"
        aria-readonly="${x => x.readOnly}"
        @keypress="${(x, c) => x.keypressHandler(c.event)}"
        @click="${(x, c) => x.clickHandler(c.event)}"
    >
        <div part="control" class="control">
            <slot name="checked-indicator">
                <div part="checked-indicator" class="checked-indicator"></div>
            </slot>
        </div>
        <label
            part="label"
            class="${x => x.defaultSlottedNodes && x.defaultSlottedNodes.length
    ? "label"
    : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
    </template>
`;

    class _Radio extends FASTElement {
    }
    /**
     * A form-associated base class for the {@link @microsoft/fast-foundation#(Radio:class)} component.
     *
     * @internal
     */
    class FormAssociatedRadio extends FormAssociated(_Radio) {
        constructor() {
            super(...arguments);
            this.proxy = document.createElement("input");
        }
    }

    /**
     * A Radio Custom HTML Element.
     * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#radio | ARIA radio }.
     *
     * @public
     */
    class Radio extends FormAssociatedRadio {
        constructor() {
            var _a;
            super();
            /**
             * The element's value to be included in form submission when checked.
             * Default to "on" to reach parity with input[type="radio"]
             *
             * @internal
             */
            this.initialValue = "on";
            /**
             * Provides the default checkedness of the input element
             * Passed down to proxy
             *
             * @public
             * @remarks
             * HTML Attribute: checked
             */
            this.checkedAttribute = false;
            /**
             * Tracks whether the "checked" property has been changed.
             * This is necessary to provide consistent behavior with
             * normal input radios
             */
            this.dirtyChecked = false;
            /**
             * @internal
             */
            this.formResetCallback = () => {
                this.checked = !!this.defaultChecked;
                this.dirtyChecked = false;
            };
            /**
             * @internal
             */
            this.keypressHandler = (e) => {
                switch (e.keyCode) {
                    case keyCodeSpace:
                        if (!this.checked && !this.readOnly) {
                            this.checked = true;
                        }
                        return;
                }
                return true;
            };
            /**
             * @internal
             */
            this.clickHandler = (e) => {
                if (!this.disabled && !this.readOnly && !this.checked) {
                    this.checked = true;
                }
            };
            this.checked = (_a = this.defaultChecked) !== null && _a !== void 0 ? _a : false;
        }
        readOnlyChanged() {
            if (this.proxy instanceof HTMLInputElement) {
                this.proxy.readOnly = this.readOnly;
            }
        }
        checkedAttributeChanged() {
            this.defaultChecked = this.checkedAttribute;
        }
        defaultCheckedChanged() {
            var _a;
            if (this.$fastController.isConnected && !this.dirtyChecked) {
                // Setting this.checked will cause us to enter a dirty state,
                // but if we are clean when defaultChecked is changed, we want to stay
                // in a clean state, so reset this.dirtyChecked
                if (!this.isInsideRadioGroup()) {
                    this.checked = (_a = this.defaultChecked) !== null && _a !== void 0 ? _a : false;
                    this.dirtyChecked = false;
                }
            }
        }
        checkedChanged() {
            if (this.$fastController.isConnected) {
                // changing the value via code and from radio-group
                if (!this.dirtyChecked) {
                    this.dirtyChecked = true;
                }
                this.updateForm();
                if (this.proxy instanceof HTMLInputElement) {
                    this.proxy.checked = this.checked;
                }
                this.$emit("change");
                this.validate();
            }
        }
        /**
         * @internal
         */
        connectedCallback() {
            var _a, _b;
            super.connectedCallback();
            this.proxy.setAttribute("type", "radio");
            this.validate();
            if (((_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute("role")) !== "radiogroup" &&
                this.getAttribute("tabindex") === null) {
                if (!this.disabled) {
                    this.setAttribute("tabindex", "0");
                }
            }
            this.updateForm();
            if (this.checkedAttribute) {
                if (!this.dirtyChecked) {
                    // Setting this.checked will cause us to enter a dirty state,
                    // but if we are clean when defaultChecked is changed, we want to stay
                    // in a clean state, so reset this.dirtyChecked
                    if (!this.isInsideRadioGroup()) {
                        this.checked = (_b = this.defaultChecked) !== null && _b !== void 0 ? _b : false;
                        this.dirtyChecked = false;
                    }
                }
            }
        }
        isInsideRadioGroup() {
            const parent = this.closest("[role=radiogroup]");
            return parent !== null;
        }
        updateForm() {
            const value = this.checked ? this.value : null;
            this.setFormValue(value, value);
        }
    }
    __decorate([
        attr$1({ attribute: "readonly", mode: "boolean" })
    ], Radio.prototype, "readOnly", void 0);
    __decorate([
        observable
    ], Radio.prototype, "name", void 0);
    __decorate([
        attr$1({ attribute: "checked", mode: "boolean" })
    ], Radio.prototype, "checkedAttribute", void 0);
    __decorate([
        observable
    ], Radio.prototype, "defaultSlottedNodes", void 0);
    __decorate([
        observable
    ], Radio.prototype, "defaultChecked", void 0);
    __decorate([
        observable
    ], Radio.prototype, "checked", void 0);

    /**
     * The template for the {@link @microsoft/fast-foundation#Tab} component.
     * @public
     */
    const TabTemplate = html `
    <template slot="tab" role="tab" aria-disabled="${x => x.disabled}">
        <slot></slot>
    </template>
`;

    /**
     * A Tab Component to be used with {@link @microsoft/fast-foundation#(Tabs:class)}
     * @public
     */
    class Tab extends FASTElement {
    }
    __decorate([
        attr$1({ mode: "boolean" })
    ], Tab.prototype, "disabled", void 0);

    /**
     * The template for the {@link @microsoft/fast-foundation#(Tabs:class)} component.
     * @public
     */
    const TabsTemplate = html `
    <template class="${x => x.orientation}">
        ${startTemplate}
        <div class="tablist" part="tablist" role="tablist">
            <slot class="tab" name="tab" part="tab" ${slotted("tabs")}></slot>

            ${when(x => x.showActiveIndicator, html `
                    <div
                        ${ref("activeIndicatorRef")}
                        class="activeIndicator"
                        part="activeIndicator"
                    ></div>
                `)}
        </div>
        ${endTemplate}
        <div class="tabpanel">
            <slot name="tabpanel" part="tabpanel" ${slotted("tabpanels")}></slot>
        </div>
    </template>
`;

    /**
     * The orientation of the {@link @microsoft/fast-foundation#(Tabs:class)} component
     * @public
     */
    var TabsOrientation;
    (function (TabsOrientation) {
        TabsOrientation["vertical"] = "vertical";
        TabsOrientation["horizontal"] = "horizontal";
    })(TabsOrientation || (TabsOrientation = {}));
    /**
     * A Tabs Custom HTML Element.
     * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#tablist | ARIA tablist }.
     *
     * @public
     */
    class Tabs extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * The orientation
             * @public
             * @remarks
             * HTML Attribute: orientation
             */
            this.orientation = TabsOrientation.horizontal;
            /**
             * Whether or not to show the active indicator
             * @public
             * @remarks
             * HTML Attribute: activeindicator
             */
            this.activeindicator = true;
            /**
             * @internal
             */
            this.showActiveIndicator = true;
            this.prevActiveTabIndex = 0;
            this.activeTabIndex = 0;
            this.ticking = false;
            this.change = () => {
                this.$emit("change", this.activetab);
            };
            this.isDisabledElement = (el) => {
                return el.getAttribute("aria-disabled") === "true";
            };
            this.isFocusableElement = (el) => {
                return !this.isDisabledElement(el);
            };
            this.setTabs = () => {
                const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
                this.tabIds = this.getTabIds();
                this.tabpanelIds = this.getTabPanelIds();
                this.activeTabIndex = this.getActiveIndex();
                this.showActiveIndicator = false;
                this.tabs.forEach((tab, index) => {
                    if (tab.slot === "tab" && this.isFocusableElement(tab)) {
                        if (this.activeindicator) {
                            this.showActiveIndicator = true;
                        }
                        const tabId = this.tabIds[index];
                        const tabpanelId = this.tabpanelIds[index];
                        tab.setAttribute("id", typeof tabId !== "string" ? `tab-${index + 1}` : tabId);
                        tab.setAttribute("aria-selected", this.activeTabIndex === index ? "true" : "false");
                        tab.setAttribute("aria-controls", typeof tabpanelId !== "string" ? `panel-${index + 1}` : tabpanelId);
                        tab.addEventListener("click", this.handleTabClick);
                        tab.addEventListener("keydown", this.handleTabKeyDown);
                        tab.setAttribute("tabindex", this.activeTabIndex === index ? "0" : "-1");
                        if (this.activeTabIndex === index) {
                            this.activetab = tab;
                        }
                    }
                    tab.style[gridProperty] = `${index + 1}`;
                    !this.isHorizontal()
                        ? tab.classList.add("vertical")
                        : tab.classList.remove("vertical");
                });
            };
            this.setTabPanels = () => {
                this.tabIds = this.getTabIds();
                this.tabpanelIds = this.getTabPanelIds();
                this.tabpanels.forEach((tabpanel, index) => {
                    const tabId = this.tabIds[index];
                    const tabpanelId = this.tabpanelIds[index];
                    tabpanel.setAttribute("id", typeof tabpanelId !== "string" ? `panel-${index + 1}` : tabpanelId);
                    tabpanel.setAttribute("aria-labelledby", typeof tabId !== "string" ? `tab-${index + 1}` : tabId);
                    this.activeTabIndex !== index
                        ? tabpanel.setAttribute("hidden", "")
                        : tabpanel.removeAttribute("hidden");
                });
            };
            this.handleTabClick = (event) => {
                const selectedTab = event.currentTarget;
                if (selectedTab.nodeType === 1) {
                    this.prevActiveTabIndex = this.activeTabIndex;
                    this.activeTabIndex = this.tabs.indexOf(selectedTab);
                    this.setComponent();
                }
            };
            this.handleTabKeyDown = (event) => {
                const keyCode = event.keyCode;
                if (this.isHorizontal()) {
                    switch (keyCode) {
                        case keyCodeArrowLeft:
                            event.preventDefault();
                            this.adjustBackward(event);
                            break;
                        case keyCodeArrowRight:
                            event.preventDefault();
                            this.adjustForward(event);
                            break;
                    }
                }
                else {
                    switch (keyCode) {
                        case keyCodeArrowUp:
                            event.preventDefault();
                            this.adjustBackward(event);
                            break;
                        case keyCodeArrowDown:
                            event.preventDefault();
                            this.adjustForward(event);
                            break;
                    }
                }
                switch (keyCode) {
                    case keyCodeHome:
                        event.preventDefault();
                        this.adjust(-this.activeTabIndex);
                        break;
                    case keyCodeEnd:
                        event.preventDefault();
                        this.adjust(this.tabs.length - this.activeTabIndex - 1);
                        break;
                }
            };
            this.adjustForward = (e) => {
                const group = this.tabs;
                let index = 0;
                index = this.activetab ? group.indexOf(this.activetab) + 1 : 1;
                if (index === group.length) {
                    index = 0;
                }
                while (index < group.length && group.length > 1) {
                    if (this.isFocusableElement(group[index])) {
                        this.moveToTabByIndex(group, index);
                        break;
                    }
                    else if (this.activetab && index === group.indexOf(this.activetab)) {
                        break;
                    }
                    else if (index + 1 >= group.length) {
                        index = 0;
                    }
                    else {
                        index += 1;
                    }
                }
            };
            this.adjustBackward = (e) => {
                const group = this.tabs;
                let index = 0;
                index = this.activetab ? group.indexOf(this.activetab) - 1 : 0;
                index = index < 0 ? group.length - 1 : index;
                while (index >= 0 && group.length > 1) {
                    if (this.isFocusableElement(group[index])) {
                        this.moveToTabByIndex(group, index);
                        break;
                    }
                    else if (index - 1 < 0) {
                        index = group.length - 1;
                    }
                    else {
                        index -= 1;
                    }
                }
            };
            this.moveToTabByIndex = (group, index) => {
                const tab = group[index];
                this.activetab = tab;
                this.prevActiveTabIndex = this.activeTabIndex;
                this.activeTabIndex = index;
                tab.focus();
                this.setComponent();
            };
        }
        /**
         * @internal
         */
        activeidChanged() {
            if (this.$fastController.isConnected &&
                this.tabs.length <= this.tabpanels.length) {
                this.setTabs();
                this.setTabPanels();
                this.handleActiveIndicatorPosition();
            }
        }
        /**
         * @internal
         */
        tabsChanged() {
            if (this.$fastController.isConnected &&
                this.tabs.length <= this.tabpanels.length) {
                this.setTabs();
                this.setTabPanels();
                this.handleActiveIndicatorPosition();
            }
        }
        /**
         * @internal
         */
        tabpanelsChanged() {
            if (this.$fastController.isConnected &&
                this.tabpanels.length <= this.tabs.length) {
                this.setTabs();
                this.setTabPanels();
                this.handleActiveIndicatorPosition();
            }
        }
        getActiveIndex() {
            const id = this.activeid;
            if (id !== undefined) {
                return this.tabIds.indexOf(this.activeid) === -1
                    ? 0
                    : this.tabIds.indexOf(this.activeid);
            }
            else {
                return 0;
            }
        }
        getTabIds() {
            return this.tabs.map((tab) => {
                return tab.getAttribute("id");
            });
        }
        getTabPanelIds() {
            return this.tabpanels.map((tabPanel) => {
                return tabPanel.getAttribute("id");
            });
        }
        setComponent() {
            if (this.activeTabIndex !== this.prevActiveTabIndex) {
                this.activeid = this.tabIds[this.activeTabIndex];
                this.change();
                this.setTabs();
                this.handleActiveIndicatorPosition();
                this.setTabPanels();
                this.focusTab();
                this.change();
            }
        }
        isHorizontal() {
            return this.orientation === TabsOrientation.horizontal;
        }
        handleActiveIndicatorPosition() {
            // Ignore if we click twice on the same tab
            if (this.showActiveIndicator &&
                this.activeindicator &&
                this.activeTabIndex !== this.prevActiveTabIndex) {
                if (this.ticking) {
                    this.ticking = false;
                }
                else {
                    this.ticking = true;
                    this.animateActiveIndicator();
                }
            }
        }
        animateActiveIndicator() {
            this.ticking = true;
            const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
            const translateProperty = this.isHorizontal()
                ? "translateX"
                : "translateY";
            const offsetProperty = this.isHorizontal() ? "offsetLeft" : "offsetTop";
            const prev = this.activeIndicatorRef[offsetProperty];
            this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
            const next = this.activeIndicatorRef[offsetProperty];
            this.activeIndicatorRef.style[gridProperty] = `${this.prevActiveTabIndex + 1}`;
            const dif = next - prev;
            this.activeIndicatorRef.style.transform = `${translateProperty}(${dif}px)`;
            this.activeIndicatorRef.classList.add("activeIndicatorTransition");
            this.activeIndicatorRef.addEventListener("transitionend", () => {
                this.ticking = false;
                this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
                this.activeIndicatorRef.style.transform = `${translateProperty}(0px)`;
                this.activeIndicatorRef.classList.remove("activeIndicatorTransition");
            });
        }
        /**
         * The adjust method for FASTTabs
         * @public
         * @remarks
         * This method allows the active index to be adjusted by numerical increments
         */
        adjust(adjustment) {
            this.prevActiveTabIndex = this.activeTabIndex;
            this.activeTabIndex = wrapInBounds(0, this.tabs.length - 1, this.activeTabIndex + adjustment);
            this.setComponent();
        }
        focusTab() {
            this.tabs[this.activeTabIndex].focus();
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            this.tabIds = this.getTabIds();
            this.tabpanelIds = this.getTabPanelIds();
            this.activeTabIndex = this.getActiveIndex();
        }
    }
    __decorate([
        attr$1
    ], Tabs.prototype, "orientation", void 0);
    __decorate([
        attr$1
    ], Tabs.prototype, "activeid", void 0);
    __decorate([
        observable
    ], Tabs.prototype, "tabs", void 0);
    __decorate([
        observable
    ], Tabs.prototype, "tabpanels", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], Tabs.prototype, "activeindicator", void 0);
    __decorate([
        observable
    ], Tabs.prototype, "activeIndicatorRef", void 0);
    __decorate([
        observable
    ], Tabs.prototype, "showActiveIndicator", void 0);
    applyMixins(Tabs, StartEnd);

    class _TextArea extends FASTElement {
    }
    /**
     * A form-associated base class for the {@link @microsoft/fast-foundation#(TextArea:class)} component.
     *
     * @internal
     */
    class FormAssociatedTextArea extends FormAssociated(_TextArea) {
        constructor() {
            super(...arguments);
            this.proxy = document.createElement("textarea");
        }
    }

    /**
     * Resize mode for a TextArea
     * @public
     */
    var TextAreaResize;
    (function (TextAreaResize) {
        /**
         * No resize.
         */
        TextAreaResize["none"] = "none";
        /**
         * Resize vertically and horizontally.
         */
        TextAreaResize["both"] = "both";
        /**
         * Resize horizontally.
         */
        TextAreaResize["horizontal"] = "horizontal";
        /**
         * Resize vertically.
         */
        TextAreaResize["vertical"] = "vertical";
    })(TextAreaResize || (TextAreaResize = {}));

    /**
     * A Text Area Custom HTML Element.
     * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea | <textarea> element }.
     *
     * @public
     */
    class TextArea extends FormAssociatedTextArea {
        constructor() {
            super(...arguments);
            /**
             * The resize mode of the element.
             * @public
             * @remarks
             * HTML Attribute: resize
             */
            this.resize = TextAreaResize.none;
            /**
             * Sizes the element horizontally by a number of character columns.
             *
             * @public
             * @remarks
             * HTML Attribute: cols
             */
            this.cols = 20;
            /**
             * @internal
             */
            this.handleTextInput = () => {
                this.value = this.control.value;
            };
        }
        readOnlyChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.readOnly = this.readOnly;
            }
        }
        autofocusChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.autofocus = this.autofocus;
            }
        }
        listChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.setAttribute("list", this.list);
            }
        }
        maxlengthChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.maxLength = this.maxlength;
            }
        }
        minlengthChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.minLength = this.minlength;
            }
        }
        spellcheckChanged() {
            if (this.proxy instanceof HTMLTextAreaElement) {
                this.proxy.spellcheck = this.spellcheck;
            }
        }
        /**
         * Change event handler for inner control.
         * @remarks
         * "Change" events are not `composable` so they will not
         * permeate the shadow DOM boundary. This fn effectively proxies
         * the change event, emitting a `change` event whenever the internal
         * control emits a `change` event
         * @internal
         */
        handleChange() {
            this.$emit("change");
        }
    }
    __decorate([
        attr$1({ mode: "boolean" })
    ], TextArea.prototype, "readOnly", void 0);
    __decorate([
        attr$1
    ], TextArea.prototype, "resize", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TextArea.prototype, "autofocus", void 0);
    __decorate([
        attr$1({ attribute: "form" })
    ], TextArea.prototype, "formId", void 0);
    __decorate([
        attr$1
    ], TextArea.prototype, "list", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter })
    ], TextArea.prototype, "maxlength", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter })
    ], TextArea.prototype, "minlength", void 0);
    __decorate([
        attr$1
    ], TextArea.prototype, "name", void 0);
    __decorate([
        attr$1
    ], TextArea.prototype, "placeholder", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "cols", void 0);
    __decorate([
        attr$1({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "rows", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TextArea.prototype, "spellcheck", void 0);
    __decorate([
        observable
    ], TextArea.prototype, "defaultSlottedNodes", void 0);
    applyMixins(TextArea, DelegatesARIATextbox);

    /**
     * The template for the {@link @microsoft/fast-foundation#(TextArea:class)} component.
     * @public
     */
    const TextAreaTemplate = html `
    <template
        class="
            ${x => (x.readOnly ? "readonly" : "")}
            ${x => (x.resize !== TextAreaResize.none ? `resize-${x.resize}` : "")}"
    >
        <label
            part="label"
            for="control"
            class="${x => x.defaultSlottedNodes && x.defaultSlottedNodes.length
    ? "label"
    : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <textarea
            part="control"
            class="control"
            id="control"
            ?autofocus="${x => x.autofocus}"
            cols="${x => x.cols}"
            ?disabled="${x => x.disabled}"
            form="${x => x.form}"
            list="${x => x.list}"
            maxlength="${x => x.maxlength}"
            minlength="${x => x.minlength}"
            name="${x => x.name}"
            placeholder="${x => x.placeholder}"
            ?readonly="${x => x.readOnly}"
            ?required="${x => x.required}"
            rows="${x => x.rows}"
            ?spellcheck="${x => x.spellcheck}"
            :value="${x => x.value}"
            aria-atomic="${x => x.ariaAtomic}"
            aria-busy="${x => x.ariaBusy}"
            aria-controls="${x => x.ariaControls}"
            aria-current="${x => x.ariaCurrent}"
            aria-describedBy="${x => x.ariaDescribedby}"
            aria-details="${x => x.ariaDetails}"
            aria-disabled="${x => x.ariaDisabled}"
            aria-errormessage="${x => x.ariaErrormessage}"
            aria-flowto="${x => x.ariaFlowto}"
            aria-haspopup="${x => x.ariaHaspopup}"
            aria-hidden="${x => x.ariaHidden}"
            aria-invalid="${x => x.ariaInvalid}"
            aria-keyshortcuts="${x => x.ariaKeyshortcuts}"
            aria-label="${x => x.ariaLabel}"
            aria-labelledby="${x => x.ariaLabelledby}"
            aria-live="${x => x.ariaLive}"
            aria-owns="${x => x.ariaOwns}"
            aria-relevant="${x => x.ariaRelevant}"
            aria-roledescription="${x => x.ariaRoledescription}"
            @input="${(x, c) => x.handleTextInput()}"
            @change="${x => x.handleChange()}"
            ${ref("control")}
        ></textarea>
    </template>
`;

    /**
     * The template for the {@link @microsoft/fast-foundation#(TreeItem:class)} component.
     * @public
     */
    const TreeItemTemplate = html `
    <template
        role="treeitem"
        slot="${x => (x.isNestedItem() ? "item" : void 0)}"
        tabindex="${x => (x.disabled || !x.focusable ? void 0 : 0)}"
        class="${x => (x.expanded ? "expanded" : "")} ${x => x.selected ? "selected" : ""} ${x => (x.nested ? "nested" : "")}
            ${x => (x.disabled ? "disabled" : "")}"
        aria-expanded="${x => x.childItems && x.childItemLength() > 0 ? x.expanded : void 0}"
        aria-selected="${x => x.selected}"
        aria-disabled="${x => x.disabled}"
        @keydown="${(x, c) => x.handleKeyDown(c.event)}"
        @click="${(x, c) => x.handleClick(c.event)}"
        ${children$1({
    property: "childItems",
    filter: elements(),
})}
    >
        <div class="positioning-region" part="positioning-region">
            <div class="content-region" part="content-region">
                ${when(x => x.childItems && x.childItemLength() > 0, html `
                        <div
                            aria-hidden="true"
                            class="expand-collapse-button"
                            part="expand-collapse-button"
                            @click="${(x, c) => x.handleExpandCollapseButtonClick(c.event)}"
                            ${ref("expandCollapseButton")}
                        >
                            <slot name="expand-collapse-glyph">
                                <svg
                                    viewBox="0 0 16 16"
                                    xmlns="http://www.w3.org/2000/svg"
                                    class="expand-collapse-glyph"
                                >
                                    <path
                                        d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
                                    />
                                </svg>
                            </slot>
                        </div>
                    `)}
                ${startTemplate}
                <slot></slot>
                ${endTemplate}
            </div>
        </div>
        ${when(x => x.childItems &&
    x.childItemLength() > 0 &&
    (x.expanded || x.renderCollapsedChildren), html `
                <div role="group" class="items" part="items">
                    <slot name="item" ${slotted("items")}></slot>
                </div>
            `)}
    </template>
`;

    /**
     * check if the item is a tree item
     * @public
     * @remarks
     * determines if element is an HTMLElement and if it has the role treeitem
     */
    function isTreeItemElement(el) {
        return isHTMLElement(el) && el.getAttribute("role") === "treeitem";
    }
    /**
     * A Tree item Custom HTML Element.
     *
     * @public
     */
    class TreeItem extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * When true, the control will be appear expanded by user interaction.
             * @public
             * @remarks
             * HTML Attribute: expanded
             */
            this.expanded = false;
            this.focusable = false;
            this.enabledChildTreeItems = [];
            /**
             * @deprecated - no longer needed.
             * @param e - Event object
             */
            /* eslint-disable-next-line */
            this.handleFocus = (e) => { };
            /**
             * @deprecated - no longer needed.
             * @param e - Event object
             */
            /* eslint-disable-next-line */
            this.handleBlur = (e) => { };
            /**
             * The keyboarding on treeview should conform to the following spec
             * https://w3c.github.io/aria-practices/#keyboard-interaction-23
             * @param e - Event object for keyDown event
             */
            this.handleKeyDown = (e) => {
                if (e.target !== e.currentTarget) {
                    return true;
                }
                switch (e.keyCode) {
                    case keyCodeArrowLeft:
                        this.collapseOrFocusParent();
                        break;
                    case keyCodeArrowRight:
                        this.expandOrFocusFirstChild();
                        break;
                    case keyCodeArrowDown:
                        // preventDefault to ensure we don't scroll the page
                        e.preventDefault();
                        this.focusNextNode(1);
                        break;
                    case keyCodeArrowUp:
                        // preventDefault to ensure we don't scroll the page
                        e.preventDefault();
                        this.focusNextNode(-1);
                        break;
                    case keyCodeEnter:
                        // In single-select trees where selection does not follow focus (see note below),
                        // the default action is typically to select the focused node.
                        this.handleSelected(e);
                        break;
                }
                return true;
            };
            this.handleExpandCollapseButtonClick = (e) => {
                if (!this.disabled) {
                    e.preventDefault();
                    this.setExpanded(!this.expanded);
                }
            };
            this.handleClick = (e) => {
                if (!e.defaultPrevented && !this.disabled) {
                    this.handleSelected(e);
                }
            };
            this.isNestedItem = () => {
                return isTreeItemElement(this.parentElement);
            };
        }
        itemsChanged(oldValue, newValue) {
            if (this.$fastController.isConnected) {
                this.items.forEach((node) => {
                    if (isTreeItemElement(node)) {
                        // TODO: maybe not require it to be a TreeItem?
                        node.nested = true;
                    }
                });
                this.enabledChildTreeItems = this.items.filter((item) => {
                    return isTreeItemElement(item) && !item.hasAttribute("disabled");
                });
            }
        }
        getParentTreeNode() {
            const parentNode = this.parentElement.closest("[role='tree']");
            return parentNode;
        }
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            const parentTreeNode = this.getParentTreeNode();
            if (parentTreeNode) {
                if (parentTreeNode.hasAttribute("render-collapsed-nodes")) {
                    this.renderCollapsedChildren =
                        parentTreeNode.getAttribute("render-collapsed-nodes") === "true";
                }
                this.notifier = Observable.getNotifier(parentTreeNode);
                this.notifier.subscribe(this, "renderCollapsedNodes");
            }
        }
        /**
         * @internal
         */
        disconnectedCallback() {
            super.disconnectedCallback();
            if (this.notifier) {
                this.notifier.unsubscribe(this, "renderCollapsedNodes");
            }
        }
        /**
         * Places document focus on a tree item and adds the item to the sequential tab order.
         * @param el - the element to focus
         */
        static focusItem(el) {
            el.setAttribute("tabindex", "0");
            el.focusable = true;
            el.focus();
        }
        handleChange(source, propertyName) {
            switch (propertyName) {
                case "renderCollapsedNodes":
                    this.renderCollapsedChildren = source.renderCollapsedNodes;
                    break;
            }
        }
        childItemLength() {
            const treeChildren = this.childItems.filter((item) => {
                return isTreeItemElement(item);
            });
            return treeChildren ? treeChildren.length : 0;
        }
        collapseOrFocusParent() {
            if (this.expanded) {
                this.setExpanded(false);
            }
            else if (isHTMLElement(this.parentElement)) {
                const parentTreeItemNode = this.parentElement.closest("[role='treeitem']");
                if (isHTMLElement(parentTreeItemNode)) {
                    TreeItem.focusItem(parentTreeItemNode);
                }
            }
        }
        expandOrFocusFirstChild() {
            if (typeof this.expanded !== "boolean") {
                return;
            }
            if (!this.expanded && this.childItemLength() > 0) {
                this.setExpanded(true);
            }
            else {
                if (this.enabledChildTreeItems.length > 0) {
                    TreeItem.focusItem(this.enabledChildTreeItems[0]);
                }
            }
        }
        focusNextNode(delta) {
            const visibleNodes = this.getVisibleNodes();
            if (!visibleNodes) {
                return;
            }
            const currentIndex = visibleNodes.indexOf(this);
            if (currentIndex !== -1) {
                let nextElement = visibleNodes[currentIndex + delta];
                if (nextElement !== undefined) {
                    while (nextElement.hasAttribute("disabled")) {
                        const offset = delta >= 0 ? 1 : -1;
                        nextElement = visibleNodes[currentIndex + delta + offset];
                        if (!nextElement) {
                            break;
                        }
                    }
                }
                if (isHTMLElement(nextElement)) {
                    TreeItem.focusItem(nextElement);
                }
            }
        }
        getVisibleNodes() {
            return getDisplayedNodes(this.getTreeRoot(), "[role='treeitem']");
        }
        getTreeRoot() {
            /* eslint-disable-next-line  @typescript-eslint/no-this-alias */
            const currentNode = this;
            if (!isHTMLElement(currentNode)) {
                return null;
            }
            return currentNode.closest("[role='tree']");
        }
        handleSelected(e) {
            this.selected = !this.selected;
            this.$emit("selected-change", e);
        }
        setExpanded(expanded) {
            this.expanded = expanded;
            this.$emit("expanded-change", this);
        }
    }
    __decorate([
        attr$1({ mode: "boolean" })
    ], TreeItem.prototype, "expanded", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TreeItem.prototype, "selected", void 0);
    __decorate([
        attr$1({ mode: "boolean" })
    ], TreeItem.prototype, "disabled", void 0);
    __decorate([
        observable
    ], TreeItem.prototype, "focusable", void 0);
    __decorate([
        observable
    ], TreeItem.prototype, "childItems", void 0);
    __decorate([
        observable
    ], TreeItem.prototype, "items", void 0);
    __decorate([
        observable
    ], TreeItem.prototype, "nested", void 0);
    __decorate([
        observable
    ], TreeItem.prototype, "renderCollapsedChildren", void 0);
    applyMixins(TreeItem, StartEnd);

    /**
     * The template for the {@link @microsoft/fast-foundation#TreeView} component.
     * @public
     */
    const TreeViewTemplate = html `
    <template
        role="tree"
        ${ref("treeView")}
        @keydown="${(x, c) => x.handleKeyDown(c.event)}"
        @focus="${(x, c) => x.handleFocus(c.event)}"
        @focusout="${(x, c) => x.handleBlur(c.event)}"
    >
        <slot ${slotted("slottedTreeItems")}></slot>
    </template>
`;

    /**
     * A Tree view Custom HTML Element.
     * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.
     *
     * @public
     */
    class TreeView extends FASTElement {
        constructor() {
            super(...arguments);
            /**
             * @deprecated - the tree itself is no longer a focusable area.
             */
            this.focusable = true;
            this.handleBlur = (e) => {
                const { relatedTarget, target } = e;
                /**
                 * Clean up previously focused item's tabindex if we've moved to another item in the tree
                 */
                if (relatedTarget instanceof HTMLElement &&
                    target instanceof HTMLElement &&
                    this.contains(relatedTarget)) {
                    target.removeAttribute("tabindex");
                }
            };
            /**
             * @deprecated - no longer needed
             */
            /* eslint-disable-next-line */
            this.handleFocus = (e) => { };
            this.handleKeyDown = (e) => {
                if (!this.treeItems) {
                    return true;
                }
                switch (e.keyCode) {
                    case keyCodeHome:
                        if (this.treeItems && this.treeItems.length) {
                            TreeItem.focusItem(this.treeItems[0]);
                        }
                        break;
                    case keyCodeEnd:
                        if (this.treeItems && this.treeItems.length) {
                            TreeItem.focusItem(this.treeItems[this.treeItems.length - 1]);
                        }
                        break;
                    default:
                        return true;
                }
            };
            this.setItems = () => {
                const focusIndex = this.treeItems.findIndex(this.isFocusableElement);
                for (let item = 0; item < this.treeItems.length; item++) {
                    if (item === focusIndex && !this.treeItems[item].hasAttribute("disabled")) {
                        this.treeItems[item].setAttribute("tabindex", "0");
                    }
                    this.treeItems[item].addEventListener("selected-change", this.handleItemSelected);
                }
            };
            this.resetItems = () => {
                for (let item = 0; item < this.treeItems.length; item++) {
                    this.treeItems[item].removeEventListener("selected-change", this.handleItemSelected);
                }
            };
            this.handleItemSelected = (e) => {
                const newSelection = e.target;
                if (newSelection !== this.currentSelected) {
                    if (this.currentSelected) {
                        // TODO: fix this below, shouldn't need both
                        this.currentSelected.removeAttribute("selected");
                        this.currentSelected.selected = false;
                    }
                    this.currentSelected = newSelection;
                }
            };
            /**
             * check if the item is focusable
             */
            this.isFocusableElement = (el) => {
                return isTreeItemElement(el) && !this.isDisabledElement(el);
            };
            /**
             * check if the item is disabled
             */
            this.isDisabledElement = (el) => {
                return isTreeItemElement(el) && el.getAttribute("aria-disabled") === "true";
            };
        }
        slottedTreeItemsChanged(oldValue, newValue) {
            if (this.$fastController.isConnected) {
                // filter the tree items until that's done for us in the framework
                this.resetItems();
                this.treeItems = this.getVisibleNodes();
                this.setItems();
                // check if any tree items have nested items
                // if they do, apply the nested attribute
                if (this.checkForNestedItems()) {
                    this.slottedTreeItems.forEach(node => {
                        if (isTreeItemElement(node)) {
                            node.nested = true;
                        }
                    });
                }
            }
        }
        checkForNestedItems() {
            return this.slottedTreeItems.some((node) => {
                return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
            });
        }
        connectedCallback() {
            super.connectedCallback();
            this.treeItems = this.getVisibleNodes();
            DOM.queueUpdate(() => {
                //only supporting single select
                const node = this.treeView.querySelector("[aria-selected='true']");
                if (node) {
                    this.currentSelected = node;
                }
            });
        }
        getVisibleNodes() {
            const treeItems = [];
            if (this.slottedTreeItems !== undefined) {
                this.slottedTreeItems.forEach((item) => {
                    if (isTreeItemElement(item)) {
                        treeItems.push(item);
                    }
                });
            }
            return treeItems;
        }
    }
    __decorate([
        attr$1({ attribute: "render-collapsed-nodes" })
    ], TreeView.prototype, "renderCollapsedNodes", void 0);
    __decorate([
        observable
    ], TreeView.prototype, "focusable", void 0);
    __decorate([
        observable
    ], TreeView.prototype, "currentSelected", void 0);
    __decorate([
        observable
    ], TreeView.prototype, "lastFocused", void 0);
    __decorate([
        observable
    ], TreeView.prototype, "nested", void 0);
    __decorate([
        observable
    ], TreeView.prototype, "slottedTreeItems", void 0);

    /**
     * DO NOT EDIT THIS FILE DIRECTLY
     * This file generated by fast-components/build/generate-default-palettes.js
     */
    const neutralPalette$1 = [
        "#FFFFFF",
        "#FCFCFC",
        "#FAFAFA",
        "#F7F7F7",
        "#F5F5F5",
        "#F2F2F2",
        "#EFEFEF",
        "#EDEDED",
        "#EAEAEA",
        "#E8E8E8",
        "#E5E5E5",
        "#E2E2E2",
        "#E0E0E0",
        "#DDDDDD",
        "#DBDBDB",
        "#D8D8D8",
        "#D6D6D6",
        "#D3D3D3",
        "#D0D0D0",
        "#CECECE",
        "#CBCBCB",
        "#C9C9C9",
        "#C6C6C6",
        "#C3C3C3",
        "#C1C1C1",
        "#BEBEBE",
        "#BCBCBC",
        "#B9B9B9",
        "#B6B6B6",
        "#B4B4B4",
        "#B1B1B1",
        "#AFAFAF",
        "#ACACAC",
        "#A9A9A9",
        "#A7A7A7",
        "#A4A4A4",
        "#A2A2A2",
        "#9F9F9F",
        "#9D9D9D",
        "#9A9A9A",
        "#979797",
        "#959595",
        "#929292",
        "#909090",
        "#8D8D8D",
        "#8A8A8A",
        "#888888",
        "#858585",
        "#838383",
        "#808080",
        "#7D7D7D",
        "#7B7B7B",
        "#787878",
        "#767676",
        "#737373",
        "#717171",
        "#6E6E6E",
        "#6B6B6B",
        "#696969",
        "#666666",
        "#646464",
        "#616161",
        "#5F5F5F",
        "#5C5C5C",
        "#5A5A5A",
        "#575757",
        "#545454",
        "#525252",
        "#4F4F4F",
        "#4D4D4D",
        "#4A4A4A",
        "#484848",
        "#454545",
        "#424242",
        "#404040",
        "#3D3D3D",
        "#3B3B3B",
        "#383838",
        "#363636",
        "#333333",
        "#313131",
        "#2E2E2E",
        "#2B2B2B",
        "#292929",
        "#262626",
        "#242424",
        "#212121",
        "#1E1E1E",
        "#1B1B1B",
        "#181818",
        "#151515",
        "#121212",
        "#101010",
        "#000000"
    ];
    const accentPalette$1 = [
        "#FFFFFF",
        "#FEFBFC",
        "#FEF7FA",
        "#FDF4F7",
        "#FDF0F5",
        "#FCECF2",
        "#FBE8EF",
        "#FBE5ED",
        "#FAE1EA",
        "#FADDE7",
        "#F9D9E5",
        "#F8D6E2",
        "#F8D2E0",
        "#F7CEDD",
        "#F7CADA",
        "#F6C7D8",
        "#F5C3D5",
        "#F5BFD2",
        "#F4BBD0",
        "#F3B8CD",
        "#F3B4CB",
        "#F2B0C8",
        "#F2ACC5",
        "#F1A9C3",
        "#F0A5C0",
        "#F0A1BD",
        "#EF9DBB",
        "#EF9AB8",
        "#EE96B6",
        "#ED92B3",
        "#ED8EB0",
        "#EC8BAE",
        "#EC87AB",
        "#EB83A8",
        "#EA7FA6",
        "#EA7CA3",
        "#E978A1",
        "#E9749E",
        "#E8709B",
        "#E76D99",
        "#E76996",
        "#E66593",
        "#E66191",
        "#E55E8E",
        "#E45A8C",
        "#E45689",
        "#E35286",
        "#E24F84",
        "#E24B81",
        "#E1477E",
        "#E1437C",
        "#E04079",
        "#DF3C77",
        "#DF3874",
        "#DE3471",
        "#DE316F",
        "#DD2D6C",
        "#DC2969",
        "#DC2567",
        "#DB2264",
        "#DB1E62",
        "#DA1A5F",
        "#D4195C",
        "#CD1859",
        "#C71857",
        "#C01754",
        "#BA1651",
        "#B3154E",
        "#AD154B",
        "#A71449",
        "#A01346",
        "#9A1243",
        "#931240",
        "#8D113D",
        "#86103B",
        "#800F38",
        "#7A0F35",
        "#730E32",
        "#6D0D2F",
        "#660C2D",
        "#600B2A",
        "#590B27",
        "#530A24",
        "#4D0921",
        "#46081F",
        "#40081C",
        "#3B071A",
        "#350617",
        "#300615",
        "#2B0513",
        "#260511",
        "#21040E",
        "#1C030C",
        "#000000"
    ];

    /**
     * The default values for {@link FASTDesignSystem}
     * @public
     */
    const fastDesignSystemDefaults = {
        typeRampMinus2FontSize: "10px",
        typeRampMinus2LineHeight: "16px",
        typeRampMinus1FontSize: "12px",
        typeRampMinus1LineHeight: "16px",
        typeRampBaseFontSize: "14px",
        typeRampBaseLineHeight: "20px",
        typeRampPlus1FontSize: "16px",
        typeRampPlus1LineHeight: "24px",
        typeRampPlus2FontSize: "20px",
        typeRampPlus2LineHeight: "28px",
        typeRampPlus3FontSize: "28px",
        typeRampPlus3LineHeight: "36px",
        typeRampPlus4FontSize: "34px",
        typeRampPlus4LineHeight: "44px",
        typeRampPlus5FontSize: "46px",
        typeRampPlus5LineHeight: "56px",
        typeRampPlus6FontSize: "60px",
        typeRampPlus6LineHeight: "72px",
        accentBaseColor: "#DA1A5F",
        accentPalette: accentPalette$1,
        backgroundColor: "#181818",
        baseHeightMultiplier: 10,
        baseHorizontalSpacingMultiplier: 3,
        cornerRadius: 3,
        density: 0,
        designUnit: 4,
        direction: Direction.ltr,
        disabledOpacity: 0.3,
        focusOutlineWidth: 2,
        neutralPalette: neutralPalette$1,
        outlineWidth: 1,
        /**
         * Recipe Deltas
         */
        accentFillRestDelta: 0,
        accentFillHoverDelta: 4,
        accentFillActiveDelta: -5,
        accentFillFocusDelta: 0,
        accentFillSelectedDelta: 12,
        accentForegroundRestDelta: 0,
        accentForegroundHoverDelta: 6,
        accentForegroundActiveDelta: -4,
        accentForegroundFocusDelta: 0,
        neutralFillRestDelta: 7,
        neutralFillHoverDelta: 10,
        neutralFillActiveDelta: 5,
        neutralFillFocusDelta: 0,
        neutralFillSelectedDelta: 7,
        neutralFillInputRestDelta: 0,
        neutralFillInputHoverDelta: 0,
        neutralFillInputActiveDelta: 0,
        neutralFillInputFocusDelta: 0,
        neutralFillInputSelectedDelta: 0,
        neutralFillStealthRestDelta: 0,
        neutralFillStealthHoverDelta: 5,
        neutralFillStealthActiveDelta: 3,
        neutralFillStealthFocusDelta: 0,
        neutralFillStealthSelectedDelta: 7,
        neutralFillToggleHoverDelta: 8,
        neutralFillToggleActiveDelta: -5,
        neutralFillToggleFocusDelta: 0,
        baseLayerLuminance: -1,
        neutralFillCardDelta: 3,
        neutralForegroundHoverDelta: 0,
        neutralForegroundActiveDelta: 0,
        neutralForegroundFocusDelta: 0,
        neutralDividerRestDelta: 8,
        neutralOutlineRestDelta: 25,
        neutralOutlineHoverDelta: 40,
        neutralOutlineActiveDelta: 16,
        neutralOutlineFocusDelta: 25,
        neutralContrastFillRestDelta: 0,
        neutralContrastFillHoverDelta: -3,
        neutralContrastFillActiveDelta: 7,
        neutralContrastFillFocusDelta: 0,
    };
    /**
     * Returns the argument if basic, otherwise calls the DesignSystemResolver function.
     *
     * @param arg A value or a DesignSystemResolver function
     * @param designSystem The design system config.
     */
    function evaluateDesignSystemResolver(arg, designSystem) {
        return typeof arg === "function"
            ? arg(designSystem)
            : arg;
    }
    /**
     * Safely retrieves the value from a key of the DesignSystem.
     */
    function getDesignSystemValue(key) {
        return (designSystem) => {
            return designSystem && designSystem[key] !== undefined
                ? designSystem[key]
                : fastDesignSystemDefaults[key];
        };
    }
    /**
     * Retrieve the backgroundColor when invoked with a DesignSystem
     */
    const backgroundColor = getDesignSystemValue("backgroundColor");
    /**
     * Retrieve the accentBaseColor when invoked with a DesignSystem
     */
    const accentBaseColor = getDesignSystemValue("accentBaseColor");
    /**
     * Retrieve the neutral palette from the design system
     */
    const neutralPalette = getDesignSystemValue("neutralPalette");
    /**
     * Retrieve the accent palette from the design system
     */
    const accentPalette = getDesignSystemValue("accentPalette");
    const accentFillHoverDelta = getDesignSystemValue("accentFillHoverDelta");
    const accentFillActiveDelta = getDesignSystemValue("accentFillActiveDelta");
    const accentFillFocusDelta = getDesignSystemValue("accentFillFocusDelta");
    const accentFillSelectedDelta = getDesignSystemValue("accentFillSelectedDelta");
    const accentForegroundRestDelta = getDesignSystemValue("accentForegroundRestDelta");
    const accentForegroundHoverDelta = getDesignSystemValue("accentForegroundHoverDelta");
    const accentForegroundActiveDelta = getDesignSystemValue("accentForegroundActiveDelta");
    const accentForegroundFocusDelta = getDesignSystemValue("accentForegroundFocusDelta");
    const neutralFillRestDelta = getDesignSystemValue("neutralFillRestDelta");
    const neutralFillHoverDelta = getDesignSystemValue("neutralFillHoverDelta");
    const neutralFillActiveDelta = getDesignSystemValue("neutralFillActiveDelta");
    const neutralFillFocusDelta = getDesignSystemValue("neutralFillFocusDelta");
    const neutralFillSelectedDelta = getDesignSystemValue("neutralFillSelectedDelta");
    const neutralFillInputRestDelta = getDesignSystemValue("neutralFillInputRestDelta");
    const neutralFillInputHoverDelta = getDesignSystemValue("neutralFillInputHoverDelta");
    const neutralFillInputActiveDelta = getDesignSystemValue("neutralFillInputActiveDelta");
    const neutralFillInputFocusDelta = getDesignSystemValue("neutralFillInputFocusDelta");
    const neutralFillInputSelectedDelta = getDesignSystemValue("neutralFillInputSelectedDelta");
    const neutralFillStealthRestDelta = getDesignSystemValue("neutralFillStealthRestDelta");
    const neutralFillStealthHoverDelta = getDesignSystemValue("neutralFillStealthHoverDelta");
    const neutralFillStealthActiveDelta = getDesignSystemValue("neutralFillStealthActiveDelta");
    const neutralFillStealthFocusDelta = getDesignSystemValue("neutralFillStealthFocusDelta");
    const neutralFillStealthSelectedDelta = getDesignSystemValue("neutralFillStealthSelectedDelta");
    const neutralFillToggleHoverDelta = getDesignSystemValue("neutralFillToggleHoverDelta");
    const neutralFillToggleActiveDelta = getDesignSystemValue("neutralFillToggleActiveDelta");
    const neutralFillToggleFocusDelta = getDesignSystemValue("neutralFillToggleFocusDelta");
    const baseLayerLuminance = getDesignSystemValue("baseLayerLuminance");
    const neutralFillCardDelta = getDesignSystemValue("neutralFillCardDelta");
    const neutralForegroundHoverDelta = getDesignSystemValue("neutralForegroundHoverDelta");
    const neutralForegroundActiveDelta = getDesignSystemValue("neutralForegroundActiveDelta");
    const neutralForegroundFocusDelta = getDesignSystemValue("neutralForegroundFocusDelta");
    const neutralDividerRestDelta = getDesignSystemValue("neutralDividerRestDelta");
    const neutralOutlineRestDelta = getDesignSystemValue("neutralOutlineRestDelta");
    const neutralOutlineHoverDelta = getDesignSystemValue("neutralOutlineHoverDelta");
    const neutralOutlineActiveDelta = getDesignSystemValue("neutralOutlineActiveDelta");
    const neutralOutlineFocusDelta = getDesignSystemValue("neutralOutlineFocusDelta");
    const neutralContrastFillHoverDelta = getDesignSystemValue("neutralContrastFillHoverDelta");
    const neutralContrastFillActiveDelta = getDesignSystemValue("neutralContrastFillActiveDelta");
    const neutralContrastFillFocusDelta = getDesignSystemValue("neutralContrastFillFocusDelta");

    /**
     * Ensures that an input number does not exceed a max value and is not less than a min value.
     * @param i - the number to clamp
     * @param min - the maximum (inclusive) value
     * @param max - the minimum (inclusive) value
     * @public
     */
    function clamp$1(i, min, max) {
        if (isNaN(i) || i <= min) {
            return min;
        }
        else if (i >= max) {
            return max;
        }
        return i;
    }
    /**
     * Scales an input to a number between 0 and 1
     * @param i - a number between min and max
     * @param min - the max value
     * @param max - the min value
     * @public
     */
    function normalize(i, min, max) {
        if (isNaN(i) || i <= min) {
            return 0.0;
        }
        else if (i >= max) {
            return 1.0;
        }
        return i / (max - min);
    }
    /**
     * Scales a number between 0 and 1
     * @param i - the number to denormalize
     * @param min - the min value
     * @param max - the max value
     * @public
     */
    function denormalize(i, min, max) {
        if (isNaN(i)) {
            return min;
        }
        return min + i * (max - min);
    }
    /**
     * Converts a number between 0 and 255 to a hex string.
     * @param i - the number to convert to a hex string
     * @public
     */
    function getHexStringForByte(i) {
        const s = Math.round(clamp$1(i, 0.0, 255.0)).toString(16);
        if (s.length === 1) {
            return "0" + s;
        }
        return s;
    }
    /**
     *
     * Will return infinity if i*10^(precision) overflows number
     * note that floating point rounding rules come into play here
     * so values that end up rounding on a .5 round to the nearest
     * even not always up so 2.5 rounds to 2
     * @param i - the number to round
     * @param precision - the precision to round to
     *
     * @public
     */
    function roundToPrecisionSmall(i, precision) {
        const factor = Math.pow(10, precision);
        return Math.round(i * factor) / factor;
    }

    /**
     * A RGBA color with 64 bit channels.
     *
     * @example
     * ```ts
     * new ColorRGBA64(1, 0, 0, 1) // red
     * ```
     * @public
     */
    class ColorRGBA64 {
        /**
         *
         * @param red - the red value
         * @param green - the green value
         * @param blue - the blue value
         * @param alpha - the alpha value
         */
        constructor(red, green, blue, alpha) {
            this.r = red;
            this.g = green;
            this.b = blue;
            this.a = typeof alpha === "number" && !isNaN(alpha) ? alpha : 1;
        }
        /**
         * Construct a {@link ColorRGBA64} from a {@link ColorRGBA64Config}
         * @param data - the config object
         */
        static fromObject(data) {
            return data && !isNaN(data.r) && !isNaN(data.g) && !isNaN(data.b)
                ? new ColorRGBA64(data.r, data.g, data.b, data.a)
                : null;
        }
        /**
         * Determines if one color is equal to another.
         * @param rhs - the color to compare
         */
        equalValue(rhs) {
            return (this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a);
        }
        /**
         * Returns the color formatted as a string; #RRGGBB
         */
        toStringHexRGB() {
            return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("");
        }
        /**
         * Returns the color formatted as a string; #RRGGBBAA
         */
        toStringHexRGBA() {
            return this.toStringHexRGB() + this.formatHexValue(this.a);
        }
        /**
         * Returns the color formatted as a string; #AARRGGBB
         */
        toStringHexARGB() {
            return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("");
        }
        /**
         * Returns the color formatted as a string; "rgb(0xRR, 0xGG, 0xBB)"
         */
        toStringWebRGB() {
            return `rgb(${Math.round(denormalize(this.r, 0.0, 255.0))},${Math.round(denormalize(this.g, 0.0, 255.0))},${Math.round(denormalize(this.b, 0.0, 255.0))})`;
        }
        /**
         * Returns the color formatted as a string; "rgba(0xRR, 0xGG, 0xBB, a)"
         * @remarks
         * Note that this follows the convention of putting alpha in the range [0.0,1.0] while the other three channels are [0,255]
         */
        toStringWebRGBA() {
            return `rgba(${Math.round(denormalize(this.r, 0.0, 255.0))},${Math.round(denormalize(this.g, 0.0, 255.0))},${Math.round(denormalize(this.b, 0.0, 255.0))},${clamp$1(this.a, 0, 1)})`;
        }
        /**
         * Returns a new {@link ColorRGBA64} rounded to the provided precision
         * @param precision - the precision to round to
         */
        roundToPrecision(precision) {
            return new ColorRGBA64(roundToPrecisionSmall(this.r, precision), roundToPrecisionSmall(this.g, precision), roundToPrecisionSmall(this.b, precision), roundToPrecisionSmall(this.a, precision));
        }
        /**
         * Returns a new {@link ColorRGBA64} with channel values clamped between 0 and 1.
         */
        clamp() {
            return new ColorRGBA64(clamp$1(this.r, 0, 1), clamp$1(this.g, 0, 1), clamp$1(this.b, 0, 1), clamp$1(this.a, 0, 1));
        }
        /**
         * Converts the {@link ColorRGBA64} to a {@link ColorRGBA64Config}.
         */
        toObject() {
            return { r: this.r, g: this.g, b: this.b, a: this.a };
        }
        formatHexValue(value) {
            return getHexStringForByte(denormalize(value, 0.0, 255.0));
        }
    }

    // All hue values are in degrees rather than radians or normalized
    // All conversions use the D65 2 degree white point for XYZ
    // Info on conversions and constants used can be found in the following:
    // https://en.wikipedia.org/wiki/CIELAB_color_space
    // https://en.wikipedia.org/wiki/Illuminant_D65
    // https://ninedegreesbelow.com/photography/xyz-rgb.html
    // http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
    // https://web.stanford.edu/~sujason/ColorBalancing/adaptation.html
    // http://brucelindbloom.com/index.html
    /**
     * Get the luminance of a color in the linear RGB space.
     * This is not the same as the relative luminance in the sRGB space for WCAG contrast calculations. Use rgbToRelativeLuminance instead.
     * @param rgb - The input color
     *
     * @public
     */
    function rgbToLinearLuminance(rgb) {
        return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
    }
    /**
     * Get the relative luminance of a color.
     * Adjusts the color to sRGB space, which is necessary for the WCAG contrast spec.
     * The alpha channel of the input is ignored.
     * @param rgb - The input color
     *
     * @public
     */
    function rgbToRelativeLuminance(rgb) {
        function luminanceHelper(i) {
            if (i <= 0.03928) {
                return i / 12.92;
            }
            return Math.pow((i + 0.055) / 1.055, 2.4);
        }
        return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));
    }
    const calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);
    /**
     * Calculate the contrast ratio between two colors. Uses the formula described by {@link https://www.w3.org/TR/WCAG20-TECHS/G17.html | WCAG 2.0}.
     *
     * @remarks
     * The alpha channel of the input is ignored
     *
     * @public
     */
    function contrastRatio(a, b) {
        const luminanceA = rgbToRelativeLuminance(a);
        const luminanceB = rgbToRelativeLuminance(b);
        return luminanceA > luminanceB
            ? calculateContrastRatio(luminanceA, luminanceB)
            : calculateContrastRatio(luminanceB, luminanceA);
    }

    // Matches rgb(R, G, B) where R, G, and B are integers [0 - 255]
    const webRGBRegex = /^rgb\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){2}(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*)\)$/i;
    // Matches #RGB and #RRGGBB, where R, G, and B are [0-9] or [A-F]
    const hexRGBRegex = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i;
    /**
     * Test if a color matches #RRGGBB or #RGB
     * @public
     */
    function isColorStringHexRGB(raw) {
        return hexRGBRegex.test(raw);
    }
    /**
     * Test if a color matches rgb(rr, gg, bb)
     * @public
     */
    function isColorStringWebRGB(raw) {
        return webRGBRegex.test(raw);
    }
    /**
     * Converts a hexadecimal color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
     * @param raw - a color string in the form of "#RRGGBB" or "#RGB"
     * @example
     * ```ts
     * parseColorHexRGBA("#FF0000");
     * parseColorHexRGBA("#F00");
     * ```
     * @public
     */
    function parseColorHexRGB(raw) {
        const result = hexRGBRegex.exec(raw);
        if (result === null) {
            return null;
        }
        let digits = result[1];
        if (digits.length === 3) {
            const r = digits.charAt(0);
            const g = digits.charAt(1);
            const b = digits.charAt(2);
            digits = r.concat(r, g, g, b, b);
        }
        const rawInt = parseInt(digits, 16);
        if (isNaN(rawInt)) {
            return null;
        }
        // Note the use of >>> rather than >> as we want JS to manipulate these as unsigned numbers
        return new ColorRGBA64(normalize((rawInt & 0xff0000) >>> 16, 0, 255), normalize((rawInt & 0x00ff00) >>> 8, 0, 255), normalize(rawInt & 0x0000ff, 0, 255), 1);
    }
    /**
     * Converts a rgb color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
     * @param raw - a color string format "rgba(RR,GG,BB)" where RR,GG,BB are [0,255]
     * @example
     * ```ts
     * parseColorWebRGB("rgba(255, 0, 0");
     * ```
     * @public
     */
    function parseColorWebRGB(raw) {
        const result = webRGBRegex.exec(raw);
        if (result === null) {
            return null;
        }
        const split = result[1].split(",");
        return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), 1);
    }

    /**
     * The states that a swatch can have
     * @internal
     */
    var SwatchFamilyType;
    (function (SwatchFamilyType) {
        SwatchFamilyType["rest"] = "rest";
        SwatchFamilyType["hover"] = "hover";
        SwatchFamilyType["active"] = "active";
        SwatchFamilyType["focus"] = "focus";
        SwatchFamilyType["selected"] = "selected";
    })(SwatchFamilyType || (SwatchFamilyType = {}));
    /**
     * @internal
     */
    function colorRecipeFactory(recipe) {
        const memoizedRecipe = memoize(recipe);
        function curryRecipe(arg) {
            if (typeof arg === "function" || typeof arg === "string") {
                return (designSystem) => {
                    return memoizedRecipe(Object.assign({}, designSystem, {
                        backgroundColor: typeof arg === "function" ? arg(designSystem) : arg,
                    }));
                };
            }
            else {
                return memoizedRecipe(arg);
            }
        }
        return curryRecipe;
    }
    /**
     * Helper function to transform a SwatchFamilyResolver into simple ColorRecipe for simple use
     * use in stylesheets.
     *
     * @internal
     */
    function swatchFamilyToSwatchRecipeFactory(type, callback) {
        const memoizedRecipe = memoize(callback);
        return (arg) => {
            if (typeof arg === "function" || typeof arg === "string") {
                return (designSystem) => {
                    return memoizedRecipe(Object.assign({}, designSystem, {
                        backgroundColor: typeof arg === "function" ? arg(designSystem) : arg,
                    }))[type];
                };
            }
            else {
                return memoizedRecipe(arg)[type];
            }
        };
    }
    /**
     * Converts a color string into a ColorRGBA64 instance.
     * Supports #RRGGBB and rgb(r, g, b) formats
     *
     * @public
     */
    const parseColorString = memoize((color) => {
        let parsed = parseColorHexRGB(color);
        if (parsed !== null) {
            return parsed;
        }
        parsed = parseColorWebRGB(color);
        if (parsed !== null) {
            return parsed;
        }
        throw new Error(`${color} cannot be converted to a ColorRGBA64. Color strings must be one of the following formats: "#RGB", "#RRGGBB", or "rgb(r, g, b)"`);
    });
    /**
     * Determines if a string value represents a color
     * Supports #RRGGBB and rgb(r, g, b) formats
     * @internal
     */
    function isValidColor(color) {
        return isColorStringHexRGB(color) || isColorStringWebRGB(color);
    }
    /**
     * Determines if a color string matches another color.
     * Supports #RRGGBB and rgb(r, g, b) formats
     * @internal
     */
    function colorMatches(a, b) {
        return parseColorString(a).equalValue(parseColorString(b));
    }
    /**
     * Returns the contrast value between two color strings.
     * Supports #RRGGBB and rgb(r, g, b) formats.
     * @internal
     */
    const contrast = memoize((a, b) => {
        return contrastRatio(parseColorString(a), parseColorString(b));
    }, (a, b) => a + b);
    /**
     * Returns the relative luminance of a color. If the value is not a color, -1 will be returned
     * Supports #RRGGBB and rgb(r, g, b) formats
     * @internal
     */
    function luminance(color) {
        return rgbToRelativeLuminance(parseColorString(color));
    }
    /**
     * @internal
     */
    function designSystemResolverMax(...args) {
        return (designSystem) => Math.max.apply(null, args.map((fn) => fn(designSystem)));
    }
    /**
     * @internal
     */
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    /**
     * The named palettes of the MSFT design system
     * @deprecated - use neutralPalette and accentPalette functions instead
     * @public
     */
    var PaletteType;
    (function (PaletteType) {
        PaletteType["neutral"] = "neutral";
        PaletteType["accent"] = "accent";
    })(PaletteType || (PaletteType = {}));
    /**
     * A function to find the index of a swatch in a specified palette. If the color is found,
     * otherwise it will return -1
     *
     * @internal
     */
    function findSwatchIndex(paletteResolver, swatch) {
        return (designSystem) => {
            if (!isValidColor(swatch)) {
                return -1;
            }
            const colorPalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
            const index = colorPalette.indexOf(swatch);
            // If we don't find the string exactly, it might be because of color formatting differences
            return index !== -1
                ? index
                : colorPalette.findIndex((paletteSwatch) => {
                    return (isValidColor(paletteSwatch) && colorMatches(swatch, paletteSwatch));
                });
        };
    }
    /**
     * Returns the closest swatch in a palette to an input swatch.
     * If the input swatch cannot be converted to a color, 0 will be returned
     *
     * @internal
     */
    function findClosestSwatchIndex(paletteResolver, swatch) {
        return (designSystem) => {
            const resolvedPalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
            const resolvedSwatch = evaluateDesignSystemResolver(swatch, designSystem);
            const index = findSwatchIndex(resolvedPalette, resolvedSwatch)(designSystem);
            let swatchLuminance;
            if (index !== -1) {
                return index;
            }
            try {
                swatchLuminance = luminance(resolvedSwatch);
            }
            catch (e) {
                swatchLuminance = -1;
            }
            if (swatchLuminance === -1) {
                return 0;
            }
            return resolvedPalette
                .map((mappedSwatch, mappedIndex) => {
                return {
                    luminance: luminance(mappedSwatch),
                    index: mappedIndex,
                };
            })
                .reduce((previousValue, currentValue) => {
                return Math.abs(currentValue.luminance - swatchLuminance) <
                    Math.abs(previousValue.luminance - swatchLuminance)
                    ? currentValue
                    : previousValue;
            }).index;
        };
    }
    /**
     * Determines if the design-system should be considered in "dark mode".
     *
     * @public
     * @privateRemarks
     * A color is in dark mode if there is more contrast between #000000 and a background
     * color than #FFFFFF and a background color. That threshold can be expressed as a relative luminance
     * using the contrast formula as (1 + 0.5) / (bg + 0.05) === (bg + 0.05) / (0 + 0.05),
     * which reduces to the following, where bg is the relative luminance of the background color
     */
    function isDarkMode(designSystem) {
        return luminance(backgroundColor(designSystem)) <= (-0.1 + Math.sqrt(0.21)) / 2;
    }
    function getSwatch(index, colorPalette) {
        if (typeof index === "function") {
            return (designSystem) => {
                return colorPalette(designSystem)[clamp(index(designSystem), 0, colorPalette(designSystem).length - 1)];
            };
        }
        else {
            return colorPalette[clamp(index, 0, colorPalette.length - 1)];
        }
    }
    /**
     * @internal
     */
    function swatchByMode(paletteResolver) {
        return (valueA, valueB) => {
            return (designSystem) => {
                return getSwatch(isDarkMode(designSystem)
                    ? evaluateDesignSystemResolver(valueB, designSystem)
                    : evaluateDesignSystemResolver(valueA, designSystem), paletteResolver(designSystem));
            };
        };
    }
    function binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {
        if (endIndex === startIndex) {
            return valuesToSearch[startIndex];
        }
        const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;
        // Check to see if this passes on the item in the center of the array
        // if it does check the previous values
        if (searchCondition(valuesToSearch[middleIndex])) {
            return binarySearch(valuesToSearch, searchCondition, startIndex, middleIndex // include this index because it passed the search condition
            );
        }
        else {
            return binarySearch(valuesToSearch, searchCondition, middleIndex + 1, // exclude this index because it failed the search condition
            endIndex);
        }
    }
    // disable type-defs because this a deeply curried function and the call-signature is pretty complicated
    // and typescript can work it out automatically for consumers
    /**
     * Retrieves a swatch from an input palette, where the swatch's contrast against the reference color
     * passes an input condition. The direction to search in the palette is determined by an input condition.
     * Where to begin the search in the palette will be determined another input function that should return the starting index.
     * example: swatchByContrast(
     *              "#FFF" // compare swatches against "#FFF"
     *          )(
     *              neutralPalette // use the neutral palette from the DesignSystem - since this is a function, it will be evaluated with the DesignSystem
     *          )(
     *              () => 0 // begin searching for a swatch at the beginning of the neutral palette
     *          )(
     *              () => 1 // While searching, search in the direction toward the end of the array (-1 moves towards the beginning of the array)
     *          )(
     *              minContrastTargetFactory(4.5) // A swatch is only valid if the contrast is greater than 4.5
     *          )(
     *              designSystem // Pass the design-system. The first swatch that passes the previous condition will be returned from this function
     *          )
     * @internal
     */
    function swatchByContrast(referenceColor) {
        /**
         * A function that expects a function that resolves a palette
         */
        return (paletteResolver) => {
            /**
             * A function that expects a function that resolves the index
             * of the palette that the algorithm should begin looking for a swatch at
             */
            return (indexResolver) => {
                /**
                 * A function that expects a function that determines which direction in the
                 * palette we should look for a swatch relative to the initial index
                 */
                return (directionResolver) => {
                    /**
                     * A function that expects a function that determines if the contrast
                     * between the reference color and color from the palette are acceptable
                     */
                    return (contrastCondition) => {
                        /**
                         * A function that accepts a design-system. It resolves all of the curried arguments
                         * and loops over the palette until we reach the bounds of the palette or the condition
                         * is satisfied. Once either the condition is satisfied or we reach the end of the palette,
                         * we return the color
                         */
                        return (designSystem) => {
                            const color = evaluateDesignSystemResolver(referenceColor, designSystem);
                            const sourcePalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
                            const length = sourcePalette.length;
                            const initialSearchIndex = clamp(indexResolver(color, sourcePalette, designSystem), 0, length - 1);
                            const direction = directionResolver(initialSearchIndex, sourcePalette, designSystem);
                            function contrastSearchCondition(valueToCheckAgainst) {
                                return contrastCondition(contrast(color, valueToCheckAgainst));
                            }
                            const constrainedSourcePalette = [].concat(sourcePalette);
                            const endSearchIndex = length - 1;
                            let startSearchIndex = initialSearchIndex;
                            if (direction === -1) {
                                // reverse the palette array when the direction that
                                // the contrast resolves for is reversed
                                constrainedSourcePalette.reverse();
                                startSearchIndex = endSearchIndex - startSearchIndex;
                            }
                            return binarySearch(constrainedSourcePalette, contrastSearchCondition, startSearchIndex, endSearchIndex);
                        };
                    };
                };
            };
        };
    }
    /**
     * Resolves the index that the contrast search algorithm should start at
     * @internal
     */
    function referenceColorInitialIndexResolver(referenceColor, sourcePalette, designSystem) {
        return findClosestSwatchIndex(sourcePalette, referenceColor)(designSystem);
    }
    /**
     * @internal
     */
    function findClosestBackgroundIndex(designSystem) {
        return findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);
    }
    /**
     * @internal
     */
    function minContrastTargetFactory(targetContrast) {
        return (instanceContrast) => instanceContrast >= targetContrast;
    }

    function indexToSwatchFamily(accessibleIndex, palette, direction, restDelta, hoverDelta, activeDelta, focusDelta) {
        // One of the indexes will be rest, the other will be hover. Depends on the offsets and the direction.
        const accessibleIndex2 = accessibleIndex + direction * Math.abs(restDelta - hoverDelta);
        const indexOneIsRestState = direction === 1
            ? restDelta < hoverDelta
            : direction * restDelta > direction * hoverDelta;
        const restIndex = indexOneIsRestState ? accessibleIndex : accessibleIndex2;
        const hoverIndex = indexOneIsRestState ? accessibleIndex2 : accessibleIndex;
        const activeIndex = restIndex + direction * activeDelta;
        const focusIndex = restIndex + direction * focusDelta;
        return {
            rest: getSwatch(restIndex, palette),
            hover: getSwatch(hoverIndex, palette),
            active: getSwatch(activeIndex, palette),
            focus: getSwatch(focusIndex, palette),
        };
    }
    /**
     * Function to derive accessible colors from contrast and delta configuration.
     * Performs a simple contrast check against the colors and returns
     * the color that has the most contrast against the background. If contrast
     * cannot be retrieved correctly, function returns black.
     * @internal
     */
    function accessibleAlgorithm(palette, minContrast, restDelta, hoverDelta, activeDelta, focusDelta) {
        return (designSystem) => {
            const resolvedPalette = evaluateDesignSystemResolver(palette, designSystem);
            const direction = isDarkMode(designSystem) ? -1 : 1;
            const accessibleSwatch = swatchByContrast(backgroundColor // Compare swatches against the background
            )(resolvedPalette // Use the provided palette
            )(referenceColorInitialIndexResolver // Begin searching from the background color
            )(() => direction // Search direction based on light/dark mode
            )(minContrastTargetFactory(evaluateDesignSystemResolver(minContrast, designSystem)) // A swatch is only valid if the contrast is greater than indicated
            )(designSystem // Pass the design system
            );
            const accessibleIndex = findSwatchIndex(palette, accessibleSwatch)(designSystem);
            const resolvedRest = evaluateDesignSystemResolver(restDelta, designSystem);
            const resolvedHover = evaluateDesignSystemResolver(hoverDelta, designSystem);
            const resolvedActive = evaluateDesignSystemResolver(activeDelta, designSystem);
            const resolvedFocus = evaluateDesignSystemResolver(focusDelta, designSystem);
            return indexToSwatchFamily(accessibleIndex, resolvedPalette, direction, resolvedRest, resolvedHover, resolvedActive, resolvedFocus);
        };
    }

    /**
     * @internal
     */
    const neutralForeground = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 14, 0, neutralForegroundHoverDelta, neutralForegroundActiveDelta, neutralForegroundFocusDelta));
    /**
     * @internal
     */
    const neutralForegroundRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralForeground);

    /**
     * @internal
     */
    const white = "#FFFFFF";
    /**
     * @internal
     */
    const black = "#000000";

    /**
     * @internal
     */
    const neutralFillToggle = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 4.5, 0, neutralFillToggleHoverDelta, neutralFillToggleActiveDelta, neutralFillToggleFocusDelta));
    /**
     * @internal
     */
    const neutralFillToggleRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralFillToggle);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralFillToggle);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralFillToggle);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralFillToggle);

    /**
     * Function to derive neutralForegroundToggle from an input background and target contrast ratio
     */
    const neutralForegroundToggleAlgorithm = (backgroundColor, targetContrast) => {
        return contrast(white, backgroundColor) >= targetContrast ? white : black;
    };
    /**
     * Factory to create a neutral-foreground-toggle function that operates on a target contrast ratio
     */
    function neutralForegroundToggleFactory(targetContrast) {
        function neutralForegroundToggleInternal(arg) {
            return typeof arg === "function" || typeof arg === "string"
                ? (designSystem) => {
                    return neutralForegroundToggleAlgorithm(typeof arg === "function" ? arg(designSystem) : arg, targetContrast);
                }
                : neutralForegroundToggleAlgorithm(neutralFillToggleRest(arg), targetContrast);
        }
        return neutralForegroundToggleInternal;
    }
    /**
     * Toggle text for normal sized text, less than 18pt normal weight
     * @internal
     */
    const neutralForegroundToggle = neutralForegroundToggleFactory(4.5);
    /**
     * Toggle text for large sized text, greater than 18pt or 16pt and bold
     * @internal
     */
    const neutralForegroundToggleLarge = neutralForegroundToggleFactory(3);

    /**
     * Function to derive accentForegroundCut from an input background and target contrast ratio
     */
    const accentForegroundCutAlgorithm = (backgroundColor, targetContrast) => {
        return contrast(white, backgroundColor) >= targetContrast ? white : black;
    };
    /**
     * Factory to create a accent-foreground-cut function that operates on a target contrast ratio
     */
    function accentForegroundCutFactory(targetContrast) {
        function accentForegroundCutInternal(arg) {
            return typeof arg === "function" || typeof arg === "string"
                ? (designSystem) => {
                    return accentForegroundCutAlgorithm(typeof arg === "function" ? arg(designSystem) : arg, targetContrast);
                }
                : accentForegroundCutAlgorithm(accentBaseColor(arg), targetContrast);
        }
        return accentForegroundCutInternal;
    }
    /**
     * Cut text for normal sized text, less than 18pt normal weight
     * @internal
     */
    const accentForegroundCut = accentForegroundCutFactory(4.5);

    function neutralForegroundHintAlgorithm(targetContrast) {
        return accessibleAlgorithm(neutralPalette, targetContrast, 0, 0, 0, 0);
    }
    /**
     * Hint text for normal sized text, less than 18pt normal weight
     * @internal
     */
    const neutralForegroundHint = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, colorRecipeFactory(neutralForegroundHintAlgorithm(4.5)));
    /**
     * Hint text for large sized text, greater than 18pt or 16pt and bold
     * @internal
     */
    const neutralForegroundHintLarge = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, colorRecipeFactory(neutralForegroundHintAlgorithm(3)));

    function accentForegroundAlgorithm(contrastTarget) {
        return (designSystem) => {
            const palette = accentPalette(designSystem);
            const accent = accentBaseColor(designSystem);
            const accentIndex = findClosestSwatchIndex(accentPalette, accent)(designSystem);
            const stateDeltas = {
                rest: accentForegroundRestDelta(designSystem),
                hover: accentForegroundHoverDelta(designSystem),
                active: accentForegroundActiveDelta(designSystem),
                focus: accentForegroundFocusDelta(designSystem),
            };
            const direction = isDarkMode(designSystem) ? -1 : 1;
            const startIndex = accentIndex +
                (direction === 1
                    ? Math.min(stateDeltas.rest, stateDeltas.hover)
                    : Math.max(direction * stateDeltas.rest, direction * stateDeltas.hover));
            const accessibleSwatch = swatchByContrast(backgroundColor // Compare swatches against the background
            )(accentPalette // Use the accent palette
            )(() => startIndex // Begin searching based on accent index, direction, and deltas
            )(() => direction // Search direction based on light/dark mode
            )((swatchContrast) => swatchContrast >= contrastTarget // A swatch is only valid if the contrast is greater than indicated
            )(designSystem // Pass the design system
            );
            // One of these will be rest, the other will be hover. Depends on the offsets and the direction.
            const accessibleIndex1 = findSwatchIndex(accentPalette, accessibleSwatch)(designSystem);
            const accessibleIndex2 = accessibleIndex1 + direction * Math.abs(stateDeltas.rest - stateDeltas.hover);
            const indexOneIsRestState = direction === 1
                ? stateDeltas.rest < stateDeltas.hover
                : direction * stateDeltas.rest > direction * stateDeltas.hover;
            const restIndex = indexOneIsRestState
                ? accessibleIndex1
                : accessibleIndex2;
            const hoverIndex = indexOneIsRestState
                ? accessibleIndex2
                : accessibleIndex1;
            const activeIndex = restIndex + direction * stateDeltas.active;
            const focusIndex = restIndex + direction * stateDeltas.focus;
            return {
                rest: getSwatch(restIndex, palette),
                hover: getSwatch(hoverIndex, palette),
                active: getSwatch(activeIndex, palette),
                focus: getSwatch(focusIndex, palette),
            };
        };
    }
    /**
     * @internal
     */
    const accentForeground = colorRecipeFactory(accentForegroundAlgorithm(4.5));
    /**
     * @internal
     */
    const accentForegroundLarge = colorRecipeFactory(accentForegroundAlgorithm(3));
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentForeground);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentForegroundLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentForegroundLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentForegroundLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentForegroundLarge);

    const neutralFillThreshold$1 = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta);
    function neutralFillAlgorithm(deltaResolver) {
        return (designSystem) => {
            const backgroundIndex = findClosestBackgroundIndex(designSystem);
            const swapThreshold = neutralFillThreshold$1(designSystem);
            const direction = backgroundIndex >= swapThreshold ? -1 : 1;
            return getSwatch(backgroundIndex + direction * deltaResolver(designSystem), neutralPalette(designSystem));
        };
    }
    /**
     * @internal
     */
    const neutralFillRest = colorRecipeFactory(neutralFillAlgorithm(neutralFillRestDelta));
    /**
     * @internal
     */
    const neutralFillHover = colorRecipeFactory(neutralFillAlgorithm(neutralFillHoverDelta));
    /**
     * @internal
     */
    const neutralFillActive = colorRecipeFactory(neutralFillAlgorithm(neutralFillActiveDelta));
    /**
     * @internal
     */
    const neutralFillFocus = colorRecipeFactory(neutralFillAlgorithm(neutralFillFocusDelta));
    /**
     * @internal
     */
    const neutralFillSelected = colorRecipeFactory(neutralFillAlgorithm(neutralFillSelectedDelta));
    /**
     * @internal
     */
    const neutralFill = colorRecipeFactory((designSystem) => {
        return {
            rest: neutralFillRest(designSystem),
            hover: neutralFillHover(designSystem),
            active: neutralFillActive(designSystem),
            focus: neutralFillFocus(designSystem),
            selected: neutralFillSelected(designSystem),
        };
    });

    const neutralFillStealthSwapThreshold = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta, neutralFillStealthRestDelta, neutralFillStealthHoverDelta, neutralFillStealthActiveDelta, neutralFillStealthFocusDelta);
    function neutralFillStealthAlgorithm(deltaResolver) {
        return (designSystem) => {
            const backgroundIndex = findClosestBackgroundIndex(designSystem);
            const swapThreshold = neutralFillStealthSwapThreshold(designSystem);
            const direction = backgroundIndex >= swapThreshold ? -1 : 1;
            return getSwatch(backgroundIndex + direction * deltaResolver(designSystem), neutralPalette(designSystem));
        };
    }
    /**
     * @internal
     */
    const neutralFillStealthRest = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthRestDelta));
    /**
     * @internal
     */
    const neutralFillStealthHover = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthHoverDelta));
    /**
     * @internal
     */
    const neutralFillStealthActive = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthActiveDelta));
    /**
     * @internal
     */
    const neutralFillStealthFocus = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthFocusDelta));
    /**
     * @internal
     */
    const neutralFillStealthSelected = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthSelectedDelta));
    /**
     * @internal
     */
    const neutralFillStealth = colorRecipeFactory((designSystem) => {
        return {
            rest: neutralFillStealthRest(designSystem),
            hover: neutralFillStealthHover(designSystem),
            active: neutralFillStealthActive(designSystem),
            focus: neutralFillStealthFocus(designSystem),
            selected: neutralFillStealthSelected(designSystem),
        };
    });

    /**
     * Algorithm for determining neutral backplate colors
     */
    function neutralFillInputAlgorithm(indexResolver) {
        return (designSystem) => {
            const direction = isDarkMode(designSystem) ? -1 : 1;
            return getSwatch(findClosestBackgroundIndex(designSystem) -
                indexResolver(designSystem) * direction, neutralPalette(designSystem));
        };
    }
    /**
     * @internal
     */
    const neutralFillInputRest = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputRestDelta));
    /**
     * @internal
     */
    const neutralFillInputHover = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputHoverDelta));
    /**
     * @internal
     */
    const neutralFillInputActive = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputActiveDelta));
    /**
     * @internal
     */
    const neutralFillInputFocus = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputFocusDelta));
    /**
     * @internal
     */
    const neutralFillInputSelected = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputSelectedDelta));
    /**
     * @internal
     */
    const neutralFillInput = colorRecipeFactory((designSystem) => {
        return {
            rest: neutralFillInputRest(designSystem),
            hover: neutralFillInputHover(designSystem),
            active: neutralFillInputActive(designSystem),
            focus: neutralFillInputFocus(designSystem),
            selected: neutralFillInputSelected(designSystem),
        };
    });

    const neutralFillThreshold = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta);
    function accentFillAlgorithm(contrastTarget) {
        return (designSystem) => {
            const palette = accentPalette(designSystem);
            const paletteLength = palette.length;
            const accent = accentBaseColor(designSystem);
            const textColor = accentForegroundCut(Object.assign({}, designSystem, {
                backgroundColor: accent,
            }));
            const hoverDelta = accentFillHoverDelta(designSystem);
            // Use the hover direction that matches the neutral fill recipe.
            const backgroundIndex = findClosestBackgroundIndex(designSystem);
            const swapThreshold = neutralFillThreshold(designSystem);
            const direction = backgroundIndex >= swapThreshold ? -1 : 1;
            const maxIndex = paletteLength - 1;
            const accentIndex = findClosestSwatchIndex(accentPalette, accent)(designSystem);
            let accessibleOffset = 0;
            // Move the accent color the direction of hover, while maintaining the foreground color.
            while (accessibleOffset < direction * hoverDelta &&
                inRange(accentIndex + accessibleOffset + direction, 0, paletteLength) &&
                contrast(palette[accentIndex + accessibleOffset + direction], textColor) >=
                    contrastTarget &&
                inRange(accentIndex + accessibleOffset + direction + direction, 0, maxIndex)) {
                accessibleOffset += direction;
            }
            const hoverIndex = accentIndex + accessibleOffset;
            const restIndex = hoverIndex + direction * -1 * hoverDelta;
            const activeIndex = restIndex + direction * accentFillActiveDelta(designSystem);
            const focusIndex = restIndex + direction * accentFillFocusDelta(designSystem);
            return {
                rest: getSwatch(restIndex, palette),
                hover: getSwatch(hoverIndex, palette),
                active: getSwatch(activeIndex, palette),
                focus: getSwatch(focusIndex, palette),
                selected: getSwatch(restIndex +
                    (isDarkMode(designSystem)
                        ? accentFillSelectedDelta(designSystem) * -1
                        : accentFillSelectedDelta(designSystem)), palette),
            };
        };
    }
    /**
     * @internal
     */
    const accentFill = colorRecipeFactory(accentFillAlgorithm(4.5));
    /**
     * @internal
     */
    const accentFillLarge = colorRecipeFactory(accentFillAlgorithm(3));
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFillLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFillLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFillLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFillLarge);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFillLarge);

    /**
     * @internal
     */
    const neutralContrastFill = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 14, 0, neutralContrastFillHoverDelta, neutralContrastFillActiveDelta, neutralContrastFillFocusDelta));
    /**
     * @internal
     */
    const neutralContrastFillRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralContrastFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralContrastFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralContrastFill);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralContrastFill);

    const neutralCardFillAlgorithm = (designSystem) => {
        const offset = neutralFillCardDelta(designSystem);
        const index = findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);
        return getSwatch(index - (index < offset ? offset * -1 : offset), neutralPalette(designSystem));
    };
    /**
     * @internal
     */
    function neutralFillCard(arg) {
        if (typeof arg === "function") {
            return (designSystem) => {
                return neutralCardFillAlgorithm(Object.assign({}, designSystem, { backgroundColor: arg(designSystem) }));
            };
        }
        else {
            return neutralCardFillAlgorithm(arg);
        }
    }

    const neutralOutlineAlgorithm = (designSystem) => {
        const palette = neutralPalette(designSystem);
        const backgroundIndex = findClosestBackgroundIndex(designSystem);
        const direction = isDarkMode(designSystem) ? -1 : 1;
        const restDelta = neutralOutlineRestDelta(designSystem);
        const restIndex = backgroundIndex + direction * restDelta;
        const hoverDelta = neutralOutlineHoverDelta(designSystem);
        const hoverIndex = restIndex + direction * (hoverDelta - restDelta);
        const activeDelta = neutralOutlineActiveDelta(designSystem);
        const activeIndex = restIndex + direction * (activeDelta - restDelta);
        const focusDelta = neutralOutlineFocusDelta(designSystem);
        const focusIndex = restIndex + direction * (focusDelta - restDelta);
        return {
            rest: getSwatch(restIndex, palette),
            hover: getSwatch(hoverIndex, palette),
            active: getSwatch(activeIndex, palette),
            focus: getSwatch(focusIndex, palette),
        };
    };
    /**
     * @internal
     */
    const neutralOutline = colorRecipeFactory(neutralOutlineAlgorithm);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralOutline);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralOutline);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralOutline);
    /**
     * @internal
     */
    swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralOutline);

    const neutralDividerAlgorithm = (designSystem) => {
        const palette = neutralPalette(designSystem);
        const backgroundIndex = findClosestBackgroundIndex(designSystem);
        const delta = neutralDividerRestDelta(designSystem);
        const direction = isDarkMode(designSystem) ? -1 : 1;
        const index = backgroundIndex + direction * delta;
        return getSwatch(index, palette);
    };
    /**
     * @internal
     */
    const neutralDividerRest = colorRecipeFactory(neutralDividerAlgorithm);

    function performOperation(operation) {
        return (...args) => {
            return (designSystem) => {
                const firstArg = args[0];
                let value = typeof firstArg === "function" ? firstArg(designSystem) : firstArg;
                for (let i = 1; i < args.length; i++) {
                    const currentValue = args[i];
                    value = operation(value, typeof currentValue === "function"
                        ? currentValue(designSystem)
                        : currentValue);
                }
                return value;
            };
        };
    }
    const _add = performOperation((a, b) => a + b);
    const _subtract = performOperation((a, b) => a - b);
    const _multiply = performOperation((a, b) => a * b);
    /**
     * Adds numbers or functions that accept a design system and return a number.
     * @internal
     */
    function add(...args) {
        return _add.apply(this, args);
    }
    /**
     * Subtract numbers or functions that accept a design system and return a number.
     * @internal
     */
    function subtract(...args) {
        return _subtract.apply(this, args);
    }
    /**
     * Multiplies numbers or functions that accept a design system and return a number.
     * @internal
     */
    function multiply(...args) {
        return _multiply.apply(this, args);
    }

    /**
     * Recommended values for light and dark mode for {@link @microsoft/fast-components#FASTDesignSystem.baseLayerLuminance}.
     *
     * @public
     */
    var StandardLuminance;
    (function (StandardLuminance) {
        StandardLuminance[StandardLuminance["LightMode"] = 1] = "LightMode";
        StandardLuminance[StandardLuminance["DarkMode"] = 0.23] = "DarkMode";
    })(StandardLuminance || (StandardLuminance = {}));
    function luminanceOrBackgroundColor(luminanceRecipe, backgroundRecipe) {
        return (designSystem) => {
            return baseLayerLuminance(designSystem) === -1
                ? backgroundRecipe(designSystem)
                : luminanceRecipe(designSystem);
        };
    }
    /**
     * Find the palette color that's closest to the desired base layer luminance.
     */
    const baseLayerLuminanceSwatch = (designSystem) => {
        const luminance = baseLayerLuminance(designSystem);
        return new ColorRGBA64(luminance, luminance, luminance, 1).toStringHexRGB();
    };
    /**
     * Get the index of the base layer palette color.
     */
    const baseLayerLuminanceIndex = findClosestSwatchIndex(neutralPalette, baseLayerLuminanceSwatch);
    /**
     * Get the actual value of the card layer index, clamped so we can use it to base other layers from.
     */
    const neutralLayerCardIndex = (designSystem) => clamp$1(subtract(baseLayerLuminanceIndex, neutralFillCardDelta)(designSystem), 0, neutralPalette(designSystem).length - 1);
    /**
     * Light mode L2 is significant because it happens at the same point as the neutral fill flip. Use this as the minimum index for L2.
     */
    const lightNeutralLayerL2 = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta);
    /**
     * The index for L2 based on luminance, adjusted for the flip in light mode if necessary.
     */
    const neutralLayerL2Index = designSystemResolverMax(add(baseLayerLuminanceIndex, neutralFillCardDelta), lightNeutralLayerL2);
    /**
     * Dark mode L4 is the darkest recommended background in the standard guidance, which is
     * calculated based on luminance to work with variable sized ramps.
     */
    const darkNeutralLayerL4 = (designSystem) => {
        const darkLum = 0.14;
        const darkColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);
        const darkRefIndex = findClosestSwatchIndex(neutralPalette, darkColor.toStringHexRGB())(designSystem);
        return darkRefIndex;
    };
    /**
     * Used as the background color for floating layers like context menus and flyouts.
     * @internal
     */
    const neutralLayerFloating = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(subtract(neutralLayerCardIndex, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 5)))));
    /**
     * Used as the background color for cards. Pair with `neutralLayerCardContainer` for the container background.
     * @internal
     */
    const neutralLayerCard = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(neutralLayerCardIndex, neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 4)))));
    /**
     * Used as the background color for card containers. Pair with `neutralLayerCard` for the card backgrounds.
     * @internal
     */
    const neutralLayerCardContainer = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerCardIndex, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(neutralFillCardDelta, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 3)))));
    /**
     * Used as the background color for the primary content layer (L1).
     * @internal
     */
    const neutralLayerL1 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(baseLayerLuminanceIndex, neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 3)))));
    /**
     * Alternate darker color for L1 surfaces. Currently the same as card container, but use
     * the most applicable semantic named recipe.
     * @internal
     */
    const neutralLayerL1Alt = neutralLayerCardContainer;
    /**
     * Used as the background for the top command surface, logically below L1.
     * @internal
     */
    const neutralLayerL2 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(neutralLayerL2Index, neutralPalette), swatchByMode(neutralPalette)(lightNeutralLayerL2, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 2)))));
    /**
     * Used as the background for secondary command surfaces, logically below L2.
     * @internal
     */
    const neutralLayerL3 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerL2Index, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(add(lightNeutralLayerL2, neutralFillCardDelta), subtract(darkNeutralLayerL4, neutralFillCardDelta))));
    /**
     * Used as the background for the lowest command surface or title bar, logically below L3.
     * @internal
     */
    const neutralLayerL4 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerL2Index, multiply(neutralFillCardDelta, 2)), neutralPalette), swatchByMode(neutralPalette)(add(lightNeutralLayerL2, multiply(neutralFillCardDelta, 2)), darkNeutralLayerL4)));

    const targetRatio = 3.5;
    function neutralFocusIndexResolver(referenceColor, palette, designSystem) {
        return findClosestSwatchIndex(neutralPalette, referenceColor)(designSystem);
    }
    function neutralFocusDirectionResolver(index, palette, designSystem) {
        return isDarkMode(designSystem) ? -1 : 1;
    }
    function neutralFocusContrastCondition(contrastRatio) {
        return contrastRatio > targetRatio;
    }
    const neutralFocusAlgorithm = swatchByContrast(backgroundColor)(neutralPalette)(neutralFocusIndexResolver)(neutralFocusDirectionResolver)(neutralFocusContrastCondition);
    /**
     * @internal
     */
    const neutralFocus = colorRecipeFactory(neutralFocusAlgorithm);
    function neutralFocusInnerAccentIndexResolver(accentFillColor) {
        return (referenceColor, sourcePalette, designSystem) => {
            return sourcePalette.indexOf(accentFillColor(designSystem));
        };
    }
    function neutralFocusInnerAccentDirectionResolver(referenceIndex, palette, designSystem) {
        return isDarkMode(designSystem) ? 1 : -1;
    }
    /**
     * @internal
     */
    function neutralFocusInnerAccent(accentFillColor) {
        return swatchByContrast(neutralFocus)(accentPalette)(neutralFocusInnerAccentIndexResolver(accentFillColor))(neutralFocusInnerAccentDirectionResolver)(neutralFocusContrastCondition);
    }

    const DesignSystemProviderStyles = css `
    ${display("block")};
`;

    const color = new CSSCustomPropertyBehavior("neutral-foreground-rest", neutralForegroundRest, (el) => el);
    const backgroundStyles = css `
    :host {
        background-color: var(--background-color);
        color: ${color.var};
    }
`.withBehaviors(color, forcedColorsStylesheetBehavior(css `
            :host {
                background-color: ${SystemColors.ButtonFace};
                box-shadow: 0 0 0 1px ${SystemColors.CanvasText};
                color: ${SystemColors.ButtonText};
            }
        `));
    /**
     * The FAST DesignSystemProvider Element. Implements {@link @microsoft/fast-foundation#DesignSystemProvider},
     * {@link @microsoft/fast-foundation#DesignSystemProviderTemplate} and {@link @microsoft/fast-components#FASTDesignSystem}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-design-system-provider\>
     */
    exports.FASTDesignSystemProvider = class FASTDesignSystemProvider extends DesignSystemProvider {
        constructor() {
            super(...arguments);
            /**
             * Used to instruct the FASTDesignSystemProvider
             * that it should not set the CSS
             * background-color and color properties
             *
             * @remarks
             * HTML boolean attribute: no-paint
             */
            this.noPaint = false;
        }
        noPaintChanged() {
            if (!this.noPaint && this.backgroundColor !== void 0) {
                this.$fastController.addStyles(backgroundStyles);
            }
            else {
                this.$fastController.removeStyles(backgroundStyles);
            }
        }
        backgroundColorChanged() {
            // If background changes or is removed, we need to
            // re-evaluate whether we should have paint styles applied
            this.noPaintChanged();
        }
    };
    __decorate$1([
        attr$1({ attribute: "no-paint", mode: "boolean" })
    ], exports.FASTDesignSystemProvider.prototype, "noPaint", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "background-color",
            default: fastDesignSystemDefaults.backgroundColor,
        })
    ], exports.FASTDesignSystemProvider.prototype, "backgroundColor", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-base-color",
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentBaseColor,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentBaseColor", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: false,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralPalette,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralPalette", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: false,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentPalette,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentPalette", void 0);
    __decorate$1([
        designSystemProperty({
            default: fastDesignSystemDefaults.density,
            converter: nullableNumberConverter,
        })
    ], exports.FASTDesignSystemProvider.prototype, "density", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "design-unit",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.designUnit,
        })
    ], exports.FASTDesignSystemProvider.prototype, "designUnit", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "direction",
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.direction,
        })
    ], exports.FASTDesignSystemProvider.prototype, "direction", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "base-height-multiplier",
            default: fastDesignSystemDefaults.baseHeightMultiplier,
            converter: nullableNumberConverter,
        })
    ], exports.FASTDesignSystemProvider.prototype, "baseHeightMultiplier", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "base-horizontal-spacing-multiplier",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.baseHorizontalSpacingMultiplier,
        })
    ], exports.FASTDesignSystemProvider.prototype, "baseHorizontalSpacingMultiplier", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "corner-radius",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.cornerRadius,
        })
    ], exports.FASTDesignSystemProvider.prototype, "cornerRadius", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "outline-width",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.outlineWidth,
        })
    ], exports.FASTDesignSystemProvider.prototype, "outlineWidth", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "focus-outline-width",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.focusOutlineWidth,
        })
    ], exports.FASTDesignSystemProvider.prototype, "focusOutlineWidth", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "disabled-opacity",
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.disabledOpacity,
        })
    ], exports.FASTDesignSystemProvider.prototype, "disabledOpacity", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-minus-2-font-size",
            default: fastDesignSystemDefaults.typeRampMinus2FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampMinus2FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-minus-2-line-height",
            default: fastDesignSystemDefaults.typeRampMinus2LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampMinus2LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-minus-1-font-size",
            default: fastDesignSystemDefaults.typeRampMinus1FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampMinus1FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-minus-1-line-height",
            default: fastDesignSystemDefaults.typeRampMinus1LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampMinus1LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-base-font-size",
            default: fastDesignSystemDefaults.typeRampBaseFontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampBaseFontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-base-line-height",
            default: fastDesignSystemDefaults.typeRampBaseLineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampBaseLineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-1-font-size",
            default: fastDesignSystemDefaults.typeRampPlus1FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus1FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-1-line-height",
            default: fastDesignSystemDefaults.typeRampPlus1LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus1LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-2-font-size",
            default: fastDesignSystemDefaults.typeRampPlus2FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus2FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-2-line-height",
            default: fastDesignSystemDefaults.typeRampPlus2LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus2LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-3-font-size",
            default: fastDesignSystemDefaults.typeRampPlus3FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus3FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-3-line-height",
            default: fastDesignSystemDefaults.typeRampPlus3LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus3LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-4-font-size",
            default: fastDesignSystemDefaults.typeRampPlus4FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus4FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-4-line-height",
            default: fastDesignSystemDefaults.typeRampPlus4LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus4LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-5-font-size",
            default: fastDesignSystemDefaults.typeRampPlus5FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus5FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-5-line-height",
            default: fastDesignSystemDefaults.typeRampPlus5LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus5LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-6-font-size",
            default: fastDesignSystemDefaults.typeRampPlus6FontSize,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus6FontSize", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "type-ramp-plus-6-line-height",
            default: fastDesignSystemDefaults.typeRampPlus6LineHeight,
        })
    ], exports.FASTDesignSystemProvider.prototype, "typeRampPlus6LineHeight", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-fill-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentFillRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentFillRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-fill-hover-delta",
            cssCustomProperty: false,
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.accentFillHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentFillHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-fill-active-delta",
            cssCustomProperty: false,
            converter: nullableNumberConverter,
            default: fastDesignSystemDefaults.accentFillActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentFillActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-fill-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentFillFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentFillFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-fill-selected-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentFillSelectedDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentFillSelectedDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-foreground-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentForegroundRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentForegroundRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-foreground-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentForegroundHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentForegroundHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-foreground-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentForegroundActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentForegroundActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "accent-foreground-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.accentForegroundFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "accentForegroundFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-selected-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillSelectedDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillSelectedDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-input-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillInputRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillInputRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-input-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillInputHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillInputHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-input-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillInputActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillInputActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-input-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillInputFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillInputFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-input-selected-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillInputSelectedDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillInputSelectedDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-stealth-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillStealthRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillStealthRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-stealth-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillStealthHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillStealthHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-stealth-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillStealthActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillStealthActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-stealth-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillStealthFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillStealthFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-stealth-selected-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillStealthSelectedDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillStealthSelectedDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-toggle-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillToggleHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillToggleHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-toggle-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillToggleActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillToggleActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-toggle-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillToggleFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillToggleFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "base-layer-luminance",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.baseLayerLuminance,
        })
    ], exports.FASTDesignSystemProvider.prototype, "baseLayerLuminance", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-fill-card-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralFillCardDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralFillCardDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-foreground-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralForegroundHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralForegroundHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-foreground-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralForegroundActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralForegroundActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-foreground-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralForegroundFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralForegroundFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-divider-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralDividerRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralDividerRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-outline-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralOutlineRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralOutlineRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-outline-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralOutlineHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralOutlineHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-outline-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralOutlineActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralOutlineActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-outline-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralOutlineFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralOutlineFocusDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-contrast-fill-rest-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralContrastFillRestDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralContrastFillRestDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-contrast-fill-hover-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralContrastFillHoverDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralContrastFillHoverDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-contrast-fill-active-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralContrastFillActiveDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralContrastFillActiveDelta", void 0);
    __decorate$1([
        designSystemProperty({
            attribute: "neutral-contrast-fill-focus-delta",
            converter: nullableNumberConverter,
            cssCustomProperty: false,
            default: fastDesignSystemDefaults.neutralContrastFillFocusDelta,
        })
    ], exports.FASTDesignSystemProvider.prototype, "neutralContrastFillFocusDelta", void 0);
    exports.FASTDesignSystemProvider = __decorate$1([
        designSystemProvider({
            name: "fast-design-system-provider",
            template: DesignSystemProviderTemplate,
            styles: DesignSystemProviderStyles,
        })
    ], exports.FASTDesignSystemProvider);

    /**
     * Behavior to resolve and make available the neutral-foreground-rest CSS custom property.
     * @public
     */
    const neutralForegroundRestBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-rest", x => neutralForeground(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-hover CSS custom property.
     * @public
     */
    const neutralForegroundHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-hover", x => neutralForeground(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-active CSS custom property.
     * @public
     */
    const neutralForegroundActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-active", x => neutralForeground(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-focus CSS custom property.
     * @public
     */
    const neutralForegroundFocusBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-focus", x => neutralForeground(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-toggle CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-foreground-toggle", neutralForegroundToggle, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-toggle-large CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-foreground-toggle-large", neutralForegroundToggleLarge, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-hint CSS custom property.
     * @public
     */
    const neutralForegroundHintBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-hint", neutralForegroundHint, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-foreground-hint-large CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-foreground-hint-large", neutralForegroundHintLarge, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-rest CSS custom property.
     * @public
     */
    const accentForegroundRestBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-rest", x => accentForeground(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-hover CSS custom property.
     * @public
     */
    const accentForegroundHoverBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-hover", x => accentForeground(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-active CSS custom property.
     * @public
     */
    const accentForegroundActiveBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-active", x => accentForeground(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-foreground-focus", x => accentForeground(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-cut-rest CSS custom property.
     * @public
     */
    const accentForegroundCutRestBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-cut-rest", x => accentForegroundCut(x), exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-large-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-foreground-large-rest", x => accentForegroundLarge(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-large-hover CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-foreground-large-hover", x => accentForegroundLarge(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-large-active CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-foreground-large-active", x => accentForegroundLarge(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-foreground-large-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-foreground-large-focus", x => accentForegroundLarge(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-rest CSS custom property.
     * @public
     */
    const neutralFillRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-rest", x => neutralFill(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-hover CSS custom property.
     * @public
     */
    const neutralFillHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-hover", x => neutralFill(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-active CSS custom property.
     * @public
     */
    const neutralFillActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-active", x => neutralFill(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-focus", x => neutralFill(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-selected CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-selected", x => neutralFill(x).selected, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-stealth-rest CSS custom property.
     * @public
     */
    const neutralFillStealthRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-rest", x => neutralFillStealth(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-stealth-hover CSS custom property.
     * @public
     */
    const neutralFillStealthHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-hover", x => neutralFillStealth(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-stealth-active CSS custom property.
     * @public
     */
    const neutralFillStealthActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-active", x => neutralFillStealth(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-stealth-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-stealth-focus", x => neutralFillStealth(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-stealth-selected CSS custom property.
     * @public
     */
    const neutralFillStealthSelectedBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-selected", x => neutralFillStealth(x).selected, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-toggle-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-toggle-rest", x => neutralFillToggle(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-toggle-hover CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-toggle-hover", x => neutralFillToggle(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-toggle-active CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-toggle-active", x => neutralFillToggle(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-toggle-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-toggle-focus", x => neutralFillToggle(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-input-rest CSS custom property.
     * @public
     */
    const neutralFillInputRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-rest", x => neutralFillInput(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-input-hover CSS custom property.
     * @public
     */
    const neutralFillInputHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-hover", x => neutralFillInput(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-input-active CSS custom property.
     * @public
     */
    const neutralFillInputActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-active", x => neutralFillInput(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-input-selected CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-input-selected", x => neutralFillInput(x).selected, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-input-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-input-focus", x => neutralFillInput(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-rest CSS custom property.
     * @public
     */
    const accentFillRestBehavior = cssCustomPropertyBehaviorFactory("accent-fill-rest", x => accentFill(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-hover CSS custom property.
     * @public
     */
    const accentFillHoverBehavior = cssCustomPropertyBehaviorFactory("accent-fill-hover", x => accentFill(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-active CSS custom property.
     * @public
     */
    const accentFillActiveBehavior = cssCustomPropertyBehaviorFactory("accent-fill-active", x => accentFill(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-focus", x => accentFill(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-selected CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-selected", x => accentFill(x).selected, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-large-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-large-rest", x => accentFillLarge(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-large-hover CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-large-hover", x => accentFillLarge(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-large-active CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-large-active", x => accentFillLarge(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-large-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-large-focus", x => accentFillLarge(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the accent-fill-large-selected CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("accent-fill-large-selected", x => accentFillLarge(x).selected, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-fill-card-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-fill-card-rest", x => neutralFillCard(x), exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-outline-rest CSS custom property.
     * @public
     */
    const neutralOutlineRestBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-rest", x => neutralOutline(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-outline-hover CSS custom property.
     * @public
     */
    const neutralOutlineHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-hover", x => neutralOutline(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-outline-active CSS custom property.
     * @public
     */
    const neutralOutlineActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-active", x => neutralOutline(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-outline-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-outline-focus", x => neutralOutline(x).focus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-divider-rest CSS custom property.
     * @public
     */
    const neutralDividerRestBehavior = cssCustomPropertyBehaviorFactory("neutral-divider-rest", neutralDividerRest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-floating CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-floating", neutralLayerFloating, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-card CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-card", neutralLayerCard, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-card-container CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-card-container", neutralLayerCardContainer, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-l1 CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-l1", neutralLayerL1, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-l1-alt CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-l1-alt", neutralLayerL1Alt, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-l2 CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-l2", neutralLayerL2, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-l3 CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-l3", neutralLayerL3, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-layer-l4 CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-layer-l4", neutralLayerL4, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-focus CSS custom property.
     * @public
     */
    const neutralFocusBehavior = cssCustomPropertyBehaviorFactory("neutral-focus", neutralFocus, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-focus-inner-accent CSS custom property.
     * @public
     */
    const neutralFocusInnerAccentBehavior = cssCustomPropertyBehaviorFactory("neutral-focus-inner-accent", neutralFocusInnerAccent(accentBaseColor), exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-contrast-foreground-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-contrast-foreground-rest", x => neutralForegroundRest(neutralContrastFillRest)(x), exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-contrast-fill-rest CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-contrast-fill-rest", x => neutralContrastFill(x).rest, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-contrast-fill-hover CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-contrast-fill-hover", x => neutralContrastFill(x).hover, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-contrast-fill-active CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-contrast-fill-active", x => neutralContrastFill(x).active, exports.FASTDesignSystemProvider.findProvider);
    /**
     * Behavior to resolve and make available the neutral-contrast-fill-focus CSS custom property.
     * @public
     */
    cssCustomPropertyBehaviorFactory("neutral-contrast-fill-focus", x => neutralContrastFill(x).focus, exports.FASTDesignSystemProvider.findProvider);

    const AccordionStyles = css `
    ${display("flex")} :host {
        box-sizing: border-box;
        flex-direction: column;
        font-family: var(--body-font);
        font-size: var(--type-ramp-minus-1-font-size);
        line-height: var(--type-ramp-minus-1-line-height);
        color: ${neutralForegroundRestBehavior.var};
        border-top: calc(var(--outline-width) * 1px) solid
            ${neutralDividerRestBehavior.var};
    }
`.withBehaviors(neutralDividerRestBehavior, neutralForegroundRestBehavior);

    /**
     * A formula to retrieve the control height.
     * Use this as the value of any CSS property that
     * accepts a pixel size.
     */
    const heightNumber = "(var(--base-height-multiplier) + var(--density)) * var(--design-unit)";

    const AccordionItemStyles = css `
    ${display("flex")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        flex-direction: column;
        font-size: var(--type-ramp-minus-1-font-size);
        line-height: var(--type-ramp-minus-1-line-height);
        border-bottom: calc(var(--outline-width) * 1px) solid var(--neutral-divider-rest);
    }
    
    .region {
        display: none;
        padding: calc((6 + (var(--design-unit) * 2 * var(--density))) * 1px);
    }

    .heading {
        display: grid;
        position: relative;
        grid-template-columns: auto 1fr auto calc(${heightNumber} * 1px);
        z-index: 2;
    }

    .button {
        appearance: none;
        border: none;
        background: none;
        grid-column: 2;
        grid-row: 1;
        outline: none;
        padding: 0 calc((6 + (var(--design-unit) * 2 * var(--density))) * 1px);
        text-align: left;
        height: calc(${heightNumber} * 1px);
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-family: inherit;
    }

    .button:hover {
        color: ${neutralForegroundHoverBehavior.var};
    }

    .button:active {
        color: ${neutralForegroundActiveBehavior.var};
    }

    .button::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        cursor: pointer;
    }

    .button:${focusVisible}::before {
        outline: none;
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px)
            ${neutralFocusBehavior.var};
    }

    :host([expanded]) .region {
        display: block;
    }

    .icon {
        display: flex;
        align-items: center;
        justify-content: center;
        grid-column: 4;
        z-index: 2;
        pointer-events: none;
    }

    slot[name="expanded-icon"],
    slot[name="collapsed-icon"] {
        fill: ${accentFillRestBehavior.var};
    }

    slot[name="collapsed-icon"] {
        display: flex;
    }

    :host([expanded]) slot[name="collapsed-icon"] {
        display: none;
    }

    slot[name="expanded-icon"] {
        display: none;
    }
    
    :host([expanded]) slot[name="expanded-icon"] {
        display: flex;
    }

    .start {
        display: flex;
        align-items: center;
        padding-inline-start: calc(var(--design-unit) * 1px);
        justify-content: center;
        grid-column: 1;
        z-index: 2;
    }

    .end {
        display: flex;
        align-items: center;
        justify-content: center;
        grid-column: 3;
        z-index: 2;
    }
`.withBehaviors(accentFillRestBehavior, neutralDividerRestBehavior, neutralForegroundActiveBehavior, neutralForegroundFocusBehavior, neutralForegroundHoverBehavior, neutralForegroundRestBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css `
            .button:${focusVisible}::before {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.Highlight};
            }
        `));

    /**
     * The FAST Accordion Item Element. Implements {@link @microsoft/fast-foundation#AccordionItem},
     * {@link @microsoft/fast-foundation#AccordionItemTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-accordion-item\>
     */
    exports.FASTAccordionItem = class FASTAccordionItem extends AccordionItem {
    };
    exports.FASTAccordionItem = __decorate$1([
        customElement({
            name: "fast-accordion-item",
            template: AccordionItemTemplate,
            styles: AccordionItemStyles,
        })
    ], exports.FASTAccordionItem);

    /**
     * The FAST Accordion Element. Implements {@link @microsoft/fast-foundation#Accordion},
     * {@link @microsoft/fast-foundation#AccordionTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-accordion\>
     */
    exports.FASTAccordion = class FASTAccordion extends Accordion {
    };
    exports.FASTAccordion = __decorate$1([
        customElement({
            name: "fast-accordion",
            template: AccordionTemplate,
            styles: AccordionStyles,
        })
    ], exports.FASTAccordion);

    /**
     * @internal
     */
    const BaseButtonStyles = css `
    ${display("inline-flex")} :host {
        font-family: var(--body-font);
        outline: none;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        height: calc(${heightNumber} * 1px);
        min-width: calc(${heightNumber} * 1px);
        background-color: ${neutralFillRestBehavior.var};
        color: ${neutralForegroundRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        fill: currentcolor;
        cursor: pointer;
    }

    .control {
        background: transparent;
        height: inherit;
        flex-grow: 1;
        box-sizing: border-box;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0 calc((10 + (var(--design-unit) * 2 * var(--density))) * 1px);
        white-space: nowrap;
        outline: none;
        text-decoration: none;
        border: calc(var(--outline-width) * 1px) solid transparent;
        color: inherit;
        border-radius: inherit;
        fill: inherit;
        cursor: inherit;
        font-family: inherit;
        font-size: inherit;
        line-height: inherit;
    }

    :host(:hover) {
        background-color: ${neutralFillHoverBehavior.var};
    }

    :host(:active) {
        background-color: ${neutralFillActiveBehavior.var};
    }

    .control:${focusVisible} {
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${neutralFocusBehavior.var};
    }

    .control::-moz-focus-inner {
        border: 0;
    }

    .start,
    .end {
        display: flex;
    }

    .control.icon-only {
        padding: 0;
        line-height: 0;
    }

    ::slotted(svg) {
        ${
/* Glyph size and margin-left is temporary -
replace when adaptive typography is figured out */ ""} width: 16px;
        height: 16px;
        pointer-events: none;
    }

    .start {
        margin-inline-end: 11px;
    }

    .end {
        margin-inline-start: 11px;
    }
`.withBehaviors(neutralFillRestBehavior, neutralForegroundRestBehavior, neutralFillHoverBehavior, neutralFillActiveBehavior, forcedColorsStylesheetBehavior(css `
            :host .control {
              background-color: ${SystemColors.ButtonFace};
              border-color: ${SystemColors.ButtonText};
              color: ${SystemColors.ButtonText};
              fill: currentColor;
            }
    
            :host(:hover) .control {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              color: ${SystemColors.HighlightText};
            }

            .control:${focusVisible} {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              border-color: ${SystemColors.ButtonText};
              box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.ButtonText};
              color: ${SystemColors.HighlightText};
            }

            .control:hover,
            :host([appearance="outline"]) .control:hover {
              border-color: ${SystemColors.ButtonText};
            }

            :host([href]) .control {
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.LinkText};
            }

            :host([href]) .control:hover,
            :host([href]) .control:${focusVisible}{
              forced-color-adjust: none;
              background: ${SystemColors.ButtonFace};
              border-color: ${SystemColors.LinkText};
              box-shadow: 0 0 0 1px ${SystemColors.LinkText} inset;
              color: ${SystemColors.LinkText};
              fill: currentColor;
            }
        `));
    /**
     * @internal
     */
    const AccentButtonStyles = css `
    :host([appearance="accent"]) {
        background: ${accentFillRestBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host([appearance="accent"]:hover) {
        background: ${accentFillHoverBehavior.var};
    }

    :host([appearance="accent"]:active) .control:active {
        background: ${accentFillActiveBehavior.var};
    }

    :host([appearance="accent"]) .control:${focusVisible} {
        box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) inset ${neutralFocusInnerAccentBehavior.var};
    }
`.withBehaviors(accentFillRestBehavior, accentForegroundCutRestBehavior, accentFillHoverBehavior, accentFillActiveBehavior, neutralFocusInnerAccentBehavior, forcedColorsStylesheetBehavior(css `
            :host([appearance="accent"]) .control {
                forced-color-adjust: none;
                background: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
            }

            :host([appearance="accent"]) .control:hover {
                background: ${SystemColors.HighlightText};
                border-color: ${SystemColors.Highlight};
                color: ${SystemColors.Highlight};
            }

            :host([appearance="accent"]) .control:${focusVisible} {
                border-color: ${SystemColors.ButtonText};
                box-shadow: 0 0 0 2px ${SystemColors.HighlightText} inset;
            }

            :host([appearance="accent"][href]) .control{
                background: ${SystemColors.LinkText};
                color: ${SystemColors.HighlightText};
            }

            :host([appearance="accent"][href]) .control:hover {
                background: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.LinkText};
                box-shadow: none;
                color: ${SystemColors.LinkText};
                fill: currentColor;
            }

            :host([appearance="accent"][href]) .control:${focusVisible} {
                border-color: ${SystemColors.LinkText};
                box-shadow: 0 0 0 2px ${SystemColors.HighlightText} inset;
            }
        `));
    /**
     * @internal
     */
    css `
    :host([appearance="hypertext"]) {
        font-size: inherit;
        line-height: inherit;
        height: auto;
        min-width: 0;
        background: transparent;
    }

    :host([appearance="hypertext"]) .control {
        display: inline;
        padding: 0;
        border: none;
        box-shadow: none;
        border-radius: 0;
        line-height: 1;
    }

    :host a.control:not(:link) {
        background-color: transparent;
        cursor: default;
    }
    :host([appearance="hypertext"]) .control:link,
    :host([appearance="hypertext"]) .control:visited {
        background: transparent;
        color: ${accentForegroundRestBehavior.var};
        border-bottom: calc(var(--outline-width) * 1px) solid ${accentForegroundRestBehavior.var};
    }

    :host([appearance="hypertext"]) .control:hover {
        border-bottom-color: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="hypertext"]) .control:active {
        border-bottom-color: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="hypertext"]) .control:${focusVisible} {
        border-bottom: calc(var(--focus-outline-width) * 1px) solid ${neutralFocusBehavior.var};
        margin-bottom: calc(calc(var(--outline-width) - var(--focus-outline-width)) * 1px);
    }
`.withBehaviors(accentForegroundRestBehavior, accentForegroundHoverBehavior, accentForegroundActiveBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css `
            :host([appearance="hypertext"]:hover) {
                background-color: ${SystemColors.ButtonFace};
                color: ${SystemColors.ButtonText};
            }
            :host([appearance="hypertext"][href]) .control:hover,
            :host([appearance="hypertext"][href]) .control:active,
            :host([appearance="hypertext"][href]) .control:${focusVisible} {
                color: ${SystemColors.LinkText};
                border-bottom-color: ${SystemColors.LinkText};
                box-shadow: none;
            }
        `));
    /**
     * @internal
     */
    const LightweightButtonStyles = css `
    :host([appearance="lightweight"]) {
        background: transparent;
        color: ${accentForegroundRestBehavior.var};
    }

    :host([appearance="lightweight"]) .control {
        padding: 0;
        height: initial;
        border: none;
        box-shadow: none;
        border-radius: 0;
    }

    :host([appearance="lightweight"]:hover) {
        color: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="lightweight"]:active) {
        color: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="lightweight"]) .content {
        position: relative;
    }

    :host([appearance="lightweight"]) .content::before {
        content: "";
        display: block;
        height: calc(var(--outline-width) * 1px);
        position: absolute;
        top: calc(1em + 4px);
        width: 100%;
    }

    :host([appearance="lightweight"]:hover) .content::before {
        background: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="lightweight"]:active) .content::before {
        background: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
        background: ${neutralForegroundRestBehavior.var};
        height: calc(var(--focus-outline-width) * 1px);
    }
`.withBehaviors(accentForegroundRestBehavior, accentForegroundHoverBehavior, accentForegroundActiveBehavior, accentForegroundHoverBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css `
            :host([appearance="lightweight"]) .control:hover,
            :host([appearance="lightweight"]) .control:${focusVisible} {
                forced-color-adjust: none;
                background: ${SystemColors.ButtonFace};
                color: ${SystemColors.Highlight};
            }
            :host([appearance="lightweight"]) .control:hover .content::before,
            :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
                background: ${SystemColors.Highlight};
            }

            :host([appearance="lightweight"][href]) .control:hover,
            :host([appearance="lightweight"][href]) .control:${focusVisible} {
                background: ${SystemColors.ButtonFace};
                box-shadow: none;
                color: ${SystemColors.LinkText};
            }

            :host([appearance="lightweight"][href]) .control:hover .content::before,
            :host([appearance="lightweight"][href]) .control:${focusVisible} .content::before {
                background: ${SystemColors.LinkText};
            }
        `));
    /**
     * @internal
     */
    const OutlineButtonStyles = css `
    :host([appearance="outline"]) {
        background: transparent;
        border-color: ${accentFillRestBehavior.var};
    }

    :host([appearance="outline"]:hover) {
        border-color: ${accentFillHoverBehavior.var};
    }

    :host([appearance="outline"]:active) {
        border-color: ${accentFillActiveBehavior.var};
    }

    :host([appearance="outline"]) .control {
        border-color: inherit;
    }

    :host([appearance="outline"]) .control:${focusVisible} {
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }
`.withBehaviors(accentFillRestBehavior, accentFillHoverBehavior, accentFillActiveBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css `
            :host([appearance="outline"]) .control {
                border-color: ${SystemColors.ButtonText};
            }
            :host([appearance="outline"]) .control:${focusVisible} {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              border-color: ${SystemColors.ButtonText};
              box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.ButtonText};
              color: ${SystemColors.HighlightText};
              fill: currentColor;
            }
            :host([appearance="outline"][href]) .control {
                background: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.LinkText};
                fill: currentColor;
            }
            :host([appearance="outline"][href]) .control:hover,
            :host([appearance="outline"][href]) .control:${focusVisible} {
              forced-color-adjust: none;
              border-color: ${SystemColors.LinkText};
              box-shadow: 0 0 0 1px ${SystemColors.LinkText} inset;
            }
        `));
    /**
     * @internal
     */
    const StealthButtonStyles = css `
    :host([appearance="stealth"]) {
        background: ${neutralFillStealthRestBehavior.var};
    }

    :host([appearance="stealth"]:hover) {
        background: ${neutralFillStealthHoverBehavior.var};
    }

    :host([appearance="stealth"]:active) {
        background: ${neutralFillStealthActiveBehavior.var};
    }
`.withBehaviors(neutralFillStealthRestBehavior, neutralFillStealthHoverBehavior, neutralFillStealthActiveBehavior, forcedColorsStylesheetBehavior(css `
            :host([appearance="stealth"]),
            :host([appearance="stealth"]) .control {
                forced-color-adjust: none;
                background: ${SystemColors.ButtonFace};
                border-color: transparent;
                color: ${SystemColors.ButtonText};
                fill: currentColor;
            }

            :host([appearance="stealth"]:hover) .control {
                background: ${SystemColors.Highlight};
                border-color: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"]:${focusVisible}) .control {
                background: ${SystemColors.Highlight};
                box-shadow: 0 0 0 1px ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"][href]) .control {
                color: ${SystemColors.LinkText};
            }

            :host([appearance="stealth"][href]:hover) .control,
            :host([appearance="stealth"][href]:${focusVisible}) .control {
                background: ${SystemColors.LinkText};
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"][href]:${focusVisible}) .control {
                forced-color-adjust: none;
                box-shadow: 0 0 0 1px ${SystemColors.LinkText};
            }
        `));

    /**
     * Behavior that will conditionally apply a stylesheet based on the elements
     * appearance property
     *
     * @param value - The value of the appearance property
     * @param styles - The styles to be applied when condition matches
     *
     * @public
     */
    function appearanceBehavior(value, styles) {
        return new PropertyStyleSheetBehavior("appearance", value, styles);
    }

    const ButtonStyles = css `
    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
        opacity: var(--disabled-opacity);
        background-color: ${neutralFillRestBehavior.var};
        cursor: ${disabledCursor};
    }

    ${BaseButtonStyles}
`.withBehaviors(forcedColorsStylesheetBehavior(css `
            :host([disabled]),
            :host([disabled]) .control {
                forced-color-adjust: none;
                background-color: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.GrayText};
                color: ${SystemColors.GrayText};
                cursor: ${disabledCursor};
                opacity: 1;
            }
        `), appearanceBehavior("accent", css `
            :host([appearance="accent"][disabled]),
            :host([appearance="accent"][disabled]:hover),
            :host([appearance="accent"][disabled]:active) {
                background: ${accentFillRestBehavior.var};
            }

            ${AccentButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css `
                    :host([appearance="accent"][disabled]) .control,
                    :host([appearance="accent"][disabled]) .control:hover {
                        background: ${SystemColors.ButtonFace};
                        border-color: ${SystemColors.GrayText};
                        color: ${SystemColors.GrayText};
                    }
                `))), appearanceBehavior("lightweight", css `
            :host([appearance="lightweight"][disabled]:hover),
            :host([appearance="lightweight"][disabled]:active) {
                background-color: transparent;
                color: ${accentForegroundRestBehavior.var};
            }

            :host([appearance="lightweight"][disabled]) .content::before,
            :host([appearance="lightweight"][disabled]:hover) .content::before,
            :host([appearance="lightweight"][disabled]:active) .content::before {
                background: transparent;
            }

            ${LightweightButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css `
                    :host([appearance="lightweight"].disabled) .control {
                        forced-color-adjust: none;
                        color: ${SystemColors.GrayText};
                    }

                    :host([appearance="lightweight"].disabled)
                        .control:hover
                        .content::before {
                        background: none;
                    }
                `))), appearanceBehavior("outline", css `
            :host([appearance="outline"][disabled]),
            :host([appearance="outline"][disabled]:hover),
            :host([appearance="outline"][disabled]:active) {
                background: transparent;
                border-color: ${accentFillRestBehavior.var};
            }

            ${OutlineButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css `
                    :host([appearance="outline"][disabled]) .control {
                        border-color: ${SystemColors.GrayText};
                    }
                `))), appearanceBehavior("stealth", css `
            :host([appearance="stealth"][disabled]),
            :host([appearance="stealth"][disabled]:hover),
            :host([appearance="stealth"][disabled]:active) {
                background: ${neutralFillStealthRestBehavior.var};
            }

            ${StealthButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css `
                    :host([appearance="stealth"][disabled]) {
                        background: ${SystemColors.ButtonFace};
                    }

                    :host([appearance="stealth"][disabled]) .control {
                        background: ${SystemColors.ButtonFace};
                        border-color: transparent;
                        color: ${SystemColors.GrayText};
                    }
                `))));

    /**
     * The FAST Button Element. Implements {@link @microsoft/fast-foundation#Button},
     * {@link @microsoft/fast-foundation#ButtonTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-button\>
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus | delegatesFocus}
     */
    let FASTButton = class FASTButton extends Button {
        connectedCallback() {
            super.connectedCallback();
            if (!this.appearance) {
                this.appearance = "neutral";
            }
        }
        /**
         * Applies 'icon-only' class when there is only an SVG in the default slot
         *
         * @public
         * @remarks
         */
        defaultSlottedContentChanged(oldValue, newValue) {
            const slottedElements = this.defaultSlottedContent.filter(x => x.nodeType === Node.ELEMENT_NODE);
            if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
                this.control.classList.add("icon-only");
            }
            else {
                this.control.classList.remove("icon-only");
            }
        }
    };
    __decorate$1([
        attr$1
    ], FASTButton.prototype, "appearance", void 0);
    FASTButton = __decorate$1([
        customElement({
            name: "fast-button",
            template: ButtonTemplate,
            styles: ButtonStyles,
            shadowOptions: {
                delegatesFocus: true,
            },
        })
    ], FASTButton);

    const RadioStyles = css `
    ${display("inline-flex")} :host {
        --input-size: calc((${heightNumber} / 2) + var(--design-unit));
        align-items: center;
        outline: none;
        margin: calc(var(--design-unit) * 1px) 0;
        ${
/*
 * Chromium likes to select label text or the default slot when
 * the radio button is clicked. Maybe there is a better solution here?
 */ ""} user-select: none;
        position: relative;
        flex-direction: row;
        transition: all 0.2s ease-in-out;
    }

    .control {
        position: relative;
        width: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        height: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        box-sizing: border-box;
        border-radius: 999px;
        border: calc(var(--outline-width) * 1px) solid ${neutralOutlineRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        outline: none;
        cursor: pointer;
    }

    .label {
        font-family: var(--body-font);
        color: ${neutralForegroundRestBehavior.var};
        ${
/* Need to discuss with Brian how HorizontalSpacingNumber can work. https://github.com/microsoft/fast/issues/2766 */ ""} padding-inline-start: calc(var(--design-unit) * 2px + 2px);
        margin-inline-end: calc(var(--design-unit) * 2px + 2px);
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    .control, .checked-indicator {
        flex-shrink: 0;
    }

    .checked-indicator {
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        border-radius: 999px;
        display: inline-block;
        background: ${accentForegroundCutRestBehavior.var};
        fill: ${accentForegroundCutRestBehavior.var};
        opacity: 0;
        pointer-events: none;
    }

    :host(:not([disabled])) .control:hover{
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${neutralOutlineHoverBehavior.var};
    }

    :host(:not([disabled])) .control:active {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${neutralOutlineActiveBehavior.var};
    }

    :host(:${focusVisible}) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }

    :host([aria-checked="true"]) .control {
        background: ${accentFillRestBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:hover {
        background: ${accentFillHoverBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillHoverBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:active {
        background: ${accentFillActiveBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillActiveBehavior.var};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: transparent;
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }

    :host([aria-checked="true"]) .checked-indicator {
        opacity: 1;
    }

    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundCutRestBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineActiveBehavior, neutralOutlineHoverBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css `
            .control,
            :host([checked]:not([disabled])) .control {
                forced-color-adjust: none;
                border-color: ${SystemColors.FieldText};
                background: ${SystemColors.Field};
            }
            :host(:not([disabled])) .control:hover {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.Field};
            }
            :host([checked]:not([disabled])) .control:hover,
            :host([checked]:not([disabled])) .control:active {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.Highlight};
            }
            :host([checked]) .checked-indicator {
                background: ${SystemColors.Highlight};
                fill: ${SystemColors.Highlight};
            }
            :host([checked]:not([disabled])) .control:hover .checked-indicator,
            :host([checked]:not([disabled])) .control:active .checked-indicator {
                background: ${SystemColors.HighlightText};
                fill: ${SystemColors.HighlightText};
            }
            :host(:${focusVisible}) .control {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([checked]:${focusVisible}:not([disabled])) .control {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([disabled]) {
                forced-color-adjust: none;
                opacity: 1;
            }
            :host([disabled]) .label {
                color: ${SystemColors.GrayText};
            }
            :host([disabled]) .control,
            :host([checked][disabled]) .control:hover, .control:active {
                background: ${SystemColors.Field};
                border-color: ${SystemColors.GrayText};
            }
            :host([disabled]) .checked-indicator,
            :host([checked][disabled]) .control:hover .checked-indicator {
                fill: ${SystemColors.GrayText};
                background: ${SystemColors.GrayText};
            }
        `));

    /**
     * The FAST Radio Element. Implements {@link @microsoft/fast-foundation#Radio},
     * {@link @microsoft/fast-foundation#RadioTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-radio\>
     */
    exports.FASTRadio = class FASTRadio extends Radio {
    };
    exports.FASTRadio = __decorate$1([
        customElement({
            name: "fast-radio",
            template: RadioTemplate,
            styles: RadioStyles,
        })
    ], exports.FASTRadio);

    const RadioGroupStyles = css `
    ${display("flex")} :host {
        align-items: flex-start;
        margin: calc(var(--design-unit) * 1px) 0;
        flex-direction: column;
    }
    .positioning-region {
        display: flex;
        flex-wrap: wrap;
    }
    :host([orientation="vertical"]) .positioning-region {
        flex-direction: column;
    }
    :host([orientation="horizontal"]) .positioning-region {
        flex-direction: row;
    }
`;

    /**
     * The FAST Radio Group Element. Implements {@link @microsoft/fast-foundation#RadioGroup},
     * {@link @microsoft/fast-foundation#RadioGroupTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-radio-group\>
     */
    exports.FASTRadioGroup = class FASTRadioGroup extends RadioGroup {
    };
    exports.FASTRadioGroup = __decorate$1([
        customElement({
            name: "fast-radio-group",
            template: RadioGroupTemplate,
            styles: RadioGroupStyles,
        })
    ], exports.FASTRadioGroup);

    const TabsStyles = css `
    ${display("grid")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        color: ${neutralForegroundRestBehavior.var};
        grid-template-columns: auto 1fr auto;
        grid-template-rows: auto 1fr;
    }

    .tablist {
        display: grid;
        grid-template-rows: auto auto;
        grid-template-columns: auto;
        position: relative;
        width: max-content;
        align-self: end;
        padding: calc(var(--design-unit) * 4px) calc(var(--design-unit) * 4px) 0;
        box-sizing: border-box;
    }

    .start,
    .end {
        align-self: center;
    }

    .activeIndicator {
        grid-row: 2;
        grid-column: 1;
        width: 100%;
        height: 5px;
        justify-self: center;
        background: ${accentFillRestBehavior.var};
        margin-top: 10px;
        border-radius: calc(var(--corner-radius) * 1px) calc(var(--corner-radius) * 1px) 0
            0;
    }

    .activeIndicatorTransition {
        transition: transform 0.2s ease-in-out;
    }

    .tabpanel {
        grid-row: 2;
        grid-column-start: 1;
        grid-column-end: 4;
        position: relative;
    }

    :host([orientation="vertical"]) {
        grid-template-rows: auto 1fr auto;
        grid-template-columns: auto 1fr;
    }

    :host([orientation="vertical"]) .tablist {
        grid-row-start: 2;
        grid-row-end: 2;
        display: grid;
        grid-template-rows: auto;
        grid-template-columns: auto 1fr;
        position: relative;
        width: max-content;
        justify-self: end;
        width: 100%;
        padding: calc((${heightNumber} - var(--design-unit)) * 1px)
            calc(var(--design-unit) * 4px)
            calc((${heightNumber} - var(--design-unit)) * 1px) 0;
    }

    :host([orientation="vertical"]) .tabpanel {
        grid-column: 2;
        grid-row-start: 1;
        grid-row-end: 4;
    }

    :host([orientation="vertical"]) .end {
        grid-row: 3;
    }

    :host([orientation="vertical"]) .activeIndicator {
        grid-column: 1;
        grid-row: 1;
        width: 5px;
        height: 100%;
        margin-inline-end: 10px;
        align-self: center;
        background: ${accentFillRestBehavior.var};
        margin-top: 0;
        border-radius: 0 calc(var(--corner-radius) * 1px) calc(var(--corner-radius) * 1px)
            0;
    }

    :host([orientation="vertical"]) .activeIndicatorTransition {
        transition: transform 0.2s linear;
    }
`.withBehaviors(accentFillRestBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css `
            .activeIndicator,
            :host([orientation="vertical"]) .activeIndicator {
                forced-color-adjust: none;
                background: ${SystemColors.Highlight};
            }
        `));

    const TabStyles = css `
    ${display("inline-flex")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        height: calc(${heightNumber} * 1px);
        padding: calc(var(--design-unit) * 5px) calc(var(--design-unit) * 4px);
        color: ${neutralForegroundHintBehavior.var};
        fill: currentcolor;
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid transparent;
        align-items: center;
        justify-content: center;
        grid-row: 1;
        cursor: pointer;
    }

    :host(:hover) {
        color: ${neutralForegroundHoverBehavior.var};
        fill: currentcolor;
    }

    :host(:active) {
        color: ${neutralForegroundActiveBehavior.var};
        fill: currentcolor;
    }

    :host([disabled]) {
        cursor: ${disabledCursor};
        opacity: var(--disabled-opacity);
    }

    :host([disabled]:hover) {
        color: ${neutralForegroundHintBehavior.var};
        background: ${neutralFillStealthRestBehavior.var};
    }

    :host([aria-selected="true"]) {
        background: ${neutralFillRestBehavior.var};
        color: ${accentForegroundRestBehavior.var};
        fill: currentcolor;
    }

    :host([aria-selected="true"]:hover) {
        background: ${neutralFillHoverBehavior.var};
        color: ${accentForegroundHoverBehavior.var};
        fill: currentcolor;
    }

    :host([aria-selected="true"]:active) {
        background: ${neutralFillActiveBehavior.var};
        color: ${accentForegroundActiveBehavior.var};
        fill: currentcolor;
    }

    :host(:${focusVisible}) {
        outline: none;
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px)
            ${neutralFocusBehavior.var};
    }

    :host(:focus) {
        outline: none;
    }

    :host(.vertical) {
        justify-content: end;
        grid-column: 2;
    }

    :host(.vertical[aria-selected="true"]) {
        z-index: 2;
    }

    :host(.vertical:hover) {
        color: ${neutralForegroundHoverBehavior.var};
    }

    :host(.vertical:active) {
        color: ${neutralForegroundActiveBehavior.var};
    }

    :host(.vertical:hover[aria-selected="true"]) {
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundActiveBehavior, accentForegroundHoverBehavior, accentForegroundRestBehavior, neutralFillActiveBehavior, neutralFillHoverBehavior, neutralFillRestBehavior, neutralFillStealthRestBehavior, neutralFocusBehavior, neutralForegroundHintBehavior, neutralForegroundActiveBehavior, neutralForegroundHoverBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css `
            :host {
                forced-color-adjust: none;
                border-color: transparent;
                color: ${SystemColors.ButtonText};
                fill: currentcolor;
            }
            :host(:hover),
            :host(.vertical:hover),
            :host([aria-selected="true"]:hover) {
                background: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentcolor;
            }
            :host([aria-selected="true"]) {
                background: ${SystemColors.HighlightText};
                color: ${SystemColors.Highlight};
                fill: currentcolor;
            }
            :host(:${focusVisible}) {
                border-color: ${SystemColors.ButtonText};
                box-shadow: none;
            }
        `));

    /**
     * The FAST Tab Custom Element. Implements {@link @microsoft/fast-foundation#Tab},
     * {@link @microsoft/fast-foundation#TabTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-tab\>
     */
    let FASTTab = class FASTTab extends Tab {
    };
    FASTTab = __decorate$1([
        customElement({
            name: "fast-tab",
            template: TabTemplate,
            styles: TabStyles,
        })
    ], FASTTab);

    /**
     * The FAST Tabs Custom Element. Implements {@link @microsoft/fast-foundation#Tabs},
     * {@link @microsoft/fast-foundation#TabsTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-tabs\>
     */
    let FASTTabs = class FASTTabs extends Tabs {
    };
    FASTTabs = __decorate$1([
        customElement({
            name: "fast-tabs",
            template: TabsTemplate,
            styles: TabsStyles,
        })
    ], FASTTabs);

    const TextAreaStyles = css `
    ${display("inline-block")} :host {
        font-family: var(--body-font);
        outline: none;
        user-select: none;
    }

    .control {
        box-sizing: border-box;
        position: relative;
        color: ${neutralForegroundRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
        height: calc(${heightNumber} * 2px);
        font: inherit;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        padding: calc(var(--design-unit) * 2px + 1px);
        width: 100%;
        resize: none;
    }

    .control:hover:enabled {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${accentFillHoverBehavior.var};
    }

    .control:active:enabled {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${accentFillActiveBehavior.var};
    }

    .control:hover,
    .control:${focusVisible},
    .control:disabled,
    .control:active {
        outline: none;
    }

    :host(:focus-within) .control {
        border-color: ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 1px ${neutralFocusBehavior.var} inset;
    }

    :host([appearance="filled"]) .control {
        background: ${neutralFillRestBehavior.var};
    }

    :host([appearance="filled"]:hover:not([disabled])) .control {
        background: ${neutralFillHoverBehavior.var};
    }

    :host([resize="both"]) .control {
        resize: both;
    }

    :host([resize="horizontal"]) .control {
        resize: horizontal;
    }

    :host([resize="vertical"]) .control {
        resize: vertical;
    }

    .label {
        display: block;
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        margin-bottom: 4px;
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }
    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }
    :host([disabled]) .control {
        border-color: ${neutralOutlineRestBehavior.var};
    }
 `.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, neutralFillHoverBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFillRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css `
            :host([disabled]) {
                opacity: 1;
            }
        `));

    /**
     * The FAST Text Area Custom Element. Implements {@link @microsoft/fast-foundation#TextArea},
     * {@link @microsoft/fast-foundation#TextAreaTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-text-area\>
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus | delegatesFocus}
     */
    exports.FASTTextArea = class FASTTextArea extends TextArea {
        /**
         * @internal
         */
        connectedCallback() {
            super.connectedCallback();
            if (!this.appearance) {
                this.appearance = "outline";
            }
        }
    };
    __decorate$1([
        attr$1
    ], exports.FASTTextArea.prototype, "appearance", void 0);
    exports.FASTTextArea = __decorate$1([
        customElement({
            name: "fast-text-area",
            template: TextAreaTemplate,
            styles: TextAreaStyles,
            shadowOptions: {
                delegatesFocus: true,
            },
        })
    ], exports.FASTTextArea);

    const TreeViewStyles = css `
    :host([hidden]) {
        display: none;
    }

    ${display("flex")} :host {
        flex-direction: column;
        align-items: stretch;
        min-width: fit-content;
        font-size: 0;
    }

    :host:focus-visible {
        outline: none;
    }
`;

    /**
     * The FAST tree view Custom Element. Implements, {@link @microsoft/fast-foundation#TreeView}
     * {@link @microsoft/fast-foundation#TreeViewTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-tree-view\>
     *
     */
    exports.FASTTreeView = class FASTTreeView extends TreeView {
    };
    exports.FASTTreeView = __decorate$1([
        customElement({
            name: "fast-tree-view",
            template: TreeViewTemplate,
            styles: TreeViewStyles,
        })
    ], exports.FASTTreeView);

    const ltr = css `
    .expand-collapse-glyph {
        transform: rotate(0deg);
    }
    :host(.nested) .expand-collapse-button {
        left: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
    }
    :host([selected])::after {
        left: calc(var(--focus-outline-width) * 1px);
    }
    :host([expanded]) > .positioning-region .expand-collapse-glyph {
        transform: rotate(45deg);
    }
`;
    const rtl = css `
    .expand-collapse-glyph {
        transform: rotate(180deg);
    }
    :host(.nested) .expand-collapse-button {
        right: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
    }
    :host([selected])::after {
        right: calc(var(--focus-outline-width) * 1px);
    }
    :host([expanded]) > .positioning-region .expand-collapse-glyph {
        transform: rotate(135deg);
    }
`;
    const expandCollapseButtonSize = "((var(--base-height-multiplier) / 2) * var(--design-unit)) + ((var(--design-unit) * var(--density)) / 2)";
    const expandCollapseHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-stealth-hover-over-hover", x => neutralFillStealthHover(neutralFillStealthHover)(x), exports.FASTDesignSystemProvider.findProvider);
    const selectedExpandCollapseHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-stealth-hover-over-selected", x => neutralFillStealthHover(neutralFillStealthSelected)(x), exports.FASTDesignSystemProvider.findProvider);
    const TreeItemStyles = css `
    ${display("block")} :host {
        contain: content;
        position: relative;
        outline: none;
        color: ${neutralForegroundRestBehavior.var};
        background: ${neutralFillStealthRestBehavior.var};
        cursor: pointer;
        font-family: var(--body-font);
        --expand-collapse-button-size: calc(${heightNumber} * 1px);
        --tree-item-nested-width: 0;
    }

    :host(:focus) > .positioning-region {
        outline: none;
    }

    :host(:focus) .content-region {
        outline: none;
    }

    :host(:${focusVisible}) .positioning-region {
        border: ${neutralFocusBehavior.var} calc(var(--outline-width) * 1px) solid;
        border-radius: calc(var(--corner-radius) * 1px);
        color: ${neutralForegroundActiveBehavior.var};
    }

    .positioning-region {
        display: flex;
        position: relative;
        box-sizing: border-box;
        border: transparent calc(var(--outline-width) * 1px) solid;
        height: calc((${heightNumber} + 1) * 1px);
    }

    .positioning-region::before {
        content: "";
        display: block;
        width: var(--tree-item-nested-width);
        flex-shrink: 0;
    }

    .positioning-region:hover {
        background: ${neutralFillStealthHoverBehavior.var};
    }

    .positioning-region:active {
        background: ${neutralFillStealthActiveBehavior.var};
    }

    .content-region {
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
        width: 100%;
        height: calc(${heightNumber} * 1px);
        margin-inline-start: calc(var(--design-unit) * 2px + 8px);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        font-weight: 400;
    }

    .items {
        display: none;
        ${
/* Font size should be based off calc(1em + (design-unit + glyph-size-number) * 1px) -
update when density story is figured out */ ""} font-size: calc(1em + (var(--design-unit) + 16) * 1px);
    }

    .expand-collapse-button {
        background: none;
        border: none;
        outline: none;
        ${
/* Width and Height should be based off calc(glyph-size-number + (design-unit * 4) * 1px) -
update when density story is figured out */ ""} width: calc((${expandCollapseButtonSize} + (var(--design-unit) * 2)) * 1px);
        height: calc((${expandCollapseButtonSize} + (var(--design-unit) * 2)) * 1px);
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        margin-left: 6px;
        margin-right: 6px;
    }

    .expand-collapse-glyph {
        ${
/* Glyph size is temporary -
replace when glyph-size var is added */ ""} width: 16px;
        height: 16px;
        transition: transform 0.1s linear;

        pointer-events: none;
        fill: currentcolor;
    }

    .start,
    .end {
        display: flex;
        fill: currentcolor;
    }

     ::slotted(svg) {
        ${
/* Glyph size is temporary -
replace when glyph-size var is added */ ""} width: 16px;
        height: 16px;
    }

    .start {
        ${
/* need to swap out once we understand how horizontalSpacing will work */ ""} margin-inline-end: calc(var(--design-unit) * 2px + 2px);
    }

    .end {
        ${
/* need to swap out once we understand how horizontalSpacing will work */ ""} margin-inline-start: calc(var(--design-unit) * 2px + 2px);
    }

    :host([expanded]) > .items {
        display: block;
    }

    :host([disabled]) .content-region {
        opacity: var(--disabled-opacity);
        cursor: ${disabledCursor};
    }

    :host(.nested) .content-region {
        position: relative;
        margin-inline-start: var(--expand-collapse-button-size);
    }

    :host(.nested) .expand-collapse-button {
        position: absolute;
    }

    :host(.nested) .expand-collapse-button:hover {
        background: ${expandCollapseHoverBehavior.var};
    }
    
    :host([selected]) .positioning-region {
        background: ${neutralFillStealthSelectedBehavior.var};
    }

    :host([selected]) .expand-collapse-button:hover {
        background: ${selectedExpandCollapseHoverBehavior.var};
    }

    :host([selected])::after {
        content: "";
        display: block;
        position: absolute;
        top: calc((${heightNumber} / 4) * 1px);
        width: 3px;
        height: calc((${heightNumber} / 2) * 1px);
        ${
/* The french fry background needs to be calculated based on the selected background state for this control.
We currently have no way of changing that, so setting to accent-foreground-rest for the time being */ ""} background: ${accentForegroundRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
    }

    ::slotted(fast-tree-item) {
        --tree-item-nested-width: 1em;
        --expand-collapse-button-nested-width: calc(${heightNumber} * -1px);
    }
`.withBehaviors(accentForegroundRestBehavior, neutralFillStealthSelectedBehavior, neutralFillStealthActiveBehavior, expandCollapseHoverBehavior, neutralFillStealthHoverBehavior, selectedExpandCollapseHoverBehavior, neutralFillStealthRestBehavior, neutralFocusBehavior, neutralFocusInnerAccentBehavior, neutralForegroundActiveBehavior, neutralForegroundRestBehavior, new DirectionalStyleSheetBehavior(ltr, rtl), forcedColorsStylesheetBehavior(css `
        :host {
            forced-color-adjust: none;
            border-color: transparent;
            background: ${SystemColors.Field};
            color: ${SystemColors.FieldText};
        }
        :host .content-region .expand-collapse-glyph {
            fill: ${SystemColors.FieldText};
        }
        :host .positioning-region:hover,
        :host([selected]) .positioning-region {
            background: ${SystemColors.Highlight};
        }
        :host .positioning-region:hover .content-region,
        :host([selected]) .positioning-region .content-region {
            color: ${SystemColors.HighlightText};
        }
        :host .positioning-region:hover .content-region .expand-collapse-glyph,
        :host .positioning-region:hover .content-region .start,
        :host .positioning-region:hover .content-region .end,
        :host([selected]) .content-region .expand-collapse-glyph,
        :host([selected]) .content-region .start,
        :host([selected]) .content-region .end {
            fill: ${SystemColors.HighlightText};
        }
        :host([selected])::after {
            background: ${SystemColors.Field};
        }
        :host(:${focusVisible}) .positioning-region {
            border-color: ${SystemColors.FieldText};
            box-shadow: 0 0 0 2px inset ${SystemColors.Field};
            color: ${SystemColors.FieldText};
        }
        :host([disabled]) .content-region,
        :host([disabled]) .positioning-region:hover .content-region {
            opacity: 1;
            color: ${SystemColors.GrayText};
        }
        :host([disabled]) .content-region .expand-collapse-glyph,
        :host([disabled]) .content-region .start,
        :host([disabled]) .content-region .end,
        :host([disabled]) .positioning-region:hover .content-region .expand-collapse-glyph,
        :host([disabled]) .positioning-region:hover .content-region .start,
        :host([disabled]) .positioning-region:hover .content-region .end {
            fill: ${SystemColors.GrayText};
        }
        :host([disabled]) .positioning-region:hover {
            background: ${SystemColors.Field};
        }
        .expand-collapse-glyph,
        .start,
        .end {
            fill: ${SystemColors.FieldText};
        }
        :host(.nested) .expand-collapse-button:hover {
            background: ${SystemColors.Field};
        }
        :host(.nested) .expand-collapse-button:hover .expand-collapse-glyph {
            fill: ${SystemColors.FieldText};
        }
        `));

    /**
     * The FAST tree item Custom Element. Implements, {@link @microsoft/fast-foundation#TreeItem}
     * {@link @microsoft/fast-foundation#TreeItemTemplate}
     *
     *
     * @public
     * @remarks
     * HTML Element: \<fast-tree-item\>
     *
     */
    exports.FASTTreeItem = class FASTTreeItem extends TreeItem {
    };
    exports.FASTTreeItem = __decorate$1([
        customElement({
            name: "fast-tree-item",
            template: TreeItemTemplate,
            styles: TreeItemStyles,
        })
    ], exports.FASTTreeItem);

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function self$1(fn) {
        return function (event) {
            // @ts-ignore
            if (event.target === this)
                fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function checkIframe(element) {
        if (element.ownerDocument !== document) {
            const iframes = Array.from(document.querySelectorAll('iframe'));
            return iframes.find((iframe) => iframe.contentDocument === element.ownerDocument);
        }
    }
    function checkIgnore(element) {
        try {
            if (element.classList.contains('iteria-ignore'))
                return true;
            if (element.tagName === 'BODY')
                return false;
            return checkIgnore(element.parentElement);
        }
        catch (error) {
            return true;
        }
    }
    function listenScrollEvent(element, callback) {
        let scrollable = element;
        const scrollableElements = new Set();
        while (scrollable) {
            const { scrollHeight, offsetHeight, scrollWidth, offsetWidth } = scrollable;
            const isScrollable = scrollHeight > offsetHeight || scrollWidth > offsetWidth;
            if (isScrollable && !scrollableElements.has(scrollable)) {
                scrollableElements.add(scrollable);
                scrollable.removeEventListener('scroll', callback);
                scrollable.addEventListener('scroll', callback);
            }
            if (scrollable.tagName === 'BODY')
                break;
            scrollable = scrollable.parentElement;
        }
        return () => {
            scrollableElements.forEach(element => {
                element.removeEventListener("scroll", callback);
            });
        };
    }
    function isBlue(element) {
        const rgb = window.getComputedStyle(element, null).backgroundColor;
        if (rgb) {
            const colors = [];
            rgb.replace(/\d+/g, (color) => {
                colors.push(parseInt(color));
                return "";
            });
            if (colors.length >= 3) {
                if (typeof colors[3] !== "undefined") {
                    if (colors[3] < 0.5) {
                        if (element.tagName === "BODY")
                            return false;
                        return isBlue(element.parentElement);
                    }
                }
                if (colors[0] < colors[2] && colors[1] < colors[2])
                    return true;
            }
        }
        return false;
    }

    /* src\components\WidgetElevation.svelte generated by Svelte v3.38.2 */

    const { window: window_1$3 } = globals;
    const file$b = "src\\components\\WidgetElevation.svelte";

    // (70:0) {#if element}
    function create_if_block$8(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", "overlay overlay-1 svelte-sfsk7d");
    			add_location(div0, file$b, 71, 4, 2321);
    			attr_dev(div1, "class", "overlay overlay-2 svelte-sfsk7d");
    			add_location(div1, file$b, 72, 4, 2385);
    			attr_dev(div2, "class", "overlay overlay-3 svelte-sfsk7d");
    			add_location(div2, file$b, 73, 4, 2449);
    			attr_dev(div3, "class", "overlay overlay-4 svelte-sfsk7d");
    			add_location(div3, file$b, 74, 4, 2513);
    			attr_dev(div4, "class", "overlays");
    			attr_dev(div4, "style", /*overlayVars*/ ctx[1]);
    			add_location(div4, file$b, 70, 2, 2273);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div4, t2);
    			append_dev(div4, div3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "pointerenter", /*pointerenter_handler*/ ctx[11], false, false, false),
    					listen_dev(div0, "click", /*click_handler*/ ctx[12], false, false, false),
    					listen_dev(div1, "pointerenter", /*pointerenter_handler_1*/ ctx[9], false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[10], false, false, false),
    					listen_dev(div2, "pointerenter", /*pointerenter_handler_2*/ ctx[7], false, false, false),
    					listen_dev(div2, "click", /*click_handler_2*/ ctx[8], false, false, false),
    					listen_dev(div3, "pointerenter", /*pointerenter_handler_3*/ ctx[5], false, false, false),
    					listen_dev(div3, "click", /*click_handler_3*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*overlayVars*/ 2) {
    				attr_dev(div4, "style", /*overlayVars*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(70:0) {#if element}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*element*/ ctx[0] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(window_1$3, "resize", /*update*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*element*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const stroke = 2;

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetElevation", slots, []);
    	let { element } = $$props;

    	onMount(() => {
    		element.addEventListener("keyup", update);

    		return () => {
    			element.removeEventListener("keyup", update);
    		};
    	});

    	let overlayVars = "";
    	let iframe = null;
    	let removeScrollEventListeners = () => null;
    	let elementBoundries = null;
    	let iframeBoundries = null;

    	function update() {
    		if (checkIgnore(element)) return;
    		iframe = checkIframe(element);
    		window["iframe"] = iframe;
    		updateBoundries();
    		removeScrollEventListeners();
    		removeScrollEventListeners = listenScrollEvent(iframe || element, updateBoundries);
    	}

    	function updateBoundries() {
    		$$invalidate(3, elementBoundries = element.getBoundingClientRect());

    		if (iframe) {
    			$$invalidate(4, iframeBoundries = iframe.getBoundingClientRect());
    		} else {
    			$$invalidate(4, iframeBoundries = {
    				top: 0,
    				left: 0,
    				x: 0,
    				y: 0,
    				right: window.innerWidth,
    				bottom: window.innerHeight,
    				width: window.innerWidth,
    				height: window.innerHeight
    			});
    		}
    	}

    	onDestroy(() => removeScrollEventListeners());
    	const writable_props = ["element"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetElevation> was created with unknown prop '${key}'`);
    	});

    	function pointerenter_handler_3(event) {
    		bubble($$self, event);
    	}

    	function click_handler_3(event) {
    		bubble($$self, event);
    	}

    	function pointerenter_handler_2(event) {
    		bubble($$self, event);
    	}

    	function click_handler_2(event) {
    		bubble($$self, event);
    	}

    	function pointerenter_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function pointerenter_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		checkIframe,
    		checkIgnore,
    		listenScrollEvent,
    		element,
    		overlayVars,
    		iframe,
    		removeScrollEventListeners,
    		elementBoundries,
    		iframeBoundries,
    		update,
    		updateBoundries,
    		stroke
    	});

    	$$self.$inject_state = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("overlayVars" in $$props) $$invalidate(1, overlayVars = $$props.overlayVars);
    		if ("iframe" in $$props) iframe = $$props.iframe;
    		if ("removeScrollEventListeners" in $$props) removeScrollEventListeners = $$props.removeScrollEventListeners;
    		if ("elementBoundries" in $$props) $$invalidate(3, elementBoundries = $$props.elementBoundries);
    		if ("iframeBoundries" in $$props) $$invalidate(4, iframeBoundries = $$props.iframeBoundries);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element*/ 1) {
    			if (element) update();
    		}

    		if ($$self.$$.dirty & /*elementBoundries, iframeBoundries*/ 24) {
    			if (elementBoundries) {
    				$$invalidate(1, overlayVars = `
    --stroke: ${stroke}px;

    --local-top: ${elementBoundries.top - stroke}px;
    --local-right: ${elementBoundries.right + stroke}px;
    --local-bottom: ${elementBoundries.bottom + stroke}px;
    --local-left: ${elementBoundries.left - stroke}px;
    --local-width: ${elementBoundries.width}px;
    --local-height: ${elementBoundries.height - stroke}px;

    --offset-top: ${iframeBoundries ? iframeBoundries.top : 0}px;
    --offset-left: ${iframeBoundries ? iframeBoundries.left : 0}px;
    --offset-right: ${iframeBoundries ? iframeBoundries.right : 0}px;
    --offset-bottom: ${iframeBoundries ? iframeBoundries.bottom : 0}px;
    --offset-width: ${iframeBoundries ? iframeBoundries.width : 0}px;
    --offset-height: ${iframeBoundries ? iframeBoundries.height : 0}px;
    `);
    			}
    		}
    	};

    	return [
    		element,
    		overlayVars,
    		update,
    		elementBoundries,
    		iframeBoundries,
    		pointerenter_handler_3,
    		click_handler_3,
    		pointerenter_handler_2,
    		click_handler_2,
    		pointerenter_handler_1,
    		click_handler_1,
    		pointerenter_handler,
    		click_handler
    	];
    }

    class WidgetElevation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$d, create_fragment$e, safe_not_equal, { element: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetElevation",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*element*/ ctx[0] === undefined && !("element" in props)) {
    			console.warn("<WidgetElevation> was created without expected prop 'element'");
    		}
    	}

    	get element() {
    		throw new Error("<WidgetElevation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<WidgetElevation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetTippy.svelte generated by Svelte v3.38.2 */

    const { window: window_1$2 } = globals;
    const file$a = "src\\components\\WidgetTippy.svelte";

    // (89:6) {#if mode == 'editing'}
    function create_if_block_1$5(ctx) {
    	let div1;
    	let div0;
    	let span0;
    	let div1_title_value;
    	let t1;
    	let div3;
    	let div2;
    	let span1;
    	let svg;
    	let path0;
    	let path1;
    	let div3_title_value;
    	let t2;
    	let div5;
    	let div4;
    	let span2;
    	let div5_title_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "content_copy";
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span1 = element("span");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t2 = space();
    			div5 = element("div");
    			div4 = element("div");
    			span2 = element("span");
    			span2.textContent = "code";
    			attr_dev(span0, "class", "material-icons clone svelte-qxh3rp");
    			add_location(span0, file$a, 91, 12, 2969);
    			attr_dev(div0, "class", "button svelte-qxh3rp");
    			add_location(div0, file$a, 90, 10, 2884);
    			attr_dev(div1, "class", "action svelte-qxh3rp");
    			attr_dev(div1, "title", div1_title_value = "clone" + (/*disabled*/ ctx[2] ? " is disabled" : ""));
    			toggle_class(div1, "disabled", /*disabled*/ ctx[2]);
    			add_location(div1, file$a, 89, 8, 2786);
    			attr_dev(path0, "fill", "white");
    			attr_dev(path0, "d", "M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13z");
    			add_location(path0, file$a, 98, 16, 3382);
    			attr_dev(path1, "fill", "white");
    			attr_dev(path1, "d", "M9 8h2v9H9zm4 0h2v9h-2z");
    			add_location(path1, file$a, 101, 18, 3541);
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "width", "20");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", " NMm5M svelte-qxh3rp");
    			add_location(svg, file$a, 97, 14, 3283);
    			attr_dev(span1, "class", "");
    			add_location(span1, file$a, 96, 12, 3252);
    			attr_dev(div2, "class", "button svelte-qxh3rp");
    			add_location(div2, file$a, 95, 10, 3166);
    			attr_dev(div3, "class", "action svelte-qxh3rp");
    			attr_dev(div3, "title", div3_title_value = "delete" + (/*disabled*/ ctx[2] ? " is disabled" : ""));
    			toggle_class(div3, "disabled", /*disabled*/ ctx[2]);
    			add_location(div3, file$a, 94, 8, 3067);
    			attr_dev(span2, "class", "material-icons showsource svelte-qxh3rp");
    			add_location(span2, file$a, 108, 12, 3866);
    			attr_dev(div4, "class", "button svelte-qxh3rp");
    			add_location(div4, file$a, 107, 10, 3776);
    			attr_dev(div5, "class", "action svelte-qxh3rp");
    			attr_dev(div5, "title", div5_title_value = "source" + (/*disabled*/ ctx[2] ? " is disabled" : ""));
    			toggle_class(div5, "disabled", /*disabled*/ ctx[2]);
    			add_location(div5, file$a, 106, 8, 3677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, span1);
    			append_dev(span1, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, span2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler_1*/ ctx[21], false, false, false),
    					listen_dev(div2, "click", /*click_handler_2*/ ctx[22], false, false, false),
    					listen_dev(div4, "click", /*click_handler_3*/ ctx[23], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*disabled*/ 4 && div1_title_value !== (div1_title_value = "clone" + (/*disabled*/ ctx[2] ? " is disabled" : ""))) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			if (dirty & /*disabled*/ 4) {
    				toggle_class(div1, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*disabled*/ 4 && div3_title_value !== (div3_title_value = "delete" + (/*disabled*/ ctx[2] ? " is disabled" : ""))) {
    				attr_dev(div3, "title", div3_title_value);
    			}

    			if (dirty & /*disabled*/ 4) {
    				toggle_class(div3, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*disabled*/ 4 && div5_title_value !== (div5_title_value = "source" + (/*disabled*/ ctx[2] ? " is disabled" : ""))) {
    				attr_dev(div5, "title", div5_title_value);
    			}

    			if (dirty & /*disabled*/ 4) {
    				toggle_class(div5, "disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(89:6) {#if mode == 'editing'}",
    		ctx
    	});

    	return block;
    }

    // (114:4) {#if mode === 'inspecting' && text}
    function create_if_block$7(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*text*/ ctx[0]);
    			attr_dev(span, "class", "text svelte-qxh3rp");
    			add_location(span, file$a, 114, 6, 4025);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(114:4) {#if mode === 'inspecting' && text}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div5;
    	let div0;
    	let t0;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let span;

    	let t1_value = (/*mode*/ ctx[1] == "inspecting"
    	? /*icon*/ ctx[4]
    	: "clear") + "";

    	let t1;
    	let t2;
    	let t3;
    	let div4_resize_listener;
    	let div5_class_value;
    	let div5_style_value;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[19]);
    	let if_block0 = /*mode*/ ctx[1] == "editing" && create_if_block_1$5(ctx);
    	let if_block1 = /*mode*/ ctx[1] === "inspecting" && /*text*/ ctx[0] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "arrow svelte-qxh3rp");
    			add_location(div0, file$a, 77, 2, 2365);
    			attr_dev(span, "class", "material-icons svelte-qxh3rp");
    			add_location(span, file$a, 82, 10, 2612);
    			attr_dev(div1, "class", "button svelte-qxh3rp");
    			add_location(div1, file$a, 81, 8, 2536);
    			attr_dev(div2, "class", "action svelte-qxh3rp");
    			add_location(div2, file$a, 80, 6, 2506);
    			attr_dev(div3, "class", "actions svelte-qxh3rp");
    			add_location(div3, file$a, 79, 4, 2477);
    			attr_dev(div4, "class", "tippy svelte-qxh3rp");
    			add_render_callback(() => /*div4_elementresize_handler*/ ctx[24].call(div4));
    			add_location(div4, file$a, 78, 2, 2390);
    			attr_dev(div5, "class", div5_class_value = "tippy-wrapper iteria-ignore fadein transition " + /*alignX*/ ctx[10] + " svelte-qxh3rp");
    			attr_dev(div5, "style", div5_style_value = "" + (/*css*/ ctx[3] + /*otherVars*/ ctx[11]));
    			toggle_class(div5, "bottom", !/*fatElement*/ ctx[12] && /*top*/ ctx[9] <= 50);
    			toggle_class(div5, "transform", /*fatElement*/ ctx[12]);
    			add_location(div5, file$a, 71, 0, 2185);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, span);
    			append_dev(span, t1);
    			append_dev(div3, t2);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div4, t3);
    			if (if_block1) if_block1.m(div4, null);
    			div4_resize_listener = add_resize_listener(div4, /*div4_elementresize_handler*/ ctx[24].bind(div4));

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1$2, "resize", /*onwindowresize*/ ctx[19]),
    					listen_dev(div1, "click", /*click_handler*/ ctx[20], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*mode, icon*/ 18 && t1_value !== (t1_value = (/*mode*/ ctx[1] == "inspecting"
    			? /*icon*/ ctx[4]
    			: "clear") + "")) set_data_dev(t1, t1_value);

    			if (/*mode*/ ctx[1] == "editing") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					if_block0.m(div3, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*mode*/ ctx[1] === "inspecting" && /*text*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					if_block1.m(div4, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*alignX*/ 1024 && div5_class_value !== (div5_class_value = "tippy-wrapper iteria-ignore fadein transition " + /*alignX*/ ctx[10] + " svelte-qxh3rp")) {
    				attr_dev(div5, "class", div5_class_value);
    			}

    			if (dirty & /*css, otherVars*/ 2056 && div5_style_value !== (div5_style_value = "" + (/*css*/ ctx[3] + /*otherVars*/ ctx[11]))) {
    				attr_dev(div5, "style", div5_style_value);
    			}

    			if (dirty & /*alignX, fatElement, top*/ 5632) {
    				toggle_class(div5, "bottom", !/*fatElement*/ ctx[12] && /*top*/ ctx[9] <= 50);
    			}

    			if (dirty & /*alignX, fatElement*/ 5120) {
    				toggle_class(div5, "transform", /*fatElement*/ ctx[12]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			div4_resize_listener();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let top;
    	let bottom;
    	let otherVars;
    	let fatElement;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetTippy", slots, []);
    	let { text = "" } = $$props;
    	let { mode = "inspecting" } = $$props;
    	let { offset = { top: 0, left: 0 } } = $$props;
    	let { boundries = null } = $$props;
    	let { disabled = false } = $$props;
    	let { css = "" } = $$props;
    	let { icon = "settings" } = $$props;
    	let { contentWindow = window } = $$props;
    	const dispatch = createEventDispatcher();
    	let tippyWidth = 0;
    	let tippyHeight = 0;
    	let windowWidth = 0;
    	let windowHeight = 0;
    	let mouse = [0, 0];
    	let alignX = "right";
    	let lastActiveWindow;

    	function switchContext(window) {
    		if (window !== lastActiveWindow) {
    			if (lastActiveWindow) lastActiveWindow.removeEventListener("pointermove", pointerMoved);
    			window.addEventListener("pointermove", pointerMoved);
    			lastActiveWindow = window;
    		}
    	}

    	function pointerMoved(e) {
    		$$invalidate(17, mouse = [e.clientX, e.clientY]);

    		if (tippyWidth > boundries.width) {
    			$$invalidate(10, alignX = "left");
    		} else if (tippyWidth < boundries.width / 3) {
    			if (mouse[0] < boundries.left + boundries.width / 3) {
    				$$invalidate(10, alignX = "left");
    			} else if (mouse[0] < boundries.left + boundries.width * 2 / 3) {
    				$$invalidate(10, alignX = "center");
    			} else {
    				$$invalidate(10, alignX = "right");
    			}
    		} else if (tippyWidth < boundries.width / 2) {
    			if (mouse[0] < boundries.left + boundries.width / 2) {
    				$$invalidate(10, alignX = "left");
    			} else {
    				$$invalidate(10, alignX = "right");
    			}
    		} else {
    			$$invalidate(10, alignX = "right");
    		}
    	}

    	const writable_props = [
    		"text",
    		"mode",
    		"offset",
    		"boundries",
    		"disabled",
    		"css",
    		"icon",
    		"contentWindow"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetTippy> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		$$invalidate(7, windowWidth = window_1$2.innerWidth);
    		$$invalidate(8, windowHeight = window_1$2.innerHeight);
    	}

    	const click_handler = e => dispatch("modechange", e);
    	const click_handler_1 = event => dispatch("clone", { event });
    	const click_handler_2 = event => dispatch("delete", { event });
    	const click_handler_3 = event => dispatch("showsource", { event });

    	function div4_elementresize_handler() {
    		tippyWidth = this.clientWidth;
    		tippyHeight = this.clientHeight;
    		$$invalidate(5, tippyWidth);
    		$$invalidate(6, tippyHeight);
    	}

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
    		if ("offset" in $$props) $$invalidate(14, offset = $$props.offset);
    		if ("boundries" in $$props) $$invalidate(15, boundries = $$props.boundries);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ("css" in $$props) $$invalidate(3, css = $$props.css);
    		if ("icon" in $$props) $$invalidate(4, icon = $$props.icon);
    		if ("contentWindow" in $$props) $$invalidate(16, contentWindow = $$props.contentWindow);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		text,
    		mode,
    		offset,
    		boundries,
    		disabled,
    		css,
    		icon,
    		contentWindow,
    		dispatch,
    		tippyWidth,
    		tippyHeight,
    		windowWidth,
    		windowHeight,
    		mouse,
    		alignX,
    		lastActiveWindow,
    		switchContext,
    		pointerMoved,
    		top,
    		bottom,
    		otherVars,
    		fatElement
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
    		if ("offset" in $$props) $$invalidate(14, offset = $$props.offset);
    		if ("boundries" in $$props) $$invalidate(15, boundries = $$props.boundries);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ("css" in $$props) $$invalidate(3, css = $$props.css);
    		if ("icon" in $$props) $$invalidate(4, icon = $$props.icon);
    		if ("contentWindow" in $$props) $$invalidate(16, contentWindow = $$props.contentWindow);
    		if ("tippyWidth" in $$props) $$invalidate(5, tippyWidth = $$props.tippyWidth);
    		if ("tippyHeight" in $$props) $$invalidate(6, tippyHeight = $$props.tippyHeight);
    		if ("windowWidth" in $$props) $$invalidate(7, windowWidth = $$props.windowWidth);
    		if ("windowHeight" in $$props) $$invalidate(8, windowHeight = $$props.windowHeight);
    		if ("mouse" in $$props) $$invalidate(17, mouse = $$props.mouse);
    		if ("alignX" in $$props) $$invalidate(10, alignX = $$props.alignX);
    		if ("lastActiveWindow" in $$props) lastActiveWindow = $$props.lastActiveWindow;
    		if ("top" in $$props) $$invalidate(9, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(18, bottom = $$props.bottom);
    		if ("otherVars" in $$props) $$invalidate(11, otherVars = $$props.otherVars);
    		if ("fatElement" in $$props) $$invalidate(12, fatElement = $$props.fatElement);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*contentWindow*/ 65536) {
    			switchContext(contentWindow || window);
    		}

    		if ($$self.$$.dirty & /*offset, boundries*/ 49152) {
    			$$invalidate(9, top = offset.top + boundries.top);
    		}

    		if ($$self.$$.dirty & /*offset, boundries*/ 49152) {
    			$$invalidate(18, bottom = offset.top + boundries.bottom);
    		}

    		if ($$self.$$.dirty & /*tippyWidth, tippyHeight, windowWidth, windowHeight, mouse*/ 131552) {
    			$$invalidate(11, otherVars = `
  --tippy-width: ${tippyWidth}px;
  --tippy-height: ${tippyHeight}px;
  --tippy-arrow-width: 1rem;
  --tippy-arrow-height: 0.5rem;
  --screen-width: ${windowWidth}px;
  --screen-height: ${windowHeight}px;
  --mouse-x: ${mouse[0]}px;
  --mouse-y: ${Math.min(windowHeight - 50, Math.floor(mouse[1] / 200) * 200)}px;
  `);
    		}

    		if ($$self.$$.dirty & /*top, bottom*/ 262656) {
    			$$invalidate(12, fatElement = top <= 50 && bottom >= window.innerHeight - 50);
    		}
    	};

    	return [
    		text,
    		mode,
    		disabled,
    		css,
    		icon,
    		tippyWidth,
    		tippyHeight,
    		windowWidth,
    		windowHeight,
    		top,
    		alignX,
    		otherVars,
    		fatElement,
    		dispatch,
    		offset,
    		boundries,
    		contentWindow,
    		mouse,
    		bottom,
    		onwindowresize,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		div4_elementresize_handler
    	];
    }

    class WidgetTippy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$c, create_fragment$d, safe_not_equal, {
    			text: 0,
    			mode: 1,
    			offset: 14,
    			boundries: 15,
    			disabled: 2,
    			css: 3,
    			icon: 4,
    			contentWindow: 16
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetTippy",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get text() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get offset() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set offset(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get boundries() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set boundries(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get css() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set css(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentWindow() {
    		throw new Error("<WidgetTippy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentWindow(value) {
    		throw new Error("<WidgetTippy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetFrame.svelte generated by Svelte v3.38.2 */

    const { window: window_1$1 } = globals;
    const file$9 = "src\\components\\WidgetFrame.svelte";

    // (77:0) {#if frameShown}
    function create_if_block_1$4(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;
    	let div4_style_value;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", "frame frame-top svelte-lgwpsc");
    			add_location(div0, file$9, 82, 4, 2559);
    			attr_dev(div1, "class", "frame frame-right svelte-lgwpsc");
    			add_location(div1, file$9, 83, 4, 2596);
    			attr_dev(div2, "class", "frame frame-bottom svelte-lgwpsc");
    			add_location(div2, file$9, 84, 4, 2635);
    			attr_dev(div3, "class", "frame frame-left svelte-lgwpsc");
    			add_location(div3, file$9, 85, 4, 2675);
    			attr_dev(div4, "class", "frame-wrapper iteria-ignore svelte-lgwpsc");
    			attr_dev(div4, "style", div4_style_value = "" + (/*offsetVars*/ ctx[5] + /*positionVars*/ ctx[6] + /*otherVars*/ ctx[7]));
    			toggle_class(div4, "fallback-color", /*isBgBlue*/ ctx[10]);
    			add_location(div4, file$9, 77, 2, 2415);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*offsetVars, positionVars, otherVars*/ 224 && div4_style_value !== (div4_style_value = "" + (/*offsetVars*/ ctx[5] + /*positionVars*/ ctx[6] + /*otherVars*/ ctx[7]))) {
    				attr_dev(div4, "style", div4_style_value);
    			}

    			if (dirty & /*isBgBlue*/ 1024) {
    				toggle_class(div4, "fallback-color", /*isBgBlue*/ ctx[10]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(77:0) {#if frameShown}",
    		ctx
    	});

    	return block;
    }

    // (90:0) {#if displayTippy && element}
    function create_if_block$6(ctx) {
    	let widgettippy;
    	let current;

    	widgettippy = new WidgetTippy({
    			props: {
    				icon: /*tippyIcon*/ ctx[13],
    				offset: /*offset*/ ctx[1],
    				boundries: /*boundries*/ ctx[2],
    				mode: /*mode*/ ctx[4],
    				text: /*text*/ ctx[0],
    				disabled: /*isDisabled*/ ctx[11],
    				contentWindow: /*iframe*/ ctx[8]
    				? /*iframe*/ ctx[8].contentWindow
    				: window,
    				css: "" + (/*offsetVars*/ ctx[5] + /*positionVars*/ ctx[6] + /*otherVars*/ ctx[7])
    			},
    			$$inline: true
    		});

    	widgettippy.$on("modechange", /*modechange_handler*/ ctx[18]);
    	widgettippy.$on("clone", /*clone_handler*/ ctx[19]);
    	widgettippy.$on("delete", /*delete_handler*/ ctx[20]);
    	widgettippy.$on("showsource", /*showsource_handler*/ ctx[21]);

    	const block = {
    		c: function create() {
    			create_component(widgettippy.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(widgettippy, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const widgettippy_changes = {};
    			if (dirty & /*tippyIcon*/ 8192) widgettippy_changes.icon = /*tippyIcon*/ ctx[13];
    			if (dirty & /*offset*/ 2) widgettippy_changes.offset = /*offset*/ ctx[1];
    			if (dirty & /*boundries*/ 4) widgettippy_changes.boundries = /*boundries*/ ctx[2];
    			if (dirty & /*mode*/ 16) widgettippy_changes.mode = /*mode*/ ctx[4];
    			if (dirty & /*text*/ 1) widgettippy_changes.text = /*text*/ ctx[0];
    			if (dirty & /*isDisabled*/ 2048) widgettippy_changes.disabled = /*isDisabled*/ ctx[11];

    			if (dirty & /*iframe*/ 256) widgettippy_changes.contentWindow = /*iframe*/ ctx[8]
    			? /*iframe*/ ctx[8].contentWindow
    			: window;

    			if (dirty & /*offsetVars, positionVars, otherVars*/ 224) widgettippy_changes.css = "" + (/*offsetVars*/ ctx[5] + /*positionVars*/ ctx[6] + /*otherVars*/ ctx[7]);
    			widgettippy.$set(widgettippy_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widgettippy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widgettippy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widgettippy, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(90:0) {#if displayTippy && element}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*frameShown*/ ctx[9] && create_if_block_1$4(ctx);
    	let if_block1 = /*displayTippy*/ ctx[12] && /*element*/ ctx[3] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1$1, "resize", /*update*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*frameShown*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*displayTippy*/ ctx[12] && /*element*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*displayTippy, element*/ 4104) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetFrame", slots, []);
    	const dispatch = createEventDispatcher();
    	let { color = "#4a87ee" } = $$props;
    	let { fallbackColor = "orange" } = $$props;
    	let { element } = $$props;
    	let { mode = "inspecting" } = $$props;
    	let { text = "tippy" } = $$props;
    	let { offset = { top: 0, left: 0 } } = $$props;
    	let { boundries = null } = $$props;
    	let offsetVars = "";
    	let positionVars = "";
    	let otherVars = "";
    	let iframe;
    	let removeScrollEventListeners = () => null;
    	let frameShown = true;
    	let isBgBlue = false;
    	let isDisabled = false;
    	let displayTippy = false;
    	let tippyIcon = "settings";

    	function update() {
    		if (!checkIgnore(element)) {
    			dispatch("hover", inspectCallback);
    			$$invalidate(2, boundries = boundries || new DOMRect());

    			$$invalidate(5, offsetVars = `
      --offset-top: ${offset.top}px;
      --offset-left: ${offset.left}px;
      `);

    			$$invalidate(6, positionVars = `
      --position-top: ${boundries.top}px;
      --position-right: ${boundries.right}px;
      --position-bottom: ${boundries.bottom}px;
      --position-left: ${boundries.left}px;
      --position-width: ${boundries.width}px;
      --position-height: ${boundries.height}px;
      `);

    			$$invalidate(7, otherVars = `
      --frame-width: 4px;
      --frame-half-width: calc(var(--frame-width) / 2);
      --frame-color: ${color};
      --frame-fallback-color: ${fallbackColor};
      `);
    		}
    	}

    	function inspectCallback({ display, tooltipText, disabled, icon = "settings" }) {
    		$$invalidate(13, tippyIcon = icon);
    		$$invalidate(0, text = tooltipText);
    		$$invalidate(11, isDisabled = !!disabled);
    		$$invalidate(12, displayTippy = !!display);
    		if (!display) return;
    		$$invalidate(10, isBgBlue = isBlue(element));
    		$$invalidate(9, frameShown = false);
    		$$invalidate(2, boundries = element.getBoundingClientRect());
    		$$invalidate(8, iframe = checkIframe(element));

    		if (iframe) {
    			const iframeBoundries = iframe.getBoundingClientRect();

    			$$invalidate(1, offset = {
    				top: iframeBoundries.top,
    				left: iframeBoundries.left
    			});
    		} else {
    			$$invalidate(1, offset = { top: 0, left: 0 });
    		}

    		removeScrollEventListeners();
    		removeScrollEventListeners = listenScrollEvent(iframe || element, update);

    		setTimeout(
    			() => {
    				$$invalidate(9, frameShown = true);
    			},
    			0
    		);
    	}

    	const writable_props = ["color", "fallbackColor", "element", "mode", "text", "offset", "boundries"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetFrame> was created with unknown prop '${key}'`);
    	});

    	const modechange_handler = () => dispatch("modechange", {
    		mode: mode === "inspecting" ? "editing" : "inspecting",
    		target: element
    	});

    	function clone_handler(event) {
    		bubble($$self, event);
    	}

    	function delete_handler(event) {
    		bubble($$self, event);
    	}

    	function showsource_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("color" in $$props) $$invalidate(16, color = $$props.color);
    		if ("fallbackColor" in $$props) $$invalidate(17, fallbackColor = $$props.fallbackColor);
    		if ("element" in $$props) $$invalidate(3, element = $$props.element);
    		if ("mode" in $$props) $$invalidate(4, mode = $$props.mode);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("offset" in $$props) $$invalidate(1, offset = $$props.offset);
    		if ("boundries" in $$props) $$invalidate(2, boundries = $$props.boundries);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		checkIframe,
    		checkIgnore,
    		isBlue,
    		listenScrollEvent,
    		WidgetTippy,
    		dispatch,
    		color,
    		fallbackColor,
    		element,
    		mode,
    		text,
    		offset,
    		boundries,
    		offsetVars,
    		positionVars,
    		otherVars,
    		iframe,
    		removeScrollEventListeners,
    		frameShown,
    		isBgBlue,
    		isDisabled,
    		displayTippy,
    		tippyIcon,
    		update,
    		inspectCallback
    	});

    	$$self.$inject_state = $$props => {
    		if ("color" in $$props) $$invalidate(16, color = $$props.color);
    		if ("fallbackColor" in $$props) $$invalidate(17, fallbackColor = $$props.fallbackColor);
    		if ("element" in $$props) $$invalidate(3, element = $$props.element);
    		if ("mode" in $$props) $$invalidate(4, mode = $$props.mode);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("offset" in $$props) $$invalidate(1, offset = $$props.offset);
    		if ("boundries" in $$props) $$invalidate(2, boundries = $$props.boundries);
    		if ("offsetVars" in $$props) $$invalidate(5, offsetVars = $$props.offsetVars);
    		if ("positionVars" in $$props) $$invalidate(6, positionVars = $$props.positionVars);
    		if ("otherVars" in $$props) $$invalidate(7, otherVars = $$props.otherVars);
    		if ("iframe" in $$props) $$invalidate(8, iframe = $$props.iframe);
    		if ("removeScrollEventListeners" in $$props) removeScrollEventListeners = $$props.removeScrollEventListeners;
    		if ("frameShown" in $$props) $$invalidate(9, frameShown = $$props.frameShown);
    		if ("isBgBlue" in $$props) $$invalidate(10, isBgBlue = $$props.isBgBlue);
    		if ("isDisabled" in $$props) $$invalidate(11, isDisabled = $$props.isDisabled);
    		if ("displayTippy" in $$props) $$invalidate(12, displayTippy = $$props.displayTippy);
    		if ("tippyIcon" in $$props) $$invalidate(13, tippyIcon = $$props.tippyIcon);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element*/ 8) {
    			if (element) update();
    		}
    	};

    	return [
    		text,
    		offset,
    		boundries,
    		element,
    		mode,
    		offsetVars,
    		positionVars,
    		otherVars,
    		iframe,
    		frameShown,
    		isBgBlue,
    		isDisabled,
    		displayTippy,
    		tippyIcon,
    		dispatch,
    		update,
    		color,
    		fallbackColor,
    		modechange_handler,
    		clone_handler,
    		delete_handler,
    		showsource_handler
    	];
    }

    class WidgetFrame extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$b, create_fragment$c, safe_not_equal, {
    			color: 16,
    			fallbackColor: 17,
    			element: 3,
    			mode: 4,
    			text: 0,
    			offset: 1,
    			boundries: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetFrame",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*element*/ ctx[3] === undefined && !("element" in props)) {
    			console.warn("<WidgetFrame> was created without expected prop 'element'");
    		}
    	}

    	get color() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fallbackColor() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fallbackColor(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get offset() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set offset(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get boundries() {
    		throw new Error("<WidgetFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set boundries(value) {
    		throw new Error("<WidgetFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const template = document.createElement("div");
    template.innerHTML = (

        //'<div class=winbox>' +

            '<div class=wb-header>' +
                '<div class=wb-icon>' +
                    '<span class=wb-min></span>' +
                    '<span class=wb-max></span>' +
                    '<span class=wb-full></span>' +
                    '<span class=wb-close></span>' +
                '</div>' +
                '<div class=wb-title> </div>' +
            '</div>' +

            '<div class=wb-body></div>' +

            '<div class=wb-n></div>' +
            '<div class=wb-s></div>' +
            '<div class=wb-w></div>' +
            '<div class=wb-e></div>' +
            '<div class=wb-nw></div>' +
            '<div class=wb-ne></div>' +
            '<div class=wb-se></div>' +
            '<div class=wb-sw></div>'

        //'</div>'
    );

    function template$1(){

        return template.cloneNode(true);
    }

    /**
     * @param {Window|Element} node
     * @param {string} event
     * @param {Function} fn
     * @param {AddEventListenerOptions|boolean=} opt
     */

    function addListener(node, event, fn, opt){

        node.addEventListener(event, fn, opt || (opt === false) ? opt : true);
    }

    /**
     * @param {Window|Element} node
     * @param {string} event
     * @param {Function} fn
     * @param {AddEventListenerOptions|boolean=} opt
     */

    function removeListener(node, event, fn, opt){

        node.removeEventListener(event, fn, opt || (opt === false) ? opt : true);
    }

    /**
     * @param event
     * @param {boolean=} prevent
     */

    function preventEvent(event, prevent){

        event.stopPropagation();
        /*prevent &&*/ event.cancelable && event.preventDefault();

        //event.stopImmediatePropagation();
        //event.returnValue = false;
    }

    function getByClass(root, name){

        return root.getElementsByClassName(name)[0];
    }

    function addClass(node, classname){

        node.classList.add(classname);
    }

    function removeClass(node, classname){

        node.classList.remove(classname);
    }

    function setStyle(node, style, value){

        value = "" + value;

        if(node["_s_" + style] !== value){

            node.style.setProperty(style, value);
            node["_s_" + style] = value;
        }
    }

    function setText(node, value){

        node.firstChild.nodeValue = value;
    }

    /**
     * WinBox.js
     * Copyright 2021 Nextapps GmbH
     * Author: Thomas Wilkerling
     * Licence: Apache-2.0
     * https://github.com/nextapps-de/winbox
     */
    //const doc = document.documentElement;
    const stack_min = [];
    let body;
    let id_counter = 0;
    let dblclick_timer = 0;
    let index;
    let is_fullscreen;
    let last_focus;
    let prefix_request;
    let prefix_exit;
    let root_w, root_h;

    /**
     * @param {string|Object=} params
     * @param {Object=} _title
     * @constructor
     * @this WinBox
     */

    function WinBox(params, _title){

        if(!(this instanceof WinBox)) {

            return new WinBox(params);
        }

        index || setup();

        this.dom = template$1();
        this.body = getByClass(this.dom, "wb-body");

        let id,
            root,
            title,
            mount,
            html,
            url,
            width,
            height,
            x,
            y,
            max,
            top,
            left,
            bottom,
            right,
            modal,
            onclose,
            onfocus,
            onblur,
            onmove,
            onresize,
            background,
            border,
            classname;

        if(params){

            if(_title){

                title = params;
                params = _title;
            }

            if(typeof params === "string"){

                title = params;
            }
            else {

                if((modal = params["modal"])){

                    x = y = "center";
                }

                id = params["id"];
                root = params["root"];
                title = title || params["title"];
                mount = params["mount"];
                html = params["html"];
                url = params["url"];
                width = params["width"];
                height = params["height"];
                x = params["x"] || x;
                y = params["y"] || y;
                max = params["max"];
                top = params["top"];
                left = params["left"];
                bottom = params["bottom"];
                right = params["right"];
                index = params["index"] || index;
                onclose = params["onclose"];
                onfocus = params["onfocus"];
                onblur = params["onblur"];
                onmove = params["onmove"];
                onresize = params["onresize"];
                background = params["background"];
                border = params["border"];
                classname = params["class"];

                if(background){

                    this.setBackground(background);
                }

                if(border){

                    setStyle(this.body, "margin", border + (isNaN(border) ? "" : "px"));
                }
            }
        }

        this.setTitle(title || "");

        let max_width = root_w;
        let max_height = root_h;

        top = top ? parse(top, max_height) : 0;
        bottom = bottom ? parse(bottom, max_height) : 0;
        left = left ? parse(left, max_width) : 0;
        right = right ? parse(right, max_width) : 0;

        max_width -= left + right;
        max_height -= top + bottom;

        width = width ? parse(width, max_width) : (max_width / 2) | 0;
        height = height ? parse(height, max_height) : (max_height / 2) | 0;

        x = x ? parse(x, max_width, width) : left;
        y = y ? parse(y, max_height, height) : top;

        index = index || 10;

        this.dom.id =
        this.id = id || ("winbox-" + (++id_counter));
        this.dom.className = "winbox" + (classname ? " " + (typeof classname === "string" ? classname : classname.join(" ")) : "") +
                                        (modal ? " modal" : "");
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;

        this.border = border;
        this.min = false;
        this.max = false;

        this.onclose = onclose;
        this.onfocus = onfocus;
        this.onblur = onblur;
        this.onmove = onmove;
        this.onresize = onresize;

        if(max){

            this.maximize();
        }
        else {

            this.move().resize();
        }

        this.focus();

        if(mount){

            this.mount(mount);
        }
        else if(html){

            this.body.innerHTML = html;
        }
        else if(url){

            this.setUrl(url);
        }

        register(this);
        (root || body).appendChild(this.dom);
    }

    WinBox["new"] = function(params){

        return new WinBox(params);
    };

    /**
     * @param {number|string} num
     * @param {number} base
     * @param {number=} center
     * @return number
     */

    function parse(num, base, center){

        if(typeof num === "string"){

            if(num === "center"){

                num = ((base - center) / 2) | 0;
            }
            else if(num === "right" || num === "bottom"){

                num = (base - center);
            }
            else {

                const value = parseFloat(num);
                const unit = (("" + value) !== num) && num.substring(("" + value).length);

                if(unit === "%"){

                    num = (base / 100 * value) | 0;
                }
                else {

                    num = value;
                }
            }
        }

        return num;
    }

    function setup(){

        body = document.body;

        body[prefix_request = "requestFullscreen"] ||
        body[prefix_request = "msRequestFullscreen"] ||
        body[prefix_request = "webkitRequestFullscreen"] ||
        body[prefix_request = "mozRequestFullscreen"] ||
        (prefix_request = "");

        prefix_exit = prefix_request && (

            prefix_request.replace("request", "exit")
                          .replace("mozRequest", "mozCancel")
                          .replace("Request", "Exit")
        );

        addListener(window, "resize", function(){

            init();
            update_min_stack();
        });

        init();
    }

    /**
     * @param {WinBox} self
     */

    function register(self){

        addWindowListener(self, "title");
        addWindowListener(self, "n");
        addWindowListener(self, "s");
        addWindowListener(self, "w");
        addWindowListener(self, "e");
        addWindowListener(self, "nw");
        addWindowListener(self, "ne");
        addWindowListener(self, "se");
        addWindowListener(self, "sw");

        addListener(getByClass(self.dom, "wb-min"), "click", function(event){

            preventEvent(event);
            self.minimize();
        });

        addListener(getByClass(self.dom, "wb-max"), "click", function(event){

            preventEvent(event);
            self.focus().maximize();
        });

        if(prefix_request){

            addListener(getByClass(self.dom, "wb-full"), "click", function(event){

                preventEvent(event);
                self.focus().fullscreen();
            });
        }
        else {

            self.addClass("no-full");
        }

        addListener(getByClass(self.dom, "wb-close"), "click", function(event){

            preventEvent(event);
            self.close() || (self = null);
        });

        addListener(self.dom, "click", function(event){

            // stop propagation would disable global listeners used inside window contents
            // use event bubbling for this listener to skip this handler by the other click listeners
            self.focus();

        }, false);
    }

    /**
     * @param {WinBox} self
     */

    function remove_min_stack(self){

        stack_min.splice(stack_min.indexOf(self), 1);
        update_min_stack();
        self.removeClass("min");
        self.min = false;
        self.dom.title = "";
    }

    function update_min_stack(){

        const len = stack_min.length;

        for(let i = 0, self, width; i < len; i++){

            self = stack_min[i];
            width = Math.min((root_w - self.left * 2) / len, 250);
            self.resize((width + 1) | 0, 35, true)
                .move((self.left + i * width) | 0, root_h - self.bottom - 35, true);
        }
    }

    /**
     * @param {WinBox} self
     * @param {string} dir
     */

    function addWindowListener(self, dir){

        const node = getByClass(self.dom, "wb-" + dir);
        let touch, x, y;

        addListener(node, "mousedown", mousedown);
        addListener(node, "touchstart", mousedown, { "passive": false });

        function mousedown(event){

            // prevent the full iteration through the fallback chain of a touch event (touch > mouse > click)
            preventEvent(event);

            if(self.min){

                self.minimize();
            }
            else {

                if(dir === "title"){

                    const now = Date.now();
                    const diff = now - dblclick_timer;

                    dblclick_timer = now;

                    if(diff < 250){

                        self.maximize();
                        return;
                    }
                }

                if(!self.max){

                    addClass(body, "wb-drag");

                    if((touch = event.touches) && (touch = touch[0])){

                        event = touch;

                        // TODO: fix when touch events bubbles up to the document body
                        //addListener(self.dom, "touchmove", preventEvent);
                        addListener(window, "touchmove", handler_mousemove);
                        addListener(window, "touchend", handler_mouseup);
                    }
                    else {

                        //addListener(this, "mouseleave", handler_mouseup);
                        addListener(window, "mousemove", handler_mousemove);
                        addListener(window, "mouseup", handler_mouseup);
                    }

                    x = event.pageX;
                    y = event.pageY;

                    // appearing scrollbars on the root element does not trigger "window.onresize",
                    // force refresh window size via init(), also force layout recalculation (layout trashing)
                    // it is probably very rare that the body overflow changes between window open and close

                    //init();
                    self.focus();
                }
            }
        }

        function handler_mousemove(event){

            preventEvent(event);

            if(touch){

                event = event.touches[0];
            }

            const pageX = event.pageX;
            const pageY = event.pageY;
            const offsetX = pageX - x;
            const offsetY = pageY - y;

            let resize_w, resize_h, move_x, move_y;

            if(dir === "title"){

                self.x += offsetX;
                self.y += offsetY;
                move_x = move_y = 1;
            }
            else {

                if(dir === "e" || dir === "se" || dir === "ne"){

                    self.width += offsetX;
                    resize_w = 1;
                }
                else if(dir === "w" || dir === "sw" || dir === "nw"){

                    self.x += offsetX;
                    self.width -= offsetX;
                    resize_w = 1;
                    move_x = 1;
                }

                if(dir === "s" || dir === "se" || dir === "sw"){

                    self.height += offsetY;
                    resize_h = 1;
                }
                else if(dir === "n" || dir === "ne" || dir === "nw"){

                    self.y += offsetY;
                    self.height -= offsetY;
                    resize_h = 1;
                    move_y = 1;
                }
            }

            if(resize_w || resize_h){

                if(resize_w){

                    self.width = Math.max(Math.min(self.width, root_w - self.x - self.right), 150);
                }

                if(resize_h){

                    self.height = Math.max(Math.min(self.height, root_h - self.y - self.bottom), 35);
                }

                self.resize();
            }

            if(move_x || move_y){

                if(move_x){

                    self.x = Math.max(Math.min(self.x, root_w - self.width - self.right), self.left);
                }

                if(move_y){

                    self.y = Math.max(Math.min(self.y, root_h - self.height - self.bottom), self.top);
                }

                self.move();
            }

            x = pageX;
            y = pageY;
        }

        function handler_mouseup(event){

            preventEvent(event);
            removeClass(body, "wb-drag");

            if(touch){

                //removeListener(self.dom, "touchmove", preventEvent);
                removeListener(window, "touchmove", handler_mousemove);
                removeListener(window, "touchend", handler_mouseup);
            }
            else {

                //removeListener(this, "mouseleave", handler_mouseup);
                removeListener(window, "mousemove", handler_mousemove);
                removeListener(window, "mouseup", handler_mouseup);
            }
        }
    }

    function init(){

        // TODO: the window height of iOS isn't determined correctly when the bottom toolbar disappears

        // the bounding rect provides more precise dimensions (float values)
        // //const rect = doc.getBoundingClientRect();
        // this.root_w = doc.clientWidth; //rect.width || (rect.right - rect.left);
        // this.root_h = doc.clientHeight; //rect.height || (rect.top - rect.bottom);

        // if(ios){
        //     this.root_h = window.innerHeight * (this.root_w / window.innerWidth);
        // }

        // root_w = doc.clientWidth;
        // root_h = doc.clientHeight;

        root_w = body.clientWidth;
        root_h = body.clientHeight;
    }

    /**
     * @param {Element=} src
     * @this WinBox
     */

    WinBox.prototype.mount = function(src){

        // handles mounting over:
        this.unmount();

        src._backstore || (src._backstore = src.parentNode);
        this.body.textContent = "";
        this.body.appendChild(src);

        return this;
    };

    /**
     * @param {Element=} dest
     * @this WinBox
     */

    WinBox.prototype.unmount = function(dest){

        const node = this.body.firstChild;

        if(node){

            const root = dest || node._backstore;

            root && root.appendChild(node);
            node._backstore = dest;
        }

        return this;
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.setTitle = function(title){

        setText(getByClass(this.dom, "wb-title"), this.title = title);
        return this;
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.setBackground = function(background){

        setStyle(this.dom, "background", background);
        return this;
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.setUrl = function(url){

        this.body.innerHTML = '<iframe src="' + url + '"></iframe>';
        return this;
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.focus = function(){

        if(last_focus !== this){

            setStyle(this.dom, "z-index", index++);
            this.addClass("focus");

            if(last_focus){

                last_focus.removeClass("focus");
                last_focus.onblur && last_focus.onblur();
            }

            last_focus = this;
            this.onfocus && this.onfocus();
        }

        return this;
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.hide = function(){

        return this.addClass("hide");
    };

    /**
     * @this WinBox
     */

    WinBox.prototype.show = function(){

        return this.removeClass("hide");
    };

    /**
     * @this WinBox
     * @param {boolean=} state
     */

    WinBox.prototype.minimize = function(state){

        if(is_fullscreen){

            cancel_fullscreen();
        }

        if(!state && this.min){

            remove_min_stack(this);
            this.resize().move().focus();
        }
        else if((state !== false) && !this.min){

            stack_min.push(this);
            update_min_stack();
            this.dom.title = this.title;
            this.addClass("min");
            this.min = true;
        }

        if(this.max){

            this.removeClass("max");
            this.max = false;
        }

        return this;
    };

    /**
     * @this WinBox
     * @param {boolean=} state
     */

    WinBox.prototype.maximize = function(state){

        if(typeof state === "undefined" || (state !== this.max)){

            if(this.min){

                remove_min_stack(this);
            }

            if((this.max = !this.max)){

                this.addClass("max").resize(

                    root_w - this.left - this.right,
                    root_h - this.top - this.bottom /* - 1 */,
                    true

                ).move(

                    this.left,
                    this.top,
                    true
                );
            }
            else {

                this.resize().move().removeClass("max");
            }
        }

        return this;
    };

    /**
     * @this WinBox
     * @param {boolean=} state
     */

    WinBox.prototype.fullscreen = function(state){

        if(typeof state === "undefined" || (state !== is_fullscreen)){

            if(this.min){

                this.resize().move();
                remove_min_stack(this);
            }

            // fullscreen could be changed by user manually!

            if(!is_fullscreen || !cancel_fullscreen()){

                // requestFullscreen is executed as async and returns promise.
                // in this case it is better to set the state to "this.full" after the requestFullscreen was fired,
                // because it may break when browser does not support fullscreen properly and bypass it silently.

                //this.dom[prefix_request]();
                this.body[prefix_request]();
                is_fullscreen = true;
            }

            // dispatch resize callback on fullscreen?

            // else{
            //
            //     this.onresize && this.onresize(this.width, this.height);
            // }
        }

        return this;
    };

    function has_fullscreen(){

        return (

            document["fullscreen"] ||
            document["fullscreenElement"] ||
            document["webkitFullscreenElement"] ||
            document["mozFullScreenElement"]
        );
    }

    /**
     * @param {WinBox} self
     * @return {boolean|void}
     */

    function cancel_fullscreen(self){

        is_fullscreen = false;

        if(has_fullscreen()){

            // exitFullscreen is executed as async and returns promise.
            // the important part is that the promise callback runs before the event "onresize" was fired!

            document[prefix_exit]();
            return true;
        }
    }

    /**
     * @param {boolean=} force
     * @this WinBox
     */

    WinBox.prototype.close = function(force) {

        if(this.onclose && this.onclose(force)){

            return true;
        }

        if(this.min){

            remove_min_stack(this);
        }

        this.unmount();
        this.dom.parentNode.removeChild(this.dom);

        if(last_focus === this){

            last_focus = null;
        }
    };

    /**
     * @param {number|string=} x
     * @param {number|string=} y
     * @param {boolean=} _skip_update
     * @this WinBox
     */

    WinBox.prototype.move = function(x, y, _skip_update){

        if(!x && (x !== 0)){

            x = this.x;
            y = this.y;
        }
        else if(!_skip_update){

            this.x = x ? x = parse(x, root_w - this.left - this.right, this.width) : 0;
            this.y = y ? y = parse(y, root_h - this.top - this.bottom, this.height) : 0;
        }

        setStyle(this.dom, "transform", "translate(" + x + "px," + y + "px)");

        this.onmove && this.onmove(x, y);
        return this;
    };

    /**
     * @param {number|string=} w
     * @param {number|string=} h
     * @param {boolean=} _skip_update
     * @this WinBox
     */

    WinBox.prototype.resize = function(w, h, _skip_update){

        if(!w && (w !== 0)){

            w = this.width;
            h = this.height;
        }
        else if(!_skip_update){

            this.width = w ? w = parse(w, root_w - this.left - this.right) : 0;
            this.height = h ? h = parse(h, root_h - this.top - this.bottom) : 0;
        }

        setStyle(this.dom, "width", w + "px");
        setStyle(this.dom, "height", h + "px");

        this.onresize && this.onresize(w, h);
        return this;
    };

    /**
     * @param {string} classname
     * @this WinBox
     */

    WinBox.prototype.addClass = function(classname){

        addClass(this.dom, classname);
        return this;
    };

    /**
     * @param {string} classname
     * @this WinBox
     */

    WinBox.prototype.removeClass = function(classname){

        removeClass(this.dom, classname);
        return this;
    };

    /*
    WinBox.prototype.use = function(plugin){

        plugin(this);
        return this;
    };
    */

    /* src\components\Winbox.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$2 } = globals;
    const file$8 = "src\\components\\Winbox.svelte";

    function create_fragment$b(ctx) {
    	let div;
    	let winbox_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "winbox-target");
    			attr_dev(div, "class", "svelte-e6t8gc");
    			add_location(div, file$8, 55, 0, 1850);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[10](div);

    			if (!mounted) {
    				dispose = action_destroyer(winbox_action = /*winbox*/ ctx[2].call(null, div, /*component*/ ctx[0]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (winbox_action && is_function(winbox_action.update) && dirty & /*component*/ 1) winbox_action.update.call(null, /*component*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[10](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Winbox", slots, []);
    	
    	let { component = undefined } = $$props;
    	let { props = {} } = $$props;
    	let { events = {} } = $$props;
    	let { title = "Fields" } = $$props;
    	let { x = "center" } = $$props;
    	let { y = "center" } = $$props;
    	let { width = 400 } = $$props;
    	let { height = 500 } = $$props;
    	let target;

    	function newComponent(Component, target) {
    		const instance = new Component({ target, props });
    		const eventNames = Object.keys(events);

    		eventNames.forEach(eventName => {
    			instance.$on(eventName, events[eventName]);
    		});
    	}

    	function winbox(target, Component) {
    		const _x = x === "left"
    		? 0
    		: x === "right" ? window.innerWidth - width : "center";

    		const _y = y === "top"
    		? 0
    		: y === "bottom" ? window.innerHeight - height : "center";

    		let box = new WinBox({
    				title,
    				x: _x,
    				y: _y,
    				width,
    				height,
    				root: target,
    				background: "var(--theme-color)"
    			});

    		const winboxBody = target.querySelector(`div.wb-body`);

    		if (Component && winboxBody) {
    			newComponent(Component, winboxBody);
    		}

    		return {
    			update(Component) {
    				if (box && box.close) box.close();

    				if (Component) {
    					box = new WinBox({
    							title,
    							x: box.x,
    							y: box.y,
    							width: box.width,
    							height: box.height,
    							root: target,
    							background: "var(--theme-color)"
    						});

    					const winboxBody = target.querySelector(`div.wb-body`);
    					if (winboxBody) newComponent(Component, winboxBody);
    				}
    			},
    			destroy() {
    				if (box && box.close) {
    					box.close();
    				}
    			}
    		};
    	}

    	const writable_props = ["component", "props", "events", "title", "x", "y", "width", "height"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Winbox> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			target = $$value;
    			$$invalidate(1, target);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("props" in $$props) $$invalidate(3, props = $$props.props);
    		if ("events" in $$props) $$invalidate(4, events = $$props.events);
    		if ("title" in $$props) $$invalidate(5, title = $$props.title);
    		if ("x" in $$props) $$invalidate(6, x = $$props.x);
    		if ("y" in $$props) $$invalidate(7, y = $$props.y);
    		if ("width" in $$props) $$invalidate(8, width = $$props.width);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Winbox: WinBox,
    		component,
    		props,
    		events,
    		title,
    		x,
    		y,
    		width,
    		height,
    		target,
    		newComponent,
    		winbox
    	});

    	$$self.$inject_state = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("props" in $$props) $$invalidate(3, props = $$props.props);
    		if ("events" in $$props) $$invalidate(4, events = $$props.events);
    		if ("title" in $$props) $$invalidate(5, title = $$props.title);
    		if ("x" in $$props) $$invalidate(6, x = $$props.x);
    		if ("y" in $$props) $$invalidate(7, y = $$props.y);
    		if ("width" in $$props) $$invalidate(8, width = $$props.width);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("target" in $$props) $$invalidate(1, target = $$props.target);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		component,
    		target,
    		winbox,
    		props,
    		events,
    		title,
    		x,
    		y,
    		width,
    		height,
    		div_binding
    	];
    }

    class Winbox_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$a, create_fragment$b, safe_not_equal, {
    			component: 0,
    			props: 3,
    			events: 4,
    			title: 5,
    			x: 6,
    			y: 7,
    			width: 8,
    			height: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Winbox_1",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get component() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get props() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set props(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get events() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set events(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Winbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Winbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    /**
     * (c) jSuites Javascript Web Components
     *
     * Website: https://jsuites.net
     * Description: Create amazing web based applications.
     *
     * MIT License
     *
     */

    var jsuites = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    }(commonjsGlobal, (function () {

    var jSuites = function(options) {
        var obj = {};
        var version = '4.6.7';

        var find = function(DOMElement, component) {
            if (DOMElement[component.type] && DOMElement[component.type] == component) {
                return true;
            }
            if (DOMElement.parentNode) {
                return find(DOMElement.parentNode, component);
            }
            return false;
        };

        var isOpened = function(e) {
            if (jSuites.current.length > 0) {
                for (var i = 0; i < jSuites.current.length; i++) {
                    if (jSuites.current[i] && ! find(e.target, jSuites.current[i])) {
                        jSuites.current[i].close();
                    }
                }
            }
        };

        obj.init = function() {
            document.addEventListener("click", isOpened);

            obj.version = version;
        };

        obj.tracking = function(component, state) {
            if (state == true) {
                jSuites.current = jSuites.current.filter(function(v) {
                    return v !== null;
                });

                // Start after all events
                setTimeout(function() {
                    jSuites.current.push(component);
                }, 0);

            } else {
                var index = jSuites.current.indexOf(component);
                if (index >= 0) {
                    jSuites.current[index] = null;
                }
            }
        };

        obj.path = function(str) {
            str = str.split('.');
            if (str.length) {
                var o = this;
                var t = null;
                while (t = str.shift()) {
                    if (o.hasOwnProperty(t)) {
                        o = o[t];
                    } else {
                        return undefined;
                    }
                }
                return o;
            }
            return false;
        };

        // Array of opened components
        obj.current = [];

        return obj;
    }();

    /**
     * Global jsuites event
     */
    if (typeof(document) !== "undefined") {
        jSuites.init();
    }

    jSuites.ajax = (function(options, complete) {
        if (Array.isArray(options)) {
            // Create multiple request controller 
            var multiple = {
                instance: [],
                complete: complete,
            };

            if (options.length > 0) {
                for (var i = 0; i < options.length; i++) {
                    options[i].multiple = multiple;
                    multiple.instance.push(jSuites.ajax(options[i]));
                }
            }

            return multiple;
        }

        if (! options.data) {
            options.data = {};
        }

        if (options.type) {
            options.method = options.type;
        }

        // Default method
        if (! options.method) {
            options.method = 'GET';
        }

        // Default type
        if (! options.dataType) {
            options.dataType = 'json';
        }

        if (options.data) {
            // Parse object to variables format
            var parseData = function(value, key) {
                var vars = [];
                var keys = Object.keys(value);
                if (keys.length) {
                    for (var i = 0; i < keys.length; i++) {
                        if (key) {
                            var k = key + '[' + keys[i] + ']';
                        } else {
                            var k = keys[i];
                        }

                        if (typeof(value[keys[i]]) == 'object') {
                            var r = parseData(value[keys[i]], k);
                            var o = Object.keys(r);
                            for (var j = 0; j < o.length; j++) {
                                vars[o[j]] = r[o[j]];
                            }
                        } else {
                            vars[k] = value[keys[i]];
                        }
                    }
                }

                return vars;
            };

            var data = [];
            var d = parseData(options.data);
            var k = Object.keys(d);
            for (var i = 0; i < k.length; i++) {
                data.push(k[i] + '=' + encodeURIComponent(d[k[i]]));
            }

            if (options.method == 'GET' && data.length > 0) {
                if (options.url.indexOf('?') < 0) {
                    options.url += '?';
                }
                options.url += data.join('&');
            }
        }

        var httpRequest = new XMLHttpRequest();
        httpRequest.open(options.method, options.url, true);
        httpRequest.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

        if (options.method == 'POST') {
            httpRequest.setRequestHeader('Accept', 'application/json');
            httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        } else {
            if (options.dataType == 'json') {
                httpRequest.setRequestHeader('Content-Type', 'text/json');
            } else if (options.dataType == 'blob') {
                httpRequest.responseType = "blob";
            } else if (options.dataType == 'html') {
                httpRequest.setRequestHeader('Content-Type', 'text/html');
            }
        }

        // No cache
        if (options.cache != true) {
            httpRequest.setRequestHeader('pragma', 'no-cache');
            httpRequest.setRequestHeader('cache-control', 'no-cache');
        }

        // Authentication
        if (options.withCredentials == true) {
            httpRequest.withCredentials = true;
        }

        // Before send
        if (typeof(options.beforeSend) == 'function') {
            options.beforeSend(httpRequest);
        }

        httpRequest.onload = function() {
            if (httpRequest.status === 200) {
                if (options.dataType == 'json') {
                    try {
                        var result = JSON.parse(httpRequest.responseText);

                        if (options.success && typeof(options.success) == 'function') {
                            options.success(result);
                        }
                    } catch(err) {
                        if (options.error && typeof(options.error) == 'function') {
                            options.error(err, result);
                        }
                    }
                } else {
                    if (options.dataType == 'blob') {
                        var result = httpRequest.response;
                    } else {
                        var result = httpRequest.responseText;
                    }

                    if (options.success && typeof(options.success) == 'function') {
                        options.success(result);
                    }
                }
            } else {
                if (options.error && typeof(options.error) == 'function') {
                    options.error(httpRequest.responseText, httpRequest.status);
                }
            }

            // Global queue
            if (jSuites.ajax.queue && jSuites.ajax.queue.length > 0) {
                jSuites.ajax.send(jSuites.ajax.queue.shift());
            }

            // Global complete method
            if (jSuites.ajax.requests && jSuites.ajax.requests.length) {
                // Get index of this request in the container
                var index = jSuites.ajax.requests.indexOf(httpRequest);
                // Remove from the ajax requests container
                jSuites.ajax.requests.splice(index, 1);
                // Last one?
                if (! jSuites.ajax.requests.length) {
                    // Object event
                    if (options.complete && typeof(options.complete) == 'function') {
                        options.complete(result);
                    }
                    // Global event
                    if (typeof(jSuites.ajax.oncomplete[options.group]) == 'function') {
                        jSuites.ajax.oncomplete[options.group]();
                        jSuites.ajax.oncomplete[options.group] = null;
                    }
                }
                // Controllers
                if (options.multiple && options.multiple.instance) {
                    // Get index of this request in the container
                    var index = options.multiple.instance.indexOf(httpRequest);
                    // Remove from the ajax requests container
                    options.multiple.instance.splice(index, 1);
                    // If this is the last one call method complete
                    if (! options.multiple.instance.length) {
                        if (options.multiple.complete && typeof(options.multiple.complete) == 'function') {
                            options.multiple.complete(result);
                        }
                    }
                }
            }
        };

        // Keep the options
        httpRequest.options = options;
        // Data
        httpRequest.data = data;

        // Queue
        if (options.queue == true && jSuites.ajax.requests.length > 0) {
            jSuites.ajax.queue.push(httpRequest);
        } else {
            jSuites.ajax.send(httpRequest);
        }

        return httpRequest;
    });

    jSuites.ajax.send = function(httpRequest) {
        if (httpRequest.data) {
            httpRequest.send(httpRequest.data.join('&'));
        } else {
            httpRequest.send();
        }

        jSuites.ajax.requests.push(httpRequest);
    };

    jSuites.ajax.exists = function(url, __callback) {
        var http = new XMLHttpRequest();
        http.open('HEAD', url, false);
        http.send();
        if (http.status) {
            __callback(http.status);
        }
    };

    jSuites.ajax.pending = function(group) {
        var n = 0;
        var o = jSuites.ajax.requests;
        if (o && o.length) {
            for (var i = 0; i < o.length; i++) {
                if (! group || group == o[i].options.group) {
                    n++;
                }
            }
        }
        return n;
    };

    jSuites.ajax.oncomplete = {};
    jSuites.ajax.requests = [];
    jSuites.ajax.queue = [];

    jSuites.alert = function(message) {
        if (jSuites.getWindowWidth() < 800 && jSuites.dialog) {
            jSuites.dialog.open({
                title:'Alert',
                message:message,
            });
        } else {
            alert(message);
        }
    };

    jSuites.animation = {};

    jSuites.animation.slideLeft = function(element, direction, done) {
        if (direction == true) {
            element.classList.add('slide-left-in');
            setTimeout(function() {
                element.classList.remove('slide-left-in');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        } else {
            element.classList.add('slide-left-out');
            setTimeout(function() {
                element.classList.remove('slide-left-out');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        }
    };

    jSuites.animation.slideRight = function(element, direction, done) {
        if (direction == true) {
            element.classList.add('slide-right-in');
            setTimeout(function() {
                element.classList.remove('slide-right-in');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        } else {
            element.classList.add('slide-right-out');
            setTimeout(function() {
                element.classList.remove('slide-right-out');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        }
    };

    jSuites.animation.slideTop = function(element, direction, done) {
        if (direction == true) {
            element.classList.add('slide-top-in');
            setTimeout(function() {
                element.classList.remove('slide-top-in');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        } else {
            element.classList.add('slide-top-out');
            setTimeout(function() {
                element.classList.remove('slide-top-out');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        }
    };

    jSuites.animation.slideBottom = function(element, direction, done) {
        if (direction == true) {
            element.classList.add('slide-bottom-in');
            setTimeout(function() {
                element.classList.remove('slide-bottom-in');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 400);
        } else {
            element.classList.add('slide-bottom-out');
            setTimeout(function() {
                element.classList.remove('slide-bottom-out');
                if (typeof(done) == 'function') {
                    done();
                }
            }, 100);
        }
    };

    jSuites.animation.fadeIn = function(element, done) {
        element.style.display = '';
        element.classList.add('fade-in');
        setTimeout(function() {
            element.classList.remove('fade-in');
            if (typeof(done) == 'function') {
                done();
            }
        }, 2000);
    };

    jSuites.animation.fadeOut = function(element, done) {
        element.classList.add('fade-out');
        setTimeout(function() {
            element.style.display = 'none';
            element.classList.remove('fade-out');
            if (typeof(done) == 'function') {
                done();
            }
        }, 1000);
    };

    jSuites.calendar = (function(el, options) {
        // Already created, update options
        if (el.calendar) {
            return el.calendar.setOptions(options, true);
        }

        // New instance
        var obj = { type:'calendar' };
        obj.options = {};

        // Date
        obj.date = null;

        /**
         * Update options
         */
        obj.setOptions = function(options, reset) {
            // Default configuration
            var defaults = {
                // Render type: [ default | year-month-picker ]
                type: 'default',
                // Restrictions
                validRange: null,
                // Starting weekday - 0 for sunday, 6 for saturday
                startingDay: null, 
                // Date format
                format: 'DD/MM/YYYY',
                // Allow keyboard date entry
                readonly: true,
                // Today is default
                today: false,
                // Show timepicker
                time: false,
                // Show the reset button
                resetButton: true,
                // Placeholder
                placeholder: '',
                // Translations can be done here
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                monthsFull: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                weekdays: ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                weekdays_short: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                textDone: 'Done',
                textReset: 'Reset',
                textUpdate: 'Update',
                // Value
                value: null,
                // Fullscreen (this is automatic set for screensize < 800)
                fullscreen: false,
                // Create the calendar closed as default
                opened: false,
                // Events
                onopen: null,
                onclose: null,
                onchange: null,
                onupdate: null,
                // Internal mode controller
                mode: null,
                position: null,
            };

            // Loop through our object
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Reset button
            if (obj.options.resetButton == false) {
                calendarReset.style.display = 'none';
            } else {
                calendarReset.style.display = '';
            }

            // Readonly
            if (obj.options.readonly) {
                el.setAttribute('readonly', 'readonly');
            } else {
                el.removeAttribute('readonly');
            }

            // Placeholder
            if (obj.options.placeholder) {
                el.setAttribute('placeholder', obj.options.placeholder);
            } else {
                el.removeAttribute('placeholder');
            }

            // Texts
            calendarReset.innerHTML = obj.options.textReset;
            calendarConfirm.innerHTML = obj.options.textDone;
            calendarControlsUpdateButton.innerHTML = obj.options.textUpdate;

            // Define mask
            el.setAttribute('data-mask', obj.options.format.toLowerCase());

            // Value
            if (! obj.options.value && obj.options.today) {
                var value = jSuites.calendar.now();
            } else {
                var value = obj.options.value;
            }

            // Set internal date
            if (value) {
                // Force the update
                obj.options.value = null;
                // New value
                obj.setValue(value);
            }

            return obj;
        };

        /**
         * Open the calendar
         */
        obj.open = function (value) {
            if (! calendar.classList.contains('jcalendar-focus')) {
                if (! calendar.classList.contains('jcalendar-inline')) {
                    // Current
                    jSuites.calendar.current = obj;
                    // Start tracking
                    jSuites.tracking(obj, true);
                    // Create the days
                    obj.getDays();
                    // Render months
                    if (obj.options.type == 'year-month-picker') {
                        obj.getMonths();
                    }
                    // Get time
                    if (obj.options.time) {
                        calendarSelectHour.value = obj.date[3];
                        calendarSelectMin.value = obj.date[4];
                    }

                    // Show calendar
                    calendar.classList.add('jcalendar-focus');

                    // Get the position of the corner helper
                    if (jSuites.getWindowWidth() < 800 || obj.options.fullscreen) {
                        calendar.classList.add('jcalendar-fullsize');
                        // Animation
                        jSuites.animation.slideBottom(calendarContent, 1);
                    } else {
                        calendar.classList.remove('jcalendar-fullsize');

                        var rect = el.getBoundingClientRect();
                        var rectContent = calendarContent.getBoundingClientRect();

                        if (obj.options.position) {
                            calendarContainer.style.position = 'fixed';
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                calendarContainer.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                            } else {
                                calendarContainer.style.top = (rect.top + rect.height + 2) + 'px';
                            }
                            calendarContainer.style.left = rect.left + 'px';
                        } else {
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                var d = -1 * (rect.height + rectContent.height + 2);
                                if (d + rect.top < 0) {
                                    d = -1 * (rect.top + rect.height);
                                }
                                calendarContainer.style.top = d + 'px';
                            } else {
                                calendarContainer.style.top = 2 + 'px'; 
                            }

                            if (window.innerWidth < rect.left + rectContent.width) {
                                var d = window.innerWidth - (rect.left + rectContent.width + 20);
                                calendarContainer.style.left = d + 'px';
                            } else {
                                calendarContainer.style.left = '0px'; 
                            }
                        }
                    }

                    // Events
                    if (typeof(obj.options.onopen) == 'function') {
                        obj.options.onopen(el);
                    }
                }
            }
        };

        obj.close = function (ignoreEvents, update) {
            if (calendar.classList.contains('jcalendar-focus')) {
                if (update !== false) {
                    var element = calendar.querySelector('.jcalendar-selected');

                    if (typeof(update) == 'string') {
                        var value = update;
                    } else if (! element || element.classList.contains('jcalendar-disabled')) {
                        var value = obj.options.value;
                    } else {
                        var value = obj.getValue();
                    }

                    obj.setValue(value);
                }

                // Events
                if (! ignoreEvents && typeof(obj.options.onclose) == 'function') {
                    obj.options.onclose(el);
                }
                // Hide
                calendar.classList.remove('jcalendar-focus');
                // Stop tracking
                jSuites.tracking(obj, false);
                // Current
                jSuites.calendar.current = null;
            }

            return obj.options.value;
        };

        obj.prev = function() {
            // Check if the visualization is the days picker or years picker
            if (obj.options.mode == 'years') {
                obj.date[0] = obj.date[0] - 12;

                // Update picker table of days
                obj.getYears();
            } else if (obj.options.mode == 'months') {
                obj.date[0] = parseInt(obj.date[0]) - 1;
                // Update picker table of months
                obj.getMonths();
            } else {
                // Go to the previous month
                if (obj.date[1] < 2) {
                    obj.date[0] = obj.date[0] - 1;
                    obj.date[1] = 12;
                } else {
                    obj.date[1] = obj.date[1] - 1;
                }

                // Update picker table of days
                obj.getDays();
            }
        };

        obj.next = function() {
            // Check if the visualization is the days picker or years picker
            if (obj.options.mode == 'years') {
                obj.date[0] = parseInt(obj.date[0]) + 12;

                // Update picker table of days
                obj.getYears();
            } else if (obj.options.mode == 'months') {
                obj.date[0] = parseInt(obj.date[0]) + 1;
                // Update picker table of months
                obj.getMonths();
            } else {
                // Go to the previous month
                if (obj.date[1] > 11) {
                    obj.date[0] = parseInt(obj.date[0]) + 1;
                    obj.date[1] = 1;
                } else {
                    obj.date[1] = parseInt(obj.date[1]) + 1;
                }

                // Update picker table of days
                obj.getDays();
            }
        };

        /**
         * Set today
         */
        obj.setToday = function() {
            // Today
            var value = new Date().toISOString().substr(0, 10);
            // Change value
            obj.setValue(value);
            // Value
            return value;
        };

        obj.setValue = function(val) {
            if (! val) {
                val = '' + val;
            }
            // Values
            var newValue = val;
            var oldValue = obj.options.value;

            if (oldValue != newValue) {
                // Set label
                if (! newValue) {
                    obj.date = null;
                    var val = '';
                } else {
                    obj.setLabel(newValue, obj.options);
                    var date = newValue.split(' ');
                    if (! date[1]) {
                        date[1] = '00:00:00';
                    }
                    var time = date[1].split(':');
                    var date = date[0].split('-');
                    var y = parseInt(date[0]);
                    var m = parseInt(date[1]);
                    var d = parseInt(date[2]);
                    var h = parseInt(time[0]);
                    var i = parseInt(time[1]);
                    obj.date = [ y, m, d, h, i, 0 ];
                    var val = obj.setLabel(newValue, obj.options);
                }

                // New value
                obj.options.value = newValue;

                if (typeof(obj.options.onchange) ==  'function') {
                    obj.options.onchange(el, newValue, oldValue);
                }

                // Lemonade JS
                if (el.value != val) {
                    el.value = val;
                    if (typeof(el.onchange) == 'function') {
                        el.onchange({
                            type: 'change',
                            target: el,
                            value: el.value
                        });
                    }
                }
            }

            obj.getDays();
        };

        obj.getValue = function() {
            if (obj.date) {
                if (obj.options.time) {
                    return jSuites.two(obj.date[0]) + '-' + jSuites.two(obj.date[1]) + '-' + jSuites.two(obj.date[2]) + ' ' + jSuites.two(obj.date[3]) + ':' + jSuites.two(obj.date[4]) + ':' + jSuites.two(0);
                } else {
                    return jSuites.two(obj.date[0]) + '-' + jSuites.two(obj.date[1]) + '-' + jSuites.two(obj.date[2]) + ' ' + jSuites.two(0) + ':' + jSuites.two(0) + ':' + jSuites.two(0);
                }
            } else {
                return "";
            }
        };

        /**
         *  Calendar
         */
        obj.update = function(element, v) {
            if (element.classList.contains('jcalendar-disabled')) ; else {
                var elements = calendar.querySelector('.jcalendar-selected');
                if (elements) {
                    elements.classList.remove('jcalendar-selected');
                }
                element.classList.add('jcalendar-selected');

                if (element.classList.contains('jcalendar-set-month')) {
                    obj.date[1] = v;
                } else {
                    obj.date[2] = element.innerText;
                }

                if (! obj.options.time) {
                    obj.close();
                } else {
                    obj.date[3] = calendarSelectHour.value;
                    obj.date[4] = calendarSelectMin.value;
                }
            }

            // Update
            updateActions();
        };

        /**
         * Set to blank
         */
        obj.reset = function() {
            // Close calendar
            obj.setValue('');
            obj.date = null;
            obj.close(false, false);
        };

        /**
         * Get calendar days
         */
        obj.getDays = function() {
            // Mode
            obj.options.mode = 'days';

            // Setting current values in case of NULLs
            var date = new Date();

            // Current selection
            var year = obj.date && jSuites.isNumeric(obj.date[0]) ? obj.date[0] : parseInt(date.getFullYear());
            var month = obj.date && jSuites.isNumeric(obj.date[1]) ? obj.date[1] : parseInt(date.getMonth()) + 1;
            var day = obj.date && jSuites.isNumeric(obj.date[2]) ? obj.date[2] : parseInt(date.getDate());
            var hour = obj.date && jSuites.isNumeric(obj.date[3]) ? obj.date[3] : parseInt(date.getHours());
            var min = obj.date && jSuites.isNumeric(obj.date[4]) ? obj.date[4] : parseInt(date.getMinutes());

            // Selection container
            obj.date = [ year, month, day, hour, min, 0 ];

            // Update title
            calendarLabelYear.innerHTML = year;
            calendarLabelMonth.innerHTML = obj.options.months[month - 1];

            // Current month and Year
            var isCurrentMonthAndYear = (date.getMonth() == month - 1) && (date.getFullYear() == year) ? true : false;
            var currentDay = date.getDate();

            // Number of days in the month
            var date = new Date(year, month, 0, 0, 0);
            var numberOfDays = date.getDate();

            // First day
            var date = new Date(year, month-1, 0, 0, 0);
            var firstDay = date.getDay() + 1;

            // Index value
            var index = obj.options.startingDay || 0;

            // First of day relative to the starting calendar weekday
            firstDay = firstDay - index;

            // Reset table
            calendarBody.innerHTML = '';

            // Weekdays Row
            var row = document.createElement('tr');
            row.setAttribute('align', 'center');
            calendarBody.appendChild(row);

            // Create weekdays row
            for (var i = 0; i < 7; i++) {
                var cell = document.createElement('td');
                cell.classList.add('jcalendar-weekday');
                cell.innerHTML = obj.options.weekdays_short[index];
                row.appendChild(cell);
                // Next week day
                index++;
                // Restart index
                if (index > 6) {
                    index = 0;
                }
            }

            // Index of days
            var index = 0;
            var d = 0;
     
            // Calendar table
            for (var j = 0; j < 6; j++) {
                // Reset cells container
                var row = document.createElement('tr');
                row.setAttribute('align', 'center');
                // Data control
                var emptyRow = true;
                // Create cells
                for (var i = 0; i < 7; i++) {
                    // Create cell
                    var cell = document.createElement('td');
                    cell.classList.add('jcalendar-set-day');

                    if (index >= firstDay && index < (firstDay + numberOfDays)) {
                        // Day cell
                        d++;
                        cell.innerHTML = d;

                        // Selected
                        if (d == day) {
                            cell.classList.add('jcalendar-selected');
                        }

                        // Current selection day is today
                        if (isCurrentMonthAndYear && currentDay == d) {
                            cell.style.fontWeight = 'bold';
                        }

                        // Current selection day
                        var current = jSuites.calendar.now(new Date(year, month-1, d), true);

                        // Available ranges
                        if (obj.options.validRange) {
                            if (! obj.options.validRange[0] || current >= obj.options.validRange[0]) {
                                var test1 = true;
                            } else {
                                var test1 = false;
                            }

                            if (! obj.options.validRange[1] || current <= obj.options.validRange[1]) {
                                var test2 = true;
                            } else {
                                var test2 = false;
                            }

                            if (! (test1 && test2)) {
                                cell.classList.add('jcalendar-disabled');
                            }
                        }

                        // Control
                        emptyRow = false;
                    }
                    // Day cell
                    row.appendChild(cell);
                    // Index
                    index++;
                }

                // Add cell to the calendar body
                if (emptyRow == false) {
                    calendarBody.appendChild(row);
                }
            }

            // Show time controls
            if (obj.options.time) {
                calendarControlsTime.style.display = '';
            } else {
                calendarControlsTime.style.display = 'none';
            }

            // Update
            updateActions();
        };

        obj.getMonths = function() {
            // Mode
            obj.options.mode = 'months';

            // Loading month labels
            var months = obj.options.months;

            // Value
            obj.options.value; 

            // Current date
            var date = new Date();
            var currentYear = parseInt(date.getFullYear());
            var currentMonth = parseInt(date.getMonth()) + 1;
            var selectedYear = obj.date && jSuites.isNumeric(obj.date[0]) ? obj.date[0] : currentYear;
            var selectedMonth = obj.date && jSuites.isNumeric(obj.date[1]) ? obj.date[1] : currentMonth;

            // Update title
            calendarLabelYear.innerHTML = obj.date[0];
            calendarLabelMonth.innerHTML = months[selectedMonth-1];

            // Table
            var table = document.createElement('table');
            table.setAttribute('width', '100%');

            // Row
            var row = null;

            // Calendar table
            for (var i = 0; i < 12; i++) {
                if (! (i % 4)) {
                    // Reset cells container
                    var row = document.createElement('tr');
                    row.setAttribute('align', 'center');
                    table.appendChild(row);
                }

                // Create cell
                var cell = document.createElement('td');
                cell.classList.add('jcalendar-set-month');
                cell.setAttribute('data-value', i+1);
                cell.innerText = months[i];

                if (obj.options.validRange) {
                    var current = selectedYear + '-' + jSuites.two(i+1);
                    if (! obj.options.validRange[0] || current >= obj.options.validRange[0].substr(0,7)) {
                        var test1 = true;
                    } else {
                        var test1 = false;
                    }

                    if (! obj.options.validRange[1] || current <= obj.options.validRange[1].substr(0,7)) {
                        var test2 = true;
                    } else {
                        var test2 = false;
                    }

                    if (! (test1 && test2)) {
                        cell.classList.add('jcalendar-disabled');
                    }
                }

                if (i+1 == selectedMonth) {
                    cell.classList.add('jcalendar-selected');
                }

                if (currentYear == selectedYear && i+1 == currentMonth) {
                    cell.style.fontWeight = 'bold';
                }

                row.appendChild(cell);
            }

            calendarBody.innerHTML = '<tr><td colspan="7"></td></tr>';
            calendarBody.children[0].children[0].appendChild(table);

            // Update
            updateActions();
        };

        obj.getYears = function() { 
            // Mode
            obj.options.mode = 'years';

            // Current date
            var date = new Date();
            var currentYear = date.getFullYear();
            var selectedYear = obj.date && jSuites.isNumeric(obj.date[0]) ? obj.date[0] : parseInt(date.getFullYear());

            // Array of years
            var y = [];
            for (var i = 0; i < 25; i++) {
                y[i] = parseInt(obj.date[0]) + (i - 12);
            }

            // Assembling the year tables
            var table = document.createElement('table');
            table.setAttribute('width', '100%');

            for (var i = 0; i < 25; i++) {
                if (! (i % 5)) {
                    // Reset cells container
                    var row = document.createElement('tr');
                    row.setAttribute('align', 'center');
                    table.appendChild(row);
                }

                // Create cell
                var cell = document.createElement('td');
                cell.classList.add('jcalendar-set-year');
                cell.innerText = y[i];

                if (selectedYear == y[i]) {
                    cell.classList.add('jcalendar-selected');
                }

                if (currentYear == y[i]) {
                    cell.style.fontWeight = 'bold';
                }

                row.appendChild(cell);
            }

            calendarBody.innerHTML = '<tr><td colspan="7"></td></tr>';
            calendarBody.firstChild.firstChild.appendChild(table);

            // Update
            updateActions();
        };

        obj.setLabel = function(value, mixed) {
            return jSuites.calendar.getDateString(value, mixed);
        };

        obj.fromFormatted = function (value, format) {
            return jSuites.calendar.extractDateFromString(value, format);
        };

        var mouseUpControls = function(e) {
            var element = jSuites.findElement(e.target, 'jcalendar-container');
            if (element) {
                var action = e.target.className;

                // Object id
                if (action == 'jcalendar-prev') {
                    obj.prev();
                } else if (action == 'jcalendar-next') {
                    obj.next();
                } else if (action == 'jcalendar-month') {
                    obj.getMonths();
                } else if (action == 'jcalendar-year') {
                    obj.getYears();
                } else if (action == 'jcalendar-set-year') {
                    obj.date[0] = e.target.innerText;
                    if (obj.options.type == 'year-month-picker') {
                        obj.getMonths();
                    } else {
                        obj.getDays();
                    }
                } else if (e.target.classList.contains('jcalendar-set-month')) {
                    var month = parseInt(e.target.getAttribute('data-value'));
                    if (obj.options.type == 'year-month-picker') {
                        obj.update(e.target, month);
                    } else {
                        obj.date[1] = month;
                        obj.getDays();
                    }
                } else if (action == 'jcalendar-confirm' || action == 'jcalendar-update' || action == 'jcalendar-close') {
                    obj.close();
                } else if (action == 'jcalendar-backdrop') {
                    obj.close(false, false);
                } else if (action == 'jcalendar-reset') {
                    obj.reset();
                } else if (e.target.classList.contains('jcalendar-set-day') && e.target.innerText) {
                    obj.update(e.target);
                }
            } else {
                obj.close();
            }
        };

        var keyUpControls = function(e) {
            if (e.target.value && e.target.value.length > 3) {
                var test = jSuites.calendar.extractDateFromString(e.target.value, obj.options.format);
                if (test) {
                    if (e.target.getAttribute('data-completed') == 'true') {
                        obj.setValue(test);
                    }
                }
            }
        };

        // Update actions button
        var updateActions = function() {
            var currentDay = calendar.querySelector('.jcalendar-selected');

            if (currentDay && currentDay.classList.contains('jcalendar-disabled')) {
                calendarControlsUpdateButton.setAttribute('disabled', 'disabled');
                calendarSelectHour.setAttribute('disabled', 'disabled');
                calendarSelectMin.setAttribute('disabled', 'disabled');
            } else {
                calendarControlsUpdateButton.removeAttribute('disabled');
                calendarSelectHour.removeAttribute('disabled');
                calendarSelectMin.removeAttribute('disabled');
            }

            // Event
            if (typeof(obj.options.onupdate) == 'function') {
                obj.options.onupdate(el, obj.getValue());
            }
        };

        var calendar = null;
        var calendarReset = null;
        var calendarConfirm = null;
        var calendarContainer = null;
        var calendarContent = null;
        var calendarLabelYear = null;
        var calendarLabelMonth = null;
        var calendarTable = null;
        var calendarBody = null;

        var calendarControls = null;
        var calendarControlsTime = null;
        var calendarControlsUpdate = null;
        var calendarControlsUpdateButton = null;
        var calendarSelectHour = null;
        var calendarSelectMin = null;

        var init = function() {
            // Get value from initial element if that is an input
            if (el.tagName == 'INPUT' && el.value) {
                options.value = el.value;
            }

            // Calendar DOM elements
            calendarReset = document.createElement('div');
            calendarReset.className = 'jcalendar-reset';

            calendarConfirm = document.createElement('div');
            calendarConfirm.className = 'jcalendar-confirm';

            calendarControls = document.createElement('div');
            calendarControls.className = 'jcalendar-controls';
            calendarControls.style.borderBottom = '1px solid #ddd';
            calendarControls.appendChild(calendarReset);
            calendarControls.appendChild(calendarConfirm);

            calendarContainer = document.createElement('div');
            calendarContainer.className = 'jcalendar-container';

            calendarContent = document.createElement('div');
            calendarContent.className = 'jcalendar-content';
            calendarContainer.appendChild(calendarContent);

            // Main element
            if (el.tagName == 'DIV') {
                calendar = el;
                calendar.classList.add('jcalendar-inline');
            } else {
                // Add controls to the screen
                calendarContent.appendChild(calendarControls);

                calendar = document.createElement('div');
                calendar.className = 'jcalendar';
            }
            calendar.classList.add('jcalendar-container');
            calendar.appendChild(calendarContainer);

            // Table container
            var calendarTableContainer = document.createElement('div');
            calendarTableContainer.className = 'jcalendar-table';
            calendarContent.appendChild(calendarTableContainer);

            // Previous button
            var calendarHeaderPrev = document.createElement('td');
            calendarHeaderPrev.setAttribute('colspan', '2');
            calendarHeaderPrev.className = 'jcalendar-prev';

            // Header with year and month
            calendarLabelYear = document.createElement('span');
            calendarLabelYear.className = 'jcalendar-year';
            calendarLabelMonth = document.createElement('span');
            calendarLabelMonth.className = 'jcalendar-month';

            var calendarHeaderTitle = document.createElement('td');
            calendarHeaderTitle.className = 'jcalendar-header';
            calendarHeaderTitle.setAttribute('colspan', '3');
            calendarHeaderTitle.appendChild(calendarLabelMonth);
            calendarHeaderTitle.appendChild(calendarLabelYear);

            var calendarHeaderNext = document.createElement('td');
            calendarHeaderNext.setAttribute('colspan', '2');
            calendarHeaderNext.className = 'jcalendar-next';

            var calendarHeader = document.createElement('thead');
            var calendarHeaderRow = document.createElement('tr');
            calendarHeaderRow.appendChild(calendarHeaderPrev);
            calendarHeaderRow.appendChild(calendarHeaderTitle);
            calendarHeaderRow.appendChild(calendarHeaderNext);
            calendarHeader.appendChild(calendarHeaderRow);

            calendarTable = document.createElement('table');
            calendarBody = document.createElement('tbody');
            calendarTable.setAttribute('cellpadding', '0');
            calendarTable.setAttribute('cellspacing', '0');
            calendarTable.appendChild(calendarHeader);
            calendarTable.appendChild(calendarBody);
            calendarTableContainer.appendChild(calendarTable);

            calendarSelectHour = document.createElement('select');
            calendarSelectHour.className = 'jcalendar-select';
            calendarSelectHour.onchange = function() {
                obj.date[3] = this.value; 

                // Event
                if (typeof(obj.options.onupdate) == 'function') {
                    obj.options.onupdate(el, obj.getValue());
                }
            };

            for (var i = 0; i < 24; i++) {
                var element = document.createElement('option');
                element.value = i;
                element.innerHTML = jSuites.two(i);
                calendarSelectHour.appendChild(element);
            }

            calendarSelectMin = document.createElement('select');
            calendarSelectMin.className = 'jcalendar-select';
            calendarSelectMin.onchange = function() {
                obj.date[4] = this.value;

                // Event
                if (typeof(obj.options.onupdate) == 'function') {
                    obj.options.onupdate(el, obj.getValue());
                }
            };

            for (var i = 0; i < 60; i++) {
                var element = document.createElement('option');
                element.value = i;
                element.innerHTML = jSuites.two(i);
                calendarSelectMin.appendChild(element);
            }

            // Footer controls
            var calendarControlsFooter = document.createElement('div');
            calendarControlsFooter.className = 'jcalendar-controls';

            calendarControlsTime = document.createElement('div');
            calendarControlsTime.className = 'jcalendar-time';
            calendarControlsTime.style.maxWidth = '140px';
            calendarControlsTime.appendChild(calendarSelectHour);
            calendarControlsTime.appendChild(calendarSelectMin);

            calendarControlsUpdateButton = document.createElement('button');
            calendarControlsUpdateButton.setAttribute('type', 'button');
            calendarControlsUpdateButton.className = 'jcalendar-update';

            calendarControlsUpdate = document.createElement('div');
            calendarControlsUpdate.style.flexGrow = '10';
            calendarControlsUpdate.appendChild(calendarControlsUpdateButton);
            calendarControlsFooter.appendChild(calendarControlsTime);

            // Only show the update button for input elements
            if (el.tagName == 'INPUT') {
                calendarControlsFooter.appendChild(calendarControlsUpdate);
            }

            calendarContent.appendChild(calendarControlsFooter);

            var calendarBackdrop = document.createElement('div');
            calendarBackdrop.className = 'jcalendar-backdrop';
            calendar.appendChild(calendarBackdrop);

            // Handle events
            el.addEventListener("keyup", keyUpControls);

            // Add global events
            calendar.addEventListener("swipeleft", function(e) {
                jSuites.animation.slideLeft(calendarTable, 0, function() {
                    obj.next();
                    jSuites.animation.slideRight(calendarTable, 1);
                });
                e.preventDefault();
                e.stopPropagation();
            });

            calendar.addEventListener("swiperight", function(e) {
                jSuites.animation.slideRight(calendarTable, 0, function() {
                    obj.prev();
                    jSuites.animation.slideLeft(calendarTable, 1);
                });
                e.preventDefault();
                e.stopPropagation();
            });

            el.onmouseup = function() {
                obj.open();
            };

            if ('ontouchend' in document.documentElement === true) {
                calendar.addEventListener("touchend", mouseUpControls);
            } else {
                calendar.addEventListener("mouseup", mouseUpControls);
            }

            // Global controls
            if (! jSuites.calendar.hasEvents) {
                // Execute only one time
                jSuites.calendar.hasEvents = true;
                // Enter and Esc
                document.addEventListener("keydown", jSuites.calendar.keydown);
            }

            // Set configuration
            obj.setOptions(options);

            // Append element to the DOM
            if (el.tagName == 'INPUT') {
                el.parentNode.insertBefore(calendar, el.nextSibling);
                // Add properties
                el.setAttribute('autocomplete', 'off');
                // Element
                el.classList.add('jcalendar-input');
                // Value
                el.value = obj.setLabel(obj.getValue(), obj.options);
            } else {
                // Get days
                obj.getDays();
                // Hour
                if (obj.options.time) {
                    calendarSelectHour.value = obj.date[3];
                    calendarSelectMin.value = obj.date[4];
                }
            }

            // Default opened
            if (obj.options.opened == true) {
                obj.open();
            }

            // Change method
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue();
                } else {
                    obj.setValue(val);
                }
            };

            // Keep object available from the node
            el.calendar = calendar.calendar = obj;
        };

        init();

        return obj;
    });

    jSuites.calendar.keydown = function(e) {
        var calendar = null;
        if (calendar = jSuites.calendar.current) { 
            if (e.which == 13) {
                // ENTER
                calendar.close(false, true);
            } else if (e.which == 27) {
                // ESC
                calendar.close(false, false);
            }
        }
    };

    jSuites.calendar.prettify = function(d, texts) {
        if (! texts) {
            var texts = {
                justNow: 'Just now',
                xMinutesAgo: '{0}m ago',
                xHoursAgo: '{0}h ago',
                xDaysAgo: '{0}d ago',
                xWeeksAgo: '{0}w ago',
                xMonthsAgo: '{0} mon ago',
                xYearsAgo: '{0}y ago',
            };
        }

        var d1 = new Date();
        var d2 = new Date(d);
        var total = parseInt((d1 - d2) / 1000 / 60);

        String.prototype.format = function(o) {
            return this.replace('{0}', o);
        };

        if (total == 0) {
            var text = texts.justNow;
        } else if (total < 90) {
            var text = texts.xMinutesAgo.format(total);
        } else if (total < 1440) { // One day
            var text = texts.xHoursAgo.format(Math.round(total/60));
        } else if (total < 20160) { // 14 days
            var text = texts.xDaysAgo.format(Math.round(total / 1440));
        } else if (total < 43200) { // 30 days
            var text = texts.xWeeksAgo.format(Math.round(total / 10080));
        } else if (total < 1036800) { // 24 months
            var text = texts.xMonthsAgo.format(Math.round(total / 43200));
        } else { // 24 months+
            var text = texts.xYearsAgo.format(Math.round(total / 525600));
        }

        return text;
    };

    jSuites.calendar.prettifyAll = function() {
        var elements = document.querySelectorAll('.prettydate');
        for (var i = 0; i < elements.length; i++) {
            if (elements[i].getAttribute('data-date')) {
                elements[i].innerHTML = jSuites.calendar.prettify(elements[i].getAttribute('data-date'));
            } else {
                elements[i].setAttribute('data-date', elements[i].innerHTML);
                elements[i].innerHTML = jSuites.calendar.prettify(elements[i].innerHTML);
            }
        }
    };

    jSuites.calendar.now = function(date, dateOnly) {
        if (! date) {
            var date = new Date();
        }
        var y = date.getFullYear();
        var m = date.getMonth() + 1;
        var d = date.getDate();
        var h = date.getHours();
        var i = date.getMinutes();
        var s = date.getSeconds();

        if (dateOnly == true) {
            return jSuites.two(y) + '-' + jSuites.two(m) + '-' + jSuites.two(d);
        } else {
            return jSuites.two(y) + '-' + jSuites.two(m) + '-' + jSuites.two(d) + ' ' + jSuites.two(h) + ':' + jSuites.two(i) + ':' + jSuites.two(s);
        }
    };

    jSuites.calendar.toArray = function(value) {
        var date = value.split(((value.indexOf('T') !== -1) ? 'T' : ' '));
        var time = date[1];
        var date = date[0].split('-');
        var y = parseInt(date[0]);
        var m = parseInt(date[1]);
        var d = parseInt(date[2]);

        if (time) {
            var time = time.split(':');
            var h = parseInt(time[0]);
            var i = parseInt(time[1]);
        } else {
            var h = 0;
            var i = 0;
        }
        return [ y, m, d, h, i, 0 ];
    };

    // Helper to extract date from a string
    jSuites.calendar.extractDateFromString = function(date, format) {
        if (date > 0 && Number(date) == date) {
            var d = new Date(Math.round((date - 25569)*86400*1000));
            return d.getFullYear() + "-" + jSuites.two(d.getMonth()) + "-" + jSuites.two(d.getDate()) + ' 00:00:00';
        }

        var v1 = '' + date;
        var v2 = format.replace(/[0-9]/g,'');

        var test = 1;

        // Get year
        var y = v2.search("YYYY");
        y = v1.substr(y,4);
        if (parseInt(y) != y) {
            test = 0;
        }

        // Get month
        var m = v2.search("MM");
        m = v1.substr(m,2);
        if (parseInt(m) != m || m > 12) {
            test = 0;
        }

        // Get day
        var d = v2.search("DD");
        d = v1.substr(d,2);
        if (parseInt(d) != d  || d > 31) {
            test = 0;
        }

        // Get hour
        var h = v2.search("HH");
        if (h >= 0) {
            h = v1.substr(h,2);
            if (! parseInt(h) || h > 23) {
                h = '00';
            }
        } else {
            h = '00';
        }

        // Get minutes
        var i = v2.search("MI");
        if (i >= 0) {
            i = v1.substr(i,2);
            if (! parseInt(i) || i > 59) {
                i = '00';
            }
        } else {
            i = '00';
        }

        // Get seconds
        var s = v2.search("SS");
        if (s >= 0) {
            s = v1.substr(s,2);
            if (! parseInt(s) || s > 59) {
                s = '00';
            }
        } else {
            s = '00';
        }

        if (test == 1 && date.length == v2.length) {
            // Update source
            return y + '-' + m + '-' + d + ' ' + h + ':' +  i + ':' + s;
        }

        return '';
    };

    // Helper to convert date into string
    jSuites.calendar.getDateString = function(value, options) {
        if (! options) {
            var options = {};
        }

        // Labels
        if (typeof(options) == 'string') {
            var format = options;
        } else {
            var format = options.format;
        }

        // Labels
        if (options && options.weekdays) {
            var weekdays = options.weekdays;
        } else {
            var weekdays = [ 'Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday' ];
        }

        // Labels
        if (options && options.months) {
            var months = options.months;
        } else {
            var months = [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ];
        }

        // Labels
        if (options && options.months) {
            var monthsFull = options.monthsFull;
        } else {
            var monthsFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        }

        // Default date format
        if (! format) {
            format = 'DD/MM/YYYY';
        }

        if (value) {
            var d = ''+value;
            var splitStr = (d.indexOf('T') !== -1) ? 'T' : ' ';
            d = d.split(splitStr);

            var h = '';
            var m = '';
            var s = '';

            if (d[1]) {
                h = d[1].split(':');
                m = h[1] ? h[1] : '00';
                s = h[2] ? h[2] : '00';
                h = h[0] ? h[0] : '00';
            } else {
                h = '00';
                m = '00';
                s = '00';
            }

            d = d[0].split('-');

            if (d[0] && d[1] && d[2] && d[0] > 0 && d[1] > 0 && d[1] < 13 && d[2] > 0 && d[2] < 32) {
                var calendar = new Date(d[0], d[1]-1, d[2]);

                d[1] = (d[1].length < 2 ? '0' : '') + d[1];
                d[2] = (d[2].length < 2 ? '0' : '') + d[2];
                h = (h.length < 2 ? '0' : '') + h;
                m = (m.length < 2 ? '0' : '') + m;
                s = (s.length < 2 ? '0' : '') + s;

                // New value
                value = format;
                // Legacy
                value = value.replace('MMM', 'MON');

                // Extract tokens
                var tokens = [ 'YYYY', 'YYY', 'YY', 'Y', 'MM', 'DD', 'DY', 'DAY', 'WD', 'D', 'Q', 'HH24', 'HH12', 'HH', 'PM', 'AM', 'MI', 'SS', 'MS', 'MONTH', 'MON'];
                var pieces = [];
                var tmp = value;

                while (tmp) {
                    var t = 0;
                    for (var i = 0; i < tokens.length; i++) {
                        if (t == 0 && tmp.toUpperCase().indexOf(tokens[i]) === 0) {
                            t = tokens[i].length;
                        }
                    }
                    if (t == 0) {
                        pieces.push(tmp.substr(0, 1));
                        tmp = tmp.substr(1);
                    } else {
                        pieces.push(tmp.substr(0, t));
                        tmp = tmp.substr(t);
                    }
                }

                // Replace tokens per values
                var replace = function(k, v, c) {
                    if (c == true) {
                        for (var i = 0; i < pieces.length; i++) {
                            if (pieces[i].toUpperCase() == k) {
                                pieces[i] = v;
                            }
                        }
                    } else {
                        for (var i = 0; i < pieces.length; i++) {
                            if (pieces[i] == k) {
                                pieces[i] = v;
                            }
                        }
                    }
                };

                replace('YYYY', d[0], true);
                replace('YYY', d[0].substring(1,4), true);
                replace('YY', d[0].substring(2,4), true);
                replace('Y', d[0].substring(3,4), true);

                replace('MM', d[1], true);
                replace('DD', d[2], true);
                replace('Q', Math.floor((calendar.getMonth() + 3) / 3), true);

                if (h) {
                    replace('HH24', h);
                }

                if (h > 12) {
                    replace('HH12', h - 12, true);
                    replace('HH', h - 12, true);
                    replace('AM', 'pm', true);
                    replace('PM', 'pm', true);
                } else {
                    replace('HH12', h, true);
                    replace('HH', h, true);
                    replace('AM', 'am', true);
                    replace('PM', 'am', true);
                }

                replace('MI', m, true);
                replace('SS', s, true);
                replace('MS', calendar.getMilliseconds(), true);

                // Textual tokens
                replace('MONTH', monthsFull[calendar.getMonth()].toUpperCase());
                replace('Month', monthsFull[calendar.getMonth()]);
                replace('month', monthsFull[calendar.getMonth()].toLowerCase());
                replace('MON', months[calendar.getMonth()].toUpperCase());
                replace('MMM', months[calendar.getMonth()].toUpperCase());
                replace('Mon', months[calendar.getMonth()]);
                replace('mon', months[calendar.getMonth()].toLowerCase());

                replace('DAY', weekdays[calendar.getDay()].toUpperCase());
                replace('Day', weekdays[calendar.getDay()]);
                replace('day', weekdays[calendar.getDay()].toLowerCase());
                replace('DY', weekdays[calendar.getDay()].substr(0,3).toUpperCase());
                replace('Dy', weekdays[calendar.getDay()].substr(0,3));
                replace('dy', weekdays[calendar.getDay()].substr(0,3).toLowerCase());
                replace('D', weekdays[calendar.getDay()]);
                replace('WD', weekdays[calendar.getDay()]);

                // Put pieces together
                value = pieces.join('');
            } else {
                value = '';
            }
        }

        return value;
    };



    jSuites.color = (function(el, options) {
        // Already created, update options
        if (el.color) {
            return el.color.setOptions(options, true);
        }

        // New instance
        var obj = { type: 'color' };
        obj.options = {};

        var container = null;
        var backdrop = null;
        var content = null;
        var resetButton = null;
        var closeButton = null;
        var tabs = null;
        var jsuitesTabs = null;

        /**
         * Update options
         */
        obj.setOptions = function(options, reset) {
            /**
             * @typedef {Object} defaults
             * @property {(string|Array)} value - Initial value of the compontent
             * @property {string} placeholder - The default instruction text on the element
             * @property {requestCallback} onchange - Method to be execute after any changes on the element
             * @property {requestCallback} onclose - Method to be execute when the element is closed
             * @property {string} doneLabel - Label for button done
             * @property {string} resetLabel - Label for button reset
             * @property {string} resetValue - Value for button reset
             * @property {Bool} showResetButton - Active or note for button reset - default false
             */
            var defaults = {
                placeholder: '',
                value: null,
                onopen: null,
                onclose: null,
                onchange: null,
                closeOnChange: true,
                palette: null,
                position: null,
                doneLabel: 'Done',
                resetLabel: 'Reset',
                fullscreen: false,
                opened: false,
            };

            if (! options) {
                options = {};
            }

            if (options && ! options.palette) {
                // Default pallete
                options.palette = jSuites.palette();
            }

            // Loop through our object
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Update the text of the controls, if they have already been created
            if (resetButton) {
                resetButton.innerHTML = obj.options.resetLabel;
            }
            if (closeButton) {
                closeButton.innerHTML = obj.options.doneLabel;
            }

            // Update the pallete
            if (obj.options.palette && jsuitesTabs) {
                jsuitesTabs.updateContent(0, table());
            }

            // Value
            if (typeof obj.options.value === 'string') {
                el.value = obj.options.value;
            }

            // Placeholder
            if (obj.options.placeholder) {
                el.setAttribute('placeholder', obj.options.placeholder);
            } else {
                if (el.getAttribute('placeholder')) {
                    el.removeAttribute('placeholder');
                }
            }

            return obj;
        };

        /**
         * Open color pallete
         */
        obj.open = function() {
            if (! container.classList.contains('jcolor-focus')) {
                // Start tracking
                jSuites.tracking(obj, true);

                // Show colorpicker
                container.classList.add('jcolor-focus');

                var rectContent = content.getBoundingClientRect();

                if (jSuites.getWindowWidth() < 800 || obj.options.fullscreen == true) {
                    content.style.top = '';
                    content.classList.add('jcolor-fullscreen');
                    jSuites.animation.slideBottom(content, 1);
                    backdrop.style.display = 'block';
                } else {
                    if (content.classList.contains('jcolor-fullscreen')) {
                        content.classList.remove('jcolor-fullscreen');
                        backdrop.style.display = '';
                    }

                    var rect = el.getBoundingClientRect();

                    if (obj.options.position) {
                        content.style.position = 'fixed';
                        if (window.innerHeight < rect.bottom + rectContent.height) {
                            content.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                        } else {
                            content.style.top = (rect.top + rect.height + 2) + 'px';
                        }
                        content.style.left = rect.left + 'px';
                    } else {
                        if (window.innerHeight < rect.bottom + rectContent.height) {
                            content.style.top = -1 * (rectContent.height + rect.height + 2) + 'px';
                        } else {
                            content.style.top = '2px';
                        }
                    }
                }

                if (typeof(obj.options.onopen) == 'function') {
                    obj.options.onopen(el);
                }

                jsuitesTabs.setBorder(jsuitesTabs.getActive());

                // Update sliders
                if (obj.options.value) {
                    var rgb = HexToRgb(obj.options.value);

                    rgbInputs.forEach(function(rgbInput, index) {
                        rgbInput.value = rgb[index];
                        rgbInput.dispatchEvent(new Event('input'));
                    });
                }
            }
        };

        /**
         * Close color pallete
         */
        obj.close = function(ignoreEvents) {
            if (container.classList.contains('jcolor-focus')) {
                // Remove focus
                container.classList.remove('jcolor-focus');
                // Make sure backdrop is hidden
                backdrop.style.display = '';
                // Call related events
                if (! ignoreEvents && typeof(obj.options.onclose) == 'function') {
                    obj.options.onclose(el);
                }
                // Stop  the object
                jSuites.tracking(obj, false);
            }

            return obj.options.value;
        };

        /**
         * Set value
         */
        obj.setValue = function(color) {
            if (! color) {
                color = '';
            }

            if (color != obj.options.value) {
                obj.options.value = color;
                slidersResult = color;

                // Remove current selecded mark
                var selected = container.querySelector('.jcolor-selected');
                if (selected) {
                    selected.classList.remove('jcolor-selected');
                }

                // Mark cell as selected
                if (obj.values[color]) {
                    obj.values[color].classList.add('jcolor-selected');
                }

                // Onchange
                if (typeof(obj.options.onchange) == 'function') {
                    obj.options.onchange(el, color);
                }

                // Changes
                if (el.value != obj.options.value) {
                    // Set input value
                    el.value = obj.options.value;
                    // Element onchange native
                    if (typeof(el.onchange) == 'function') {
                        el.onchange({
                            type: 'change',
                            target: el,
                            value: el.value
                        });
                    }
                }

                if (obj.options.closeOnChange == true) {
                    obj.close();
                }
            }
        };

        /**
         * Get value
         */
        obj.getValue = function() {
            return obj.options.value;
        };

        var backdropClickControl = false;

        // Converts a number in decimal to hexadecimal
        var decToHex = function(num) {
            var hex = num.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        };

        // Converts a color in rgb to hexadecimal
        var rgbToHex = function(r, g, b) {
            return "#" + decToHex(r) + decToHex(g) + decToHex(b);
        };

        // Converts a number in hexadecimal to decimal
        var hexToDec = function(hex) {
            return parseInt('0x' + hex);
        };

        // Converts a color in hexadecimal to rgb
        var HexToRgb = function(hex) {
            return [hexToDec(hex.substr(1, 2)), hexToDec(hex.substr(3, 2)), hexToDec(hex.substr(5, 2))]
        };

        var table = function() {
            // Content of the first tab
            var tableContainer = document.createElement('div');
            tableContainer.className = 'jcolor-grid';

            // Cells
            obj.values = [];

            // Table pallete
            var t = document.createElement('table');
            t.setAttribute('cellpadding', '7');
            t.setAttribute('cellspacing', '0');

            for (var j = 0; j < obj.options.palette.length; j++) {
                var tr = document.createElement('tr');
                for (var i = 0; i < obj.options.palette[j].length; i++) {
                    var td = document.createElement('td');
                    var color = obj.options.palette[j][i];
                    if (color.length < 7 && color.substr(0,1) !== '#') {
                        color = '#' + color;
                    }
                    td.style.backgroundColor = color;
                    td.setAttribute('data-value', color);
                    td.innerHTML = '';
                    tr.appendChild(td);

                    // Selected color
                    if (obj.options.value == color) {
                        td.classList.add('jcolor-selected');
                    }

                    // Possible values
                    obj.values[color] = td;
                }
                t.appendChild(tr);
            }

            // Append to the table
            tableContainer.appendChild(t);

            // Select color
            tableContainer.addEventListener("mouseup", function(e) {
                if (e.target.tagName == 'TD') {
                    var value = e.target.getAttribute('data-value');
                    if (value) {
                        obj.setValue(value);
                    }
                }
            });

            return tableContainer;
        };

        // Canvas where the image will be rendered
        var canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 160;
        var context = canvas.getContext("2d");

        var resizeCanvas = function() {
            // Specifications necessary to correctly obtain colors later in certain positions
            var m = tabs.firstChild.getBoundingClientRect();
            canvas.width = m.width - 14;
            gradient();
        };

        var gradient = function() {
            var g = context.createLinearGradient(0, 0, canvas.width, 0);
            // Create color gradient
            g.addColorStop(0,    "rgb(255,0,0)");
            g.addColorStop(0.15, "rgb(255,0,255)");
            g.addColorStop(0.33, "rgb(0,0,255)");
            g.addColorStop(0.49, "rgb(0,255,255)");
            g.addColorStop(0.67, "rgb(0,255,0)");
            g.addColorStop(0.84, "rgb(255,255,0)");
            g.addColorStop(1,    "rgb(255,0,0)");
            context.fillStyle = g;
            context.fillRect(0, 0, canvas.width, canvas.height);
            g = context.createLinearGradient(0, 0, 0, canvas.height);
            g.addColorStop(0,   "rgba(255,255,255,1)");
            g.addColorStop(0.5, "rgba(255,255,255,0)");
            g.addColorStop(0.5, "rgba(0,0,0,0)");
            g.addColorStop(1,   "rgba(0,0,0,1)");
            context.fillStyle = g;
            context.fillRect(0, 0, canvas.width, canvas.height);
        };

        var hsl = function() {
            var element = document.createElement('div');
            element.className = "jcolor-hsl";

            var point = document.createElement('div');
            point.className = 'jcolor-point';

            var div = document.createElement('div');
            div.appendChild(canvas);
            div.appendChild(point);
            element.appendChild(div);

            // Moves the marquee point to the specified position
            var update = function(buttons, x, y) {
                if (buttons === 1) {
                    var rect = element.getBoundingClientRect();
                    var left = x - rect.left;
                    var top = y - rect.top;
                    if (left < 0) {
                        left = 0;
                    }
                    if (top < 0) {
                        top = 0;
                    }
                    if (left > rect.width) {
                        left = rect.width;
                    }
                    if (top > rect.height) {
                        top = rect.height;
                    }
                    point.style.left = left + 'px';
                    point.style.top = top + 'px';
                    var pixel = context.getImageData(left, top, 1, 1).data;
                    slidersResult = rgbToHex(pixel[0], pixel[1], pixel[2]);
                }
            };

            // Applies the point's motion function to the div that contains it
            element.addEventListener('mousedown', function(e) {
                update(e.buttons, e.clientX, e.clientY);
            });

            element.addEventListener('mousemove', function(e) {
                update(e.buttons, e.clientX, e.clientY);
            });

            element.addEventListener('touchmove', function(e) {
                update(1, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            });

            return element;
        };

        var slidersResult = '';

        var rgbInputs = [];

        var changeInputColors = function() {
            if (slidersResult !== '') {
                for (var j = 0; j < rgbInputs.length; j++) {
                    var currentColor = HexToRgb(slidersResult);

                    currentColor[j] = 0;

                    var newGradient = 'linear-gradient(90deg, rgb(';
                    newGradient += currentColor.join(', ');
                    newGradient += '), rgb(';

                    currentColor[j] = 255;

                    newGradient += currentColor.join(', ');
                    newGradient += '))';

                    rgbInputs[j].style.backgroundImage = newGradient;
                }
            }
        };

        var sliders = function() {
            // Content of the third tab
            var slidersElement = document.createElement('div');
            slidersElement.className = 'jcolor-sliders';

            var slidersBody = document.createElement('div');

            // Creates a range-type input with the specified name
            var createSliderInput = function(name) {
                var inputContainer = document.createElement('div');
                inputContainer.className = 'jcolor-sliders-input-container';

                var label = document.createElement('label');
                label.innerText = name;

                var subContainer = document.createElement('div');
                subContainer.className = 'jcolor-sliders-input-subcontainer';

                var input = document.createElement('input');
                input.type = 'range';
                input.min = 0;
                input.max = 255;
                input.value = 0;

                inputContainer.appendChild(label);
                subContainer.appendChild(input);

                var value = document.createElement('div');
                value.innerText = input.value;

                input.addEventListener('input', function() {
                    value.innerText = input.value;
                });

                subContainer.appendChild(value);
                inputContainer.appendChild(subContainer);

                slidersBody.appendChild(inputContainer);

                return input;
            };

            // Creates red, green and blue inputs
            rgbInputs = [
                createSliderInput('Red'),
                createSliderInput('Green'),
                createSliderInput('Blue'),
            ];

            slidersElement.appendChild(slidersBody);

            // Element that prints the current color
            var slidersResultColor = document.createElement('div');
            slidersResultColor.className = 'jcolor-sliders-final-color';

            var resultElement = document.createElement('div');
            resultElement.style.visibility = 'hidden';
            resultElement.innerText = 'a';
            slidersResultColor.appendChild(resultElement);

            // Update the element that prints the current color
            var updateResult = function() {
                var resultColor = rgbToHex(parseInt(rgbInputs[0].value), parseInt(rgbInputs[1].value), parseInt(rgbInputs[2].value));

                resultElement.innerText = resultColor;
                resultElement.style.color = resultColor;
                resultElement.style.removeProperty('visibility');

                slidersResult = resultColor;
            };

            // Apply the update function to color inputs
            rgbInputs.forEach(function(rgbInput) {
                rgbInput.addEventListener('input', function() {
                    updateResult();
                    changeInputColors();
                });
            });

            slidersElement.appendChild(slidersResultColor);

            return slidersElement;
        };

        var init = function() {
            // Initial options
            obj.setOptions(options);

            // Add a proper input tag when the element is an input
            if (el.tagName == 'INPUT') {
                el.classList.add('jcolor-input');
                el.readOnly = true;
            }

            // Table container
            container = document.createElement('div');
            container.className = 'jcolor';

            // Table container
            backdrop = document.createElement('div');
            backdrop.className = 'jcolor-backdrop';
            container.appendChild(backdrop);

            // Content
            content = document.createElement('div');
            content.className = 'jcolor-content';

            // Controls
            var controls = document.createElement('div');
            controls.className = 'jcolor-controls';
            content.appendChild(controls);

            // Reset button
            resetButton  = document.createElement('div');
            resetButton.className = 'jcolor-reset';
            resetButton.innerHTML = obj.options.resetLabel;
            resetButton.onclick = function(e) {
                obj.setValue('');
                obj.close();
            };
            controls.appendChild(resetButton);

            // Close button
            closeButton  = document.createElement('div');
            closeButton.className = 'jcolor-close';
            closeButton.innerHTML = obj.options.doneLabel;
            closeButton.onclick = function(e) {
                if (jsuitesTabs.getActive() > 0) {
                    obj.setValue(slidersResult);
                }
                obj.close();
            };
            controls.appendChild(closeButton);

            // Element that will be used to create the tabs
            tabs = document.createElement('div');
            content.appendChild(tabs);

            // Starts the jSuites tabs component
            jsuitesTabs = jSuites.tabs(tabs, {
                animation: true,
                data: [
                    {
                        title: 'Grid',
                        contentElement: table(),
                    },
                    {
                        title: 'Spectrum',
                        contentElement: hsl(),
                    },
                    {
                        title: 'Sliders',
                        contentElement: sliders(),
                    }
                ],
                onchange: function(element, instance, index) {
                    if (index === 1) {
                        resizeCanvas();
                    } else {
                        var color = slidersResult !== '' ? slidersResult : obj.getValue();

                        if (index === 2 && color) {
                            var rgb = HexToRgb(color);

                            rgbInputs.forEach(function(rgbInput, index) {
                                rgbInput.value = rgb[index];
                                rgbInput.dispatchEvent(new Event('input'));
                            });
                        }
                    }
                },
                palette: 'modern',
            });

            container.appendChild(content);

            // Insert picker after the element
            if (el.tagName == 'INPUT') {
                el.parentNode.insertBefore(container, el.nextSibling);
            } else {
                el.appendChild(container);
            }

            /**
             * If element is focus open the picker
             */
            el.addEventListener("mouseup", function(e) {
                obj.open();
            });

            backdrop.addEventListener("mousedown", function(e) {
                backdropClickControl = true;
            });

            backdrop.addEventListener("mouseup", function(e) {
                if (backdropClickControl) {
                    obj.close();
                    backdropClickControl = false;
                }
            });

            // If the picker is open on the spectrum tab, it changes the canvas size when the window size is changed
            window.addEventListener('resize', function() {
                if (container.classList.contains('jcolor-focus') && jsuitesTabs.getActive() == 1) {
                    resizeCanvas();
                }
            });

            // Default opened
            if (obj.options.opened == true) {
                obj.open();
            }

            // Change
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue();
                } else {
                    obj.setValue(val);
                }
            };

            // Keep object available from the node
            el.color = obj;

            // Container shortcut
            container.color = obj;
        };

        init();

        return obj;
    });



    jSuites.contextmenu = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            items: null,
            onclick: null,
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Class definition
        el.classList.add('jcontextmenu');
        // Focusable
        el.setAttribute('tabindex', '900');

        /**
         * Open contextmenu
         */
        obj.open = function(e, items) {
            if (items) {
                // Update content
                obj.options.items = items;
                // Create items
                obj.create(items);
            }

            // Coordinates
            if ((obj.options.items && obj.options.items.length > 0) || el.children.length) {
                if (e.target) {
                    var x = e.clientX;
                    var y = e.clientY;
                } else {
                    var x = e.x;
                    var y = e.y;
                }

                el.classList.add('jcontextmenu-focus');
                el.focus();

                var rect = el.getBoundingClientRect();

                if (window.innerHeight < y + rect.height) {
                    var h = y - rect.height;
                    if (h < 0) {
                        h = 0;
                    }
                    el.style.top = h + 'px';
                } else {
                    el.style.top = y + 'px';
                }

                if (window.innerWidth < x + rect.width) {
                    if (x - rect.width > 0) {
                        el.style.left = (x - rect.width) + 'px';
                    } else {
                        el.style.left = '10px';
                    }
                } else {
                    el.style.left = x + 'px';
                }
            }
        };

        /**
         * Close menu
         */
        obj.close = function() {
            if (el.classList.contains('jcontextmenu-focus')) {
                el.classList.remove('jcontextmenu-focus');
            }
        };

        /**
         * Create items based on the declared objectd
         * @param {object} items - List of object
         */
        obj.create = function(items) {
            // Update content
            el.innerHTML = '';

            // Append items
            for (var i = 0; i < items.length; i++) {
                var itemContainer = createItemElement(items[i]);
                el.appendChild(itemContainer);
            }
        };
        
        /**
         * Private function for create a new Item element
         * @param {type} item
         * @returns {jsuitesL#15.jSuites.contextmenu.createItemElement.itemContainer}
         */
        function createItemElement(item) {
            if (item.type && (item.type == 'line' || item.type == 'divisor')) {
                var itemContainer = document.createElement('hr');
            } else {
                var itemContainer = document.createElement('div');
                var itemText = document.createElement('a');
                itemText.innerHTML = item.title;

                if (item.tooltip) {
                    itemContainer.setAttribute('title', item.tooltip);
                }

                if (item.icon) {
                    itemContainer.setAttribute('data-icon', item.icon);
                }

                if (item.id) {
                    itemContainer.id = item.id;
                }

                if (item.disabled) {
                    itemContainer.className = 'jcontextmenu-disabled';
                } else if (item.onclick) {
                    itemContainer.method = item.onclick;
                    itemContainer.addEventListener("mousedown", function(e) {
                        e.preventDefault();
                    });
                    itemContainer.addEventListener("mouseup", function() {
                        // Execute method
                        this.method(this);
                    });
                }
                itemContainer.appendChild(itemText);

                if (item.submenu) {
                    var itemIconSubmenu = document.createElement('span');
                    itemIconSubmenu.innerHTML = "&#9658;";
                    itemContainer.appendChild(itemIconSubmenu);
                    itemContainer.classList.add('jcontexthassubmenu');
                    var el_submenu = document.createElement('div');
                    // Class definition
                    el_submenu.classList.add('jcontextmenu');
                    // Focusable
                    el_submenu.setAttribute('tabindex', '900');
                    
                    // Append items
                    var submenu = item.submenu;
                    for (var i = 0; i < submenu.length; i++) {
                        var itemContainerSubMenu = createItemElement(submenu[i]);
                        el_submenu.appendChild(itemContainerSubMenu);
                    }

                    itemContainer.appendChild(el_submenu);
                } else if (item.shortcut) {
                    var itemShortCut = document.createElement('span');
                    itemShortCut.innerHTML = item.shortcut;
                    itemContainer.appendChild(itemShortCut);
                }
            }
            return itemContainer;
        }

        if (typeof(obj.options.onclick) == 'function') {
            el.addEventListener('click', function(e) {
                obj.options.onclick(obj, e);
            });
        }

        // Create items
        if (obj.options.items) {
            obj.create(obj.options.items);
        }

        el.addEventListener('blur', function(e) {
            obj.close();
        });

        if (! jSuites.contextmenu.hasEvents) {
            window.addEventListener("mousewheel", function() {
                obj.close();
            });

            document.addEventListener("contextmenu", function(e) {
                var id = jSuites.contextmenu.getElement(e.target);
                if (id) {
                    var element = document.querySelector('#' + id);
                    if (! element) {
                        console.error('JSUITES: Contextmenu id not found');
                    } else {
                        element.contextmenu.open(e);
                        e.preventDefault();
                    }
                }
            });

            jSuites.contextmenu.hasEvents = true;
        }

        el.contextmenu = obj;

        return obj;
    });

    jSuites.contextmenu.getElement = function(element) {
        var foundId = 0;

        function path (element) {
            if (element.parentNode && element.getAttribute('aria-contextmenu-id')) {
                foundId = element.getAttribute('aria-contextmenu-id');
            } else {
                if (element.parentNode) {
                    path(element.parentNode);
                }
            }
        }

        path(element);

        return foundId;
    };

    jSuites.dropdown = (function(el, options) {
        // Already created, update options
        if (el.dropdown) {
            return el.dropdown.setOptions(options, true);
        }

        // New instance
        var obj = { type: 'dropdown' };
        obj.options = {};

        // Success
        var success = function(data, val) {
            // Set data
            if (data && data.length) {
                obj.setData(data);

                // Onload method
                if (typeof(obj.options.onload) == 'function') {
                    obj.options.onload(el, obj, data, val);
                }
            }

            // Set value
            if (val) {
                applyValue(val);
            }

            // Component value
            if (val === undefined || val === null) {
                obj.options.value = '';
            }
            el.value = obj.options.value;

            // Open dropdown
            if (obj.options.opened == true) {
                obj.open();
            }
        };

        /**
         * Reset the options for the dropdown
         */
        var resetValue = function() {
            // Reset value container
            obj.value = {};
            // Remove selected
            for (var i = 0; i < obj.items.length; i++) {
                if (obj.items[i].selected == true) {
                    if (obj.items[i].element) {
                        obj.items[i].element.classList.remove('jdropdown-selected');
                    }
                    obj.items[i].selected = null;
                }
            }
            // Reset options
            obj.options.value = '';
        };

        /**
         * Apply values to the dropdown
         */
        var applyValue = function(values) {
            // Reset the current values
            resetValue();

            // Read values
            if (values !== null) {
                if (! values) {
                    if (typeof(obj.value['']) !== 'undefined') {
                        obj.value[''] = '';
                    }
                } else {
                    if (! Array.isArray(values)) {
                        values = ('' + values).split(';');
                    }
                    for (var i = 0; i < values.length; i++) {
                        obj.value[values[i]] = '';
                    }
                }
            }

            // Update the DOM
            for (var i = 0; i < obj.items.length; i++) {
                if (typeof(obj.value[Value(i)]) !== 'undefined') {
                    if (obj.items[i].element) {
                        obj.items[i].element.classList.add('jdropdown-selected');
                    }
                    obj.items[i].selected = true;

                    // Keep label
                    obj.value[Value(i)] = Text(i);
                }
            }

            // Global value
            obj.options.value = Object.keys(obj.value).join(';');

            // Update labels
            obj.header.value = obj.getText();
        };

        // Get the value of one item
        var Value = function(k, v) {
            // Legacy purposes
            if (! obj.options.format) {
                var property = 'value';
            } else {
                var property = 'id';
            }

            if (obj.items[k]) {
                if (v !== undefined) {
                    return obj.items[k].data[property] = v;
                } else {
                    return obj.items[k].data[property];
                }
            }

            return '';
        };

        // Get the label of one item
        var Text = function(k, v) {
            // Legacy purposes
            if (! obj.options.format) {
                var property = 'text';
            } else {
                var property = 'name';
            }

            if (obj.items[k]) {
                if (v !== undefined) {
                    return obj.items[k].data[property] = v;
                } else {
                    return obj.items[k].data[property];
                }
            }

            return '';
        };

        var getValue = function() {
            return Object.keys(obj.value);
        };

        var getText = function() {
            var data = [];
            var k = Object.keys(obj.value);
            for (var i = 0; i < k.length; i++) {
                data.push(obj.value[k[i]]);
            }
            return data;
        };

        obj.setOptions = function(options, reset) {
            if (! options) {
                options = {};
            }

            // Default configuration
            var defaults = {
                url: null,
                data: [],
                format: 0,
                multiple: false,
                autocomplete: false,
                remoteSearch: false,
                lazyLoading: false,
                type: null,
                width: null,
                maxWidth: null,
                opened: false,
                value: null,
                placeholder: '',
                newOptions: false,
                position: false,
                onchange: null,
                onload: null,
                onopen: null,
                onclose: null,
                onfocus: null,
                onblur: null,
                oninsert: null,
            };

            // Loop through our object
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Force autocomplete search
            if (obj.options.remoteSearch == true || obj.options.type === 'searchbar') {
                obj.options.autocomplete = true;
            }

            // New options
            if (obj.options.newOptions == true) {
                obj.header.classList.add('jdropdown-add');
            } else {
                obj.header.classList.remove('jdropdown-add');
            }

            // Autocomplete
            if (obj.options.autocomplete == true) {
                obj.header.removeAttribute('readonly');
            } else {
                obj.header.setAttribute('readonly', 'readonly');
            }

            // Place holder
            if (obj.options.placeholder) {
                obj.header.setAttribute('placeholder', obj.options.placeholder);
            } else {
                obj.header.removeAttribute('placeholder');
            }

            // Remove specific dropdown typing to add again
            el.classList.remove('jdropdown-searchbar');
            el.classList.remove('jdropdown-picker');
            el.classList.remove('jdropdown-list');

            if (obj.options.type == 'searchbar') {
                el.classList.add('jdropdown-searchbar');
            } else if (obj.options.type == 'list') {
                el.classList.add('jdropdown-list');
            } else if (obj.options.type == 'picker') {
                el.classList.add('jdropdown-picker');
            } else {
                if (jSuites.getWindowWidth() < 800) {
                    if (obj.options.autocomplete) {
                        el.classList.add('jdropdown-searchbar');
                        obj.options.type = 'searchbar';
                    } else {
                        el.classList.add('jdropdown-picker');
                        obj.options.type = 'picker';
                    }
                } else {
                    if (obj.options.width) {
                        el.style.width = obj.options.width;
                        el.style.minWidth = obj.options.width;
                    } else {
                        el.style.removeProperty('width');
                        el.style.removeProperty('min-width');
                    }

                    el.classList.add('jdropdown-default');
                    obj.options.type = 'default';
                }
            }

            // Close button
            if (obj.options.type == 'searchbar') {
                containerHeader.appendChild(closeButton);
            } else {
                container.insertBefore(closeButton, container.firstChild);
            }

            // Load the content
            if (obj.options.url && ! options.data) {
                jSuites.ajax({
                    url: obj.options.url,
                    method: 'GET',
                    dataType: 'json',
                    success: function(data) {
                        if (data) {
                            success(data, obj.options.value);
                        }
                    }
                });
            } else {
                success(obj.options.data, obj.options.value);
            }

            // Return the instance
            return obj;
        };

        // Helpers
        var containerHeader = null;
        var container = null;
        var content = null;
        var closeButton = null;
        var resetButton = null;
        var backdrop = null;

        var keyTimer = null;

        /**
         * Init dropdown
         */
        var init = function() {
            // Do not accept null
            if (! options) {
                options = {};
            }

            // If the element is a SELECT tag, create a configuration object
            if (el.tagName == 'SELECT') {
                var ret = jSuites.dropdown.extractFromDom(el, options);
                el = ret.el;
                options = ret.options;
            }

            // Place holder
            if (! options.placeholder && el.getAttribute('placeholder')) {
                options.placeholder = el.getAttribute('placeholder');
            }

            // Value container
            obj.value = {};
            // Containers
            obj.items = [];
            obj.groups = [];
            // Search options
            obj.search = '';
            obj.results = null;
            obj.numOfItems = 0;

            // Create dropdown
            el.classList.add('jdropdown');

            // Header container
            containerHeader = document.createElement('div');
            containerHeader.className = 'jdropdown-container-header';

            // Header
            obj.header = document.createElement('input');
            obj.header.className = 'jdropdown-header';
            obj.header.setAttribute('autocomplete', 'off');
            obj.header.onfocus = function() {
                if (typeof(obj.options.onfocus) == 'function') {
                    obj.options.onfocus(el);
                }
            };

            obj.header.onblur = function() {
                if (typeof(obj.options.onblur) == 'function') {
                    obj.options.onblur(el);
                }
            };

            obj.header.onkeyup = function(e) {
                if (obj.options.autocomplete == true && ! keyTimer) {
                    if (obj.search != obj.header.value.trim()) {
                        keyTimer = setTimeout(function() {
                            obj.find(obj.header.value.trim());
                            keyTimer = null;
                        }, 400);
                    }

                    if (! el.classList.contains('jdropdown-focus')) {
                        obj.open();
                    }
                } else {
                    if (! obj.options.autocomplete) {
                        obj.next(e.key);
                    }
                }
            };

            // Global controls
            if (! jSuites.dropdown.hasEvents) {
                // Execute only one time
                jSuites.dropdown.hasEvents = true;
                // Enter and Esc
                document.addEventListener("keydown", jSuites.dropdown.keydown);
            }

            // Container
            container = document.createElement('div');
            container.className = 'jdropdown-container';

            // Dropdown content
            content = document.createElement('div');
            content.className = 'jdropdown-content';

            // Close button
            closeButton = document.createElement('div');
            closeButton.className = 'jdropdown-close';
            closeButton.innerHTML = 'Done';

            // Reset button
            resetButton = document.createElement('div');
            resetButton.className = 'jdropdown-reset';
            resetButton.innerHTML = 'x';
            resetButton.onclick = function() {
                obj.reset();
                obj.close();
            };

            // Create backdrop
            backdrop = document.createElement('div');
            backdrop.className = 'jdropdown-backdrop';

            // Append elements
            containerHeader.appendChild(obj.header);

            container.appendChild(content);
            el.appendChild(containerHeader);
            el.appendChild(container);
            el.appendChild(backdrop);

            // Set the otiptions
            obj.setOptions(options);

            if ('ontouchsend' in document.documentElement === true) {
                el.addEventListener('touchsend', jSuites.dropdown.mouseup);
            } else {
                el.addEventListener('mouseup', jSuites.dropdown.mouseup);
            }

            // Lazyloading
            if (obj.options.lazyLoading == true) {
                jSuites.lazyLoading(content, {
                    loadUp: obj.loadUp,
                    loadDown: obj.loadDown,
                });
            }

            // Change method
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue(obj.options.multiple ? true : false);
                } else {
                    obj.setValue(val);
                }
            };

            // Keep object available from the node
            el.dropdown = obj;
        };

        /**
         * Get the current remote source of data URL
         */
        obj.getUrl = function() {
            return obj.options.url;
        };

        /**
         * Set the new data from a remote source
         * @param {string} url - url from the remote source
         * @param {function} callback - callback when the data is loaded
         */
        obj.setUrl = function(url, callback) {
            obj.options.url = url;

            jSuites.ajax({
                url: obj.options.url,
                method: 'GET',
                dataType: 'json',
                success: function(data) {
                    obj.setData(data);
                    // Callback
                    if (typeof(callback) == 'function') {
                        callback(obj);
                    }
                }
            });
        };

        /**
         * Set ID for one item
         */
        obj.setId = function(item, v) {
            // Legacy purposes
            if (! obj.options.format) {
                var property = 'value';
            } else {
                var property = 'id';
            }

            if (typeof(item) == 'object') {
                item[property] = v;
            } else {
                obj.items[item].data[property] = v;
            }
        };

        /**
         * Add a new item
         * @param {string} title - title of the new item
         */
        obj.add = function(title) {
            if (! title) {
                var current = obj.options.autocomplete == true ? obj.header.value : '';
                var title = prompt('Text', current);
                if (! title) {
                    return false;
                }
            }

            // Id
            var id = jSuites.guid();

            // Create new item
            if (! obj.options.format) {
                var item = {
                    value: id,
                    text: title,
                };
            } else {
                var item = {
                    id: id,
                    name: title,
                };
            }

            // Add item to the main list
            obj.options.data.push(item);

            // Create DOM
            var newItem = obj.createItem(item);

            // Append DOM to the list
            content.appendChild(newItem.element);

            // Callback
            if (typeof(obj.options.oninsert) == 'function') {
                obj.options.oninsert(obj, item, item);
            }

            // Show content
            if (content.style.display == 'none') {
                content.style.display = '';
            }

            return item;
        };

        /**
         * Create a new item
         */
        obj.createItem = function(data, group, groupName) {
            // Keep the correct source of data
            if (! obj.options.format) {
                if (! data.value && data.id !== undefined) {
                    data.value = data.id;
                    //delete data.id;
                }
                if (! data.text && data.name !== undefined) {
                    data.text = data.name;
                    //delete data.name;
                }
            } else {
                if (! data.id && data.value !== undefined) {
                    data.id = data.value;
                    //delete data.value;
                }
                if (! data.name && data.text !== undefined) {
                    data.name = data.text;
                    //delete data.text;
                }
            }

            // Create item
            var item = {};
            item.element = document.createElement('div');
            item.element.className = 'jdropdown-item';
            item.element.indexValue = obj.items.length;
            item.data = data;

            // Groupd DOM
            if (group) {
                item.group = group; 
            }

            // Id
            if (data.id) {
                item.element.setAttribute('id', data.id);
            }

            // Disabled
            if (data.disabled == true) {
                item.element.setAttribute('data-disabled', true);
            }

            // Image
            if (data.image) {
                var image = document.createElement('img');
                image.className = 'jdropdown-image';
                image.src = data.image;
                if (! data.title) {
                   image.classList.add('jdropdown-image-small');
                }
                item.element.appendChild(image);
            } else if (data.color) {
                var color = document.createElement('div');
                color.className = 'jdropdown-color';
                color.style.backgroundColor = data.color;
                item.element.appendChild(color);
            }

            // Set content
            if (! obj.options.format) {
                var text = data.text;
            } else {
                var text = data.name;
            }

            var node = document.createElement('div');
            node.className = 'jdropdown-description';
            node.innerHTML = text || '&nbsp;'; 

            // Title
            if (data.title) {
                var title = document.createElement('div');
                title.className = 'jdropdown-title';
                title.innerText = data.title;
                node.appendChild(title);
            }

            // Set content
            if (! obj.options.format) {
                var val = data.value;
            } else {
                var val = data.id;
            }

            // Value
            if (obj.value[val]) {
                item.element.classList.add('jdropdown-selected');
                item.selected = true;
            }

            // Keep DOM accessible
            obj.items.push(item);

            // Add node to item
            item.element.appendChild(node);

            return item;
        };

        obj.appendData = function(data) {
            // Create elements
            if (data.length) {
                // Reset counter
                obj.numOfItems = 0;

                // Helpers
                var items = [];
                var groups = [];

                // Prepare data
                for (var i = 0; i < data.length; i++) {
                    // Process groups
                    if (data[i].group) {
                        if (! groups[data[i].group]) {
                            groups[data[i].group] = [];
                        }
                        groups[data[i].group].push(i);
                    } else {
                        items.push(i);
                    }
                }

                // Groups
                var groupNames = Object.keys(groups);

                // Append groups in case exists
                if (groupNames.length > 0) {
                    for (var i = 0; i < groupNames.length; i++) {
                        // Group container
                        var group = document.createElement('div');
                        group.className = 'jdropdown-group';
                        // Group name
                        var groupName = document.createElement('div');
                        groupName.className = 'jdropdown-group-name';
                        groupName.innerHTML = groupNames[i];
                        // Group arrow
                        var groupArrow = document.createElement('i');
                        groupArrow.className = 'jdropdown-group-arrow jdropdown-group-arrow-down';
                        groupName.appendChild(groupArrow);
                        // Group items
                        var groupContent = document.createElement('div');
                        groupContent.className = 'jdropdown-group-items';
                        for (var j = 0; j < groups[groupNames[i]].length; j++) {
                            var item = obj.createItem(data[groups[groupNames[i]][j]], group, groupNames[i]);

                            if (obj.options.lazyLoading == false || obj.numOfItems < 200) {
                                groupContent.appendChild(item.element);
                                obj.numOfItems++;
                            }
                        }
                        // Group itens
                        group.appendChild(groupName);
                        group.appendChild(groupContent);
                        // Keep group DOM
                        obj.groups.push(group);
                        // Only add to the screen if children on the group
                        if (groupContent.children.length > 0) {
                            // Add DOM to the content
                            content.appendChild(group);
                        }
                    }
                }

                if (items.length) {
                    for (var i = 0; i < items.length; i++) {
                        var item = obj.createItem(data[items[i]]);
                        if (obj.options.lazyLoading == false || obj.numOfItems < 200) {
                            content.appendChild(item.element);
                            obj.numOfItems++;
                        }
                    }
                }
            }
        };

        obj.setData = function(data) {
            // Prepare data
            if (data.length) {
                for (var i = 0; i < data.length; i++) {
                    // Compatibility
                    if (typeof(data[i]) != 'object') {
                        // Correct format
                        if (! obj.options.format) {
                            data[i] = {
                                value: data[i],
                                text: data[i]
                            };
                        } else {
                            data[i] = {
                                id: data[i],
                                name: data[i]
                            };
                        }
                    }
                }

                // Reset current value
                resetValue();

                // Make sure the content container is blank
                content.innerHTML = '';

                // Reset
                obj.header.value = '';

                // Reset items and values
                obj.items = [];

                // Append data
                obj.appendData(data);

                // Update data
                obj.options.data = data;
            }
        };

        obj.getData = function() {
            return obj.options.data;
        };

        /**
         * Get position of the item
         */
        obj.getPosition = function(val) {
            for (var i = 0; i < obj.items.length; i++) {
                if (Value(i) == val) {
                    return i;
                }
            }
            return 0;
        };

        /**
         * Get dropdown current text
         */
        obj.getText = function(asArray) {
            // Get value
            var v = getText();
            // Return value
            if (asArray) {
                return v;
            } else {
                return v.join('; ');
            }
        };

        /**
         * Get dropdown current value
         */
        obj.getValue = function(asArray) {
            // Get value
            var v = getValue();
            // Return value
            if (asArray) {
                return v;
            } else {
                return v.join(';');
            }
        };

        /**
         * Change event
         */
        var change = function(oldValue) {
            // Events
            if (typeof(obj.options.onchange) == 'function') {
                obj.options.onchange(el, obj, oldValue, obj.options.value);
            }

            // Lemonade JS
            if (el.value != obj.options.value) {
                el.value = obj.options.value;
                if (typeof(el.onchange) == 'function') {
                    el.onchange({
                        type: 'change',
                        target: el,
                        value: el.value
                    });
                }
            }
        };

        /**
         * Set value
         */
        obj.setValue = function(newValue) {
            // Current value
            var oldValue = obj.getValue();
            // New value
            if (Array.isArray(newValue)) {
                newValue = newValue.join(';');
            }

            if (oldValue !== newValue) {
                // Set value
                applyValue(newValue);

                // Change
                change(oldValue);
            }
        };

        obj.resetSelected = function() {
            obj.setValue(null);
        }; 

        obj.selectIndex = function(index) {
            // Make sure is a number
            var index = parseInt(index);

            // Only select those existing elements
            if (obj.items && obj.items[index]) {
                // Reset cursor to a new position
                obj.setCursor(index, false);

                // Behaviour
                if (! obj.options.multiple) {
                    // Update value
                    if (obj.items[index].selected) {
                        obj.setValue(null);
                    } else {
                        obj.setValue(Value(index));
                    }

                    // Close component
                    obj.close();
                } else {
                    // Old value
                    var oldValue = obj.options.value;

                    // Toggle option
                    if (obj.items[index].selected) {
                        obj.items[index].element.classList.remove('jdropdown-selected');
                        obj.items[index].selected = false;

                        delete obj.value[Value(index)];
                    } else {
                        // Select element
                        obj.items[index].element.classList.add('jdropdown-selected');
                        obj.items[index].selected = true;

                        // Set value
                        obj.value[Value(index)] = Text(index);
                    }

                    // Global value
                    obj.options.value = Object.keys(obj.value).join(';');

                    // Update labels for multiple dropdown
                    if (obj.options.autocomplete == false) {
                        obj.header.value = getText().join('; ');
                    }

                    // Events
                    change(oldValue);
                }
            }
        };

        obj.selectItem = function(item) {
            obj.selectIndex(item.indexValue);
        };

        var exists = function(k, result) {
            for (var j = 0; j < result.length; j++) {
                if (! obj.options.format) {
                    if (result[j].value == k) {
                        return true;
                    }
                } else {
                    if (result[j].id == k) {
                        return true;
                    }
                }
            }
            return false;
        };

        obj.find = function(str) {
            if (obj.search == str.trim()) {
                return false;
            }

            // Search term
            obj.search = str;

            // Results
            obj.numOfItems = 0;

            // Remove current items in the remote search
            if (obj.options.remoteSearch == true) {
                obj.currentIndex = null;
                obj.results = null;
                jSuites.ajax({
                    url: obj.options.url + '?q=' + str,
                    method: 'GET',
                    dataType: 'json',
                    success: function(result) {
                        // Reset items
                        obj.items = [];
                        content.innerHTML = '';
                        // Add the current selected items to the results in case they are not there
                        var current = Object.keys(obj.value);
                        if (current.length) {
                            for (var i = 0; i < current.length; i++) {
                                if (! exists(current[i], result)) {
                                    if (! obj.options.format) {
                                        result.unshift({ value: current[i], text: obj.value[current[i]] });
                                    } else {
                                        result.unshift({ id: current[i], name: obj.value[current[i]] });
                                    }
                                }
                            }
                        }
                        // Append data
                        obj.appendData(result);
                        // Show or hide results
                        if (! result.length) {
                            content.style.display = 'none';
                        } else {
                            content.style.display = '';
                        }
                    }
                });
            } else {
                // Search terms
                str = new RegExp(str, 'gi');

                // Reset search
                obj.results = [];

                // Append options
                for (var i = 0; i < obj.items.length; i++) {
                    // Item label
                    var label = Text(i);
                    // Item title
                    var title = obj.items[i].data.title || '';
                    // Group name
                    var groupName = obj.items[i].data.group || '';
                    // Synonym
                    var synonym = obj.items[i].data.synonym || '';
                    if (synonym) {
                        synonym = synonym.join(' ');
                    }

                    if (str == null || obj.items[i].selected == true || label.match(str) || title.match(str) || groupName.match(str) || synonym.match(str)) {
                        obj.results.push(obj.items[i]);

                        if (obj.items[i].group && obj.items[i].group.children[1].children[0]) {
                            // Remove all nodes
                            while (obj.items[i].group.children[1].children[0]) {
                                obj.items[i].group.children[1].removeChild(obj.items[i].group.children[1].children[0]);
                            }
                        }
                    }
                }

                // Remove all nodes
                while (content.children[0]) {
                    content.removeChild(content.children[0]);
                }

                // Show 200 items at once
                var number = obj.results.length || 0;

                // Lazyloading
                if (obj.options.lazyLoading == true && number > 200) {
                    number = 200;
                }

                for (var i = 0; i < number; i++) {
                    if (obj.results[i].group) {
                        if (! obj.results[i].group.parentNode) {
                            content.appendChild(obj.results[i].group);
                        }
                        obj.results[i].group.children[1].appendChild(obj.results[i].element);
                    } else {
                        content.appendChild(obj.results[i].element);
                    }
                    obj.numOfItems++;
                }

                if (! obj.results.length) {
                    content.style.display = 'none';
                } else {
                    content.style.display = '';
                }
            }
        };

        obj.open = function() {
            // Focus
            if (! el.classList.contains('jdropdown-focus')) {
                // Current dropdown
                jSuites.dropdown.current = obj;

                // Start tracking
                jSuites.tracking(obj, true);

                // Add focus
                el.classList.add('jdropdown-focus');

                // Animation
                if (jSuites.getWindowWidth() < 800) {
                    if (obj.options.type == null || obj.options.type == 'picker') {
                        jSuites.animation.slideBottom(container, 1);
                    }
                }

                // Filter
                if (obj.options.autocomplete == true) {
                    obj.header.value = obj.search;
                    obj.header.focus();
                }

                // Set cursor for the first or first selected element
                var k = Object.keys(getValue());
                if (k[0]) {
                    var cursor = obj.getPosition(k[0]);
                    if (cursor) {
                        obj.setCursor(cursor);
                    }
                }

                // Container Size
                if (! obj.options.type || obj.options.type == 'default') {
                    var rect = el.getBoundingClientRect();
                    var rectContainer = container.getBoundingClientRect();

                    if (obj.options.position) {
                        container.style.position = 'fixed';
                        if (window.innerHeight < rect.bottom + rectContainer.height) {
                            container.style.top = '';
                            container.style.bottom = (window.innerHeight - rect.top ) + 1 + 'px';
                        } else {
                            container.style.top = rect.bottom + 'px';
                            container.style.bottom = '';
                        }
                        container.style.left = rect.left + 'px';
                    } else {
                        if (window.innerHeight < rect.bottom + rectContainer.height) {
                            container.style.top = '';
                            container.style.bottom = rect.height + 1 + 'px';
                        } else {
                            container.style.top = '';
                            container.style.bottom = '';
                        }
                    }

                    container.style.minWidth = rect.width + 'px';

                    if (obj.options.maxWidth) {
                        container.style.maxWidth = obj.options.maxWidth;
                    }

                    if (! obj.items.length && obj.options.autocomplete == true) {
                        content.style.display = 'none';
                    } else {
                        content.style.display = '';
                    }
                }
            }

            // Events
            if (typeof(obj.options.onopen) == 'function') {
                obj.options.onopen(el);
            }
        };

        obj.close = function(ignoreEvents) {
            if (el.classList.contains('jdropdown-focus')) {
                // Update labels
                obj.header.value = obj.getText();
                // Remove cursor
                obj.setCursor();
                // Events
                if (! ignoreEvents && typeof(obj.options.onclose) == 'function') {
                    obj.options.onclose(el);
                }
                // Blur
                if (obj.header.blur) {
                    obj.header.blur();
                }
                // Remove focus
                el.classList.remove('jdropdown-focus');
                // Start tracking
                jSuites.tracking(obj, false);
                // Current dropdown
                jSuites.dropdown.current = null;
            }

            return obj.getValue();
        };

        /**
         * Set cursor
         */
        obj.setCursor = function(index, setPosition) {
            // Remove current cursor
            if (obj.currentIndex != null) {
                // Remove visual cursor
                if (obj.items && obj.items[obj.currentIndex]) {
                    obj.items[obj.currentIndex].element.classList.remove('jdropdown-cursor');
                }
            }

            if (index == undefined) {
                obj.currentIndex = null;
            } else {

                obj.items[index].element.classList.add('jdropdown-cursor');
                obj.currentIndex = index;

                // Update scroll to the cursor element
                if (setPosition !== false && obj.items[obj.currentIndex].element) {
                    content.scrollTop;
                    var element = obj.items[obj.currentIndex].element;
                    content.scrollTop = element.offsetTop - element.scrollTop + element.clientTop - 95;
                }
            }
        };

        // Compatibility
        obj.resetCursor = obj.setCursor;
        obj.updateCursor = obj.setCursor;

        /**
         * Reset cursor and selected items
         */
        obj.reset = function() {
            // Reset cursor
            obj.setCursor();

            // Reset selected
            obj.setValue(null);
        };

        /**
         * First visible item
         */
        obj.firstVisible = function() {
            var newIndex = null;
            for (var i = 0; i < obj.items.length; i++) {
                if (obj.items && obj.items[i] && obj.items[i].element.parentNode && obj.items[i].element.style.display != 'none') {
                    newIndex = i;
                    break;
                }
            }

            if (newIndex == null) {
                return false;
            }

            obj.setCursor(newIndex);
        };

        /**
         * Navigation
         */
        obj.first = function() {
            var newIndex = null;
            for (var i = obj.currentIndex - 1; i >= 0; i--) {
                if (obj.items && obj.items[i] && obj.items[i].element.parentNode && obj.items[i].element.style.display != 'none') {
                    newIndex = i;
                }
            }

            if (newIndex == null) {
                return false;
            }

            obj.setCursor(newIndex);
        };

        obj.last = function() {
            var newIndex = null;
            for (var i = obj.currentIndex + 1; i < obj.items.length; i++) {
                if (obj.items && obj.items[i] && obj.items[i].element.parentNode && obj.items[i].element.style.display != 'none') {
                    newIndex = i;
                }
            }

            if (newIndex == null) {
                return false;
            }

            obj.setCursor(newIndex);
        };

        var next = function(index, letter) {
            for (var i = index; i < obj.items.length; i++) {
                if (obj.items && obj.items[i] && obj.items[i].element.parentNode && (! letter || (''+Text(i)).substr(0,1).toLowerCase() == letter)) {
                    return i;
                }
            }

            return null;
        };

        obj.next = function(letter) {
            if (letter && letter.length == 1) {
                letter = letter.toLowerCase();
            }

            if (obj.currentIndex === null) {
                var index = obj.currentIndex = 0;
            } else {
                var index = obj.currentIndex + 1;
            }

            // Try to find the next from the current position
            var newIndex = next(index, letter);

            if (newIndex == null && letter) {
                // Trying to find from the begining
                newIndex = next(0, letter);
                // Did not find
                if (newIndex == null) {
                    return false;
                }
            }

            // Set cursor
            obj.setCursor(newIndex);
        };

        obj.prev = function() {
            var newIndex = null;
            for (var i = obj.currentIndex - 1; i >= 0; i--) {
                if (obj.items && obj.items[i] && obj.items[i].element.parentNode) {
                    newIndex = i;
                    break;
                }
            }

            if (newIndex == null) {
                return false;
            }

            obj.setCursor(newIndex);
        };

        obj.loadUp = function() {
            return false;
        };

        obj.loadDown = function() {
            var test = false;

            // Search
            if (obj.results) {
                var results = obj.results;
            } else {
                var results = obj.items;
            }

            if (results.length > obj.numOfItems) {
                var numberOfItems = obj.numOfItems;
                var number = results.length - numberOfItems;
                if (number > 200) {
                    number = 200;
                }

                for (var i = numberOfItems; i < numberOfItems + number; i++) {
                    if (results[i].group) {
                        if (! results[i].group.parentNode) {
                            content.appendChild(results[i].group);
                        }
                        results[i].group.children[2].appendChild(results[i].element);
                    } else {
                        content.appendChild(results[i].element);
                    }

                    obj.numOfItems++;
                }

                // New item added
                test = true;
            }

            return test;
        };

        init();

        return obj;
    });

    jSuites.dropdown.keydown = function(e) {
        var dropdown = null;
        if (dropdown = jSuites.dropdown.current) {
            if (e.which == 13) {
                dropdown.selectIndex(dropdown.currentIndex);
            } else if (e.which == 38) {
                if (dropdown.currentIndex == null) {
                    dropdown.firstVisible();
                } else if (dropdown.currentIndex > 0) {
                    dropdown.prev();
                }
                e.preventDefault();
            } else if (e.which == 40) {
                if (dropdown.currentIndex == null) {
                    dropdown.firstVisible();
                } else if (dropdown.currentIndex + 1 < dropdown.items.length) {
                    dropdown.next();
                }
                e.preventDefault();
            } else if (e.which == 36) {
                dropdown.first();
            } else if (e.which == 35) {
                dropdown.last();
            } else if (e.which == 27) {
                dropdown.close();
            }
        }
    };

    jSuites.dropdown.mouseup = function(e) {
        var element = jSuites.findElement(e.target, 'jdropdown');
        if (element) {
            var dropdown = element.dropdown;
            if (e.target.classList.contains('jdropdown-header')) {
                if (element.classList.contains('jdropdown-focus') && element.classList.contains('jdropdown-default')) {
                    var rect = element.getBoundingClientRect();

                    if (e.changedTouches && e.changedTouches[0]) {
                        var x = e.changedTouches[0].clientX;
                        e.changedTouches[0].clientY;
                    } else {
                        var x = e.clientX;
                        e.clientY;
                    }

                    if (rect.width - (x - rect.left) < 30) {
                        if (e.target.classList.contains('jdropdown-add')) {
                            dropdown.add();
                        } else {
                            dropdown.close();
                        }
                    } else {
                        if (dropdown.options.autocomplete == false) {
                            dropdown.close();
                        }
                    }
                } else {
                    dropdown.open();
                }
            } else if (e.target.classList.contains('jdropdown-group-name')) {
                var items = e.target.nextSibling.children;
                if (e.target.nextSibling.style.display != 'none') {
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].style.display != 'none') {
                            dropdown.selectItem(items[i]);
                        }
                    }
                }
            } else if (e.target.classList.contains('jdropdown-group-arrow')) {
                if (e.target.classList.contains('jdropdown-group-arrow-down')) {
                    e.target.classList.remove('jdropdown-group-arrow-down');
                    e.target.classList.add('jdropdown-group-arrow-up');
                    e.target.parentNode.nextSibling.style.display = 'none';
                } else {
                    e.target.classList.remove('jdropdown-group-arrow-up');
                    e.target.classList.add('jdropdown-group-arrow-down');
                    e.target.parentNode.nextSibling.style.display = '';
                }
            } else if (e.target.classList.contains('jdropdown-item')) {
                dropdown.selectItem(e.target);
            } else if (e.target.classList.contains('jdropdown-image')) {
                dropdown.selectItem(e.target.parentNode);
            } else if (e.target.classList.contains('jdropdown-description')) {
                dropdown.selectItem(e.target.parentNode);
            } else if (e.target.classList.contains('jdropdown-title')) {
                dropdown.selectItem(e.target.parentNode.parentNode);
            } else if (e.target.classList.contains('jdropdown-close') || e.target.classList.contains('jdropdown-backdrop')) {
                dropdown.close();
            }
        }
    };

    jSuites.dropdown.extractFromDom = function(el, options) {
        // Keep reference
        var select = el;
        if (! options) {
            options = {};
        }
        // Prepare configuration
        if (el.getAttribute('multiple') && (! options || options.multiple == undefined)) {
            options.multiple = true;
        }
        if (el.getAttribute('placeholder') && (! options || options.placeholder == undefined)) {
            options.placeholder = el.getAttribute('placeholder');
        }
        if (el.getAttribute('data-autocomplete') && (! options || options.autocomplete == undefined)) {
            options.autocomplete = true;
        }
        if (! options || options.width == undefined) {
            options.width = el.offsetWidth;
        }
        if (el.value && (! options || options.value == undefined)) {
            options.value = el.value;
        }
        if (! options || options.data == undefined) {
            options.data = [];
            for (var j = 0; j < el.children.length; j++) {
                if (el.children[j].tagName == 'OPTGROUP') {
                    for (var i = 0; i < el.children[j].children.length; i++) {
                        options.data.push({
                            value: el.children[j].children[i].value,
                            text: el.children[j].children[i].innerHTML,
                            group: el.children[j].getAttribute('label'),
                        });
                    }
                } else {
                    options.data.push({
                        value: el.children[j].value,
                        text: el.children[j].innerHTML,
                    });
                }
            }
        }
        if (! options || options.onchange == undefined) {
            options.onchange = function(a,b,c,d) {
                if (options.multiple == true) {
                    if (obj.items[b].classList.contains('jdropdown-selected')) {
                        select.options[b].setAttribute('selected', 'selected');
                    } else {
                        select.options[b].removeAttribute('selected');
                    }
                } else {
                    select.value = d;
                }
            };
        }
        // Create DIV
        var div = document.createElement('div');
        el.parentNode.insertBefore(div, el);
        el.style.display = 'none';
        el = div;

        return { el:el, options:options };
    };

    jSuites.editor = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            // Initial HTML content
            value: null,
            // Initial snippet
            snippet: null,
            // Add toolbar
            toolbar: null,
            // Website parser is to read websites and images from cross domain
            remoteParser: null,
            // Placeholder
            placeholder: null,
            // Parse URL
            parseURL: false,
            filterPaste: true,
            // Accept drop files
            dropZone: false,
            dropAsSnippet: false,
            acceptImages: false,
            acceptFiles: false,
            maxFileSize: 5000000,
            allowImageResize: true,
            // Style
            border: true,
            padding: true,
            maxHeight: null,
            height: null,
            focus: false,
            // Events
            onclick: null,
            onfocus: null,
            onblur: null,
            onload: null,
            onkeyup: null,
            onkeydown: null,
            onchange: null,
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }
        var editorTimer = null;
        var editorAction = null;
        var files = [];

        // Make sure element is empty
        el.innerHTML = '';

        // Keep the reference for the container
        obj.el = el;

        if (typeof(obj.options.onclick) == 'function') {
            el.onclick = function(e) {
                obj.options.onclick(el, obj, e);
            };
        }

        // Prepare container
        el.classList.add('jeditor-container');

        // Padding
        if (obj.options.padding == true) {
            el.classList.add('jeditor-padding');
        }

        // Border
        if (obj.options.border == false) {
            el.style.border = '0px';
        }

        // Snippet
        var snippet = document.createElement('div');
        snippet.className = 'jsnippet';
        snippet.setAttribute('contenteditable', false);

        // Toolbar
        var toolbar = document.createElement('div');
        toolbar.className = 'jeditor-toolbar';

        // Create editor
        var editor = document.createElement('div');
        editor.setAttribute('contenteditable', true);
        editor.setAttribute('spellcheck', false);
        editor.className = 'jeditor';

        // Placeholder
        if (obj.options.placeholder) {
            editor.setAttribute('data-placeholder', obj.options.placeholder);
        }

        // Max height
        if (obj.options.maxHeight || obj.options.height) {
            editor.style.overflowY = 'auto';

            if (obj.options.maxHeight) {
                editor.style.maxHeight = obj.options.maxHeight;
            }
            if (obj.options.height) {
                editor.style.height = obj.options.height;
            }
        }

        // Set editor initial value
        if (obj.options.value) {
            var value = obj.options.value;
        } else {
            var value = el.innerHTML ? el.innerHTML : ''; 
        }

        if (! value) {
            var value = '';
        }

        /**
         * Onchange event controllers
         */
        var change = function(e) {
            if (typeof(obj.options.onchange) == 'function') { 
                obj.options.onchange(el, obj, e);
            }

            // Update value
            obj.options.value = obj.getData();

            // Lemonade JS
            if (el.value != obj.options.value) {
                el.value = obj.options.value;
                if (typeof(el.onchange) == 'function') {
                    el.onchange({
                        type: 'change',
                        target: el,
                        value: el.value
                    });
                }
            }
        };

        /**
         * Extract images from a HTML string
         */
        var extractImageFromHtml = function(html) {
            // Create temp element
            var div = document.createElement('div');
            div.innerHTML = html;

            // Extract images
            var img = div.querySelectorAll('img');

            if (img.length) {
                for (var i = 0; i < img.length; i++) {
                    obj.addImage(img[i].src);
                }
            }
        };

        /**
         * Insert node at caret
         */
        var insertNodeAtCaret = function(newNode) {
            var sel, range;

            if (window.getSelection) {
                sel = window.getSelection();
                if (sel.rangeCount) {
                    range = sel.getRangeAt(0);
                    range.toString();
                    range.deleteContents();
                    range.insertNode(newNode); 
                    // move the cursor after element
                    range.setStartAfter(newNode);
                    range.setEndAfter(newNode); 
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
        };

        var updateTotalImages = function() {
            var o = null;
            if (o = snippet.children[0]) {
                // Make sure is a grid
                if (! o.classList.contains('jslider-grid')) {
                    o.classList.add('jslider-grid');
                }
                // Quantify of images
                var number = o.children.length;
                // Set the configuration of the grid
                o.setAttribute('data-number', number > 4 ? 4 : number);
                // Total of images inside the grid
                if (number > 4) {
                    o.setAttribute('data-total', number - 4);
                } else {
                    o.removeAttribute('data-total');
                }
            }
        };

        /**
         * Append image to the snippet
         */
        var appendImage = function(image) {
            if (! snippet.innerHTML) {
                appendElement({});
            }
            snippet.children[0].appendChild(image);
            updateTotalImages();
        };

        /**
         * Append snippet
         * @Param object data
         */
        var appendElement = function(data) {
            // Reset snippet
            snippet.innerHTML = '';

            // Attributes
            var a = [ 'image', 'title', 'description', 'host', 'url' ];

            for (var i = 0; i < a.length; i++) {
                var div = document.createElement('div');
                div.className = 'jsnippet-' + a[i];
                div.setAttribute('data-k', a[i]);
                snippet.appendChild(div);
                if (data[a[i]]) {
                    if (a[i] == 'image') {
                        if (! Array.isArray(data.image)) {
                            data.image = [ data.image ];
                        }
                        for (var j = 0; j < data.image.length; j++) {
                            var img = document.createElement('img');
                            img.src = data.image[j];
                            div.appendChild(img);
                        }
                    } else {
                        div.innerHTML = data[a[i]];
                    }
                }
            }

            editor.appendChild(document.createElement('br'));
            editor.appendChild(snippet);
        };

        var verifyEditor = function() {
            clearTimeout(editorTimer);
            editorTimer = setTimeout(function() {
                var snippet = editor.querySelector('.jsnippet');
                if (! snippet) {
                    var html = editor.innerHTML.replace(/\n/g, ' ');
                    var container = document.createElement('div');
                    container.innerHTML = html;
                    var text = container.innerText; 
                    var url = jSuites.editor.detectUrl(text);

                    if (url) {
                        if (url[0].substr(-3) == 'jpg' || url[0].substr(-3) == 'png' || url[0].substr(-3) == 'gif') {
                             obj.addImage(url[0], true);
                        } else {
                            var id = jSuites.editor.youtubeParser(url[0]);
                            obj.parseWebsite(url[0], id);
                        }
                    }
                }
            }, 1000);
        };

        obj.parseContent = function() {
            verifyEditor();
        };

        obj.parseWebsite = function(url, youtubeId) {
            if (! obj.options.remoteParser) {
                console.log('The remoteParser is not defined');
            } else {
                // Youtube definitions
                if (youtubeId) {
                    var url = 'https://www.youtube.com/watch?v=' + youtubeId;
                }

                var p = {
                    title: '',
                    description: '',
                    image: '',
                    host: url.split('/')[2],
                    url: url,
                };

                jSuites.ajax({
                    url: obj.options.remoteParser + encodeURI(url.trim()),
                    method: 'GET',
                    dataType: 'json',
                    success: function(result) {
                        // Get title
                        if (result.title) {
                            p.title = result.title;
                        }
                        // Description
                        if (result.description) {
                            p.description = result.description;
                        }
                        // Host
                        if (result.host) {
                            p.host = result.host;
                        }
                        // Url
                        if (result.url) {
                            p.url = result.url;
                        }
                        // Append snippet
                        appendElement(p);
                        // Add image
                        if (result.image) {
                            obj.addImage(result.image, true);
                        } else if (result['og:image']) {
                            obj.addImage(result['og:image'], true);
                        }
                    }
                });
            }
        };

        /**
         * Set editor value
         */
        obj.setData = function(html) {
            editor.innerHTML = html;

            if (obj.options.focus) {
                jSuites.editor.setCursor(editor, true);
            }

            // Reset files container
            files = [];
        };

        obj.getFiles = function() {
            var f = editor.querySelectorAll('.jfile');
            var d = [];
            for (var i = 0; i < f.length; i++) {
                if (files[f[i].src]) {
                    d.push(files[f[i].src]);
                }
            }
            return d;
        };

        obj.getText = function() {
            return editor.innerText;
        };

        /**
         * Get editor data
         */
        obj.getData = function(json) {
            if (! json) {
                var data = editor.innerHTML;
            } else {
                var data = {
                    content : '',
                };

                // Get snippet
                if (snippet.innerHTML) {
                    data.snippet = {};
                    for (var i = 0; i < snippet.children.length; i++) {
                        // Get key from element
                        var key = snippet.children[i].getAttribute('data-k');
                        if (key) {
                            if (key == 'image') {
                                if (! data.snippet.image) {
                                    data.snippet.image = [];
                                }
                                // Get all images
                                for (var j = 0; j < snippet.children[i].children.length; j++) {
                                    data.snippet.image.push(snippet.children[i].children[j].getAttribute('src'));
                                }
                            } else {
                                data.snippet[key] = snippet.children[i].innerHTML;
                            }
                        }
                    }
                }

                // Get files
                var f = Object.keys(files);
                if (f.length) {
                    data.files = [];
                    for (var i = 0; i < f.length; i++) {
                        data.files.push(files[f[i]]);
                    }
                }

                // Get content
                var text = editor.innerHTML;
                text = text.replace(/<br>/g, "\n");
                text = text.replace(/<\/div>/g, "<\/div>\n");
                text = text.replace(/<(?:.|\n)*?>/gm, "");
                data.content = text.trim();
            }

            return data;
        };

        // Reset
        obj.reset = function() {
            editor.innerHTML = '';
            snippet.innerHTML = '';
            files = [];
        };

        obj.addPdf = function(data) {
            if (data.result.substr(0,4) != 'data') {
                console.error('Invalid source');
            } else {
                var canvas = document.createElement('canvas');
                canvas.width = 60;
                canvas.height = 60;

                var img = new Image();
                var ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(function(blob) {
                    var newImage = document.createElement('img');
                    newImage.src = window.URL.createObjectURL(blob);
                    newImage.title = data.name;
                    newImage.className = 'jfile pdf';

                    files[newImage.src] = {
                        file: newImage.src,
                        extension: 'pdf',
                        content: data.result,
                    };

                    insertNodeAtCaret(newImage);
                });
            }
        };

        obj.addImage = function(src, asSnippet) {
            if (src.substr(0,4) != 'data' && ! obj.options.remoteParser) {
                console.error('remoteParser not defined in your initialization');
            } else {
                // This is to process cross domain images
                if (src.substr(0,4) == 'data') {
                    var extension = src.split(';');
                    extension = extension[0].split('/');
                    extension = extension[1];
                } else {
                    var extension = src.substr(src.lastIndexOf('.') + 1);
                    // Work for cross browsers
                    src = obj.options.remoteParser + src;
                }

                var img = new Image();

                img.onload = function onload() {
                    var canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    canvas.toBlob(function(blob) {
                        var newImage = document.createElement('img');
                        newImage.src = window.URL.createObjectURL(blob);
                        newImage.classList.add('jfile');
                        newImage.setAttribute('tabindex', '900');
                        files[newImage.src] = {
                            file: newImage.src,
                            extension: extension,
                            content: canvas.toDataURL(),
                        };

                        if (obj.options.dropAsSnippet || asSnippet) {
                            appendImage(newImage);
                            // Just to understand the attachment is part of a snippet
                            files[newImage.src].snippet = true;
                        } else {
                            insertNodeAtCaret(newImage);
                        }

                        change();
                    });
                };

                img.src = src;
            }
        };

        obj.addFile = function(files) {
            var reader = [];

            for (var i = 0; i < files.length; i++) {
                if (files[i].size > obj.options.maxFileSize) {
                    alert('The file is too big');
                } else {
                    // Only PDF or Images
                    var type = files[i].type.split('/');

                    if (type[0] == 'image') {
                        type = 1;
                    } else if (type[1] == 'pdf') {
                        type = 2;
                    } else {
                        type = 0;
                    }

                    if (type) {
                        // Create file
                        reader[i] = new FileReader();
                        reader[i].index = i;
                        reader[i].type = type;
                        reader[i].name = files[i].name;
                        reader[i].date = files[i].lastModified;
                        reader[i].size = files[i].size;
                        reader[i].addEventListener("load", function (data) {
                            // Get result
                            if (data.target.type == 2) {
                                if (obj.options.acceptFiles == true) {
                                    obj.addPdf(data.target);
                                }
                            } else {
                                obj.addImage(data.target.result);
                            }
                        }, false);

                        reader[i].readAsDataURL(files[i]);
                    } else {
                        alert('The extension is not allowed');
                    }
                }
            }
        };

        // Destroy
        obj.destroy = function() {
            editor.removeEventListener('mouseup', editorMouseUp);
            editor.removeEventListener('mousedown', editorMouseDown);
            editor.removeEventListener('mousemove', editorMouseMove);
            editor.removeEventListener('keyup', editorKeyUp);
            editor.removeEventListener('keydown', editorKeyDown);
            editor.removeEventListener('dragstart', editorDragStart);
            editor.removeEventListener('dragenter', editorDragEnter);
            editor.removeEventListener('dragover', editorDragOver);
            editor.removeEventListener('drop', editorDrop);
            editor.removeEventListener('paste', editorPaste);

            if (typeof(obj.options.onblur) == 'function') {
                editor.removeEventListener('blur', editorBlur);
            }
            if (typeof(obj.options.onfocus) == 'function') {
                editor.removeEventListener('focus', editorFocus);
            }

            el.editor = null;
            el.classList.remove('jeditor-container');

            toolbar.remove();
            snippet.remove();
            editor.remove();
        };

        // Event handlers
        var editorMouseUp = function(e) {
            if (editorAction && editorAction.e) {
                editorAction.e.classList.remove('resizing');
            }

            editorAction = false;
        };

        var editorMouseDown = function(e) {
            var close = function(snippet) {
                var rect = snippet.getBoundingClientRect();
                if (rect.width - (e.clientX - rect.left) < 40 && e.clientY - rect.top < 40) {
                    snippet.innerHTML = '';
                    snippet.remove();
                }
            };

            if (e.target.tagName == 'IMG') {
                if (e.target.style.cursor) {
                    var rect = e.target.getBoundingClientRect();
                    editorAction = {
                        e: e.target,
                        x: e.clientX,
                        y: e.clientY,
                        w: rect.width,
                        h: rect.height,
                        d: e.target.style.cursor,
                    };

                    if (! e.target.width) {
                        e.target.width = rect.width + 'px';
                    }

                    if (! e.target.height) {
                        e.target.height = rect.height + 'px';
                    }

                    var s = window.getSelection();
                    if (s.rangeCount) {
                        for (var i = 0; i < s.rangeCount; i++) {
                            s.removeRange(s.getRangeAt(i));
                        }
                    }

                    e.target.classList.add('resizing');
                } else {
                    editorAction = true;
                }
            } else { 
                if (e.target.classList.contains('jsnippet')) {
                    close(e.target);
                } else if (e.target.parentNode.classList.contains('jsnippet')) {
                    close(e.target.parentNode);
                }

                editorAction = true;
            }
        };

        var editorMouseMove = function(e) {
            if (e.target.tagName == 'IMG' && ! e.target.parentNode.classList.contains('jsnippet-image') && obj.options.allowImageResize == true) {
                if (e.target.getAttribute('tabindex')) {
                    var rect = e.target.getBoundingClientRect();
                    if (e.clientY - rect.top < 5) {
                        if (rect.width - (e.clientX - rect.left) < 5) {
                            e.target.style.cursor = 'ne-resize';
                        } else if (e.clientX - rect.left < 5) {
                            e.target.style.cursor = 'nw-resize';
                        } else {
                            e.target.style.cursor = 'n-resize';
                        }
                    } else if (rect.height - (e.clientY - rect.top) < 5) {
                        if (rect.width - (e.clientX - rect.left) < 5) {
                            e.target.style.cursor = 'se-resize';
                        } else if (e.clientX - rect.left < 5) {
                            e.target.style.cursor = 'sw-resize';
                        } else {
                            e.target.style.cursor = 's-resize';
                        }
                    } else if (rect.width - (e.clientX - rect.left) < 5) {
                        e.target.style.cursor = 'e-resize';
                    } else if (e.clientX - rect.left < 5) {
                        e.target.style.cursor = 'w-resize';
                    } else {
                        e.target.style.cursor = '';
                    }
                }
            }

            // Move
            if (e.which == 1 && editorAction && editorAction.d) {
                if (editorAction.d == 'e-resize' || editorAction.d == 'ne-resize' ||  editorAction.d == 'se-resize') {
                    editorAction.e.width = (editorAction.w + (e.clientX - editorAction.x));

                    if (e.shiftKey) {
                        var newHeight = (e.clientX - editorAction.x) * (editorAction.h / editorAction.w);
                        editorAction.e.height = editorAction.h + newHeight;
                    } else {
                        var newHeight =  null;
                    }
                }

                if (! newHeight) {
                    if (editorAction.d == 's-resize' || editorAction.d == 'se-resize' || editorAction.d == 'sw-resize') {
                        if (! e.shiftKey) {
                            editorAction.e.height = editorAction.h + (e.clientY - editorAction.y);
                        }
                    }
                }
            }
        };

        var editorKeyUp = function(e) {
            if (! editor.innerHTML) {
                editor.innerHTML = '<div><br></div>';
            }

            if (typeof(obj.options.onkeyup) == 'function') { 
                obj.options.onkeyup(el, obj, e);
            }
        };


        var editorKeyDown = function(e) {
            // Check for URL
            if (obj.options.parseURL == true) {
                verifyEditor();
            }

            if (typeof(obj.options.onkeydown) == 'function') { 
                obj.options.onkeydown(el, obj, e);
            }

            if (e.key == 'Delete') {
                if (e.target.tagName == 'IMG' && e.target.parentNode.classList.contains('jsnippet-image')) {
                    e.target.remove();
                    updateTotalImages();
                }
            }
        };

        // Elements to be removed
        var remove = [HTMLUnknownElement];

        // Valid CSS attributes
        var validStyle = ['color', 'font-weight', 'font-size', 'background', 'background-color', 'margin'];

        var parse = function(element) {
           // Remove attributes
           if (element.attributes && element.attributes.length) {
               var style = null;
               // Process style attribute
               var elementStyle = element.getAttribute('style');
               if (elementStyle) {
                   style = [];
                   var t = elementStyle.split(';');
                   for (var j = 0; j < t.length; j++) {
                       var v = t[j].trim().split(':');
                       if (validStyle.indexOf(v[0].trim()) >= 0) {
                           var k = v.shift();
                           var v = v.join(':');
                           style.push(k + ':' + v);
                       }
                   }
               }
               // Process image
               if (element.tagName == 'IMG') {
                   if (! obj.options.acceptImages) {
                       element.remove();
                   } else {
                       // Check if is data
                       element.setAttribute('tabindex', '900');
                       // Check attributes for persistance
                       obj.addImage(element.src);
                   }
               } else {
                   // Remove attributes
                   var numAttributes = element.attributes.length - 1;
                   for (var i = numAttributes; i >= 0 ; i--) {
                       element.removeAttribute(element.attributes[i].name);
                   }
               }
               element.style = '';
               // Add valid style
               if (style && style.length) {
                   element.setAttribute('style', style.join(';'));
               }
           }
           // Parse children
           if (element.children.length) {
               for (var i = 0; i < element.children.length; i++) {
                   parse(element.children[i]);
               }
           }

           if (remove.indexOf(element.constructor) >= 0) {
               element.remove();
           }
        };

        var filter = function(data) {
            if (data) {
                data = data.replace(new RegExp('<!--(.*?)-->', 'gsi'), '');
            }
            var span = document.createElement('span');
            span.innerHTML = data;
            parse(span);
            return span;
        }; 

        var editorPaste = function(e) {
            if (obj.options.filterPaste == true) {
                if (e.clipboardData || e.originalEvent.clipboardData) {
                    var html = (e.originalEvent || e).clipboardData.getData('text/html');
                    var text = (e.originalEvent || e).clipboardData.getData('text/plain');
                    var file = (e.originalEvent || e).clipboardData.files;
                } else if (window.clipboardData) {
                    var html = window.clipboardData.getData('Html');
                    var text = window.clipboardData.getData('Text');
                    var file = window.clipboardData.files;
                }

                if (file.length) {
                    // Paste a image from the clipboard
                    obj.addFile(file);
                } else {
                    if (! html) {
                        html = text.split('\r\n');
                        if (! e.target.innerText) {
                            html.map(function(v) {
                                var d = document.createElement('div');
                                d.innerText = v;
                                editor.appendChild(d);
                            });
                        } else {
                            html = html.map(function(v) {
                                return '<div>' + v + '</div>';
                            });
                            document.execCommand('insertHtml', false, html.join(''));
                        }
                    } else {
                        var d = filter(html);
                        // Paste to the editor
                        insertNodeAtCaret(d);
                    }
                }

                e.preventDefault();
            }
        };

        var editorDragStart = function(e) {
            if (editorAction && editorAction.e) {
                e.preventDefault();
            }
        };

        var editorDragEnter = function(e) {
            if (editorAction || obj.options.dropZone == false) ; else {
                el.classList.add('jeditor-dragging');
                e.preventDefault();
            }
        };

        var editorDragOver = function(e) {
            if (editorAction || obj.options.dropZone == false) ; else {
                if (editorTimer) {
                    clearTimeout(editorTimer);
                }

                editorTimer = setTimeout(function() {
                    el.classList.remove('jeditor-dragging');
                }, 100);
                e.preventDefault();
            }
        };

        var editorDrop = function(e) {
            if (editorAction || obj.options.dropZone == false) ; else {
                // Position caret on the drop
                var range = null;
                if (document.caretRangeFromPoint) {
                    range=document.caretRangeFromPoint(e.clientX, e.clientY);
                } else if (e.rangeParent) {
                    range=document.createRange();
                    range.setStart(e.rangeParent,e.rangeOffset);
                }
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                sel.anchorNode.parentNode.focus();

                var html = (e.originalEvent || e).dataTransfer.getData('text/html');
                var text = (e.originalEvent || e).dataTransfer.getData('text/plain');
                var file = (e.originalEvent || e).dataTransfer.files;
        
                if (file.length) {
                    obj.addFile(file);
                } else if (text) {
                    extractImageFromHtml(html);
                }

                el.classList.remove('jeditor-dragging');
                e.preventDefault();
            }
        };

        var editorBlur = function(e) {
            // Blur
            if (typeof(obj.options.onblur) == 'function') {
                obj.options.onblur(el, obj, e);
            }

            change(e);
        };

        var editorFocus = function(e) {
            // Focus
            if (typeof(obj.options.onfocus) == 'function') {
                obj.options.onfocus(el, obj, e);
            }
        };

        editor.addEventListener('mouseup', editorMouseUp);
        editor.addEventListener('mousedown', editorMouseDown);
        editor.addEventListener('mousemove', editorMouseMove);
        editor.addEventListener('keyup', editorKeyUp);
        editor.addEventListener('keydown', editorKeyDown);
        editor.addEventListener('dragstart', editorDragStart);
        editor.addEventListener('dragenter', editorDragEnter);
        editor.addEventListener('dragover', editorDragOver);
        editor.addEventListener('drop', editorDrop);
        editor.addEventListener('paste', editorPaste);
        editor.addEventListener('focus', editorFocus);
        editor.addEventListener('blur', editorBlur);

        // Onload
        if (typeof(obj.options.onload) == 'function') {
            obj.options.onload(el, obj, editor);
        }

        // Set value to the editor
        editor.innerHTML = value;

        // Append editor to the containre
        el.appendChild(editor);

        // Snippet
        if (obj.options.snippet) {
            appendElement(obj.options.snippet);
        }

        // Default toolbar
        if (obj.options.toolbar == null) {
            obj.options.toolbar = jSuites.editor.getDefaultToolbar();
        }

        // Add toolbar
        if (obj.options.toolbar) {
            // Append to the DOM
            el.appendChild(toolbar);
            // Create toolbar
            jSuites.toolbar(toolbar, {
                container: true,
                items: obj.options.toolbar
            });
        }

        // Focus to the editor
        if (obj.options.focus) {
            jSuites.editor.setCursor(editor, obj.options.focus == 'initial' ? true : false);
        }

        // Change method
        el.change = obj.setData;

        // Global generic value handler
        el.val = function(val) {
            if (val === undefined) {
                // Data type
                var o = el.getAttribute('data-html') === 'true' ? false : true;
                return obj.getData(o);
            } else {
                obj.setData(val);
            }
        };

        el.editor = obj;

        return obj;
    });

    jSuites.editor.setCursor = function(element, first) {
        element.focus();
        document.execCommand('selectAll');
        var sel = window.getSelection();
        var range = sel.getRangeAt(0);
        if (first == true) {
            var node = range.startContainer;
            var size = 0;
        } else {
            var node = range.endContainer;
            var size = node.length;
        }
        range.setStart(node, size);
        range.setEnd(node, size);
        sel.removeAllRanges();
        sel.addRange(range);
    };

    jSuites.editor.getDomain = function(url) {
        return url.replace('http://','').replace('https://','').replace('www.','').split(/[/?#]/)[0].split(/:/g)[0];
    };

    jSuites.editor.detectUrl = function(text) {
        var expression = /(((https?:\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]+)/ig;
        var links = text.match(expression);

        if (links) {
            if (links[0].substr(0,3) == 'www') {
                links[0] = 'http://' + links[0];
            }
        }

        return links;
    };

    jSuites.editor.youtubeParser = function(url) {
        var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
        var match = url.match(regExp);

        return (match && match[7].length == 11) ? match[7] : false;
    };

    jSuites.editor.getDefaultToolbar = function() { 
        return [
            {
                content: 'undo',
                onclick: function() {
                    document.execCommand('undo');
                }
            },
            {
                content: 'redo',
                onclick: function() {
                    document.execCommand('redo');
                }
            },
            {
                type:'divisor'
            },
            {
                content: 'format_bold',
                onclick: function(a,b,c) {
                    document.execCommand('bold');

                    if (document.queryCommandState("bold")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                content: 'format_italic',
                onclick: function(a,b,c) {
                    document.execCommand('italic');

                    if (document.queryCommandState("italic")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                content: 'format_underline',
                onclick: function(a,b,c) {
                    document.execCommand('underline');

                    if (document.queryCommandState("underline")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                type:'divisor'
            },
            {
                content: 'format_list_bulleted',
                onclick: function(a,b,c) {
                    document.execCommand('insertUnorderedList');

                    if (document.queryCommandState("insertUnorderedList")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                content: 'format_list_numbered',
                onclick: function(a,b,c) {
                    document.execCommand('insertOrderedList');

                    if (document.queryCommandState("insertOrderedList")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                content: 'format_indent_increase',
                onclick: function(a,b,c) {
                    document.execCommand('indent', true, null);

                    if (document.queryCommandState("indent")) {
                        c.classList.add('selected');
                    } else {
                        c.classList.remove('selected');
                    }
                }
            },
            {
                content: 'format_indent_decrease',
                onclick: function() {
                    document.execCommand('outdent');

                    if (document.queryCommandState("outdent")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            }/*,
            {
                icon: ['format_align_left', 'format_align_right', 'format_align_center'],
                onclick: function() {
                    document.execCommand('justifyCenter');

                    if (document.queryCommandState("justifyCenter")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            }
            {
                type:'select',
                items: ['Verdana','Arial','Courier New'],
                onchange: function() {
                }
            },
            {
                type:'select',
                items: ['10px','12px','14px','16px','18px','20px','22px'],
                onchange: function() {
                }
            },
            {
                icon:'format_align_left',
                onclick: function() {
                    document.execCommand('JustifyLeft');

                    if (document.queryCommandState("JustifyLeft")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            },
            {
                icon:'format_align_center',
                onclick: function() {
                    document.execCommand('justifyCenter');

                    if (document.queryCommandState("justifyCenter")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            },
            {
                icon:'format_align_right',
                onclick: function() {
                    document.execCommand('justifyRight');

                    if (document.queryCommandState("justifyRight")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            },
            {
                icon:'format_align_justify',
                onclick: function() {
                    document.execCommand('justifyFull');

                    if (document.queryCommandState("justifyFull")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            },
            {
                icon:'format_list_bulleted',
                onclick: function() {
                    document.execCommand('insertUnorderedList');

                    if (document.queryCommandState("insertUnorderedList")) {
                        this.classList.add('selected');
                    } else {
                        this.classList.remove('selected');
                    }
                }
            }*/
        ];
    };


    jSuites.form = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            url: null,
            message: 'Are you sure? There are unsaved information in your form',
            ignore: false,
            currentHash: null,
            submitButton:null,
            validations: null,
            onbeforeload: null,
            onload: null,
            onbeforesave: null,
            onsave: null,
            onbeforeremove: null,
            onremove: null,
            onerror: function(el, message) {
                jSuites.alert(message);
            }
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Validations
        if (! obj.options.validations) {
            obj.options.validations = {};
        }

        // Submit Button
        if (! obj.options.submitButton) {
            obj.options.submitButton = el.querySelector('input[type=submit]');
        }

        if (obj.options.submitButton && obj.options.url) {
            obj.options.submitButton.onclick = function() {
                obj.save();
            };
        }

        if (! obj.options.validations.email) {
            obj.options.validations.email = jSuites.validations.email;
        }

        if (! obj.options.validations.length) {
            obj.options.validations.length = jSuites.validations.length;
        }

        if (! obj.options.validations.required) {
            obj.options.validations.required = jSuites.validations.required;
        }

        obj.setUrl = function(url) {
            obj.options.url = url;
        };

        obj.load = function() {
            jSuites.ajax({
                url: obj.options.url,
                method: 'GET',
                dataType: 'json',
                queue: true,
                success: function(data) {
                    // Overwrite values from the backend
                    if (typeof(obj.options.onbeforeload) == 'function') {
                        var ret = obj.options.onbeforeload(el, data);
                        if (ret) {
                            data = ret;
                        }
                    }
                    // Apply values to the form
                    jSuites.form.setElements(el, data);
                    // Onload methods
                    if (typeof(obj.options.onload) == 'function') {
                        obj.options.onload(el, data);
                    }
                }
            });
        };

        obj.save = function() {
            var test = obj.validate();

            if (test) {
                obj.options.onerror(el, test);
            } else {
                var data = jSuites.form.getElements(el, true);

                if (typeof(obj.options.onbeforesave) == 'function') {
                    var data = obj.options.onbeforesave(el, data);

                    if (data === false) {
                        console.log('Onbeforesave returned false');
                        return; 
                    }
                }

                jSuites.ajax({
                    url: obj.options.url,
                    method: 'POST',
                    dataType: 'json',
                    data: data,
                    success: function(result) {
                        if (typeof(obj.options.onsave) == 'function') {
                            obj.options.onsave(el, data, result);
                        }
                    }
                });
            }
        };

        obj.remove = function() {
            if (typeof(obj.options.onbeforeremove) == 'function') {
                var ret = obj.options.onbeforeremove(el, obj);
                if (ret === false) {
                    return false;
                }
            }

            jSuites.ajax({
                url: obj.options.url,
                method: 'DELETE',
                dataType: 'json',
                success: function(result) {
                    if (typeof(obj.options.onremove) == 'function') {
                        obj.options.onremove(el, obj, result);
                    }

                    obj.reset();
                }
            });
        };

        var addError = function(element) {
            // Add error in the element
            element.classList.add('error');
            // Submit button
            if (obj.options.submitButton) {
                obj.options.submitButton.setAttribute('disabled', true);
            }
            // Return error message
            var error = element.getAttribute('data-error') || 'There is an error in the form';
            element.setAttribute('title', error);
            return error;
        };

        var delError = function(element) {
            var error = false;
            // Remove class from this element
            element.classList.remove('error');
            element.removeAttribute('title');
            // Get elements in the form
            var elements = el.querySelectorAll("input, select, textarea, div[name]");
            // Run all elements 
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].getAttribute('data-validation')) {
                    if (elements[i].classList.contains('error')) {
                        error = true;
                    }
                }
            }

            if (obj.options.submitButton) {
                if (error) {
                    obj.options.submitButton.setAttribute('disabled', true);
                } else {
                    obj.options.submitButton.removeAttribute('disabled');
                }
            }
        };

        obj.validateElement = function(element) {
            // Test results
            var test = false;
            // Value
            var value = jSuites.form.getValue(element);
            // Validation
            var validation = element.getAttribute('data-validation');
            // Parse
            if (typeof(obj.options.validations[validation]) == 'function' && ! obj.options.validations[validation](value, element)) {
                // Not passed in the test
                test = addError(element);
            } else {
                if (element.classList.contains('error')) {
                    delError(element);
                }
            }

            return test;
        };

        obj.reset = function() {
            var elements = el.querySelectorAll("input, select, textarea, div[name]");
            // Run all elements 
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].getAttribute('name')) {
                    if (elements[i].type == 'checkbox' || elements[i].type == 'radio') {
                        elements[i].checked = false;
                    } else {
                        if (typeof(elements[i].val) == 'function') {
                            elements[i].val('');
                        } else {
                            elements[i].value = '';
                        }
                    }
                }
            }
        };

        // Run form validation
        obj.validate = function() {
            var test = [];
            // Get elements in the form
            var elements = el.querySelectorAll("input, select, textarea, div[name]");
            // Run all elements 
            for (var i = 0; i < elements.length; i++) {
                // Required
                if (elements[i].getAttribute('data-validation')) {
                    var res = obj.validateElement(elements[i]);
                    if (res) {
                        test.push(res);
                    }
                }
            }
            if (test.length > 0) {
                return test.join('<br>');
            } else {
                return false;
            }
        };

        // Check the form
        obj.getError = function() {
            // Validation
            return obj.validation() ? true : false;
        };

        // Return the form hash
        obj.setHash = function() {
            return obj.getHash(jSuites.form.getElements(el));
        };

        // Get the form hash
        obj.getHash = function(str) {
            var hash = 0, i, chr;

            if (str.length === 0) {
                return hash;
            } else {
                for (i = 0; i < str.length; i++) {
                  chr = str.charCodeAt(i);
                  hash = ((hash << 5) - hash) + chr;
                  hash |= 0;
                }
            }

            return hash;
        };

        // Is there any change in the form since start tracking?
        obj.isChanged = function() {
            var hash = obj.setHash();
            return (obj.options.currentHash != hash);
        };

        // Restart tracking
        obj.resetTracker = function() {
            obj.options.currentHash = obj.setHash();
            obj.options.ignore = false;
        };

        // Ignore flag
        obj.setIgnore = function(ignoreFlag) {
            obj.options.ignore = ignoreFlag ? true : false;
        };

        // Start tracking in one second
        setTimeout(function() {
            obj.options.currentHash = obj.setHash();
        }, 1000);

        // Validations
        el.addEventListener("keyup", function(e) {
            if (e.target.getAttribute('data-validation')) {
                obj.validateElement(e.target);
            }
        });

        // Alert
        if (! jSuites.form.hasEvents) {
            window.addEventListener("beforeunload", function (e) {
                if (obj.isChanged() && obj.options.ignore == false) {
                    var confirmationMessage =  obj.options.message? obj.options.message : "\o/";

                    if (confirmationMessage) {
                        if (typeof e == 'undefined') {
                            e = window.event;
                        }

                        if (e) {
                            e.returnValue = confirmationMessage;
                        }

                        return confirmationMessage;
                    } else {
                        return void(0);
                    }
                }
            });

            jSuites.form.hasEvents = true;
        }

        el.form = obj;

        return obj;
    });

    // Get value from one element
    jSuites.form.getValue = function(element) {
        var value = null;
        if (element.type == 'checkbox') {
            if (element.checked == true) {
                value = element.value || true;
            }
        } else if (element.type == 'radio') {
            if (element.checked == true) {
                value = element.value;
            }
        } else if (element.tagName == 'select' && element.multiple == true) {
            value = [];
            var options = element.querySelectorAll("options[selected]");
            for (var j = 0; j < options.length; j++) {
                value.push(options[j].value);
            }
        } else if (typeof(element.val) == 'function') {
            value = element.val();
        } else {
            value = element.value || '';
        }

        return value;
    };

    // Get form elements
    jSuites.form.getElements = function(el, asArray) {
        var data = {};
        var name = null;
        var elements = el.querySelectorAll("input, select, textarea, div[name]");

        for (var i = 0; i < elements.length; i++) {
            if (name = elements[i].getAttribute('name')) {
                data[name] = jSuites.form.getValue(elements[i]) || '';
            }
        }

        return asArray == true ? data : JSON.stringify(data);
    };

    //Get form elements
    jSuites.form.setElements = function(el, data) {
        var name = null;
        var value = null;
        var elements = el.querySelectorAll("input, select, textarea, div[name]");
        for (var i = 0; i < elements.length; i++) {
            // Attributes
            var type = elements[i].getAttribute('type');
            if (name = elements[i].getAttribute('name')) {
                // Transform variable names in pathname
                name = name.replace(new RegExp(/\[(.*?)\]/ig), '.$1');
                value = null;
                // Seach for the data in the path
                if (name.match(/\./)) {
                    var tmp = jSuites.path.call(data, name) || '';
                    if (typeof(tmp) !== 'undefined') {
                        value = tmp;
                    }
                } else {
                    if (typeof(data[name]) !== 'undefined') {
                        value = data[name];
                    }
                }
                // Set the values
                if (value !== null) {
                    if (type == 'checkbox' || type == 'radio') {
                        elements[i].checked = value ? true : false;
                    } else {
                        if (typeof (elements[i].val) == 'function') {
                            elements[i].val(value);
                        } else {
                            elements[i].value = value;
                        }
                    }
                }
            }
        }
    };

    // Legacy
    jSuites.tracker = jSuites.form;

    jSuites.focus = function(el) {
        if (el.innerText.length) {
            var range = document.createRange();
            var sel = window.getSelection();
            var node = el.childNodes[el.childNodes.length-1];
            range.setStart(node, node.length);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            el.scrollLeft = el.scrollWidth;
        }
    };

    jSuites.isNumeric = (function (num) {
        return !isNaN(num) && num !== null && num !== '';
    });

    jSuites.guid = function() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    jSuites.getNode = function() {
        var node = document.getSelection().anchorNode;
        if (node) {
            return (node.nodeType == 3 ? node.parentNode : node);
        } else {
            return null;
        }
    };
    /**
     * Generate hash from a string
     */
    jSuites.hash = function(str) {
        var hash = 0, i, chr;

        if (str.length === 0) {
            return hash;
        } else {
            for (i = 0; i < str.length; i++) {
                chr = str.charCodeAt(i);
                if (chr > 32) {
                    hash = ((hash << 5) - hash) + chr;
                    hash |= 0;
                }
            }
        }
        return hash;
    };

    /**
     * Generate a random color
     */
    jSuites.randomColor = function(h) {
        var lum = -0.25;
        var hex = String('#' + Math.random().toString(16).slice(2, 8).toUpperCase()).replace(/[^0-9a-f]/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        var rgb = [], c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb.push(("00" + c).substr(c.length));
        }

        // Return hex
        if (h == true) {
            return '#' + jSuites.two(rgb[0].toString(16)) + jSuites.two(rgb[1].toString(16)) + jSuites.two(rgb[2].toString(16));
        }

        return rgb;
    };

    jSuites.getWindowWidth = function() {
        var w = window,
        d = document,
        e = d.documentElement,
        g = d.getElementsByTagName('body')[0],
        x = w.innerWidth || e.clientWidth || g.clientWidth;
        return x;
    };

    jSuites.getWindowHeight = function() {
        var w = window,
        d = document,
        e = d.documentElement,
        g = d.getElementsByTagName('body')[0],
        y = w.innerHeight|| e.clientHeight|| g.clientHeight;
        return  y;
    };

    jSuites.getPosition = function(e) {
        if (e.changedTouches && e.changedTouches[0]) {
            var x = e.changedTouches[0].pageX;
            var y = e.changedTouches[0].pageY;
        } else {
            var x = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
            var y = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
        }

        return [ x, y ];
    };

    jSuites.click = function(el) {
        if (el.click) {
            el.click();
        } else {
            var evt = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            el.dispatchEvent(evt);
        }
    };

    jSuites.findElement = function(element, condition) {
        var foundElement = false;

        function path (element) {
            if (element && ! foundElement) {
                if (typeof(condition) == 'function') {
                    foundElement = condition(element);
                } else if (typeof(condition) == 'string') {
                    if (element.classList && element.classList.contains(condition)) {
                        foundElement = element;
                    }
                }
            }

            if (element.parentNode && ! foundElement) {
                path(element.parentNode);
            }
        }

        path(element);

        return foundElement;
    };

    // Two digits
    jSuites.two = function(value) {
        value = '' + value;
        if (value.length == 1) {
            value = '0' + value;
        }
        return value;
    };

    jSuites.sha512 = (function(str) {
        function int64(msint_32, lsint_32) {
            this.highOrder = msint_32;
            this.lowOrder = lsint_32;
        }

        var H = [new int64(0x6a09e667, 0xf3bcc908), new int64(0xbb67ae85, 0x84caa73b),
            new int64(0x3c6ef372, 0xfe94f82b), new int64(0xa54ff53a, 0x5f1d36f1),
            new int64(0x510e527f, 0xade682d1), new int64(0x9b05688c, 0x2b3e6c1f),
            new int64(0x1f83d9ab, 0xfb41bd6b), new int64(0x5be0cd19, 0x137e2179)];

        var K = [new int64(0x428a2f98, 0xd728ae22), new int64(0x71374491, 0x23ef65cd),
            new int64(0xb5c0fbcf, 0xec4d3b2f), new int64(0xe9b5dba5, 0x8189dbbc),
            new int64(0x3956c25b, 0xf348b538), new int64(0x59f111f1, 0xb605d019),
            new int64(0x923f82a4, 0xaf194f9b), new int64(0xab1c5ed5, 0xda6d8118),
            new int64(0xd807aa98, 0xa3030242), new int64(0x12835b01, 0x45706fbe),
            new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, 0xd5ffb4e2),
            new int64(0x72be5d74, 0xf27b896f), new int64(0x80deb1fe, 0x3b1696b1),
            new int64(0x9bdc06a7, 0x25c71235), new int64(0xc19bf174, 0xcf692694),
            new int64(0xe49b69c1, 0x9ef14ad2), new int64(0xefbe4786, 0x384f25e3),
            new int64(0x0fc19dc6, 0x8b8cd5b5), new int64(0x240ca1cc, 0x77ac9c65),
            new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483),
            new int64(0x5cb0a9dc, 0xbd41fbd4), new int64(0x76f988da, 0x831153b5),
            new int64(0x983e5152, 0xee66dfab), new int64(0xa831c66d, 0x2db43210),
            new int64(0xb00327c8, 0x98fb213f), new int64(0xbf597fc7, 0xbeef0ee4),
            new int64(0xc6e00bf3, 0x3da88fc2), new int64(0xd5a79147, 0x930aa725),
            new int64(0x06ca6351, 0xe003826f), new int64(0x14292967, 0x0a0e6e70),
            new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926),
            new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, 0x9d95b3df),
            new int64(0x650a7354, 0x8baf63de), new int64(0x766a0abb, 0x3c77b2a8),
            new int64(0x81c2c92e, 0x47edaee6), new int64(0x92722c85, 0x1482353b),
            new int64(0xa2bfe8a1, 0x4cf10364), new int64(0xa81a664b, 0xbc423001),
            new int64(0xc24b8b70, 0xd0f89791), new int64(0xc76c51a3, 0x0654be30),
            new int64(0xd192e819, 0xd6ef5218), new int64(0xd6990624, 0x5565a910),
            new int64(0xf40e3585, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8),
            new int64(0x19a4c116, 0xb8d2d0c8), new int64(0x1e376c08, 0x5141ab53),
            new int64(0x2748774c, 0xdf8eeb99), new int64(0x34b0bcb5, 0xe19b48a8),
            new int64(0x391c0cb3, 0xc5c95a63), new int64(0x4ed8aa4a, 0xe3418acb),
            new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, 0xd6b2b8a3),
            new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60),
            new int64(0x84c87814, 0xa1f0ab72), new int64(0x8cc70208, 0x1a6439ec),
            new int64(0x90befffa, 0x23631e28), new int64(0xa4506ceb, 0xde82bde9),
            new int64(0xbef9a3f7, 0xb2c67915), new int64(0xc67178f2, 0xe372532b),
            new int64(0xca273ece, 0xea26619c), new int64(0xd186b8c7, 0x21c0c207),
            new int64(0xeada7dd6, 0xcde0eb1e), new int64(0xf57d4f7f, 0xee6ed178),
            new int64(0x06f067aa, 0x72176fba), new int64(0x0a637dc5, 0xa2c898a6),
            new int64(0x113f9804, 0xbef90dae), new int64(0x1b710b35, 0x131c471b),
            new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493),
            new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, 0x9c100d4c),
            new int64(0x4cc5d4be, 0xcb3e42b6), new int64(0x597f299c, 0xfc657e2a),
            new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817)];

        var W = new Array(64);
        var a, b, c, d, e, f, g, h, i, j;
        var T1, T2;
        var charsize = 8;

        function utf8_encode(str) {
            return unescape(encodeURIComponent(str));
        }

        function str2binb(str) {
            var bin = [];
            var mask = (1 << charsize) - 1;
            var len = str.length * charsize;
        
            for (var i = 0; i < len; i += charsize) {
                bin[i >> 5] |= (str.charCodeAt(i / charsize) & mask) << (32 - charsize - (i % 32));
            }
        
            return bin;
        }

        function binb2hex(binarray) {
            var hex_tab = "0123456789abcdef";
            var str = "";
            var length = binarray.length * 4;
            var srcByte;

            for (var i = 0; i < length; i += 1) {
                srcByte = binarray[i >> 2] >> ((3 - (i % 4)) * 8);
                str += hex_tab.charAt((srcByte >> 4) & 0xF) + hex_tab.charAt(srcByte & 0xF);
            }

            return str;
        }

        function safe_add_2(x, y) {
            var lsw, msw, lowOrder, highOrder;

            lsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);
            msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);
            lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            lsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);
            msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);
            highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            return new int64(highOrder, lowOrder);
        }

        function safe_add_4(a, b, c, d) {
            var lsw, msw, lowOrder, highOrder;

            lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) + (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);
            msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);
            lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) + (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);
            msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);
            highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            return new int64(highOrder, lowOrder);
        }

        function safe_add_5(a, b, c, d, e) {
            var lsw, msw, lowOrder, highOrder;

            lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) + (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) + (e.lowOrder & 0xFFFF);
            msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) + (lsw >>> 16);
            lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) + (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (e.highOrder & 0xFFFF) + (msw >>> 16);
            msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (e.highOrder >>> 16) + (lsw >>> 16);
            highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

            return new int64(highOrder, lowOrder);
        }

        function maj(x, y, z) {
            return new int64(
                (x.highOrder & y.highOrder) ^ (x.highOrder & z.highOrder) ^ (y.highOrder & z.highOrder),
                (x.lowOrder & y.lowOrder) ^ (x.lowOrder & z.lowOrder) ^ (y.lowOrder & z.lowOrder)
            );
        }

        function ch(x, y, z) {
            return new int64(
                (x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),
                (x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)
            );
        }

        function rotr(x, n) {
            if (n <= 32) {
                return new int64(
                 (x.highOrder >>> n) | (x.lowOrder << (32 - n)),
                 (x.lowOrder >>> n) | (x.highOrder << (32 - n))
                );
            } else {
                return new int64(
                 (x.lowOrder >>> n) | (x.highOrder << (32 - n)),
                 (x.highOrder >>> n) | (x.lowOrder << (32 - n))
                );
            }
        }

        function sigma0(x) {
            var rotr28 = rotr(x, 28);
            var rotr34 = rotr(x, 34);
            var rotr39 = rotr(x, 39);

            return new int64(
                rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,
                rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder
            );
        }

        function sigma1(x) {
            var rotr14 = rotr(x, 14);
            var rotr18 = rotr(x, 18);
            var rotr41 = rotr(x, 41);

            return new int64(
                rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,
                rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder
            );
        }

        function gamma0(x) {
            var rotr1 = rotr(x, 1), rotr8 = rotr(x, 8), shr7 = shr(x, 7);

            return new int64(
                rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,
                rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder
            );
        }

        function gamma1(x) {
            var rotr19 = rotr(x, 19);
            var rotr61 = rotr(x, 61);
            var shr6 = shr(x, 6);

            return new int64(
                rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,
                rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder
            );
        }

        function shr(x, n) {
            if (n <= 32) {
                return new int64(
                    x.highOrder >>> n,
                    x.lowOrder >>> n | (x.highOrder << (32 - n))
                );
            } else {
                return new int64(
                    0,
                    x.highOrder << (32 - n)
                );
            }
        }

        var str = utf8_encode(str);
        var strlen = str.length*charsize;
        str = str2binb(str);

        str[strlen >> 5] |= 0x80 << (24 - strlen % 32);
        str[(((strlen + 128) >> 10) << 5) + 31] = strlen;

        for (var i = 0; i < str.length; i += 32) {
            a = H[0];
            b = H[1];
            c = H[2];
            d = H[3];
            e = H[4];
            f = H[5];
            g = H[6];
            h = H[7];

            for (var j = 0; j < 80; j++) {
                if (j < 16) {
                    W[j] = new int64(str[j*2 + i], str[j*2 + i + 1]);
                } else {
                    W[j] = safe_add_4(gamma1(W[j - 2]), W[j - 7], gamma0(W[j - 15]), W[j - 16]);
                }

                T1 = safe_add_5(h, sigma1(e), ch(e, f, g), K[j], W[j]);
                T2 = safe_add_2(sigma0(a), maj(a, b, c));
                h = g;
                g = f;
                f = e;
                e = safe_add_2(d, T1);
                d = c;
                c = b;
                b = a;
                a = safe_add_2(T1, T2);
            }

            H[0] = safe_add_2(a, H[0]);
            H[1] = safe_add_2(b, H[1]);
            H[2] = safe_add_2(c, H[2]);
            H[3] = safe_add_2(d, H[3]);
            H[4] = safe_add_2(e, H[4]);
            H[5] = safe_add_2(f, H[5]);
            H[6] = safe_add_2(g, H[6]);
            H[7] = safe_add_2(h, H[7]);
        }

        var binarray = [];
        for (var i = 0; i < H.length; i++) {
            binarray.push(H[i].highOrder);
            binarray.push(H[i].lowOrder);
        }

        return binb2hex(binarray);
    });

    if (! jSuites.login) {
        jSuites.login = {};
        jSuites.login.sha512 = jSuites.sha512;
    }

    jSuites.image = jSuites.upload = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            type: 'image',
            extension: '*',
            input: false,
            minWidth: false,
            maxWidth: null,
            maxHeight: null,
            maxJpegSizeBytes: null, // For example, 350Kb would be 350000
            onchange: null,
            multiple: false,
            remoteParser: null,
            text:{
                extensionNotAllowed:'The extension is not allowed',
            }
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Multiple
        if (obj.options.multiple == true) {
            el.setAttribute('data-multiple', true);
        }

        // Container
        el.content = [];

        // Upload icon
        el.classList.add('jupload');

        if (obj.options.input == true) {
            el.classList.add('input');
        }

        obj.add = function(data) {
            // Reset container for single files
            if (obj.options.multiple == false) {
                el.content = [];
                el.innerText = '';
            }

            // Append to the element
            if (obj.options.type == 'image') {
                var img = document.createElement('img');
                img.setAttribute('src', data.file);
                img.setAttribute('tabindex', -1);
                if (! el.getAttribute('name')) {
                    img.className = 'jfile';
                    img.content = data;
                }
                el.appendChild(img);
            } else {
                if (data.name) {
                    var name = data.name;
                } else {
                    var name = data.file;
                }
                var div = document.createElement('div');
                div.innerText = name || obj.options.type;
                div.classList.add('jupload-item');
                div.setAttribute('tabindex', -1);
                el.appendChild(div);
            }

            if (data.content) {
                data.file = jSuites.guid();
            }

            // Push content
            el.content.push(data);

            // Onchange
            if (typeof(obj.options.onchange) == 'function') {
                obj.options.onchange(el, data);
            }
        };

        obj.addFromFile = function(file) {
            var type = file.type.split('/');
            if (type[0] == obj.options.type) {
                var readFile = new FileReader();
                readFile.addEventListener("load", function (v) {
                    var data = {
                        file: v.srcElement.result,
                        extension: file.name.substr(file.name.lastIndexOf('.') + 1),
                        name: file.name,
                        size: file.size,
                        lastmodified: file.lastModified,
                        content: v.srcElement.result,
                    };

                    obj.add(data);
                });

                readFile.readAsDataURL(file);
            } else {
                alert(obj.options.text.extensionNotAllowed);
            }
        };

        obj.addFromUrl = function(src) {
            if (src.substr(0,4) != 'data' && ! obj.options.remoteParser) {
                console.error('remoteParser not defined in your initialization');
            } else {
                // This is to process cross domain images
                if (src.substr(0,4) == 'data') {
                    var extension = src.split(';');
                    extension = extension[0].split('/');
                    var type = extension[0].replace('data:','');
                    if (type == obj.options.type) {
                        var data = {
                            file: src,
                            name: '',
                            extension: extension[1],
                            content: src,
                        };
                        obj.add(data);
                    } else {
                        alert(obj.options.text.extensionNotAllowed);
                    }
                } else {
                    var extension = src.substr(src.lastIndexOf('.') + 1);
                    // Work for cross browsers
                    src = obj.options.remoteParser + src;
                    // Get remove content
                    jSuites.ajax({
                        url: src,
                        type: 'GET',
                        dataType: 'blob',
                        success: function(data) {
                            //add(extension[0].replace('data:',''), data);
                        }
                    });
                }
            }
        };

        var mime = obj.options.type + '/' + obj.options.extension;
        var input = document.createElement('input');
        input.type = 'file';
        input.setAttribute('accept', mime);
        input.onchange = function() {
            for (var i = 0; i < this.files.length; i++) {
                obj.addFromFile(this.files[i]);
            }
        };

        // Allow multiple files
        if (obj.options.multiple == true) {
            input.setAttribute('multiple', true);
        }

        var current = null;

        el.addEventListener("click", function(e) {
            current = null;
            if (! el.children.length || e.target === el) {
                jSuites.click(input);
            } else {
                if (e.target.parentNode == el) {
                    current = e.target;
                }
            }
        });

        el.addEventListener("dblclick", function(e) {
            jSuites.click(input);
        });

        el.addEventListener('dragenter', function(e) {
            el.style.border = '1px dashed #000';
        });

        el.addEventListener('dragleave', function(e) {
            el.style.border = '1px solid #eee';
        });

        el.addEventListener('dragstop', function(e) {
            el.style.border = '1px solid #eee';
        });

        el.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        el.addEventListener('keydown', function(e) {
            if (current && e.which == 46) {
                var index = Array.prototype.indexOf.call(el.children, current);
                if (index >= 0) {
                    el.content.splice(index, 1);
                    current.remove();
                    current = null;
                }
            }
        });

        el.addEventListener('drop', function(e) {
            e.preventDefault();  
            e.stopPropagation();

            var html = (e.originalEvent || e).dataTransfer.getData('text/html');
            var file = (e.originalEvent || e).dataTransfer.files;

            if (file.length) {
                for (var i = 0; i < e.dataTransfer.files.length; i++) {
                    obj.addFromFile(e.dataTransfer.files[i]);
                }
            } else if (html) {
                if (obj.options.multiple == false) {
                    el.innerText = '';
                }

                // Create temp element
                var div = document.createElement('div');
                div.innerHTML = html;

                // Extract images
                var img = div.querySelectorAll('img');

                if (img.length) {
                    for (var i = 0; i < img.length; i++) {
                        obj.addFromUrl(img[i].src);
                    }
                }
            }

            el.style.border = '1px solid #eee';

            return false;
        });

        el.val = function(val) {
            if (val === undefined) {
                return el.content && el.content.length ? el.content : null;
            } else {
                // Reset
                el.innerText = '';
                el.content = [];

                if (val) {
                    if (Array.isArray(val)) {
                        for (var i = 0; i < val.length; i++) {
                            if (typeof(val[i]) == 'string') {
                                obj.add({ file: val[i] });
                            } else {
                                obj.add(val[i]);
                            }
                        }
                    } else if (typeof(val) == 'string') {
                        obj.add({ file: val });
                    }
                }
            }
        };

        el.upload = el.image = obj;

        return obj;
    });

    jSuites.image.create = function(data) {
        var img = document.createElement('img');
        img.setAttribute('src', data.file);
        img.className = 'jfile';
        img.setAttribute('tabindex', -1);
        img.content = data;

        return img;
    };


    jSuites.lazyLoading = (function(el, options) {
        var obj = {};

        // Mandatory options
        if (! options.loadUp || typeof(options.loadUp) != 'function') {
            options.loadUp = function() {
                return false;
            };
        }
        if (! options.loadDown || typeof(options.loadDown) != 'function') {
            options.loadDown = function() {
                return false;
            };
        }
        // Timer ms
        if (! options.timer) {
            options.timer = 100;
        }

        // Timer
        var timeControlLoading = null;

        // Controls
        var scrollControls = function(e) {
            if (timeControlLoading == null) {
                var scrollTop = el.scrollTop;
                if (el.scrollTop + (el.clientHeight * 2) >= el.scrollHeight) {
                    if (options.loadDown()) {
                        if (scrollTop == el.scrollTop) {
                            el.scrollTop = el.scrollTop - (el.clientHeight);
                        }
                    }
                } else if (el.scrollTop <= el.clientHeight) {
                    if (options.loadUp()) {
                        if (scrollTop == el.scrollTop) {
                            el.scrollTop = el.scrollTop + (el.clientHeight);
                        }
                    }
                }

                timeControlLoading = setTimeout(function() {
                    timeControlLoading = null;
                }, options.timer);
            }
        };

        // Onscroll
        el.onscroll = function(e) {
            scrollControls();
        };

        el.onwheel = function(e) {
            scrollControls();
        };

        return obj;
    });

    jSuites.loading = (function() {
        var obj = {};

        var loading = null;

        obj.show = function() {
            if (! loading) {
                loading = document.createElement('div');
                loading.className = 'jloading';
            }
            document.body.appendChild(loading);
        };

        obj.hide = function() {
            if (loading && loading.parentNode) {
                document.body.removeChild(loading);
            }
        };

        return obj;
    })();

    jSuites.mask = (function() {
        var obj = {};
        var index = 0;
        var values = [];
        var pieces = [];

        /**
         * Apply a mask over a value considering a custom decimal representation. Default: '.'
         */
        obj.run = function(value, mask, decimal) {
            if (value.toString().length && mask.toString().length) {
                // Default decimal separator
                if (typeof(decimal) == 'undefined') {
                    decimal = '.';
                }

                if (jSuites.isNumeric(value)) {
                    if (typeof(value) == 'number') {
                        var number = (''+value).split('.');
                    } else {
                        var number = (''+value).split(decimal);
                    }
                    var value = number[0];
                    var valueDecimal = number[1];
                } else {
                    value = '' + value;
                }

                // Helpers
                index = 0;
                values = [];
                // Create mask token
                obj.prepare(mask);
                // Current value
                var currentValue = value;
                if (currentValue) {
                    // Checking current value
                    for (var i = 0; i < currentValue.length; i++) {
                        if (currentValue[i] != null) {
                            obj.process(currentValue[i]);
                        }
                    }
                }
                if (valueDecimal) {
                    obj.process(decimal);
                    var currentValue = valueDecimal;
                    if (currentValue) {
                        // Checking current value
                        for (var i = 0; i < currentValue.length; i++) {
                            if (currentValue[i] != null) {
                                obj.process(currentValue[i]);
                            }
                        }
                    }
                }
                // Formatted value
                return values.join('');
            } else {
                return '';
            }
        };

        /**
         * Process new string by keydown or paste
         */
        var execute = function(str) {
            index = 0;
            values = [];
            // Create mask token
            obj.prepare(this.getAttribute('data-mask'));
            // Current value
            var currentValue = '';
            // Process selection
            if (this.tagName == 'DIV') {
                if (this.innerText) {
                    var s = window.getSelection();
                    if (s && s.anchorOffset != s.focusOffset) {
                        var offset = s.anchorOffset > s.focusOffset ? s.focusOffset : s.anchorOffset;
                        var currentValue = this.innerText.substring(0, offset);
                    } else {
                        var currentValue = this.innerText;
                    }
                }
            } else {
                if (this.selectionStart < this.selectionEnd) {
                    var currentValue = this.value.substring(0, this.selectionStart); 
                } else {
                    var currentValue = this.value;
                }
            }

            // New string to the input
            currentValue += str;

            // Checking current value
            for (var i = 0; i < currentValue.length; i++) {
                if (currentValue[i] != null) {
                    obj.process(currentValue[i]);
                }
            }

            // New value 
            var value = values.join('');

            // Update value to the element
            if (this.tagName == 'DIV') {
                if (value != this.innerText) {
                    this.innerText = value;
                    // Set focus
                    jSuites.focus(this);
                }
            } else {
                this.value = value;
            }

            // Completed attribute
            if (pieces.length == values.length && pieces[pieces.length-1].length == values[values.length-1].length) {
                this.setAttribute('data-completed', 'true');
            } else {
                this.setAttribute('data-completed', 'false');
            }
        };

        obj.apply = function(e) {
            if (e.target && ! e.target.getAttribute('readonly')) {
                var mask = e.target.getAttribute('data-mask');
                if (mask && e.key && e.key.length < 2 && ! e.ctrlKey) {
                    // Prevent default
                    e.preventDefault();
                    // Process new char
                    execute.call(e.target, e.key);
                }
            }
        };

        obj.paste = function(e) {
            if (e.target && ! e.target.getAttribute('readonly')) {
                // Only apply paste to jsuites mask elements
                var mask = e.target.getAttribute('data-mask');
                if (mask) {
                    // Get the pasted text
                    if (e.clipboardData || e.originalEvent.clipboardData) {
                        var text = (e.originalEvent || e).clipboardData.getData('text/plain');
                    } else if (window.clipboardData) {
                        var text = window.clipboardData.getData('Text');
                    }
                    // Process the new text
                    if (text) {
                        // Prevent default
                        e.preventDefault();
                        // Process new information
                        execute.call(e.target, text);
                    }
                }
            }
        };

        /**
         * Process inputs and save to values
         */
        obj.process = function(input) {
            do {
                if (pieces[index] == 'mm') {
                    if (values[index] == null || values[index] == '') {
                        if (parseInt(input) > 1 && parseInt(input) < 10) {
                            values[index] = '0' + input;
                            index++;
                            return true;
                        } else if (parseInt(input) < 10) {
                            values[index] = input;
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        if (values[index] == 1 && values[index] < 2 && parseInt(input) < 3) {
                            values[index] += input;
                            index++;
                            return true;
                        } else if (values[index] == 0 && values[index] < 10) {
                            values[index] += input;
                            index++;
                            return true;
                        } else {
                            return false
                        }
                    }
                } else if (pieces[index] == 'dd') {
                    if (values[index] == null || values[index] == '') {
                        if (parseInt(input) > 3 && parseInt(input) < 10) {
                            values[index] = '0' + input;
                            index++;
                            return true;
                        } else if (parseInt(input) < 10) {
                            values[index] = input;
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        if (values[index] == 3 && parseInt(input) < 2) {
                            values[index] += input;
                            index++;
                            return true;
                        } else if (values[index] < 3 && parseInt(input) < 10) {
                            values[index] += input;
                            index++;
                            return true;
                        } else {
                            return false
                        }
                    }
                } else if (pieces[index] == 'hh24') {
                    if (values[index] == null || values[index] == '') {
                        if (parseInt(input) > 2 && parseInt(input) < 10) {
                            values[index] = '0' + input;
                            index++;
                            return true;
                        } else if (parseInt(input) < 10) {
                            values[index] = input;
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        if (values[index] == 2 && parseInt(input) < 4) {
                            values[index] += input;
                            index++;
                            return true;
                        } else if (values[index] < 2 && parseInt(input) < 10) {
                            values[index] += input;
                            index++;
                            return true;
                        } else {
                            return false
                        }
                    }
                } else if (pieces[index] == 'hh') {
                    if (values[index] == null || values[index] == '') {
                        if (parseInt(input) > 1 && parseInt(input) < 10) {
                            values[index] = '0' + input;
                            index++;
                            return true;
                        } else if (parseInt(input) < 10) {
                            values[index] = input;
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        if (values[index] == 1 && parseInt(input) < 3) {
                            values[index] += input;
                            index++;
                            return true;
                        } else if (values[index] < 1 && parseInt(input) < 10) {
                            values[index] += input;
                            index++;
                            return true;
                        } else {
                            return false
                        }
                    }
                } else if (pieces[index] == 'mi' || pieces[index] == 'ss') {
                    if (values[index] == null || values[index] == '') {
                        if (parseInt(input) > 5 && parseInt(input) < 10) {
                            values[index] = '0' + input;
                            index++;
                            return true;
                        } else if (parseInt(input) < 10) {
                            values[index] = input;
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        if (parseInt(input) < 10) {
                            values[index] += input;
                            index++;
                            return true;
                         } else {
                            return false
                        }
                    }
                } else if (pieces[index] == 'yy' || pieces[index] == 'yyyy') {
                    if (parseInt(input) < 10) {
                        if (values[index] == null || values[index] == '') {
                            values[index] = input;
                        } else {
                            values[index] += input;
                        }
                        
                        if (values[index].length == pieces[index].length) {
                            index++;
                        }
                        return true;
                    } else {
                        return false;
                    }
                } else if (pieces[index] == '#' || pieces[index] == '#.##' || pieces[index] == '#,##' || pieces[index] == '# ##' || pieces[index] == "#'##") {
                    if (input.match(/[0-9]/g)) {
                        if (pieces[index] == '#.##') {
                            var separator = '.';
                        } else if (pieces[index] == '#,##') {
                            var separator = ',';
                        } else if (pieces[index] == '# ##') {
                            var separator = ' ';
                        } else if (pieces[index] == "#'##") {
                            var separator = "'";
                        } else {
                            var separator = '';
                        }
                        if (values[index] == null || values[index] == '') {
                            values[index] = input;
                        } else {
                            values[index] += input;
                            if (separator) {
                                values[index] = values[index].match(/[0-9]/g).join('');
                                var t = [];
                                var s = 0;
                                for (var j = values[index].length - 1; j >= 0 ; j--) {
                                    t.push(values[index][j]);
                                    s++;
                                    if (! (s % 3)) {
                                        t.push(separator);
                                    }
                                }
                                t = t.reverse();
                                values[index] = t.join('');
                                if (values[index].substr(0,1) == separator) {
                                    values[index] = values[index].substr(1);
                                } 
                            }
                        }
                        return true;
                    } else {
                        if (pieces[index] == '#.##' && input == '.') ; else if (pieces[index] == '#,##' && input == ',') ; else if (pieces[index] == '# ##' && input == ' ') ; else if (pieces[index] == "#'##" && input == "'") ; else {
                            if (values[index]) {
                                index++;
                                if (pieces[index]) {
                                    if (pieces[index] == input) {
                                        values[index] = input;
                                        return true;
                                    } else {
                                        if (pieces[index] == '0' && pieces[index+1] == input) {
                                            index++;
                                            values[index] = input;
                                            return true;
                                        }
                                    }
                                }
                            }
                        }

                        return false;
                    }
                } else if (pieces[index] == '0') {
                    if (input.match(/[0-9]/g)) {
                        values[index] = input;
                        index++;
                        return true;
                    } else {
                        return false;
                    }
                } else if (pieces[index] == 'a') {
                    if (input.match(/[a-zA-Z]/g)) {
                        values[index] = input;
                        index++;
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if (pieces[index] != null) {
                        if (pieces[index] == '\\a') {
                            var v = 'a';
                        } else if (pieces[index] == '\\0') {
                            var v = '0';
                        } else if (pieces[index] == '[-]') {
                            if (input == '-' || input == '+') {
                                var v = input;
                            } else {
                                var v = ' ';
                            }
                        } else {
                            var v = pieces[index];
                        }
                        values[index] = v;
                        if (input == v) {
                            index++;
                            return true;
                        }
                    }
                }

                index++;
            } while (pieces[index]);
        };

        /**
         * Create tokens for the mask
         */
        obj.prepare = function(mask) {
            pieces = [];
            for (var i = 0; i < mask.length; i++) {
                if (mask[i].match(/[0-9]|[a-z]|\\/g)) {
                    if (mask[i] == 'y' && mask[i+1] == 'y' && mask[i+2] == 'y' && mask[i+3] == 'y') {
                        pieces.push('yyyy');
                        i += 3;
                    } else if (mask[i] == 'y' && mask[i+1] == 'y') {
                        pieces.push('yy');
                        i++;
                    } else if (mask[i] == 'm' && mask[i+1] == 'm' && mask[i+2] == 'm' && mask[i+3] == 'm') {
                        pieces.push('mmmm');
                        i += 3;
                    } else if (mask[i] == 'm' && mask[i+1] == 'm' && mask[i+2] == 'm') {
                        pieces.push('mmm');
                        i += 2;
                    } else if (mask[i] == 'm' && mask[i+1] == 'm') {
                        pieces.push('mm');
                        i++;
                    } else if (mask[i] == 'd' && mask[i+1] == 'd') {
                        pieces.push('dd');
                        i++;
                    } else if (mask[i] == 'h' && mask[i+1] == 'h' && mask[i+2] == '2' && mask[i+3] == '4') {
                        pieces.push('hh24');
                        i += 3;
                    } else if (mask[i] == 'h' && mask[i+1] == 'h') {
                        pieces.push('hh');
                        i++;
                    } else if (mask[i] == 'm' && mask[i+1] == 'i') {
                        pieces.push('mi');
                        i++;
                    } else if (mask[i] == 's' && mask[i+1] == 's') {
                        pieces.push('ss');
                        i++;
                    } else if (mask[i] == 'a' && mask[i+1] == 'm') {
                        pieces.push('am');
                        i++;
                    } else if (mask[i] == 'p' && mask[i+1] == 'm') {
                        pieces.push('pm');
                        i++;
                    } else if (mask[i] == '\\' && mask[i+1] == '0') {
                        pieces.push('\\0');
                        i++;
                    } else if (mask[i] == '\\' && mask[i+1] == 'a') {
                        pieces.push('\\a');
                        i++;
                    } else {
                        pieces.push(mask[i]);
                    }
                } else {
                    if (mask[i] == '#' && mask[i+1] == '.' && mask[i+2] == '#' && mask[i+3] == '#') {
                        pieces.push('#.##');
                        i += 3;
                    } else if (mask[i] == '#' && mask[i+1] == ',' && mask[i+2] == '#' && mask[i+3] == '#') {
                        pieces.push('#,##');
                        i += 3;
                    } else if (mask[i] == '#' && mask[i+1] == ' ' && mask[i+2] == '#' && mask[i+3] == '#') {
                        pieces.push('# ##');
                        i += 3;
                    } else if (mask[i] == '#' && mask[i+1] == "'" && mask[i+2] == '#' && mask[i+3] == '#') {
                        pieces.push("#'##");
                        i += 3;
                    } else if (mask[i] == '[' && mask[i+1] == '-' && mask[i+2] == ']') {
                        pieces.push('[-]');
                        i += 2;
                    } else {
                        pieces.push(mask[i]);
                    }
                }
            }
        };

        if (typeof document !== 'undefined') {
            document.addEventListener('paste', obj.paste);
            document.addEventListener('keydown', obj.apply);
        }

        return obj;
    })();


    jSuites.modal = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            url: null,
            onopen: null,
            onclose: null,
            closed: false,
            width: null,
            height: null,
            title: null,
            padding: null,
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Title
        if (! obj.options.title && el.getAttribute('title')) {
            obj.options.title = el.getAttribute('title');
        }

        var temp = document.createElement('div');
        while (el.children[0]) {
            temp.appendChild(el.children[0]);
        }

        obj.content = document.createElement('div');
        obj.content.className = 'jmodal_content';
        obj.content.innerHTML = el.innerHTML;

        while (temp.children[0]) {
            obj.content.appendChild(temp.children[0]);
        }

        obj.container = document.createElement('div');
        obj.container.className = 'jmodal';
        obj.container.appendChild(obj.content);

        if (obj.options.padding) {
            obj.content.style.padding = obj.options.padding;
        }
        if (obj.options.width) {
            obj.container.style.width = obj.options.width;
        }
        if (obj.options.height) {
            obj.container.style.height = obj.options.height;
        }
        if (obj.options.title) {
            obj.container.setAttribute('title', obj.options.title);
        } else {
            obj.container.classList.add('no-title');
        }
        el.innerHTML = '';
        el.style.display = 'none';
        el.appendChild(obj.container);

        // Backdrop
        var backdrop = document.createElement('div');
        backdrop.className = 'jmodal_backdrop';
        backdrop.onclick = function() {
            obj.close();
        };
        el.appendChild(backdrop);

        obj.open = function() {
            el.style.display = 'block';
            // Fullscreen
            var rect = obj.container.getBoundingClientRect();
            if (jSuites.getWindowWidth() < rect.width) {
                obj.container.style.top = '';
                obj.container.style.left = '';
                obj.container.classList.add('jmodal_fullscreen');
                jSuites.animation.slideBottom(obj.container, 1);
            } else {
                backdrop.style.display = 'block';
            }
            // Current
            jSuites.modal.current = obj;
            // Event
            if (typeof(obj.options.onopen) == 'function') {
                obj.options.onopen(el, obj);
            }
        };

        obj.resetPosition = function() {
            obj.container.style.top = '';
            obj.container.style.left = '';
        };

        obj.isOpen = function() {
            return el.style.display != 'none' ? true : false;
        };

        obj.close = function() {
            el.style.display = 'none';
            // Backdrop
            backdrop.style.display = '';
            // Current
            jSuites.modal.current = null;
            // Remove fullscreen class
            obj.container.classList.remove('jmodal_fullscreen');
            // Event
            if (typeof(obj.options.onclose) == 'function') {
                obj.options.onclose(el, obj);
            }
        };

        if (! jSuites.modal.hasEvents) {
            jSuites.modal.current = obj;

            if ('ontouchstart' in document.documentElement === true) {
                document.addEventListener("touchstart", jSuites.modal.mouseDownControls);
            } else {
                document.addEventListener('mousedown', jSuites.modal.mouseDownControls);
                document.addEventListener('mousemove', jSuites.modal.mouseMoveControls);
                document.addEventListener('mouseup', jSuites.modal.mouseUpControls);
            }

            document.addEventListener('keydown', jSuites.modal.keyDownControls);

            jSuites.modal.hasEvents = true;
        }

        if (obj.options.url) {
            jSuites.ajax({
                url: obj.options.url,
                method: 'GET',
                dataType: 'text/html',
                success: function(data) {
                    obj.content.innerHTML = data;

                    if (! obj.options.closed) {
                        obj.open();
                    }
                }
            });
        } else {
            if (! obj.options.closed) {
                obj.open();
            }
        }

        // Keep object available from the node
        el.modal = obj;

        return obj;
    });

    jSuites.modal.current = null;
    jSuites.modal.position = null;

    jSuites.modal.keyDownControls = function(e) {
        if (e.which == 27) {
            if (jSuites.modal.current) {
                jSuites.modal.current.close();
            }
        }
    };

    jSuites.modal.mouseUpControls = function(e) {
        if (jSuites.modal.current) {
            jSuites.modal.current.container.style.cursor = 'auto';
        }
        jSuites.modal.position = null;
    };

    jSuites.modal.mouseMoveControls = function(e) {
        if (jSuites.modal.current && jSuites.modal.position) {
            if (e.which == 1 || e.which == 3) {
                var position = jSuites.modal.position;
                jSuites.modal.current.container.style.top = (position[1] + (e.clientY - position[3]) + (position[5] / 2)) + 'px';
                jSuites.modal.current.container.style.left = (position[0] + (e.clientX - position[2]) + (position[4] / 2)) + 'px';
                jSuites.modal.current.container.style.cursor = 'move';
            } else {
                jSuites.modal.current.container.style.cursor = 'auto';
            }
        }
    };

    jSuites.modal.mouseDownControls = function(e) {
        jSuites.modal.position = [];

        if (e.target.classList.contains('jmodal')) {
            setTimeout(function() {
                // Get target info
                var rect = e.target.getBoundingClientRect();

                if (e.changedTouches && e.changedTouches[0]) {
                    var x = e.changedTouches[0].clientX;
                    var y = e.changedTouches[0].clientY;
                } else {
                    var x = e.clientX;
                    var y = e.clientY;
                }

                if (rect.width - (x - rect.left) < 50 && (y - rect.top) < 50) {
                    setTimeout(function() {
                        jSuites.modal.current.close();
                    }, 100);
                } else {
                    if (e.target.getAttribute('title') && (y - rect.top) < 50) {
                        if (document.selection) {
                            document.selection.empty();
                        } else if ( window.getSelection ) {
                            window.getSelection().removeAllRanges();
                        }

                        jSuites.modal.position = [
                            rect.left,
                            rect.top,
                            e.clientX,
                            e.clientY,
                            rect.width,
                            rect.height,
                        ];
                    }
                }
            }, 100);
        }
    };


    jSuites.notification = (function(options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            icon: null,
            name: 'Notification',
            date: null,
            error: null,
            title: null,
            message: null,
            timeout: 4000,
            autoHide: true,
            closeable: true,
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        var notification = document.createElement('div');
        notification.className = 'jnotification';

        if (obj.options.error) {
            notification.classList.add('jnotification-error');
        }

        var notificationContainer = document.createElement('div');
        notificationContainer.className = 'jnotification-container';
        notification.appendChild(notificationContainer);

        var notificationHeader = document.createElement('div');
        notificationHeader.className = 'jnotification-header';
        notificationContainer.appendChild(notificationHeader);

        var notificationImage = document.createElement('div');
        notificationImage.className = 'jnotification-image';
        notificationHeader.appendChild(notificationImage);

        if (obj.options.icon) {
            var notificationIcon = document.createElement('img');
            notificationIcon.src = obj.options.icon;
            notificationImage.appendChild(notificationIcon);
        }

        var notificationName = document.createElement('div');
        notificationName.className = 'jnotification-name';
        notificationName.innerHTML = obj.options.name;
        notificationHeader.appendChild(notificationName);

        if (obj.options.closeable == true) {
            var notificationClose = document.createElement('div');
            notificationClose.className = 'jnotification-close';
            notificationClose.onclick = function() {
                obj.hide();
            };
            notificationHeader.appendChild(notificationClose);
        }

        var notificationDate = document.createElement('div');
        notificationDate.className = 'jnotification-date';
        notificationHeader.appendChild(notificationDate);

        var notificationContent = document.createElement('div');
        notificationContent.className = 'jnotification-content';
        notificationContainer.appendChild(notificationContent);

        if (obj.options.title) {
            var notificationTitle = document.createElement('div');
            notificationTitle.className = 'jnotification-title';
            notificationTitle.innerHTML = obj.options.title;
            notificationContent.appendChild(notificationTitle);
        }

        var notificationMessage = document.createElement('div');
        notificationMessage.className = 'jnotification-message';
        notificationMessage.innerHTML = obj.options.message;
        notificationContent.appendChild(notificationMessage);

        obj.show = function() {
            document.body.appendChild(notification);
            if (jSuites.getWindowWidth() > 800) { 
                jSuites.animation.fadeIn(notification);
            } else {
                jSuites.animation.slideTop(notification, 1);
            }
        };

        obj.hide = function() {
            if (jSuites.getWindowWidth() > 800) { 
                jSuites.animation.fadeOut(notification, function() {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                        if (notificationTimeout) {
                            clearTimeout(notificationTimeout);
                        }
                    }
                });
            } else {
                jSuites.animation.slideTop(notification, 0, function() {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                        if (notificationTimeout) {
                            clearTimeout(notificationTimeout);
                        }
                    }
                });
            }
        };

        obj.show();

        if (obj.options.autoHide == true) {
            var notificationTimeout = setTimeout(function() {
                obj.hide();
            }, obj.options.timeout);
        }

        if (jSuites.getWindowWidth() < 800) {
            notification.addEventListener("swipeup", function(e) {
                obj.hide();
                e.preventDefault();
                e.stopPropagation();
            });
        }

        return obj;
    });

    jSuites.notification.isVisible = function() {
        var j = document.querySelector('.jnotification');
        return j && j.parentNode ? true : false;
    };

    // More palettes https://coolors.co/ or https://gka.github.io/palettes/#/10|s|003790,005647,ffffe0|ffffe0,ff005e,93003a|1|1

    jSuites.palette = function(o) {
        // Material
        var palette = {};

        palette.material = [
            [ "#ffebee", "#fce4ec", "#f3e5f5", "#e8eaf6", "#e3f2fd", "#e0f7fa", "#e0f2f1", "#e8f5e9", "#f1f8e9", "#f9fbe7", "#fffde7", "#fff8e1", "#fff3e0", "#fbe9e7", "#efebe9", "#fafafa", "#eceff1" ],
            [ "#ffcdd2", "#f8bbd0", "#e1bee7", "#c5cae9", "#bbdefb", "#b2ebf2", "#b2dfdb", "#c8e6c9", "#dcedc8", "#f0f4c3", "#fff9c4", "#ffecb3", "#ffe0b2", "#ffccbc", "#d7ccc8", "#f5f5f5", "#cfd8dc" ],
            [ "#ef9a9a", "#f48fb1", "#ce93d8", "#9fa8da", "#90caf9", "#80deea", "#80cbc4", "#a5d6a7", "#c5e1a5", "#e6ee9c", "#fff59d", "#ffe082", "#ffcc80", "#ffab91", "#bcaaa4", "#eeeeee", "#b0bec5" ],
            [ "#e57373", "#f06292", "#ba68c8", "#7986cb", "#64b5f6", "#4dd0e1", "#4db6ac", "#81c784", "#aed581", "#dce775", "#fff176", "#ffd54f", "#ffb74d", "#ff8a65", "#a1887f", "#e0e0e0", "#90a4ae" ],
            [ "#ef5350", "#ec407a", "#ab47bc", "#5c6bc0", "#42a5f5", "#26c6da", "#26a69a", "#66bb6a", "#9ccc65", "#d4e157", "#ffee58", "#ffca28", "#ffa726", "#ff7043", "#8d6e63", "#bdbdbd", "#78909c" ],
            [ "#f44336", "#e91e63", "#9c27b0", "#3f51b5", "#2196f3", "#00bcd4", "#009688", "#4caf50", "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722", "#795548", "#9e9e9e", "#607d8b" ],
            [ "#e53935", "#d81b60", "#8e24aa", "#3949ab", "#1e88e5", "#00acc1", "#00897b", "#43a047", "#7cb342", "#c0ca33", "#fdd835", "#ffb300", "#fb8c00", "#f4511e", "#6d4c41", "#757575", "#546e7a" ],
            [ "#d32f2f", "#c2185b", "#7b1fa2", "#303f9f", "#1976d2", "#0097a7", "#00796b", "#388e3c", "#689f38", "#afb42b", "#fbc02d", "#ffa000", "#f57c00", "#e64a19", "#5d4037", "#616161", "#455a64" ],
            [ "#c62828", "#ad1457", "#6a1b9a", "#283593", "#1565c0", "#00838f", "#00695c", "#2e7d32", "#558b2f", "#9e9d24", "#f9a825", "#ff8f00", "#ef6c00", "#d84315", "#4e342e", "#424242", "#37474f" ],
            [ "#b71c1c", "#880e4f", "#4a148c", "#1a237e", "#0d47a1", "#006064", "#004d40", "#1b5e20", "#33691e", "#827717", "#f57f17", "#ff6f00", "#e65100", "#bf360c", "#3e2723", "#212121", "#263238" ],
        ];

        palette.fire = [
            ["0b1a6d","840f38","b60718","de030b","ff0c0c","fd491c","fc7521","faa331","fbb535","ffc73a"],
            ["071147","5f0b28","930513","be0309","ef0000","fa3403","fb670b","f9991b","faad1e","ffc123"],
            ["03071e","370617","6a040f","9d0208","d00000","dc2f02","e85d04","f48c06","faa307","ffba08"],
            ["020619","320615","61040d","8c0207","bc0000","c82a02","d05203","db7f06","e19405","efab00"],
            ["020515","2d0513","58040c","7f0206","aa0000","b62602","b94903","c57205","ca8504","d89b00"],
        ];

        palette.baby = [
            ["eddcd2","fff1e6","fde2e4","fad2e1","c5dedd","dbe7e4","f0efeb","d6e2e9","bcd4e6","99c1de"],
            ["e1c4b3","ffd5b5","fab6ba","f5a8c4","aacecd","bfd5cf","dbd9d0","baceda","9dc0db","7eb1d5"],
            ["daa990","ffb787","f88e95","f282a9","8fc4c3","a3c8be","cec9b3","9dbcce","82acd2","649dcb"],
            ["d69070","ff9c5e","f66770","f05f8f","74bbb9","87bfae","c5b993","83aac3","699bca","4d89c2"],
            ["c97d5d","f58443","eb4d57","e54a7b","66a9a7","78ae9c","b5a67e","7599b1","5c88b7","4978aa"],
        ];

        if (palette[o]) {
            return palette[o];
        } else {
            return palette.material;
        }
    };

    jSuites.picker = (function(el, options) {
        // Already created, update options
        if (el.picker) {
            return el.picker.setOptions(options, true);
        }

        // New instance
        var obj = { type: 'picker' };
        obj.options = {};

        var dropdownHeader = null;
        var dropdownContent = null;

        /**
         * Create the content options
         */
        var createContent = function() {
            dropdownContent.innerHTML = '';

            // Create items
            var keys = Object.keys(obj.options.data);

            // Go though all options
            for (var i = 0; i < keys.length; i++) {
                // Item
                var dropdownItem = document.createElement('div');
                dropdownItem.classList.add('jpicker-item');
                dropdownItem.k = keys[i];
                dropdownItem.v = obj.options.data[keys[i]];
                // Label
                dropdownItem.innerHTML = obj.getLabel(keys[i]);
                // Append
                dropdownContent.appendChild(dropdownItem);
            }
        };

        /**
         * Set or reset the options for the picker
         */
        obj.setOptions = function(options, reset) {
            // Default configuration
            var defaults = {
                value: 0,
                data: null,
                render: null,
                onchange: null,
                onselect: null,
                onopen: null,
                onclose: null,
                onload: null,
                width: null,
                header: true,
                right: false,
                content: false,
                columns: null,
                height: null,
            };

            // Legacy purpose only
            if (options && options.options) {
                options.data = options.options;
            }

            // Loop through the initial configuration
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Start using the options
            if (obj.options.header === false) {
                dropdownHeader.style.display = 'none';
            } else {
                dropdownHeader.style.display = '';
            }

            // Width
            if (obj.options.width) {
                dropdownHeader.style.width = parseInt(obj.options.width) + 'px';
            } else {
                dropdownHeader.style.width = '';
            }

            // Height
            if (obj.options.height) {
                dropdownContent.style.maxHeight = obj.options.height + 'px';
                dropdownContent.style.overflow = 'scroll';
            } else {
                dropdownContent.style.overflow = '';
            }

            if (obj.options.columns > 0) {
                dropdownContent.classList.add('jpicker-columns');
                dropdownContent.style.width =  obj.options.width ? obj.options.width : 36 * obj.options.columns + 'px';
            }

            if (isNaN(obj.options.value)) {
                obj.options.value = '0';
            }

            // Create list from data
            createContent();

            // Set value
            obj.setValue(obj.options.value);

            // Set options all returns the own instance
            return obj;
        };

        obj.getValue = function() {
            return obj.options.value;
        };

        obj.setValue = function(v) {
            // Set label
            obj.setLabel(v);

            // Update value
            obj.options.value = String(v);

            // Lemonade JS
            if (el.value != obj.options.value) {
                el.value = obj.options.value;
                if (typeof(el.onchange) == 'function') {
                    el.onchange({
                        type: 'change',
                        target: el,
                        value: el.value
                    });
                }
            }

            if (dropdownContent.children[v].getAttribute('type') !== 'generic') {
                obj.close();
            }
        };

        obj.getLabel = function(v) {
            var label = obj.options.data[v] || null;
            if (typeof(obj.options.render) == 'function') {
                label = obj.options.render(label);
            }
            return label;
        };

        obj.setLabel = function(v) {
            if (obj.options.content) {
                var label = '<i class="material-icons">' + obj.options.content + '</i>';
            } else {
                var label = obj.getLabel(v);
            }

            dropdownHeader.innerHTML = label;
        };

        obj.open = function() {
            if (! el.classList.contains('jpicker-focus')) {
                // Start tracking the element
                jSuites.tracking(obj, true);

                // Open picker
                el.classList.add('jpicker-focus');
                el.focus();

                var rectHeader = dropdownHeader.getBoundingClientRect();
                var rectContent = dropdownContent.getBoundingClientRect();
                if (window.innerHeight < rectHeader.bottom + rectContent.height) {
                    dropdownContent.style.marginTop = -1 * (rectContent.height + 4) + 'px';
                } else {
                    dropdownContent.style.marginTop = rectHeader.height + 2 + 'px';
                }

                if (obj.options.right === true) {
                    dropdownContent.style.marginLeft = -1 * rectContent.width + 24 + 'px';
                }

                if (typeof obj.options.onopen == 'function') {
                    obj.options.onopen(el, obj);
                }
            }
        };

        obj.close = function() {
            if (el.classList.contains('jpicker-focus')) {
                el.classList.remove('jpicker-focus');

                // Start tracking the element
                jSuites.tracking(obj, false);

                if (typeof obj.options.onclose == 'function') {
                    obj.options.onclose(el, obj);
                }
            }
        };

        /**
         * Create floating picker
         */
        var init = function() {
            // Class
            el.classList.add('jpicker');
            el.setAttribute('tabindex', '900');

            // Dropdown Header
            dropdownHeader = document.createElement('div');
            dropdownHeader.classList.add('jpicker-header');
            el.onmouseup = function(e) {
                var item = jSuites.findElement(e.target, 'jpicker-item');
                if (item) {
                    // Update label
                    obj.setValue(item.k);

                    // Call method
                    if (typeof(obj.options.onchange) == 'function') {
                        obj.options.onchange.call(obj, el, obj, item.v, item.v, item.k);
                    }
                } else {
                    if (! el.classList.contains('jpicker-focus')) {
                        obj.open();
                    } else {
                        obj.close();
                    }
                }
            };

            // Dropdown content
            dropdownContent = document.createElement('div');
            dropdownContent.classList.add('jpicker-content');

            // Append content and header
            el.appendChild(dropdownHeader);
            el.appendChild(dropdownContent);

            // Default value
            el.value = options.value || 0;

            // Set options
            obj.setOptions(options);

            if (typeof(obj.options.onload) == 'function') {
                obj.options.onload(el, obj);
            }

            // Change
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue();
                } else {
                    obj.setValue(val);
                }
            };

            // Reference
            el.picker = obj;
        };

        init();

        return obj;
    });

    jSuites.progressbar = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            value: 0,
            onchange: null,
            width: null,
        };

        // Loop through the initial configuration
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Class
        el.classList.add('jprogressbar');
        el.setAttribute('tabindex', 1);
        el.setAttribute('data-value', obj.options.value);

        var bar = document.createElement('div');
        bar.style.width = obj.options.value + '%';
        bar.style.color = '#fff';
        el.appendChild(bar);

        if (obj.options.width) {
            el.style.width = obj.options.width;
        }

        // Set value
        obj.setValue = function(value) {
            value = parseInt(value);
            obj.options.value = value;
            bar.style.width = value + '%';
            el.setAttribute('data-value', value + '%');

            if (value < 6) {
                el.style.color = '#000';
            } else {
                el.style.color = '#fff';
            }

            // Update value
            obj.options.value = value;

            if (typeof(obj.options.onchange) == 'function') {
                obj.options.onchange(el, value);
            }

            // Lemonade JS
            if (el.value != obj.options.value) {
                el.value = obj.options.value;
                if (typeof(el.onchange) == 'function') {
                    el.onchange({
                        type: 'change',
                        target: el,
                        value: el.value
                    });
                }
            }
        };

        obj.getValue = function() {
            return obj.options.value;
        };

        var action = function(e) {
            if (e.which) {
                // Get target info
                var rect = el.getBoundingClientRect();

                if (e.changedTouches && e.changedTouches[0]) {
                    var x = e.changedTouches[0].clientX;
                    e.changedTouches[0].clientY;
                } else {
                    var x = e.clientX;
                    e.clientY;
                }

                obj.setValue(Math.round((x - rect.left) / rect.width * 100));
            }
        };

        // Events
        if ('touchstart' in document.documentElement === true) {
            el.addEventListener('touchstart', action);
            el.addEventListener('touchend', action);
        } else {
            el.addEventListener('mousedown', action);
            el.addEventListener("mousemove", action);
        }

        // Change
        el.change = obj.setValue;

        // Global generic value handler
        el.val = function(val) {
            if (val === undefined) {
                return obj.getValue();
            } else {
                obj.setValue(val);
            }
        };

        // Reference
        el.progressbar = obj;

        return obj;
    });

    jSuites.rating = (function(el, options) {
        // Already created, update options
        if (el.rating) {
            return el.rating.setOptions(options, true);
        }

        // New instance
        var obj = {};
        obj.options = {};

        obj.setOptions = function(options, reset) {
            // Default configuration
            var defaults = {
                number: 5,
                value: 0,
                tooltip: [ 'Very bad', 'Bad', 'Average', 'Good', 'Very good' ],
                onchange: null,
            };

            // Loop through the initial configuration
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Make sure the container is empty
            el.innerHTML = '';

            // Add elements
            for (var i = 0; i < obj.options.number; i++) {
                var div = document.createElement('div');
                div.setAttribute('data-index', (i + 1));
                div.setAttribute('title', obj.options.tooltip[i]);
                el.appendChild(div);
            }

            // Selected option
            if (obj.options.value) {
                for (var i = 0; i < obj.options.number; i++) {
                    if (i < obj.options.value) {
                        el.children[i].classList.add('jrating-selected');
                    }
                }
            }

            return obj;
        };

        // Set value
        obj.setValue = function(index) {
            for (var i = 0; i < obj.options.number; i++) {
                if (i < index) {
                    el.children[i].classList.add('jrating-selected');
                } else {
                    el.children[i].classList.remove('jrating-over');
                    el.children[i].classList.remove('jrating-selected');
                }
            }

            obj.options.value = index;

            if (typeof(obj.options.onchange) == 'function') {
                obj.options.onchange(el, index);
            }

            // Lemonade JS
            if (el.value != obj.options.value) {
                el.value = obj.options.value;
                if (typeof(el.onchange) == 'function') {
                    el.onchange({
                        type: 'change',
                        target: el,
                        value: el.value
                    });
                }
            }
        };

        obj.getValue = function() {
            return obj.options.value;
        };

        var init = function() {
            // Start plugin
            obj.setOptions(options);

            // Class
            el.classList.add('jrating');

            // Events
            el.addEventListener("click", function(e) {
                var index = e.target.getAttribute('data-index');
                if (index != undefined) {
                    if (index == obj.options.value) {
                        obj.setValue(0);
                    } else {
                        obj.setValue(index);
                    }
                }
            });

            el.addEventListener("mouseover", function(e) {
                var index = e.target.getAttribute('data-index');
                for (var i = 0; i < obj.options.number; i++) {
                    if (i < index) {
                        el.children[i].classList.add('jrating-over');
                    } else {
                        el.children[i].classList.remove('jrating-over');
                    }
                }
            });

            el.addEventListener("mouseout", function(e) {
                for (var i = 0; i < obj.options.number; i++) {
                    el.children[i].classList.remove('jrating-over');
                }
            });

            // Change
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue();
                } else {
                    obj.setValue(val);
                }
            };

            // Reference
            el.rating = obj;
        };

        init();

        return obj;
    });


    jSuites.search = (function(el, options) {
        if (el.search) {
            return el.search;
        }

        var index =  null;

        var select = function(e) {
            if (e.target.classList.contains('jsearch_item')) {
                var element = e.target;
            } else {
                var element = e.target.parentNode;
            }

            obj.selectIndex(element);
            e.preventDefault();
        };

        var createList = function(data) {
            // Reset container
            container.innerHTML = '';
            // Print results
            if (! data.length) {
                // Show container
                el.style.display = '';
            } else {
                // Show container
                el.style.display = 'block';

                // Show items (only 10)
                var len = data.length < 11 ? data.length : 10;
                for (var i = 0; i < len; i++) {
                    // Legacy
                    var text = data[i].text;
                    if (! text && data[i].name) {
                        text = data[i].name;
                    }
                    var value = data[i].value;
                    if (! value && data[i].id) {
                        value = data[i].id;
                    }

                    var div = document.createElement('div');
                    div.setAttribute('data-value', value);
                    div.setAttribute('data-text', text);
                    div.className = 'jsearch_item';

                    if (data[i].id) {
                        div.setAttribute('id', data[i].id);
                    }

                    if (i == 0) {
                        div.classList.add('selected');
                    }
                    var img = document.createElement('img');
                    if (data[i].image) {
                        img.src = data[i].image;
                    } else {
                        img.style.display = 'none';
                    }
                    div.appendChild(img);

                    var item = document.createElement('div');
                    item.innerHTML = text;
                    div.appendChild(item);

                    // Append item to the container
                    container.appendChild(div);
                }
            }
        };

        var execute = function(str) {
            if (str != obj.terms) {
                // New terms
                obj.terms = str;
                // New index
                index = 0;
                // Array or remote search
                if (Array.isArray(obj.options.data)) {
                    var test = function(o) {
                        for (var key in o) {
                            var value = o[key];
                            if ((''+value).toLowerCase().search(str) >= 0) {
                                return true;
                            }
                        }
                        return false;
                    };

                    var results = obj.options.data.filter(function(item) {
                        return test(item);
                    });

                    // Show items
                    createList(results);
                } else {
                    // Get remove results
                    jSuites.ajax({
                        url: obj.options.data + str,
                        method: 'GET',
                        dataType: 'json',
                        success: function(data) {
                            // Show items
                            createList(data);
                        }
                    });
                }
            }
        };

        // Search timer
        var timer = null;

        // Search methods
        var obj = function(str) {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(function() {
                execute(str);
            }, 500);
        };

        obj.options = {
            data: options.data || null,
            input: options.input || null,
            onselect: options.onselect || null,
        };

        obj.selectIndex = function(item) {
            var id = item.getAttribute('id');
            var text = item.getAttribute('data-text');
            var value = item.getAttribute('data-value');
            // Onselect
            if (typeof(obj.options.onselect) == 'function') {
                obj.options.onselect(obj, text, value, id);
            }
            // Close container
            obj.close();
        };

        obj.open = function() {
            el.style.display = 'block';
        };

        obj.close = function() {
            if (timer) {
                clearTimeout(timer);
            }
            // Current terms
            obj.terms = '';
            // Remove results
            container.innerHTML = '';
            // Hide
            el.style.display = '';
        };

        obj.isOpened = function() {
            return el.style.display ? true : false;
        };

        obj.keydown = function(e) {
            if (obj.isOpened()) {
                if (e.key == 'Enter') {
                    // Enter
                    if (container.children[index]) {
                        obj.selectIndex(container.children[index]);
                        e.preventDefault();
                    }
                } else if (e.key === 'ArrowUp') {
                    // Up
                    if (container.children[0]) {
                        container.children[index].classList.remove('selected');
                        if (index > 0) {
                            index--;
                        }
                        container.children[index].classList.add('selected');
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    // Down
                    container.children[index].classList.remove('selected');
                    if (index < 9 && container.children[index+1]) {
                        index++;
                    }
                    container.children[index].classList.add('selected');
                    e.preventDefault();
                }
            }
        };

        obj.keyup = function(e) {
            if (obj.options.input) {
                obj(obj.options.input.value);
            } else {
                // Current node
                var node = jSuites.getNode();
                if (node) {
                    obj(node.innerText);
                }
            }
        };

        // Append element
        var container = document.createElement('div');
        container.classList.add('jsearch_container');
        container.onmousedown = select;
        el.appendChild(container);

        el.classList.add('jsearch');
        el.search = obj;

        return obj;
    });

    jSuites.slider = (function(el, options) {
        var obj = {};
        obj.options = {};
        obj.currentImage = null;

        if (options) {
            obj.options = options;
        }

        // Focus
        el.setAttribute('tabindex', '900');

        // Items
        obj.options.items = [];

        if (! el.classList.contains('jslider')) {
            el.classList.add('jslider');
            el.classList.add('unselectable');

            if (obj.options.height) {
                el.style.height = obj.options.height;
            }
            if (obj.options.width) {
                el.style.width = obj.options.width;
            }
            if (obj.options.grid) {
                el.classList.add('jslider-grid');
                var number = el.children.length;
                if (number > 4) {
                    el.setAttribute('data-total', number - 4);
                }
                el.setAttribute('data-number', (number > 4 ? 4 : number));
            }

            // Add slider counter
            var counter = document.createElement('div');
            counter.classList.add('jslider-counter');

            // Move children inside
            if (el.children.length > 0) {
                // Keep children items
                for (var i = 0; i < el.children.length; i++) {
                    obj.options.items.push(el.children[i]);
                    
                    // counter click event
                    var item = document.createElement('div');
                    item.onclick = function() {
                        var index = Array.prototype.slice.call(counter.children).indexOf(this);
                        obj.show(obj.currentImage = obj.options.items[index]);
                    };
                    counter.appendChild(item);
                }
            }
            // Add caption
            var caption = document.createElement('div');
            caption.className = 'jslider-caption';

            // Add close buttom
            var controls = document.createElement('div');
            var close = document.createElement('div');
            close.className = 'jslider-close';
            close.innerHTML = '';
            
            close.onclick = function() {
                obj.close();
            };
            controls.appendChild(caption);
            controls.appendChild(close);
        }

        obj.updateCounter = function(index) {
            for (var i = 0; i < counter.children.length; i ++) {
                if (counter.children[i].classList.contains('jslider-counter-focus')) {
                    counter.children[i].classList.remove('jslider-counter-focus');
                    break;
                }
            }
            counter.children[index].classList.add('jslider-counter-focus');
        };

        obj.show = function(target) {
            if (! target) {
                var target = el.children[0];
            }

            // Focus element
            el.classList.add('jslider-focus');
            el.classList.remove('jslider-grid');
            el.appendChild(controls);
            el.appendChild(counter);

            // Update counter
            var index = obj.options.items.indexOf(target);
            obj.updateCounter(index);

            // Remove display
            for (var i = 0; i < el.children.length; i++) {
                el.children[i].style.display = '';
            }
            target.style.display = 'block';

            // Is there any previous
            if (target.previousElementSibling) {
                el.classList.add('jslider-left');
            } else {
                el.classList.remove('jslider-left');
            }

            // Is there any next
            if (target.nextElementSibling && target.nextElementSibling.tagName == 'IMG') {
                el.classList.add('jslider-right');
            } else {
                el.classList.remove('jslider-right');
            }

            obj.currentImage = target;

            // Vertical image
            if (obj.currentImage.offsetHeight > obj.currentImage.offsetWidth) {
                obj.currentImage.classList.add('jslider-vertical');
            }

            controls.children[0].innerText = obj.currentImage.getAttribute('title');
        };

        obj.open = function() {
            obj.show();

            // Event
            if (typeof(obj.options.onopen) == 'function') {
                obj.options.onopen(el);
            }
        };

        obj.close = function() {
            // Remove control classes
            el.classList.remove('jslider-focus');
            el.classList.remove('jslider-left');
            el.classList.remove('jslider-right');
            // Show as a grid depending on the configuration
            if (obj.options.grid) {
                el.classList.add('jslider-grid');
            }
            // Remove display
            for (var i = 0; i < el.children.length; i++) {
                el.children[i].style.display = '';
            }
            // Remove controls from the component
            counter.remove();
            controls.remove();
            // Current image
            obj.currentImage = null;
            // Event
            if (typeof(obj.options.onclose) == 'function') {
                obj.options.onclose(el);
            }
        };

        obj.reset = function() {
            el.innerHTML = '';
        };

        obj.next = function() {
            var nextImage = obj.currentImage.nextElementSibling;
            if (nextImage && nextImage.tagName === 'IMG') {
                obj.show(obj.currentImage.nextElementSibling);
            }
        };
        
        obj.prev = function() {
            if (obj.currentImage.previousElementSibling) {
                obj.show(obj.currentImage.previousElementSibling);
            }
        };

        var mouseUp = function(e) {
            // Open slider
            if (e.target.tagName == 'IMG') {
                obj.show(e.target);
            } else if (! e.target.classList.contains('jslider-close') && ! (e.target.parentNode.classList.contains('jslider-counter') || e.target.classList.contains('jslider-counter'))){
                // Arrow controls
                var offsetX = e.offsetX || e.changedTouches[0].clientX;
                if (e.target.clientWidth - offsetX < 40) {
                    // Show next image
                    obj.next();
                } else if (offsetX < 40) {
                    // Show previous image
                    obj.prev();
                }
            }
        };

        if ('ontouchend' in document.documentElement === true) {
            el.addEventListener('touchend', mouseUp);
        } else {
            el.addEventListener('mouseup', mouseUp);
        }

        // Add global events
        el.addEventListener("swipeleft", function(e) {
            obj.next();
            e.preventDefault();
            e.stopPropagation();
        });

        el.addEventListener("swiperight", function(e) {
            obj.prev();
            e.preventDefault();
            e.stopPropagation();
        });

        el.addEventListener('keydown', function(e) {
            if (e.which == 27) {
                obj.close();
            }
        });

        el.slider = obj;

        return obj;
    });

    jSuites.sorting = (function(el, options) {
        var obj = {};
        obj.options = {};

        var defaults = {
            pointer: null,
            direction: null,
            ondragstart: null,
            ondragend: null,
            ondrop: null,
        };

        var dragElement = null;

        // Loop through the initial configuration
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        el.classList.add('jsorting');

        el.addEventListener('dragstart', function(e) {
            var position = Array.prototype.indexOf.call(e.target.parentNode.children, e.target);
            dragElement = {
                element: e.target,
                o: position,
                d: position
            };
            e.target.style.opacity = '0.25';

            if (typeof(obj.options.ondragstart) == 'function') {
                obj.options.ondragstart(el, e.target, e);
            }
        });

        el.addEventListener('dragover', function(e) {
            e.preventDefault();

            if (getElement(e.target) && dragElement) {
                if (e.target.getAttribute('draggable') == 'true' && dragElement.element != e.target) {
                    if (! obj.options.direction) {
                        var condition = e.target.clientHeight / 2 > e.offsetY;
                    } else {
                        var condition = e.target.clientWidth / 2 > e.offsetX;
                    }

                    if (condition) {
                        e.target.parentNode.insertBefore(dragElement.element, e.target);
                    } else {
                        e.target.parentNode.insertBefore(dragElement.element, e.target.nextSibling);
                    }

                    dragElement.d = Array.prototype.indexOf.call(e.target.parentNode.children, dragElement.element);
                }
            }
        });

        el.addEventListener('dragleave', function(e) {
            e.preventDefault();
        });

        el.addEventListener('dragend', function(e) {
            e.preventDefault();

            if (dragElement) {
                if (typeof(obj.options.ondragend) == 'function') {
                    obj.options.ondragend(el, dragElement.element, e);
                }

                // Cancelled put element to the original position
                if (dragElement.o < dragElement.d) {
                    e.target.parentNode.insertBefore(dragElement.element, e.target.parentNode.children[dragElement.o]);
                } else {
                    e.target.parentNode.insertBefore(dragElement.element, e.target.parentNode.children[dragElement.o].nextSibling);
                }

                dragElement.element.style.opacity = '';
                dragElement = null;
            }
        });

        el.addEventListener('drop', function(e) {
            e.preventDefault();

            if (dragElement && (dragElement.o != dragElement.d)) {
                if (typeof(obj.options.ondrop) == 'function') {
                    obj.options.ondrop(el, dragElement.o, dragElement.d, dragElement.element, e.target, e);
                }
            }

            dragElement.element.style.opacity = '';
            dragElement = null;
        });

        var getElement = function(element) {
            var sorting = false;

            function path (element) {
                if (element.className) {
                    if (element.classList.contains('jsorting')) {
                        sorting = true;
                    }
                }

                if (! sorting) {
                    path(element.parentNode);
                }
            }

            path(element);

            return sorting;
        };

        for (var i = 0; i < el.children.length; i++) {
            if (! el.children[i].hasAttribute('draggable')) {
                el.children[i].setAttribute('draggable', 'true');
            }
        }

        el.val = function() {
            var id = null;
            var data = [];
            for (var i = 0; i < el.children.length; i++) {
                if (id = el.children[i].getAttribute('data-id')) {
                    data.push(id);
                }
            }
            return data;
        };

        return el;
    });

    jSuites.tabs = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            data: [],
            position: null,
            allowCreate: false,
            allowChangePosition: false,
            onclick: null,
            onload: null,
            onchange: null,
            oncreate: null,
            ondelete: null,
            onbeforecreate: null,
            onchangeposition: null,
            animation: false,
            hideHeaders: false,
            padding: null,
            palette: null,
        };

        // Loop through the initial configuration
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        // Class
        el.classList.add('jtabs');

        var prev = null;
        var next = null;
        var border = null;

        // Helpers
        var setBorder = function(index) {
            var rect = obj.headers.children[index].getBoundingClientRect();

            if (obj.options.palette == 'modern') {
                border.style.width = rect.width - 4 + 'px';
                border.style.left = obj.headers.children[index].offsetLeft + 2 + 'px';
            } else {
                border.style.width = rect.width + 'px';
                border.style.left = obj.headers.children[index].offsetLeft + 'px';
            }

            border.style.bottom = '0px';
        };

        var updateControls = function(x) {
            if (typeof(obj.headers.scrollTo) == 'function') {
                obj.headers.scrollTo({
                    left: x,
                    behavior: 'smooth',
                });
            } else {
                obj.headers.scrollLeft = x;
            }

            if (x <= 1) {
                prev.classList.add('disabled');
            } else {
                prev.classList.remove('disabled');
            }

            if (x >= obj.headers.scrollWidth - obj.headers.offsetWidth) {
                next.classList.add('disabled');
            } else {
                next.classList.remove('disabled');
            }

            if (obj.headers.scrollWidth <= obj.headers.offsetWidth) {
                prev.style.display = 'none';
                next.style.display = 'none';
            } else {
                prev.style.display = '';
                next.style.display = '';
            }
        };

        // Set value
        obj.open = function(index) {
            var previous = null;
            for (var i = 0; i < obj.headers.children.length; i++) {
                if (obj.headers.children[i].classList.contains('jtabs-selected')) {
                    // Current one
                    previous = i;
                }
                // Remote selected
                obj.headers.children[i].classList.remove('jtabs-selected');
                if (obj.content.children[i]) {
                    obj.content.children[i].classList.remove('jtabs-selected');
                }
            }

            obj.headers.children[index].classList.add('jtabs-selected');
            if (obj.content.children[index]) {
                obj.content.children[index].classList.add('jtabs-selected');
            }

            if (previous != index && typeof(obj.options.onchange) == 'function') {
                if (obj.content.children[index]) {
                    obj.options.onchange(el, obj, index, obj.headers.children[index], obj.content.children[index]);
                }
            }

            // Hide
            if (obj.options.hideHeaders == true && (obj.headers.children.length < 3 && obj.options.allowCreate == false)) {
                obj.headers.parentNode.style.display = 'none';
            } else {
                // Set border
                if (obj.options.animation == true) {
                    setBorder(index);
                }

                obj.headers.parentNode.style.display = '';

                var x1 = obj.headers.children[index].offsetLeft;
                var x2 = x1 + obj.headers.children[index].offsetWidth;
                var r1 = obj.headers.scrollLeft;
                var r2 = r1 + obj.headers.offsetWidth;

                if (! (r1 <= x1 && r2 >= x2)) {
                    // Out of the viewport
                    updateControls(x1 - 1);
                }
            }
        };

        obj.selectIndex = function(a) {
            var index = Array.prototype.indexOf.call(obj.headers.children, a);
            if (index >= 0) {
                obj.open(index);
            }

            return index;
        };

        obj.rename = function(i, title) {
            if (! title) {
                title = prompt('New title', obj.headers.children[i].innerText);
            }
            obj.headers.children[i].innerText = title;
            obj.open(i);
        };

        obj.create = function(title, url) {
            if (typeof(obj.options.onbeforecreate) == 'function') {
                var ret = obj.options.onbeforecreate(el);
                if (ret === false) {
                    return false;
                } else {
                    title = ret;
                }
            }

            var div = obj.appendElement(title);

            if (typeof(obj.options.oncreate) == 'function') {
                obj.options.oncreate(el, div);
            }

            return div;
        };

        obj.remove = function(index) {
            return obj.deleteElement(index);
        };

        obj.nextNumber = function() {
            var num = 0;
            for (var i = 0; i < obj.headers.children.length; i++) {
                var tmp = obj.headers.children[i].innerText.match(/[0-9].*/);
                if (tmp > num) {
                    num = parseInt(tmp);
                }
            }
            if (! num) {
                num = 1;
            } else {
                num++;
            }

            return num;
        };

        obj.deleteElement = function(index) {
            if (! obj.headers.children[index]) {
                return false;
            } else {
                obj.headers.removeChild(obj.headers.children[index]);
                obj.content.removeChild(obj.content.children[index]);
            }

            obj.open(0);

            if (typeof(obj.options.ondelete) == 'function') {
                obj.options.ondelete(el, index);
            }
        };

        obj.appendElement = function(title) {
            if (! title) {
                var title = prompt('Title?', '');
            }

            if (title) {
                // Add content
                var div = document.createElement('div');
                obj.content.appendChild(div);

                // Add headers
                var h = document.createElement('div');
                h.innerHTML = title;
                h.content = div;
                obj.headers.insertBefore(h, obj.headers.lastChild);

                // Sortable
                if (obj.options.allowChangePosition) {
                    h.setAttribute('draggable', 'true');
                }
                // Open new tab
                obj.selectIndex(h);

                // Return element
                return div;
            }
        };

        obj.getActive = function() {
            for (var i = 0; i < obj.headers.children.length; i++) {
                if (obj.headers.children[i].classList.contains('jtabs-selected')) {
                    return i
                }
            }
            return 0;
        };

        obj.updateContent = function(position, newContent) {
            if (typeof newContent !== 'string') {
                var contentItem = newContent;
            } else {
                var contentItem = document.createElement('div');
                contentItem.innerHTML = newContent;
            }

            if (obj.content.children[position].classList.contains('jtabs-selected')) {
                newContent.classList.add('jtabs-selected');
            }

            obj.content.replaceChild(newContent, obj.content.children[position]);
        };

        obj.updatePosition = function(f, t) {
            // Ondrop update position of content
            if (f > t) {
                obj.content.insertBefore(obj.content.children[f], obj.content.children[t]);
            } else {
                obj.content.insertBefore(obj.content.children[f], obj.content.children[t].nextSibling);
            }

            // Open destination tab
            obj.open(t);

            // Call event
            if (typeof(obj.options.onchangeposition) == 'function') {
                obj.options.onchangeposition(obj.headers, f, t);
            }
        };

        obj.move = function(f, t) {
            if (f > t) {
                obj.headers.insertBefore(obj.headers.children[f], obj.headers.children[t]);
            } else {
                obj.headers.insertBefore(obj.headers.children[f], obj.headers.children[t].nextSibling);
            }

            obj.updatePosition(f, t);
        };

        obj.setBorder = setBorder;

        obj.init = function() {
            el.innerHTML = '';

            // Make sure the component is blank
            obj.headers = document.createElement('div');
            obj.content = document.createElement('div');
            obj.headers.classList.add('jtabs-headers');
            obj.content.classList.add('jtabs-content');

            if (obj.options.palette) {
                el.classList.add('jtabs-modern');
            } else {
                el.classList.remove('jtabs-modern');
            }

            // Padding
            if (obj.options.padding) {
                obj.content.style.padding = parseInt(obj.options.padding) + 'px';
            }

            // Header
            var header = document.createElement('div');
            header.className = 'jtabs-headers-container';
            header.appendChild(obj.headers);

            // Controls
            var controls = document.createElement('div');
            controls.className = 'jtabs-controls';
            controls.setAttribute('draggable', 'false');
            header.appendChild(controls);

            // Append DOM elements
            if (obj.options.position == 'bottom') {
                el.appendChild(obj.content);
                el.appendChild(header);
            } else {
                el.appendChild(header);
                el.appendChild(obj.content);
            }

            // New button
            if (obj.options.allowCreate == true) {
                var add = document.createElement('div');
                add.className = 'jtabs-add';
                add.onclick = function() {
                    obj.create();
                };
                controls.appendChild(add);
            }

            prev = document.createElement('div');
            prev.className = 'jtabs-prev';
            prev.onclick = function() {
                updateControls(obj.headers.scrollLeft - obj.headers.offsetWidth);
            };
            controls.appendChild(prev);

            next = document.createElement('div');
            next.className = 'jtabs-next';
            next.onclick = function() {
                updateControls(obj.headers.scrollLeft + obj.headers.offsetWidth);
            };
            controls.appendChild(next);

            // Data
            for (var i = 0; i < obj.options.data.length; i++) {
                // Title
                if (obj.options.data[i].titleElement) {
                    var headerItem = obj.options.data[i].titleElement;
                } else {
                    var headerItem = document.createElement('div');
                }
                // Icon
                if (obj.options.data[i].icon) {
                    var iconContainer = document.createElement('div');
                    var icon = document.createElement('i');
                    icon.classList.add('material-icons');
                    icon.innerHTML = obj.options.data[i].icon;
                    iconContainer.appendChild(icon);
                    headerItem.appendChild(iconContainer);
                }
                // Title
                if (obj.options.data[i].title) {
                    var title = document.createTextNode(obj.options.data[i].title);
                    headerItem.appendChild(title);
                }
                // Width
                if (obj.options.data[i].width) {
                    headerItem.style.width = obj.options.data[i].width;
                }
                // Content
                if (obj.options.data[i].contentElement) {
                    var contentItem = obj.options.data[i].contentElement;
                } else {
                    var contentItem = document.createElement('div');
                    contentItem.innerHTML = obj.options.data[i].content;
                }
                obj.headers.appendChild(headerItem);
                obj.content.appendChild(contentItem);
            }

            // Animation
            border = document.createElement('div');
            border.className = 'jtabs-border';
            obj.headers.appendChild(border);

            if (obj.options.animation) {
                el.classList.add('jtabs-animation');
            }

            // Events
            obj.headers.addEventListener("click", function(e) {
                if (e.target.parentNode.classList.contains('jtabs-headers')) {
                    var target = e.target;
                } else {
                    if (e.target.tagName == 'I') {
                        var target = e.target.parentNode.parentNode;
                    } else {
                        var target = e.target.parentNode;
                    }
                }

                var index = obj.selectIndex(target);

                if (typeof(obj.options.onclick) == 'function') {
                    obj.options.onclick(el, obj, index, obj.headers.children[index], obj.content.children[index]);
                }
            });

            obj.headers.addEventListener("contextmenu", function(e) {
                obj.selectIndex(e.target);
            });

            if (obj.headers.children.length) {
                // Open first tab
                obj.open(0);
            }

            // Update controls
            updateControls(0);

            if (obj.options.allowChangePosition == true) {
                jSuites.sorting(obj.headers, {
                    direction: 1,
                    ondrop: function(a,b,c) {
                        obj.updatePosition(b,c);
                    },
                });
            }

            if (typeof(obj.options.onload) == 'function') {
                obj.options.onload(el, obj);
            }
        };

        // Loading existing nodes as the data
        if (el.children[0] && el.children[0].children.length) {
            // Create from existing elements
            for (var i = 0; i < el.children[0].children.length; i++) {
                var item = obj.options.data && obj.options.data[i] ? obj.options.data[i] : {};

                if (el.children[1] && el.children[1].children[i]) {
                    item.titleElement = el.children[0].children[i];
                    item.contentElement = el.children[1].children[i];
                } else {
                    item.contentElement = el.children[0].children[i];
                }

                obj.options.data[i] = item;
            }
        }

        // Remote controller flag
        var loadingRemoteData = false;

        // Create from data
        if (obj.options.data) {
            // Append children
            for (var i = 0; i < obj.options.data.length; i++) {
                if (obj.options.data[i].url) {
                    jSuites.ajax({
                        url: obj.options.data[i].url,
                        type: 'GET',
                        dataType: 'text/html',
                        index: i,
                        success: function(result) {
                            obj.options.data[this.index].content = result;
                        },
                        complete: function() {
                            obj.init();
                        }
                    });

                    // Flag loading
                    loadingRemoteData = true;
                }
            }
        }

        if (! loadingRemoteData) {
            obj.init();
        }

        el.tabs = obj;

        return obj;
    });

    jSuites.tags = (function(el, options) {
        // Redefine configuration
        if (el.tags) {
            return el.tags.setOptions(options, true);
        }

        var obj = { type:'tags' };
        obj.options = {};

        // Limit
        var limit = function() {
            return obj.options.limit && el.children.length >= obj.options.limit ? true : false;
        };

        // Search helpers
        var search = null;
        var searchContainer = null;

        obj.setOptions = function(options, reset) {
            /**
             * @typedef {Object} defaults
             * @property {(string|Array)} value - Initial value of the compontent
             * @property {number} limit - Max number of tags inside the element
             * @property {string} search - The URL for suggestions
             * @property {string} placeholder - The default instruction text on the element
             * @property {validation} validation - Method to validate the tags
             * @property {requestCallback} onbeforechange - Method to be execute before any changes on the element
             * @property {requestCallback} onchange - Method to be execute after any changes on the element
             * @property {requestCallback} onfocus - Method to be execute when on focus
             * @property {requestCallback} onblur - Method to be execute when on blur
             * @property {requestCallback} onload - Method to be execute when the element is loaded
             */
            var defaults = {
                value: '',
                limit: null,
                limitMessage: 'The limit of entries is: ',
                search: null,
                placeholder: null,
                validation: null,
                onbeforechange: null,
                onchange: null,
                onfocus: null,
                onblur: null,
                onload: null,
                colors: null,
            };

            // Loop through though the default configuration
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = options[property];
                } else {
                    if (typeof(obj.options[property]) == 'undefined' || reset === true) {
                        obj.options[property] = defaults[property];
                    }
                }
            }

            // Placeholder
            if (obj.options.placeholder) {
                el.setAttribute('data-placeholder', obj.options.placeholder);
            } else {
                el.removeAttribute('data-placeholder');
            }
            el.placeholder = obj.options.placeholder;

            // Update value
            obj.setValue(obj.options.value);

            // Validate items
            filter();

            // Create search box
            if (obj.options.search) {
                if (! searchContainer) {
                    searchContainer = document.createElement('div');
                    el.parentNode.insertBefore(searchContainer, el.nextSibling);

                    // Create container
                    search = jSuites.search(searchContainer, {
                        data: obj.options.search,
                        onselect: function(a,b,c) {
                            obj.selectIndex(b,c);
                        }
                    });
                }
            } else {
                if (searchContainer) {
                    search = null;
                    searchContainer.remove();
                    searchContainer = null;
                }
            }

            return obj;
        };

        /**
         * Add a new tag to the element
         * @param {(?string|Array)} value - The value of the new element
         */
        obj.add = function(value, focus) {
            if (typeof(obj.options.onbeforechange) == 'function') {
                var ret = obj.options.onbeforechange(el, obj, obj.options.value, value);
                if (ret === false) {
                    return false;
                } else { 
                    if (ret != null) {
                        value = ret;
                    }
                }
            }

            // Make sure search is closed
            if (search) {
                search.close();
            }

            if (limit()) {
                alert(obj.options.limitMessage + ' ' + obj.options.limit);
            } else {
                // Get node
                var node = jSuites.getNode();

                if (node && node.parentNode && node.parentNode.classList.contains('jtags') &&
                    node.nextSibling && (! (node.nextSibling.innerText && node.nextSibling.innerText.trim()))) {
                    div = node.nextSibling;
                } else {
                    // Remove not used last item
                    if (el.lastChild) {
                        if (! el.lastChild.innerText.trim()) {
                            el.removeChild(el.lastChild);
                        }
                    }

                    // Mix argument string or array
                    if (! value || typeof(value) == 'string') {
                        var div = createElement(value, value, node);
                    } else {
                        for (var i = 0; i <= value.length; i++) {
                            if (! limit()) {
                                if (! value[i] || typeof(value[i]) == 'string') {
                                    var t = value[i] || '';
                                    var v = null;
                                } else {
                                    var t = value[i].text;
                                    var v = value[i].value;
                                }

                                // Add element
                                var div = createElement(t, v);
                            }
                        }
                    }

                    // Change
                    change();
                }

                // Place caret
                if (focus) {
                    setFocus(div);
                }
            }
        };

        // Remove a item node
        obj.remove = function(node) {
            // Remove node
            node.parentNode.removeChild(node);
            // Make sure element is not blank
            if (! el.children.length) {
                obj.add('', true);
            } else {
                change();
            }
        };

        /**
         * Get all tags in the element
         * @return {Array} data - All tags as an array
         */
        obj.getData = function() {
            var data = [];
            for (var i = 0; i < el.children.length; i++) {
                // Get value
                var text = el.children[i].innerText.replace("\n", "");
                // Get id
                var value = el.children[i].getAttribute('data-value');
                if (! value) {
                    value = text;
                }
                // Item
                if (text || value) {
                    data.push({ text: text, value: value });
                }
            }
            return data;
        };

        /**
         * Get the value of one tag. Null for all tags
         * @param {?number} index - Tag index number. Null for all tags.
         * @return {string} value - All tags separated by comma
         */
        obj.getValue = function(index) {
            var value = null;

            if (index != null) {
                // Get one individual value
                value = el.children[index].getAttribute('data-value');
                if (! value) {
                    value = el.children[index].innerText.replace("\n", "");
                }
            } else {
                // Get all
                var data = [];
                for (var i = 0; i < el.children.length; i++) {
                    value = el.children[i].innerText.replace("\n", "");
                    if (value) {
                        data.push(obj.getValue(i));
                    }
                }
                value = data.join(',');
            }

            return value;
        };

        /**
         * Set the value of the element based on a string separeted by (,|;|\r\n)
         * @param {mixed} value - A string or array object with values
         */
        obj.setValue = function(mixed) {
            if (! mixed) {
                obj.reset();
            } else {
                if (el.value != mixed) {
                    if (Array.isArray(mixed)) {
                        obj.add(mixed);
                    } else {
                        // Remove whitespaces
                        var text = (''+mixed).trim();
                        // Tags
                        var data = extractTags(text);
                        // Reset
                        el.innerHTML = '';
                        // Add tags to the element
                        obj.add(data);
                    }
                }
            }
        };

        /**
         * Reset the data from the element
         */
        obj.reset = function() {
            // Empty class
            el.classList.add('jtags-empty');
            // Empty element
            el.innerHTML = '<div></div>';
            // Execute changes
            change();
        };

        /**
         * Verify if all tags in the element are valid
         * @return {boolean}
         */
        obj.isValid = function() {
            var test = 0;
            for (var i = 0; i < el.children.length; i++) {
                if (el.children[i].classList.contains('jtags_error')) {
                    test++;
                }
            }
            return test == 0 ? true : false;
        };

        /**
         * Add one element from the suggestions to the element
         * @param {object} item - Node element in the suggestions container
         */ 
        obj.selectIndex = function(text, value) {
            var node = jSuites.getNode();
            if (node) {
                // Append text to the caret
                node.innerText = text;
                // Set node id
                if (value) {
                    node.setAttribute('data-value', value);
                }
                // Remove any error
                node.classList.remove('jtags_error');
                if (! limit()) {
                    // Add new item
                    obj.add('', true);
                }
            }
        };

        /**
         * Search for suggestions
         * @param {object} node - Target node for any suggestions
         */
        obj.search = function(node) {
            // Search for
            node.innerText;
        };

        // Destroy tags element
        obj.destroy = function() {
            // Bind events
            el.removeEventListener('mouseup', tagsMouseUp);
            el.removeEventListener('keydown', tagsKeyDown);
            el.removeEventListener('keyup', tagsKeyUp);
            el.removeEventListener('paste', tagsPaste);
            el.removeEventListener('focus', tagsFocus);
            el.removeEventListener('blur', tagsBlur);

            // Remove element
            el.parentNode.removeChild(el);
        };

        var setFocus = function(node) {
            var range = document.createRange();
            var sel = window.getSelection();
            range.setStart(node, node.innerText.length||0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            node.scrollLeft = node.scrollWidth;
        };

        var createElement = function(label, value, node) {
            var div = document.createElement('div');
            div.innerHTML = label ? label : '';
            if (value) {
                div.setAttribute('data-value', value);
            }

            if (node && node.parentNode.classList.contains('jtags')) {
                el.insertBefore(div, node.nextSibling);
            } else {
                el.appendChild(div);
            }

            return div;
        };

        var change = function() {
            // Value
            var value = obj.getValue();

            if (value != obj.options.value) {
                obj.options.value = value;
                if (typeof(obj.options.onchange) == 'function') {
                    obj.options.onchange(el, obj, obj.options.value);
                }

                // Lemonade JS
                if (el.value != obj.options.value) {
                    el.value = obj.options.value;
                    if (typeof(el.onchange) == 'function') {
                        el.onchange({
                            type: 'change',
                            target: el,
                            value: el.value
                        });
                    }
                }
            }

            filter();
        };

        /**
         * Filter tags
         */
        var filter = function() {
            for (var i = 0; i < el.children.length; i++) {
                // Create label design
                if (! obj.getValue(i)) {
                    el.children[i].classList.remove('jtags_label');
                } else {
                    el.children[i].classList.add('jtags_label');

                    // Validation in place
                    if (typeof(obj.options.validation) == 'function') {
                        if (obj.getValue(i)) {
                            if (! obj.options.validation(el.children[i], el.children[i].innerText, el.children[i].getAttribute('data-value'))) {
                                el.children[i].classList.add('jtags_error');
                            } else {
                                el.children[i].classList.remove('jtags_error');
                            }
                        } else {
                            el.children[i].classList.remove('jtags_error');
                        }
                    } else {
                        el.children[i].classList.remove('jtags_error');
                    }
                }
            }

            isEmpty();
        };

        var isEmpty = function() {
            // Can't be empty
            if (! el.innerText.trim()) {
                el.innerHTML = '<div></div>';
                el.classList.add('jtags-empty');
            } else {
                el.classList.remove('jtags-empty');
            }
        };

        /**
         * Extract tags from a string
         * @param {string} text - Raw string
         * @return {Array} data - Array with extracted tags
         */
        var extractTags = function(text) {
            /** @type {Array} */
            var data = [];

            /** @type {string} */
            var word = '';

            // Remove whitespaces
            text = text.trim();

            if (text) {
                for (var i = 0; i < text.length; i++) {
                    if (text[i] == ',' || text[i] == ';' || text[i] == '\n') {
                        if (word) {
                            data.push(word.trim());
                            word = '';
                        }
                    } else {
                        word += text[i];
                    }
                }

                if (word) {
                    data.push(word);
                }
            }

            return data;
        };

        /** @type {number} */
        var anchorOffset = 0;

        /**
         * Processing event keydown on the element
         * @param e {object}
         */
        var tagsKeyDown = function(e) {
            // Anchoroffset
            anchorOffset = window.getSelection().anchorOffset;

            // Verify if is empty
            isEmpty();

            // Comma
            if (e.key === 'Tab'  || e.key === ';' || e.key === ',') {
                var n = window.getSelection().anchorOffset;
                if (n > 1) {
                    if (! limit()) {
                        obj.add('', true);
                    }
                }
                e.preventDefault();
            } else if (e.key == 'Enter') {
                if (! search || ! search.isOpened()) {
                    var n = window.getSelection().anchorOffset;
                    if (n > 1) {
                        if (! limit()) {
                            obj.add('', true);
                        }
                    }
                    e.preventDefault();
                }
            } else if (e.key == 'Backspace') {
                // Back space - do not let last item to be removed
                if (el.children.length == 1 && window.getSelection().anchorOffset < 1) {
                    e.preventDefault();
                }
            }

            // Search events
            if (search) {
                search.keydown(e);
            }
        };

        /**
         * Processing event keyup on the element
         * @param e {object}
         */
        var tagsKeyUp = function(e) {
            if (e.which == 39) {
                // Right arrow
                var n = window.getSelection().anchorOffset;
                if (n > 1 && n == anchorOffset) {
                    obj.add('', true);
                }
            } else if (e.which == 13 || e.which == 38 || e.which == 40) {
                e.preventDefault();
            } else {
                if (search) {
                    search.keyup(e);
                }
            }

            filter();
        };

        /**
         * Processing event paste on the element
         * @param e {object}
         */
        var tagsPaste =  function(e) {
            if (e.clipboardData || e.originalEvent.clipboardData) {
                var text = (e.originalEvent || e).clipboardData.getData('text/plain');
            } else if (window.clipboardData) {
                var text = window.clipboardData.getData('Text');
            }

            var data = extractTags(text);
            if (data.length > 1) {
                obj.add(data, true);
                e.preventDefault();
            }
        };

        /**
         * Processing event mouseup on the element
         * @param e {object}
         */
        var tagsMouseUp = function(e) {
            if (e.target.parentNode && e.target.parentNode.classList.contains('jtags')) {
                if (e.target.classList.contains('jtags_label') || e.target.classList.contains('jtags_error')) {
                    var rect = e.target.getBoundingClientRect();
                    if (rect.width - (e.clientX - rect.left) < 16) {
                        obj.remove(e.target);
                    }
                }
            }
        };

        var tagsFocus = function() {
            if (! el.classList.contains('jtags-focus')) {
                if (! el.children.length || obj.getValue(el.children.length - 1)) {
                    if (! limit()) {
                        createElement('');
                    }
                }

                if (typeof(obj.options.onfocus) == 'function') {
                    obj.options.onfocus(el, obj, obj.getValue());
                }

                el.classList.add('jtags-focus');
            }
        };

        var tagsBlur = function() {
            if (el.classList.contains('jtags-focus')) {
                if (search) {
                    search.close();
                }

                for (var i = 0; i < el.children.length - 1; i++) {
                    // Create label design
                    if (! obj.getValue(i)) {
                        el.removeChild(el.children[i]);
                    }
                }

                change();

                el.classList.remove('jtags-focus');

                if (typeof(obj.options.onblur) == 'function') {
                    obj.options.onblur(el, obj, obj.getValue());
                }
            }
        };

        var init = function() {
            // Bind events
            if ('touchend' in document.documentElement === true) {
                el.addEventListener('touchend', tagsMouseUp);
            } else {
                el.addEventListener('mouseup', tagsMouseUp);
            }

            el.addEventListener('keydown', tagsKeyDown);
            el.addEventListener('keyup', tagsKeyUp);
            el.addEventListener('paste', tagsPaste);
            el.addEventListener('focus', tagsFocus);
            el.addEventListener('blur', tagsBlur);

            // Editable
            el.setAttribute('contenteditable', true);

            // Prepare container
            el.classList.add('jtags');

            // Initial options
            obj.setOptions(options);

            if (typeof(obj.options.onload) == 'function') {
                obj.options.onload(el, obj);
            }

            // Change methods
            el.change = obj.setValue;

            // Global generic value handler
            el.val = function(val) {
                if (val === undefined) {
                    return obj.getValue();
                } else {
                    obj.setValue(val);
                }
            };

            el.tags = obj;
        };

        init();

        return obj;
    });

    jSuites.toolbar = (function(el, options) {
        var obj = {};
        obj.options = {};

        // Default configuration
        var defaults = {
            app: null,
            container: false,
            badge: false,
            title: false,
            responsive: false,
            items: [],
        };

        // Loop through our object
        for (var property in defaults) {
            if (options && options.hasOwnProperty(property)) {
                obj.options[property] = options[property];
            } else {
                obj.options[property] = defaults[property];
            }
        }

        if (! el && options.app && options.app.el) {
            el = document.createElement('div');
            options.app.el.appendChild(el);
        }

        // Arrow
        var toolbarArrow = document.createElement('div');
        toolbarArrow.classList.add('jtoolbar-item');
        toolbarArrow.classList.add('jtoolbar-arrow');

        var toolbarFloating = document.createElement('div');
        toolbarFloating.classList.add('jtoolbar-floating');
        toolbarArrow.appendChild(toolbarFloating);

        obj.selectItem = function(element) {
            var elements = toolbarContent.children;
            for (var i = 0; i < elements.length; i++) {
                if (element != elements[i]) {
                    elements[i].classList.remove('jtoolbar-selected');
                }
            }
            element.classList.add('jtoolbar-selected');
        };

        obj.hide = function() {
            jSuites.animation.slideBottom(el, 0, function() {
                el.style.display = 'none';
            });
        };

        obj.show = function() {
            el.style.display = '';
            jSuites.animation.slideBottom(el, 1);
        };

        obj.get = function() {
            return el;
        };

        obj.setBadge = function(index, value) {
            toolbarContent.children[index].children[1].firstChild.innerHTML = value;
        };

        obj.destroy = function() {
            toolbar.remove();
            el.innerHTML = '';
        };

        var toggleState = function() {
            if (this.classList.contains('jtoolbar-active')) {
                this.classList.remove('jtoolbar-active');
            } else {
                this.classList.add('jtoolbar-active');
            }
        };

        obj.create = function(items) {
            // Reset anything in the toolbar
            toolbarContent.innerHTML = '';
            // Create elements in the toolbar
            for (var i = 0; i < items.length; i++) {
                var toolbarItem = document.createElement('div');
                toolbarItem.classList.add('jtoolbar-item');

                if (items[i].width) {
                    toolbarItem.style.width = parseInt(items[i].width) + 'px'; 
                }

                if (items[i].k) {
                    toolbarItem.k = items[i].k;
                }

                if (items[i].tooltip) {
                    toolbarItem.setAttribute('title', items[i].tooltip);
                }

                // Id
                if (items[i].id) {
                    toolbarItem.setAttribute('id', items[i].id);
                }

                // Selected
                if (items[i].state) {
                    toolbarItem.toggleState = toggleState;
                }

                if (items[i].active) {
                    toolbarItem.classList.add('jtoolbar-active');
                }

                if (items[i].type == 'select' || items[i].type == 'dropdown') {
                    jSuites.picker(toolbarItem, items[i]);
                } else if (items[i].type == 'divisor') {
                    toolbarItem.classList.add('jtoolbar-divisor');
                } else if (items[i].type == 'label') {
                    toolbarItem.classList.add('jtoolbar-label');
                    toolbarItem.innerHTML = items[i].content;
                } else {
                    // Material icons
                    var toolbarIcon = document.createElement('i');
                    if (typeof(items[i].class) === 'undefined') {
                        toolbarIcon.classList.add('material-icons');
                    } else {
                        var c = items[i].class.split(' ');
                        for (var j = 0; j < c.length; j++) {
                            toolbarIcon.classList.add(c[j]);
                        }
                    }
                    toolbarIcon.innerHTML = items[i].content ? items[i].content : '';
                    toolbarItem.appendChild(toolbarIcon);

                    // Badge options
                    if (obj.options.badge == true) {
                        var toolbarBadge = document.createElement('div');
                        toolbarBadge.classList.add('jbadge');
                        var toolbarBadgeContent = document.createElement('div');
                        toolbarBadgeContent.innerHTML = items[i].badge ? items[i].badge : '';
                        toolbarBadge.appendChild(toolbarBadgeContent);
                        toolbarItem.appendChild(toolbarBadge);
                    }

                    // Title
                    if (items[i].title) {
                        if (obj.options.title == true) {
                            var toolbarTitle = document.createElement('span');
                            toolbarTitle.innerHTML = items[i].title;
                            toolbarItem.appendChild(toolbarTitle);
                        } else {
                            toolbarItem.setAttribute('title', items[i].title);
                        }
                    }

                    if (obj.options.app && items[i].route) {
                        // Route
                        toolbarItem.route = items[i].route;
                        // Onclick for route
                        toolbarItem.onclick = function() {
                            obj.options.app.pages(this.route);
                        };
                        // Create pages
                        obj.options.app.pages(items[i].route, {
                            toolbarItem: toolbarItem,
                            closed: true
                        });
                    }
                }

                if (items[i].onclick) {
                    toolbarItem.onclick = items[i].onclick.bind(items[i], el, obj, toolbarItem);
                }

                toolbarContent.appendChild(toolbarItem);
            }

            // Fits to the page
            obj.refresh();
        };

        obj.open = function() {
            toolbarArrow.classList.add('jtoolbar-arrow-selected');

            var rect = toolbarFloating.getBoundingClientRect();
            if (rect.bottom > window.innerHeight) {
                toolbarFloating.style.bottom = '0';
            } else {
                toolbarFloating.style.removeProperty('bottom');
            }

            toolbarFloating.style.right = '0';

            toolbarArrow.children[0].focus();
            // Start tracking
            jSuites.tracking(obj, true);
        };

        obj.close = function() {
            toolbarArrow.classList.remove('jtoolbar-arrow-selected');
            // End tracking
            jSuites.tracking(obj, false);
        };

        obj.refresh = function() {
            if (obj.options.responsive == true) {
                // Remove arrow
                toolbarArrow.remove();
                // Move all items to the toolbar
                while (toolbarFloating.firstChild) {
                    toolbarContent.appendChild(toolbarFloating.firstChild);
                }
                // Available space
                var available = el.parentNode.offsetWidth - 60;
                // Move to the floating option
                while (available < toolbarContent.offsetWidth) {
                    if (toolbarContent.lastChild) {
                        toolbarFloating.insertBefore(toolbarContent.lastChild, toolbarFloating.firstChild);
                    }
                }
                // Show arrow
                if (toolbarFloating.children.length > 0) {
                    toolbarContent.appendChild(toolbarArrow);
                }
            }
        };

        el.onclick = function(e) {
            var element = jSuites.findElement(e.target, 'jtoolbar-item');
            if (element) {
                obj.selectItem(element);
            }

            if (e.target.classList.contains('jtoolbar-arrow')) {
                obj.open();
            }
        };

        window.addEventListener('resize', function() {
            obj.refresh();
        });

        // Toolbar
        el.classList.add('jtoolbar');
        // Reset content
        el.innerHTML = '';
        // Container
        if (obj.options.container == true) {
            el.classList.add('jtoolbar-container');
        }
        // Content
        var toolbarContent = document.createElement('div');
        el.appendChild(toolbarContent);
        // Special toolbar for mobile applications
        if (obj.options.app) {
            el.classList.add('jtoolbar-mobile');
        }
        // Create toolbar
        obj.create(obj.options.items);
        // Shortcut
        el.toolbar = obj;

        return obj;
    });

    jSuites.validations = {};

    jSuites.validations.email = function(data) {
        var reg = new RegExp(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
        return data && reg.test(data) ? true : false; 
    };

    jSuites.validations.length = function(data, element) {
        var len = element.getAttribute('data-length') || 5;
        return (data.length >= len) ? true : false;
    };

    jSuites.validations.required = function(data) {
        return data.trim() ? true : false;
    };

    jSuites.validations.number = function(data, config) {

        return jSuites.isNumber(data);
    };

    jSuites.validations.date = function(data, config) {
        if (config.operator == '>=') {
            return data >= config.reference;
        }
    };




        return jSuites;

    })));
    });

    /**
     * Jspreadsheet v4.7.3
     *
     * Website: https://bossanova.uk/jspreadsheet/
     * Description: Create amazing web based spreadsheets.
     *
     * This software is distribute under MIT License
     */

    var dist = createCommonjsModule(function (module, exports) {
    if (! jSuites && typeof(commonjsRequire) === 'function') {
        var jSuites = jsuites;
    }
    (function (global, factory) {
        module.exports = factory() ;
    }(commonjsGlobal, (function () {

        // Basic version information
        var Version = function() {
            // Information
            var info = {
                title: 'Jspreadsheet',
                version: '4.7.3',
                type: 'CE',
                host: 'https://bossanova.uk/jspreadsheet',
                license: 'MIT',
                print: function() {
                    return [ this.title + ' ' + this.type + ' ' + this.version, this.host, this.license ].join('\r\n'); 
                }
            };

            return function() {
                return info;
            };
        }();

        // Jspreadsheet core object
        var jexcel = (function(el, options) {
            // Create jspreadsheet object
            var obj = {};
            obj.options = {};

            if (! (el instanceof Element || el instanceof HTMLDocument)) {
                console.error('Jspreadsheet: el is not a valid DOM element');
                return false;
            } else if (el.tagName == 'TABLE') {
                if (options = jexcel.createFromTable(el, options)) {
                    var div = document.createElement('div');
                    el.parentNode.insertBefore(div, el);
                    el.remove();
                    el = div;
                } else {
                    console.error('Jspreadsheet: el is not a valid DOM element');
                    return false;
                }
            }

            // Loading default configuration
            var defaults = {
                // External data
                url:null,
                // Ajax options
                method: 'GET',
                requestVariables: null,
                // Data
                data:null,
                // Custom sorting handler
                sorting:null,
                // Copy behavior
                copyCompatibility:false,
                root:null,
                // Rows and columns definitions
                rows:[],
                columns:[],
                // Deprected legacy options
                colHeaders:[],
                colWidths:[],
                colAlignments:[],
                nestedHeaders:null,
                // Column width that is used by default
                defaultColWidth:50,
                defaultColAlign:'center',
                // Spare rows and columns
                minSpareRows:0,
                minSpareCols:0,
                // Minimal table dimensions
                minDimensions:[0,0],
                // Allow Export
                allowExport:true,
                // @type {boolean} - Include the header titles on download
                includeHeadersOnDownload:false,
                // @type {boolean} - Include the header titles on copy
                includeHeadersOnCopy:false,
                // Allow column sorting
                columnSorting:true,
                // Allow column dragging
                columnDrag:false,
                // Allow column resizing
                columnResize:true,
                // Allow row resizing
                rowResize:false,
                // Allow row dragging
                rowDrag:true,
                // Allow table edition
                editable:true,
                // Allow new rows
                allowInsertRow:true,
                // Allow new rows
                allowManualInsertRow:true,
                // Allow new columns
                allowInsertColumn:true,
                // Allow new rows
                allowManualInsertColumn:true,
                // Allow row delete
                allowDeleteRow:true,
                // Allow deleting of all rows
                allowDeletingAllRows:false,
                // Allow column delete
                allowDeleteColumn:true,
                // Allow rename column
                allowRenameColumn:true,
                // Allow comments
                allowComments:false,
                // Global wrap
                wordWrap:false,
                // Image options
                imageOptions: null,
                // CSV source
                csv:null,
                // Filename
                csvFileName:'jspreadsheet',
                // Consider first line as header
                csvHeaders:true,
                // Delimiters
                csvDelimiter:',',
                // First row as header
                parseTableFirstRowAsHeader:false,
                parseTableAutoCellType:false,
                // Disable corner selection
                selectionCopy:true,
                // Merged cells
                mergeCells:{},
                // Create toolbar
                toolbar:null,
                // Allow search
                search:false,
                // Create pagination
                pagination:false,
                paginationOptions:null,
                // Full screen
                fullscreen:false,
                // Lazy loading
                lazyLoading:false,
                loadingSpin:false,
                // Table overflow
                tableOverflow:false,
                tableHeight:'300px',
                tableWidth:null,
                textOverflow:false,
                // Meta
                meta: null,
                // Style
                style:null,
                classes:null,
                // Execute formulas
                parseFormulas:true,
                autoIncrement:true,
                autoCasting:true,
                // Security
                secureFormulas:true,
                stripHTML:true,
                stripHTMLOnCopy:false,
                // Filters
                filters:false,
                footers:null,
                // Event handles
                onundo:null,
                onredo:null,
                onload:null,
                onchange:null,
                oncomments:null,
                onbeforechange:null,
                onafterchanges:null,
                onbeforeinsertrow: null,
                oninsertrow:null,
                onbeforeinsertcolumn: null,
                oninsertcolumn:null,
                onbeforedeleterow:null,
                ondeleterow:null,
                onbeforedeletecolumn:null,
                ondeletecolumn:null,
                onmoverow:null,
                onmovecolumn:null,
                onresizerow:null,
                onresizecolumn:null,
                onsort:null,
                onselection:null,
                oncopy:null,
                onpaste:null,
                onbeforepaste:null,
                onmerge:null,
                onfocus:null,
                onblur:null,
                onchangeheader:null,
                oncreateeditor:null,
                oneditionstart:null,
                oneditionend:null,
                onchangestyle:null,
                onchangemeta:null,
                onchangepage:null,
                onbeforesave:null,
                onsave:null,
                // Global event dispatcher
                onevent:null,
                // Persistance
                persistance:false,
                // Customize any cell behavior
                updateTable:null,
                // Detach the HTML table when calling updateTable
                detachForUpdates: false,
                freezeColumns:null,
                // Texts
                text:{
                    noRecordsFound: 'No records found',
                    showingPage: 'Showing page {0} of {1} entries',
                    show: 'Show ',
                    search: 'Search',
                    entries: ' entries',
                    columnName: 'Column name',
                    insertANewColumnBefore: 'Insert a new column before',
                    insertANewColumnAfter: 'Insert a new column after',
                    deleteSelectedColumns: 'Delete selected columns',
                    renameThisColumn: 'Rename this column',
                    orderAscending: 'Order ascending',
                    orderDescending: 'Order descending',
                    insertANewRowBefore: 'Insert a new row before',
                    insertANewRowAfter: 'Insert a new row after',
                    deleteSelectedRows: 'Delete selected rows',
                    editComments: 'Edit comments',
                    addComments: 'Add comments',
                    comments: 'Comments',
                    clearComments: 'Clear comments',
                    copy: 'Copy...',
                    paste: 'Paste...',
                    saveAs: 'Save as...',
                    about: 'About',
                    areYouSureToDeleteTheSelectedRows: 'Are you sure to delete the selected rows?',
                    areYouSureToDeleteTheSelectedColumns: 'Are you sure to delete the selected columns?',
                    thisActionWillDestroyAnyExistingMergedCellsAreYouSure: 'This action will destroy any existing merged cells. Are you sure?',
                    thisActionWillClearYourSearchResultsAreYouSure: 'This action will clear your search results. Are you sure?',
                    thereIsAConflictWithAnotherMergedCell: 'There is a conflict with another merged cell',
                    invalidMergeProperties: 'Invalid merged properties',
                    cellAlreadyMerged: 'Cell already merged',
                    noCellsSelected: 'No cells selected',
                },
                // About message
                about: true,
            };
        
            // Loading initial configuration from user
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    if (property === 'text') {
                        obj.options[property] = defaults[property];
                        for (var textKey in options[property]) {
                            if (options[property].hasOwnProperty(textKey)){
                                obj.options[property][textKey] = options[property][textKey];
                            }
                        }
                    } else {
                        obj.options[property] = options[property];
                    }
                } else {
                    obj.options[property] = defaults[property];
                }
            }

            // Global elements
            obj.el = el;
            obj.corner = null;
            obj.contextMenu = null;
            obj.textarea = null;
            obj.ads = null;
            obj.content = null;
            obj.table = null;
            obj.thead = null;
            obj.tbody = null;
            obj.rows = [];
            obj.results = null;
            obj.searchInput = null;
            obj.toolbar = null;
            obj.pagination = null;
            obj.pageNumber = null;
            obj.headerContainer = null;
            obj.colgroupContainer = null;
        
            // Containers
            obj.headers = [];
            obj.records = [];
            obj.history = [];
            obj.formula = [];
            obj.colgroup = [];
            obj.selection = [];
            obj.highlighted  = [];
            obj.selectedCell = null;
            obj.selectedContainer = null;
            obj.style = [];
            obj.data = null;
            obj.filter = null;
            obj.filters = [];

            // Internal controllers
            obj.cursor = null;
            obj.historyIndex = -1;
            obj.ignoreEvents = false;
            obj.ignoreHistory = false;
            obj.edition = null;
            obj.hashString = null;
            obj.resizing = null;
            obj.dragging = null;
        
            // Lazy loading
            if (obj.options.lazyLoading == true && (obj.options.tableOverflow == false && obj.options.fullscreen == false)) {
                console.error('Jspreadsheet: The lazyloading only works when tableOverflow = yes or fullscreen = yes');
                obj.options.lazyLoading = false;
            }
            
            /**
             * Activate/Disable fullscreen 
             * use programmatically : table.fullscreen(); or table.fullscreen(true); or table.fullscreen(false);
             * @Param {boolean} activate
             */
            obj.fullscreen = function(activate) {
                // If activate not defined, get reverse options.fullscreen
                if (activate == null) {
                    activate = ! obj.options.fullscreen;
                }
        
                // If change
                if (obj.options.fullscreen != activate) {
                    obj.options.fullscreen = activate;
        
                    // Test LazyLoading conflict
                    if (activate == true) {
                        el.classList.add('fullscreen');
                    } else {
                        el.classList.remove('fullscreen');
                    }
                } 
            };

            /**
             * Trigger events
             */
            obj.dispatch = function(event) {
                // Dispatch events
                if (! obj.ignoreEvents) {
                    // Call global event
                    if (typeof(obj.options.onevent) == 'function') {
                        var ret = obj.options.onevent.apply(this, arguments);
                    }
                    // Call specific events
                    if (typeof(obj.options[event]) == 'function') {
                        var ret = obj.options[event].apply(this, Array.prototype.slice.call(arguments, 1));
                    }
                }

                // Persistance
                if (event == 'onafterchanges' && obj.options.persistance) {
                    var url = obj.options.persistance == true ? obj.options.url : obj.options.persistance;
                    var data = obj.prepareJson(arguments[2]);
                    obj.save(url, data);
                }

                return ret;
            };

            /**
             * Prepare the jspreadsheet table
             * 
             * @Param config
             */
            obj.prepareTable = function() {
        
                // Number of columns
                var size = obj.options.columns.length;
        
                if (obj.options.data && typeof(obj.options.data[0]) !== 'undefined') {
                    // Data keys
                    var keys = Object.keys(obj.options.data[0]);
        
                    if (keys.length > size) {
                        size = keys.length;
                    }
                }
        
                // Minimal dimensions
                if (obj.options.minDimensions[0] > size) {
                    size = obj.options.minDimensions[0];
                }
        
                // Requests
                var multiple = [];
        
                // Preparations
                for (var i = 0; i < size; i++) {
                    // Deprected options. You should use only columns
                    if (! obj.options.colHeaders[i]) {
                        obj.options.colHeaders[i] = '';
                    }
                    if (! obj.options.colWidths[i]) {
                        obj.options.colWidths[i] = obj.options.defaultColWidth;
                    }
                    if (! obj.options.colAlignments[i]) {
                        obj.options.colAlignments[i] = obj.options.defaultColAlign;
                    }
        
                    // Default column description
                    if (! obj.options.columns[i]) {
                        obj.options.columns[i] = { type:'text' };
                    } else if (! obj.options.columns[i].type) {
                        obj.options.columns[i].type = 'text';
                    }
                    if (! obj.options.columns[i].name) {
                        obj.options.columns[i].name = keys && keys[i] ? keys[i] : i;
                    }
                    if (! obj.options.columns[i].source) {
                        obj.options.columns[i].source = [];
                    }
                    if (! obj.options.columns[i].options) {
                        obj.options.columns[i].options = [];
                    }
                    if (! obj.options.columns[i].editor) {
                        obj.options.columns[i].editor = null;
                    }
                    if (! obj.options.columns[i].allowEmpty) {
                        obj.options.columns[i].allowEmpty = false;
                    }
                    if (! obj.options.columns[i].title) {
                        obj.options.columns[i].title = obj.options.colHeaders[i] ? obj.options.colHeaders[i] : '';
                    }
                    if (! obj.options.columns[i].width) {
                        obj.options.columns[i].width = obj.options.colWidths[i] ? obj.options.colWidths[i] : obj.options.defaultColWidth;
                    }
                    if (! obj.options.columns[i].align) {
                        obj.options.columns[i].align = obj.options.colAlignments[i] ? obj.options.colAlignments[i] : 'center';
                    }
        
                    // Pre-load initial source for json autocomplete
                    if (obj.options.columns[i].type == 'autocomplete' || obj.options.columns[i].type == 'dropdown') {
                        // if remote content
                        if (obj.options.columns[i].url) {
                            multiple.push({
                                url: obj.options.columns[i].url,
                                index: i,
                                method: 'GET',
                                dataType: 'json',
                                success: function(data) {
                                    for (var i = 0; i < data.length; i++) {
                                        obj.options.columns[this.index].source.push(data[i]);
                                    }
                                }
                            });
                        }
                    } else if (obj.options.columns[i].type == 'calendar') {
                        // Default format for date columns
                        if (! obj.options.columns[i].options.format) {
                            obj.options.columns[i].options.format = 'DD/MM/YYYY';
                        }
                    }
                }
                // Create the table when is ready
                if (! multiple.length) {
                    obj.createTable();
                } else {
                    jSuites.ajax(multiple, function() {
                        obj.createTable();
                    });
                }
            };
        
            obj.createTable = function() {
                // Elements
                obj.table = document.createElement('table');
                obj.thead = document.createElement('thead');
                obj.tbody = document.createElement('tbody');

                // Create headers controllers
                obj.headers = [];
                obj.colgroup = [];
        
                // Create table container
                obj.content = document.createElement('div');
                obj.content.classList.add('jexcel_content');
                obj.content.onscroll = function(e) {
                    obj.scrollControls(e);
                };
                obj.content.onwheel = function(e) {
                    obj.wheelControls(e);
                };

                // Create toolbar object
                obj.toolbar = document.createElement('div');
                obj.toolbar.classList.add('jexcel_toolbar');
        
                // Search
                var searchContainer = document.createElement('div');
                var searchText = document.createTextNode((obj.options.text.search) + ': ');
                obj.searchInput = document.createElement('input');
                obj.searchInput.classList.add('jexcel_search');
                searchContainer.appendChild(searchText);
                searchContainer.appendChild(obj.searchInput);
                obj.searchInput.onfocus = function() {
                    obj.resetSelection();
                };
        
                // Pagination select option
                var paginationUpdateContainer = document.createElement('div');
        
                if (obj.options.pagination > 0 && obj.options.paginationOptions && obj.options.paginationOptions.length > 0) {
                    obj.paginationDropdown = document.createElement('select');
                    obj.paginationDropdown.classList.add('jexcel_pagination_dropdown');
                    obj.paginationDropdown.onchange = function() {
                        obj.options.pagination = parseInt(this.value);
                        obj.page(0);
                    };
        
                    for (var i = 0; i < obj.options.paginationOptions.length; i++) {
                        var temp = document.createElement('option');
                        temp.value = obj.options.paginationOptions[i];
                        temp.innerHTML = obj.options.paginationOptions[i];
                        obj.paginationDropdown.appendChild(temp);
                    }
        
                    // Set initial pagination value
                    obj.paginationDropdown.value = obj.options.pagination;

                    paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.show));
                    paginationUpdateContainer.appendChild(obj.paginationDropdown);
                    paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.entries));
                }
        
                // Filter and pagination container
                var filter = document.createElement('div');
                filter.classList.add('jexcel_filter');
                filter.appendChild(paginationUpdateContainer);
                filter.appendChild(searchContainer);
        
                // Colsgroup
                obj.colgroupContainer = document.createElement('colgroup');
                var tempCol = document.createElement('col');
                tempCol.setAttribute('width', '50');
                obj.colgroupContainer.appendChild(tempCol);
        
                // Nested
                if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                    // Flexible way to handle nestedheaders
                    if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                        for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                            obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders[j]));
                        }
                    } else {
                        obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders));
                    }
                }
        
                // Row
                obj.headerContainer = document.createElement('tr');
                var tempCol = document.createElement('td');
                tempCol.classList.add('jexcel_selectall');
                obj.headerContainer.appendChild(tempCol);
        
                for (var i = 0; i < obj.options.columns.length; i++) {
                    // Create header
                    obj.createCellHeader(i);
                    // Append cell to the container
                    obj.headerContainer.appendChild(obj.headers[i]);
                    obj.colgroupContainer.appendChild(obj.colgroup[i]);
                }

                obj.thead.appendChild(obj.headerContainer);

                // Filters
                if (obj.options.filters == true) {
                    obj.filter = document.createElement('tr');
                    var td = document.createElement('td');
                    obj.filter.appendChild(td);

                    for (var i = 0; i < obj.options.columns.length; i++) {
                        var td = document.createElement('td');
                        td.innerHTML = '&nbsp;';
                        td.setAttribute('data-x', i);
                        td.className = 'jexcel_column_filter';
                        if (obj.options.columns[i].type == 'hidden') {
                            td.style.display = 'none';
                        }
                        obj.filter.appendChild(td);
                    }

                    obj.thead.appendChild(obj.filter);
                }

                // Content table
                obj.table = document.createElement('table');
                obj.table.classList.add('jexcel');
                obj.table.setAttribute('cellpadding', '0');
                obj.table.setAttribute('cellspacing', '0');
                obj.table.setAttribute('unselectable', 'yes');
                //obj.table.setAttribute('onselectstart', 'return false');
                obj.table.appendChild(obj.colgroupContainer);
                obj.table.appendChild(obj.thead);
                obj.table.appendChild(obj.tbody);

                if (! obj.options.textOverflow) {
                    obj.table.classList.add('jexcel_overflow');
                }

                // Spreadsheet corner
                obj.corner = document.createElement('div');
                obj.corner.className = 'jexcel_corner';
                obj.corner.setAttribute('unselectable', 'on');
                obj.corner.setAttribute('onselectstart', 'return false');
        
                if (obj.options.selectionCopy == false) {
                    obj.corner.style.display = 'none';
                }
        
                // Textarea helper
                obj.textarea = document.createElement('textarea');
                obj.textarea.className = 'jexcel_textarea';
                obj.textarea.id = 'jexcel_textarea';
                obj.textarea.tabIndex = '-1';

                // Contextmenu container
                obj.contextMenu = document.createElement('div');
                obj.contextMenu.className = 'jexcel_contextmenu';
        
                // Create element
                jSuites.contextmenu(obj.contextMenu, {
                    onclick:function() {
                        obj.contextMenu.contextmenu.close(false);
                    }
                });
        
                // Powered by Jspreadsheet
                var ads = document.createElement('a');
                ads.setAttribute('href', 'https://bossanova.uk/jspreadsheet/');
                obj.ads = document.createElement('div');
                obj.ads.className = 'jexcel_about';
                try {
                    if (typeof(sessionStorage) !== "undefined" && ! sessionStorage.getItem('jexcel')) {
                        sessionStorage.setItem('jexcel', true);
                        var img = document.createElement('img');
                        img.src = '//bossanova.uk/jspreadsheet/logo.png';
                        ads.appendChild(img);
                    }
                } catch (exception) {
                }
                var span = document.createElement('span');
                span.innerHTML = 'Jspreadsheet CE';
                ads.appendChild(span);
                obj.ads.appendChild(ads);

                // Create table container TODO: frozen columns
                var container = document.createElement('div');
                container.classList.add('jexcel_table');
        
                // Pagination
                obj.pagination = document.createElement('div');
                obj.pagination.classList.add('jexcel_pagination');
                var paginationInfo = document.createElement('div');
                var paginationPages = document.createElement('div');
                obj.pagination.appendChild(paginationInfo);
                obj.pagination.appendChild(paginationPages);

                // Hide pagination if not in use
                if (! obj.options.pagination) {
                    obj.pagination.style.display = 'none';
                }

                // Append containers to the table
                if (obj.options.search == true) {
                    el.appendChild(filter);
                }
        
                // Elements
                obj.content.appendChild(obj.table);
                obj.content.appendChild(obj.corner);
                obj.content.appendChild(obj.textarea);
        
                el.appendChild(obj.toolbar);
                el.appendChild(obj.content);
                el.appendChild(obj.pagination);
                el.appendChild(obj.contextMenu);
                el.appendChild(obj.ads);
                el.classList.add('jexcel_container');
        
                // Create toolbar
                if (obj.options.toolbar && obj.options.toolbar.length) {
                    obj.createToolbar();
                }
        
                // Fullscreen
                if (obj.options.fullscreen == true) {
                    el.classList.add('fullscreen');
                } else {
                    // Overflow
                    if (obj.options.tableOverflow == true) {
                        if (obj.options.tableHeight) {
                            obj.content.style['overflow-y'] = 'auto';
                            obj.content.style['box-shadow'] = 'rgb(221 221 221) 2px 2px 5px 0.1px';
                            obj.content.style.maxHeight = obj.options.tableHeight;
                        }
                        if (obj.options.tableWidth) {
                            obj.content.style['overflow-x'] = 'auto';
                            obj.content.style.width = obj.options.tableWidth;
                        }
                    }
                }
        
                // With toolbars
                if (obj.options.tableOverflow != true && obj.options.toolbar) {
                    el.classList.add('with-toolbar');
                }
        
                // Actions
                if (obj.options.columnDrag == true) {
                    obj.thead.classList.add('draggable');
                }
                if (obj.options.columnResize == true) {
                    obj.thead.classList.add('resizable');
                }
                if (obj.options.rowDrag == true) {
                    obj.tbody.classList.add('draggable');
                }
                if (obj.options.rowResize == true) {
                    obj.tbody.classList.add('resizable');
                }
        
                // Load data
                obj.setData();
        
                // Style
                if (obj.options.style) {
                    obj.setStyle(obj.options.style, null, null, 1, 1);
                }

                // Classes
                if (obj.options.classes) {
                    var k = Object.keys(obj.options.classes);
                    for (var i = 0; i < k.length; i++) {
                        var cell = jexcel.getIdFromColumnName(k[i], true);
                        obj.records[cell[1]][cell[0]].classList.add(obj.options.classes[k[i]]);
                    }
                }
            };

            /**
             * Refresh the data
             * 
             * @return void
             */
            obj.refresh = function() {
                if (obj.options.url) {
                    // Loading
                    if (obj.options.loadingSpin == true) {
                        jSuites.loading.show();
                    }
        
                    jSuites.ajax({
                        url: obj.options.url,
                        method: obj.options.method,
                        data: obj.options.requestVariables,
                        dataType: 'json',
                        success: function(result) {
                            // Data
                            obj.options.data = (result.data) ? result.data : result;
                            // Prepare table
                            obj.setData();
                            // Hide spin
                            if (obj.options.loadingSpin == true) {
                                jSuites.loading.hide();
                            }
                        }
                    });
                } else {
                    obj.setData();
                }
            };

            /**
             * Set data
             * 
             * @param array data In case no data is sent, default is reloaded
             * @return void
             */
            obj.setData = function(data) {
                // Update data
                if (data) {
                    if (typeof(data) == 'string') {
                        data = JSON.parse(data);
                    }
        
                    obj.options.data = data;
                }
        
                // Data
                if (! obj.options.data) {
                    obj.options.data = [];
                }
        
                // Prepare data
                if (obj.options.data && obj.options.data[0]) {
                    if (! Array.isArray(obj.options.data[0])) {
                        var data = [];
                        for (var j = 0; j < obj.options.data.length; j++) {
                            var row = [];
                            for (var i = 0; i < obj.options.columns.length; i++) {
                                row[i] = obj.options.data[j][obj.options.columns[i].name];
                            }
                            data.push(row);
                        }

                        obj.options.data = data;
                    }
                }

                // Adjust minimal dimensions
                var j = 0;
                var i = 0;
                var size_i = obj.options.columns.length;
                var size_j = obj.options.data.length;
                var min_i = obj.options.minDimensions[0];
                var min_j = obj.options.minDimensions[1];
                var max_i = min_i > size_i ? min_i : size_i;
                var max_j = min_j > size_j ? min_j : size_j;
        
                for (j = 0; j < max_j; j++) {
                    for (i = 0; i < max_i; i++) {
                        if (obj.options.data[j] == undefined) {
                            obj.options.data[j] = [];
                        }
        
                        if (obj.options.data[j][i] == undefined) {
                            obj.options.data[j][i] = '';
                        }
                    }
                }
        
                // Reset containers
                obj.rows = [];
                obj.results = null;
                obj.records = [];
                obj.history = [];
        
                // Reset internal controllers
                obj.historyIndex = -1;
        
                // Reset data
                obj.tbody.innerHTML = '';
        
                // Lazy loading
                if (obj.options.lazyLoading == true) {
                    // Load only 100 records
                    var startNumber = 0;
                    var finalNumber = obj.options.data.length < 100 ? obj.options.data.length : 100;
        
                    if (obj.options.pagination) {
                        obj.options.pagination = false;
                        console.error('Jspreadsheet: Pagination will be disable due the lazyLoading');
                    }
                } else if (obj.options.pagination) {
                    // Pagination
                    if (! obj.pageNumber) {
                        obj.pageNumber = 0;
                    }
                    obj.options.pagination;
                    startNumber = (obj.options.pagination * obj.pageNumber);
                    finalNumber = (obj.options.pagination * obj.pageNumber) + obj.options.pagination;
        
                    if (obj.options.data.length < finalNumber) {
                        finalNumber = obj.options.data.length;
                    }
                } else {
                    var startNumber = 0;
                    var finalNumber = obj.options.data.length;
                }
        
                // Append nodes to the HTML
                for (j = 0; j < obj.options.data.length; j++) {
                    // Create row
                    var tr = obj.createRow(j, obj.options.data[j]);
                    // Append line to the table
                    if (j >= startNumber && j < finalNumber) {
                        obj.tbody.appendChild(tr);
                    }
                }
        
                if (obj.options.lazyLoading == true) ; else if (obj.options.pagination) {
                    obj.updatePagination();
                }
        
                // Merge cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var num = obj.options.mergeCells[keys[i]];
                        obj.setMerge(keys[i], num[0], num[1], 1);
                    }
                }

                // Updata table with custom configurations if applicable
                obj.updateTable();

                // Onload
                obj.dispatch('onload', el, obj);
            };

            /**
             * Get the whole table data
             * 
             * @param bool get highlighted cells only
             * @return array data
             */
            obj.getData = function(highlighted, dataOnly) {
                // Control vars
                var dataset = [];
                var px = 0;
                var py = 0;

                // Data type
                var dataType = dataOnly == true || obj.options.copyCompatibility == false ? true : false;

                // Column and row length
                var x = obj.options.columns.length;
                var y = obj.options.data.length;
        
                // Go through the columns to get the data
                for (var j = 0; j < y; j++) {
                    px = 0;
                    for (var i = 0; i < x; i++) {
                        // Cell selected or fullset
                        if (! highlighted || obj.records[j][i].classList.contains('highlight')) {
                            // Get value
                            if (! dataset[py]) {
                                dataset[py] = [];
                            }
                            if (! dataType) {
                                dataset[py][px] = obj.records[j][i].innerHTML;
                            } else {
                                dataset[py][px] = obj.options.data[j][i];
                            }
                            px++;
                        }
                    }
                    if (px > 0) {
                        py++;
                    }
               }
        
               return dataset;
            };

            /**
            * Get json data by row number
            *
            * @param integer row number
            * @return object
            */
            obj.getJsonRow = function(rowNumber) {
                var rowData = obj.options.data[rowNumber];
                var x = obj.options.columns.length;

                var row = {};
                for (var i = 0; i < x; i++) {
                    if (! obj.options.columns[i].name) {
                        obj.options.columns[i].name = i;
                    }
                    row[obj.options.columns[i].name] = rowData[i];
                }

                return row;
            };

            /**
             * Get the whole table data
             * 
             * @param bool highlighted cells only
             * @return string value
             */
            obj.getJson = function(highlighted) {
                // Control vars
                var data = [];
        
                // Column and row length
                var x = obj.options.columns.length;
                var y = obj.options.data.length;
        
                // Go through the columns to get the data
                for (var j = 0; j < y; j++) {
                    var row = null;
                    for (var i = 0; i < x; i++) {
                        if (! highlighted || obj.records[j][i].classList.contains('highlight')) {
                            if (row == null) {
                                row = {};
                            }
                            if (! obj.options.columns[i].name) {
                                obj.options.columns[i].name = i;
                            }
                            row[obj.options.columns[i].name] = obj.options.data[j][i];
                        }
                    }
        
                    if (row != null) {
                        data.push(row);
                    }
               }
        
               return data;
            };

            /**
             * Prepare JSON in the correct format
             */
            obj.prepareJson = function(data) {
                var rows = [];
                for (var i = 0; i < data.length; i++) {
                    var x = data[i].x;
                    var y = data[i].y;
                    var k = obj.options.columns[x].name ? obj.options.columns[x].name : x;

                    // Create row
                    if (! rows[y]) {
                        rows[y] = {
                            row: y,
                            data: {},
                        };
                    }
                    rows[y].data[k] = data[i].newValue;
                }

                // Filter rows
                return rows.filter(function (el) {
                    return el != null;
                });
            };

            /**
             * Post json to a remote server
             */
            obj.save = function(url, data) {
                // Parse anything in the data before sending to the server
                var ret = obj.dispatch('onbeforesave', el, obj, data);
                if (ret) {
                    var data = ret;
                } else {
                    if (ret === false) {
                        return false;
                    }
                }

                // Remove update
                jSuites.ajax({
                    url: url,
                    method: 'POST',
                    dataType: 'json',
                    data: { data: JSON.stringify(data) },
                    success: function(result) {
                        // Event
                        obj.dispatch('onsave', el, obj, data);
                    }
                });
            };

            /**
             * Get a row data by rowNumber
             */
            obj.getRowData = function(rowNumber) {
                return obj.options.data[rowNumber];
            };
        
            /**
             * Set a row data by rowNumber
             */
            obj.setRowData = function(rowNumber, data) {
                for (var i = 0; i < obj.headers.length; i++) {
                    // Update cell
                    var columnName = jexcel.getColumnNameFromId([ i, rowNumber ]);
                    // Set value
                    if (data[i] != null) {
                        obj.setValue(columnName, data[i]);
                    }
                }
            };
        
            /**
             * Get a column data by columnNumber
             */
            obj.getColumnData = function(columnNumber) {
                var dataset = [];
                // Go through the rows to get the data
                for (var j = 0; j < obj.options.data.length; j++) {
                    dataset.push(obj.options.data[j][columnNumber]);
                }
                return dataset;
            };
        
            /**
             * Set a column data by colNumber
             */
            obj.setColumnData = function(colNumber, data) {
                for (var j = 0; j < obj.rows.length; j++) {
                    // Update cell
                    var columnName = jexcel.getColumnNameFromId([ colNumber, j ]);
                    // Set value
                    if (data[j] != null) {
                        obj.setValue(columnName, data[j]);
                    }
                }
            };
        
            /**
             * Create row
             */
            obj.createRow = function(j, data) {
                // Create container
                if (! obj.records[j]) {
                    obj.records[j] = [];
                }
                // Default data
                if (! data) {
                    var data = obj.options.data[j];
                }
                // New line of data to be append in the table
                obj.rows[j] = document.createElement('tr');
                obj.rows[j].setAttribute('data-y', j);
                // Index
                var index = null;
                // Definitions
                if (obj.options.rows[j]) {
                    if (obj.options.rows[j].height) {
                        obj.rows[j].style.height = obj.options.rows[j].height;
                    }
                    if (obj.options.rows[j].title) {
                        index = obj.options.rows[j].title;
                    }
                }
                if (! index) {
                    index = parseInt(j + 1);
                }
                // Row number label
                var td = document.createElement('td');
                td.innerHTML = index;
                td.setAttribute('data-y', j);
                td.className = 'jexcel_row';
                obj.rows[j].appendChild(td);
        
                // Data columns
                for (var i = 0; i < obj.options.columns.length; i++) {
                    // New column of data to be append in the line
                    obj.records[j][i] = obj.createCell(i, j, data[i]);
                    // Add column to the row
                    obj.rows[j].appendChild(obj.records[j][i]);
                }
        
                // Add row to the table body
                return obj.rows[j];
            };
        
            obj.parseValue = function(i, j, value) {
                if ((''+value).substr(0,1) == '=' && obj.options.parseFormulas == true) {
                    value = obj.executeFormula(value, i, j);
                }
                if (obj.options.columns[i].mask) {
                    var decimal = obj.options.columns[i].decimal || '.';
                    value = '' + jSuites.mask.run(value, obj.options.columns[i].mask, decimal);
                }

                return value;
            };

            /**
             * Create cell
             */
            obj.createCell = function(i, j, value) {
                // Create cell and properties
                var td = document.createElement('td');
                td.setAttribute('data-x', i);
                td.setAttribute('data-y', j);

                // Security
                if ((''+value).substr(0,1) == '=' && obj.options.secureFormulas == true) {
                    var val = secureFormula(value);
                    if (val != value) {
                        // Update the data container
                        value = val;
                    }
                }

                // Custom column
                if (obj.options.columns[i].editor) {
                    if (obj.options.stripHTML === false || obj.options.columns[i].stripHTML === false) {
                        td.innerHTML = value;
                    } else {
                        td.innerText = value;
                    }
                    if (typeof(obj.options.columns[i].editor.createCell) == 'function') {
                        td = obj.options.columns[i].editor.createCell(td);
                    }
                } else {
                    // Hidden column
                    if (obj.options.columns[i].type == 'hidden') {
                        td.style.display = 'none';
                        td.innerText = value;
                    } else if (obj.options.columns[i].type == 'checkbox' || obj.options.columns[i].type == 'radio') {
                        // Create input
                        var element = document.createElement('input');
                        element.type = obj.options.columns[i].type;
                        element.name = 'c' + i;
                        element.checked = (value == 1 || value == true || value == 'true') ? true : false;
                        element.onclick = function() {
                            obj.setValue(td, this.checked);
                        };

                        if (obj.options.columns[i].readOnly == true || obj.options.editable == false) {
                            element.setAttribute('disabled', 'disabled');
                        }

                        // Append to the table
                        td.appendChild(element);
                        // Make sure the values are correct
                        obj.options.data[j][i] = element.checked;
                    } else if (obj.options.columns[i].type == 'calendar') {
                        // Try formatted date
                        var formatted = jSuites.calendar.extractDateFromString(value, obj.options.columns[i].options.format);
                        // Create calendar cell
                        td.innerText = jSuites.calendar.getDateString(formatted ? formatted : value, obj.options.columns[i].options.format);
                    } else if (obj.options.columns[i].type == 'dropdown' || obj.options.columns[i].type == 'autocomplete') {
                        // Create dropdown cell
                        td.classList.add('jexcel_dropdown');
                        td.innerText = obj.getDropDownValue(i, value);
                    } else if (obj.options.columns[i].type == 'color') {
                        if (obj.options.columns[i].render == 'square') {
                            var color = document.createElement('div');
                            color.className = 'color';
                            color.style.backgroundColor = value;
                            td.appendChild(color);
                        } else {
                            td.style.color = value;
                            td.innerText = value;
                        }
                    } else if (obj.options.columns[i].type == 'image') {
                        if (value && value.substr(0, 10) == 'data:image') {
                            var img = document.createElement('img');
                            img.src = value;
                            td.appendChild(img);
                        }
                    } else {
                        if (obj.options.columns[i].type == 'html') {
                            td.innerHTML = stripScript(obj.parseValue(i, j, value));
                        } else {
                            if (obj.options.stripHTML === false || obj.options.columns[i].stripHTML === false) {
                                td.innerHTML = stripScript(obj.parseValue(i, j, value));
                            } else {
                                td.innerText = obj.parseValue(i, j, value);
                            }
                        }
                    }
                }
        
                // Readonly
                if (obj.options.columns[i].readOnly == true) {
                    td.className = 'readonly';
                }
        
                // Text align
                var colAlign = obj.options.columns[i].align ? obj.options.columns[i].align : 'center';
                td.style.textAlign = colAlign;
        
                // Wrap option
                if (obj.options.columns[i].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[i].wordWrap == true || td.innerHTML.length > 200)) {
                    td.style.whiteSpace = 'pre-wrap';
                }
        
                // Overflow
                if (i > 0) {
                    if (this.options.textOverflow == true) {
                        if (value || td.innerHTML) {
                            obj.records[j][i-1].style.overflow = 'hidden';
                        } else {
                            if (i == obj.options.columns.length - 1) {
                                td.style.overflow = 'hidden';
                            }
                        }
                    }
                }
                return td;
            };
        
            obj.createCellHeader = function(colNumber) {
                // Create col global control
                var colWidth = obj.options.columns[colNumber].width ? obj.options.columns[colNumber].width : obj.options.defaultColWidth;
                var colAlign = obj.options.columns[colNumber].align ? obj.options.columns[colNumber].align : obj.options.defaultColAlign;
        
                // Create header cell
                obj.headers[colNumber] = document.createElement('td');
                if (obj.options.stripHTML) {
                    obj.headers[colNumber].innerText = obj.options.columns[colNumber].title ? obj.options.columns[colNumber].title : jexcel.getColumnName(colNumber);
                } else {
                    obj.headers[colNumber].innerHTML = obj.options.columns[colNumber].title ? obj.options.columns[colNumber].title : jexcel.getColumnName(colNumber);
                }
                obj.headers[colNumber].setAttribute('data-x', colNumber);
                obj.headers[colNumber].style.textAlign = colAlign;
                if (obj.options.columns[colNumber].title) {
                    obj.headers[colNumber].setAttribute('title', obj.options.columns[colNumber].title);
                }
                if (obj.options.columns[colNumber].id) {
                    obj.headers[colNumber].setAttribute('id', obj.options.columns[colNumber].id);
                }
        
                // Width control
                obj.colgroup[colNumber] = document.createElement('col');
                obj.colgroup[colNumber].setAttribute('width', colWidth);
        
                // Hidden column
                if (obj.options.columns[colNumber].type == 'hidden') {
                    obj.headers[colNumber].style.display = 'none';
                    obj.colgroup[colNumber].style.display = 'none';
                }
            };

            /**
             * Update a nested header title
             */
            obj.updateNestedHeader = function(x, y, title) {
                if (obj.options.nestedHeaders[y][x].title) {
                    obj.options.nestedHeaders[y][x].title = title;
                    obj.options.nestedHeaders[y].element.children[x+1].innerText = title;
                }
            };

            /**
             * Create a nested header object
             */
            obj.createNestedHeader = function(nestedInformation) {
                var tr = document.createElement('tr');
                tr.classList.add('jexcel_nested');
                var td = document.createElement('td');
                tr.appendChild(td);
                // Element
                nestedInformation.element = tr;
        
                var headerIndex = 0;
                for (var i = 0; i < nestedInformation.length; i++) {
                    // Default values
                    if (! nestedInformation[i].colspan) {
                        nestedInformation[i].colspan = 1;
                    }
                    if (! nestedInformation[i].align) {
                        nestedInformation[i].align = 'center';
                    }
                    if (! nestedInformation[i].title) {
                        nestedInformation[i].title = '';
                    }
        
                    // Number of columns
                    var numberOfColumns = nestedInformation[i].colspan;
        
                    // Classes container
                    var column = [];
                    // Header classes for this cell
                    for (var x = 0; x < numberOfColumns; x++) {
                        if (obj.options.columns[headerIndex] && obj.options.columns[headerIndex].type == 'hidden') {
                            numberOfColumns++;
                        }
                        column.push(headerIndex);
                        headerIndex++;
                    }
        
                    // Created the nested cell
                    var td = document.createElement('td');
                    td.setAttribute('data-column', column.join(','));
                    td.setAttribute('colspan', nestedInformation[i].colspan);
                    td.setAttribute('align', nestedInformation[i].align);
                    td.innerText = nestedInformation[i].title;
                    tr.appendChild(td);
                }
        
                return tr;
            };
        
            /**
             * Create toolbar
             */
            obj.createToolbar = function(toolbar) {
                if (toolbar) {
                    obj.options.toolbar = toolbar;
                } else {
                    var toolbar = obj.options.toolbar;
                }
                for (var i = 0; i < toolbar.length; i++) {
                    if (toolbar[i].type == 'i') {
                        var toolbarItem = document.createElement('i');
                        toolbarItem.classList.add('jexcel_toolbar_item');
                        toolbarItem.classList.add('material-icons');
                        toolbarItem.setAttribute('data-k', toolbar[i].k);
                        toolbarItem.setAttribute('data-v', toolbar[i].v);
                        toolbarItem.setAttribute('id', toolbar[i].id);

                        // Tooltip
                        if (toolbar[i].tooltip) {
                            toolbarItem.setAttribute('title', toolbar[i].tooltip);
                        }
                        // Handle click
                        if (toolbar[i].onclick && typeof(toolbar[i].onclick)) {
                            toolbarItem.onclick = (function (a) {
                                var b = a;
                                return function () {
                                    toolbar[b].onclick(el, obj, this);
                                };
                            })(i);
                        } else {
                            toolbarItem.onclick = function() {
                                var k = this.getAttribute('data-k');
                                var v = this.getAttribute('data-v');
                                obj.setStyle(obj.highlighted, k, v);
                            };
                        }
                        // Append element
                        toolbarItem.innerText = toolbar[i].content;
                        obj.toolbar.appendChild(toolbarItem);
                    } else if (toolbar[i].type == 'select') {
                       var toolbarItem = document.createElement('select');
                       toolbarItem.classList.add('jexcel_toolbar_item');
                       toolbarItem.setAttribute('data-k', toolbar[i].k);
                       // Tooltip
                       if (toolbar[i].tooltip) {
                           toolbarItem.setAttribute('title', toolbar[i].tooltip);
                       }
                       // Handle onchange
                       if (toolbar[i].onchange && typeof(toolbar[i].onchange)) {
                           toolbarItem.onchange = toolbar[i].onchange;
                       } else {
                           toolbarItem.onchange = function() {
                               var k = this.getAttribute('data-k');
                               obj.setStyle(obj.highlighted, k, this.value);
                           };
                       }
                       // Add options to the dropdown
                       for(var j = 0; j < toolbar[i].v.length; j++) {
                            var toolbarDropdownOption = document.createElement('option');
                            toolbarDropdownOption.value = toolbar[i].v[j];
                            toolbarDropdownOption.innerText = toolbar[i].v[j];
                            toolbarItem.appendChild(toolbarDropdownOption);
                       }
                       obj.toolbar.appendChild(toolbarItem);
                    } else if (toolbar[i].type == 'color') {
                         var toolbarItem = document.createElement('i');
                         toolbarItem.classList.add('jexcel_toolbar_item');
                         toolbarItem.classList.add('material-icons');
                         toolbarItem.setAttribute('data-k', toolbar[i].k);
                         toolbarItem.setAttribute('data-v', '');
                         // Tooltip
                         if (toolbar[i].tooltip) {
                             toolbarItem.setAttribute('title', toolbar[i].tooltip);
                         }
                         obj.toolbar.appendChild(toolbarItem);
                         toolbarItem.innerText = toolbar[i].content;
                         jSuites.color(toolbarItem, {
                             onchange:function(o, v) {
                                 var k = o.getAttribute('data-k');
                                 obj.setStyle(obj.highlighted, k, v);
                             }
                         });
                    }
                }
            };
        
            /**
             * Merge cells
             * @param cellName
             * @param colspan
             * @param rowspan
             * @param ignoreHistoryAndEvents
             */
            obj.setMerge = function(cellName, colspan, rowspan, ignoreHistoryAndEvents) {
                var test = false;
        
                if (! cellName) {
                    if (! obj.highlighted.length) {
                        alert(obj.options.text.noCellsSelected);
                        return null;
                    } else {
                        var x1 = parseInt(obj.highlighted[0].getAttribute('data-x'));
                        var y1 = parseInt(obj.highlighted[0].getAttribute('data-y'));
                        var x2 = parseInt(obj.highlighted[obj.highlighted.length-1].getAttribute('data-x'));
                        var y2 = parseInt(obj.highlighted[obj.highlighted.length-1].getAttribute('data-y'));
                        var cellName = jexcel.getColumnNameFromId([ x1, y1 ]);
                        var colspan = (x2 - x1) + 1;
                        var rowspan = (y2 - y1) + 1;
                    }
                }
        
                var cell = jexcel.getIdFromColumnName(cellName, true);
        
                if (obj.options.mergeCells[cellName]) {
                    if (obj.records[cell[1]][cell[0]].getAttribute('data-merged')) {
                        test = obj.options.text.cellAlreadyMerged;
                    }
                } else if ((! colspan || colspan < 2) && (! rowspan || rowspan < 2)) {
                    test = obj.options.text.invalidMergeProperties;
                } else {
                    for (var j = cell[1]; j < cell[1] + rowspan; j++) {
                        for (var i = cell[0]; i < cell[0] + colspan; i++) {
                            jexcel.getColumnNameFromId([i, j]);
                            if (obj.records[j][i].getAttribute('data-merged')) {
                                test = obj.options.text.thereIsAConflictWithAnotherMergedCell;
                            }
                        }
                    }
                }
        
                if (test) {
                    alert(test);
                } else {
                    // Add property
                    if (colspan > 1) {
                        obj.records[cell[1]][cell[0]].setAttribute('colspan', colspan);
                    } else {
                        colspan = 1;
                    }
                    if (rowspan > 1) {
                        obj.records[cell[1]][cell[0]].setAttribute('rowspan', rowspan);
                    } else {
                        rowspan = 1;
                    }
                    // Keep links to the existing nodes
                    obj.options.mergeCells[cellName] = [ colspan, rowspan, [] ];
                    // Mark cell as merged
                    obj.records[cell[1]][cell[0]].setAttribute('data-merged', 'true');
                    // Overflow
                    obj.records[cell[1]][cell[0]].style.overflow = 'hidden';
                    // History data
                    var data = [];
                    // Adjust the nodes
                    for (var y = cell[1]; y < cell[1] + rowspan; y++) {
                        for (var x = cell[0]; x < cell[0] + colspan; x++) {
                            if (! (cell[0] == x && cell[1] == y)) {
                                data.push(obj.options.data[y][x]);
                                obj.updateCell(x, y, '', true);
                                obj.options.mergeCells[cellName][2].push(obj.records[y][x]);
                                obj.records[y][x].style.display = 'none';
                                obj.records[y][x] = obj.records[cell[1]][cell[0]];
                            }
                        }
                    }
                    // In the initialization is not necessary keep the history
                    obj.updateSelection(obj.records[cell[1]][cell[0]]);
        
                    if (! ignoreHistoryAndEvents) {
                        obj.setHistory({
                            action:'setMerge',
                            column:cellName,
                            colspan:colspan,
                            rowspan:rowspan,
                            data:data,
                        });
        
                        obj.dispatch('onmerge', el, cellName, colspan, rowspan);
                    }
                }
            };
        
            /**
             * Merge cells
             * @param cellName
             * @param colspan
             * @param rowspan
             * @param ignoreHistoryAndEvents
             */
            obj.getMerge = function(cellName) {
                var data = {};
                if (cellName) {
                    if (obj.options.mergeCells[cellName]) {
                        data = [ obj.options.mergeCells[cellName][0], obj.options.mergeCells[cellName][1] ];
                    } else {
                        data = null;
                    }
                } else {
                    if (obj.options.mergeCells) {
                        obj.options.mergeCells;
                        var keys = Object.keys(obj.options.mergeCells);
                        for (var i = 0; i < keys.length; i++) {
                            data[keys[i]] = [ obj.options.mergeCells[keys[i]][0], obj.options.mergeCells[keys[i]][1] ];
                        }
                    }
                }
        
                return data;
            };
        
            /**
             * Remove merge by cellname
             * @param cellName
             */
            obj.removeMerge = function(cellName, data, keepOptions) {
                if (obj.options.mergeCells[cellName]) {
                    var cell = jexcel.getIdFromColumnName(cellName, true);
                    obj.records[cell[1]][cell[0]].removeAttribute('colspan');
                    obj.records[cell[1]][cell[0]].removeAttribute('rowspan');
                    obj.records[cell[1]][cell[0]].removeAttribute('data-merged');
                    var info = obj.options.mergeCells[cellName];
        
                    var index = 0;
                    for (var j = 0; j < info[1]; j++) {
                        for (var i = 0; i < info[0]; i++) {
                            if (j > 0 || i > 0) {
                                obj.records[cell[1]+j][cell[0]+i] = info[2][index];
                                obj.records[cell[1]+j][cell[0]+i].style.display = '';
                                // Recover data
                                if (data && data[index]) {
                                    obj.updateCell(cell[0]+i, cell[1]+j, data[index]);
                                }
                                index++;
                            }
                        }
                    }
        
                    // Update selection
                    obj.updateSelection(obj.records[cell[1]][cell[0]], obj.records[cell[1]+j-1][cell[0]+i-1]);
        
                    if (! keepOptions) {
                        delete(obj.options.mergeCells[cellName]);
                    }
                }
            };
        
            /**
             * Remove all merged cells
             */
            obj.destroyMerged = function(keepOptions) {
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    obj.options.mergeCells;
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        obj.removeMerge(keys[i], null, keepOptions);
                    }
                }
            };
        
            /**
             * Is column merged
             */
            obj.isColMerged = function(x, insertBefore) {
                var cols = [];
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var info = jexcel.getIdFromColumnName(keys[i], true);
                        var colspan = obj.options.mergeCells[keys[i]][0];
                        var x1 = info[0];
                        var x2 = info[0] + (colspan > 1 ? colspan - 1 : 0);
        
                        if (insertBefore == null) {
                            if ((x1 <= x && x2 >= x)) {
                                cols.push(keys[i]);
                            }
                        } else {
                            if (insertBefore) {
                                if ((x1 < x && x2 >= x)) {
                                    cols.push(keys[i]);
                                }
                            } else {
                                if ((x1 <= x && x2 > x)) {
                                    cols.push(keys[i]);
                                }
                            }
                        }
                    }
                }
        
                return cols;
            };
        
            /**
             * Is rows merged
             */
            obj.isRowMerged = function(y, insertBefore) {
                var rows = [];
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var info = jexcel.getIdFromColumnName(keys[i], true);
                        var rowspan = obj.options.mergeCells[keys[i]][1];
                        var y1 = info[1];
                        var y2 = info[1] + (rowspan > 1 ? rowspan - 1 : 0);
        
                        if (insertBefore == null) {
                            if ((y1 <= y && y2 >= y)) {
                                rows.push(keys[i]);
                            }
                        } else {
                            if (insertBefore) {
                                if ((y1 < y && y2 >= y)) {
                                    rows.push(keys[i]);
                                }
                            } else {
                                if ((y1 <= y && y2 > y)) {
                                    rows.push(keys[i]);
                                }
                            }
                        }
                    }
                }
        
                return rows;
            };

            /**
             * Open the column filter
             */
            obj.openFilter = function(columnId) {
                if (! obj.options.filters) {
                    console.log('Jspreadsheet: filters not enabled.');
                } else {
                    // Make sure is integer
                    columnId = parseInt(columnId);
                    // Reset selection
                    obj.resetSelection();
                    // Load options
                    var optionsFiltered = [];
                    if (obj.options.columns[columnId].type == 'checkbox') {
                        optionsFiltered.push({ id: 'true', name: 'True' });
                        optionsFiltered.push({ id: 'false', name: 'False' });
                    } else {
                        var options = [];
                        var hasBlanks = false;
                        for (var j = 0; j < obj.options.data.length; j++) {
                            var k = obj.options.data[j][columnId];
                            var v = obj.records[j][columnId].innerHTML;
                            if (k && v) {
                                options[k] = v;
                            } else {
                                var hasBlanks = true;
                            }
                        }
                        var keys = Object.keys(options);
                        var optionsFiltered = [];
                        for (var j = 0; j < keys.length; j++) {
                            optionsFiltered.push({ id: keys[j], name: options[keys[j]] });
                        }
                        // Has blank options
                        if (hasBlanks) {
                            optionsFiltered.push({ value: '', id: '', name: '(Blanks)' });
                        }
                    }

                    // Create dropdown
                    var div = document.createElement('div');
                    obj.filter.children[columnId + 1].innerHTML = '';
                    obj.filter.children[columnId + 1].appendChild(div);
                    obj.filter.children[columnId + 1].style.paddingLeft = '0px';
                    obj.filter.children[columnId + 1].style.paddingRight = '0px';
                    obj.filter.children[columnId + 1].style.overflow = 'initial';

                    var opt = {
                        data: optionsFiltered,
                        multiple: true,
                        autocomplete: true,
                        opened: true,
                        value: obj.filters[columnId] !== undefined ? obj.filters[columnId] : null,
                        width:'100%',
                        position: (obj.options.tableOverflow == true || obj.options.fullscreen == true) ? true : false,
                        onclose: function(o) {
                            obj.resetFilters();
                            obj.filters[columnId] = o.dropdown.getValue(true);
                            obj.filter.children[columnId + 1].innerHTML = o.dropdown.getText();
                            obj.filter.children[columnId + 1].style.paddingLeft = '';
                            obj.filter.children[columnId + 1].style.paddingRight = '';
                            obj.filter.children[columnId + 1].style.overflow = '';
                            obj.closeFilter(columnId);
                            obj.refreshSelection();
                        }
                    };

                    // Dynamic dropdown
                    jSuites.dropdown(div, opt);
                }
            };

            obj.resetFilters = function() {
                if (obj.options.filters) {
                    for (var i = 0; i < obj.filter.children.length; i++) {
                        obj.filter.children[i].innerHTML = '&nbsp;';
                        obj.filters[i] = null;
                    }
                }
            };

            obj.closeFilter = function(columnId) {
                if (! columnId) {
                    for (var i = 0; i < obj.filter.children.length; i++) {
                        if (obj.filters[i]) {
                            columnId = i;
                        }
                    }
                }

                // Search filter
                var search = function(query, x, y) {
                    for (var i = 0; i < query.length; i++) {
                        if ((query[i] == '' && // Blank matching
                            ((obj.options.data[y][x] === false) || // Unchecked checkbox
                            (''+obj.options.data[y][x]) == '')) || // Blank non-checkbox value
                            ((query[i] != '' && // Normal non-blank filtering
                            ((''+obj.options.data[y][x]).search(query[i]) >= 0 ||
                            (''+obj.records[y][x].innerHTML).search(query[i]) >= 0)))) {
                            return true;
                        }
                    }
                    return false;
                };

                var query = obj.filters[columnId];
                obj.results = [];
                for (var j = 0; j < obj.options.data.length; j++) {
                    if (search(query, columnId, j)) {
                        obj.results.push(j);
                    }
                }
                if (! obj.results.length) {
                    obj.results = null;
                }

                obj.updateResult();
            };

            /**
             * Open the editor
             * 
             * @param object cell
             * @return void
             */
            obj.openEditor = function(cell, empty, e) {
                // Get cell position
                var y = cell.getAttribute('data-y');
                var x = cell.getAttribute('data-x');
        
                // On edition start
                obj.dispatch('oneditionstart', el, cell, x, y);
        
                // Overflow
                if (x > 0) {
                    obj.records[y][x-1].style.overflow = 'hidden';
                }
        
                // Create editor
                var createEditor = function(type) {
                    // Cell information
                    var info = cell.getBoundingClientRect();
        
                    // Create dropdown
                    var editor = document.createElement(type);
                    editor.style.width = (info.width) + 'px';
                    editor.style.height = (info.height - 2) + 'px';
                    editor.style.minHeight = (info.height - 2) + 'px';
        
                    // Edit cell
                    cell.classList.add('editor');
                    cell.innerHTML = '';
                    cell.appendChild(editor);
        
                    // On edition start
                    obj.dispatch('oncreateeditor', el, cell, x, y, editor);

                    return editor;
                };
        
                // Readonly
                if (cell.classList.contains('readonly') == true) ; else {
                    // Holder
                    obj.edition = [ obj.records[y][x], obj.records[y][x].innerHTML, x, y ];
        
                    // If there is a custom editor for it
                    if (obj.options.columns[x].editor) {
                        // Custom editors
                        obj.options.columns[x].editor.openEditor(cell, el, empty, e);
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'hidden') ; else if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                            // Get value
                            var value = cell.children[0].checked ? false : true;
                            // Toogle value
                            obj.setValue(cell, value);
                            // Do not keep edition open
                            obj.edition = null;
                        } else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            // Get current value
                            var value = obj.options.data[y][x];
                            if (obj.options.columns[x].multiple && !Array.isArray(value)) {
                                value = value.split(';');
                            }
        
                            // Create dropdown
                            if (typeof(obj.options.columns[x].filter) == 'function') {
                                var source = obj.options.columns[x].filter(el, cell, x, y, obj.options.columns[x].source);
                            } else {
                                var source = obj.options.columns[x].source;
                            }
        
                            // Do not change the original source
                            var data = [];
                            for (var j = 0; j < source.length; j++) {
                                data.push(source[j]);
                            }

                            // Create editor
                            var editor = createEditor('div');
                            var options = {
                                data: data,
                                multiple: obj.options.columns[x].multiple ? true : false,
                                autocomplete: obj.options.columns[x].autocomplete || obj.options.columns[x].type == 'autocomplete' ? true : false,
                                opened:true,
                                value: value,
                                width:'100%',
                                height:editor.style.minHeight,
                                position: (obj.options.tableOverflow == true || obj.options.fullscreen == true) ? true : false,
                                onclose:function() {
                                    obj.closeEditor(cell, true);
                                }
                            };
                            if (obj.options.columns[x].options && obj.options.columns[x].options.type) {
                                options.type = obj.options.columns[x].options.type;
                            }
                            jSuites.dropdown(editor, options);
                        } else if (obj.options.columns[x].type == 'calendar' || obj.options.columns[x].type == 'color') {
                            // Value
                            var value = obj.options.data[y][x];
                            // Create editor
                            var editor = createEditor('input');
                            editor.value = value;
        
                            if (obj.options.tableOverflow == true || obj.options.fullscreen == true) {
                                obj.options.columns[x].options.position = true;
                            }
                            obj.options.columns[x].options.value = obj.options.data[y][x];
                            obj.options.columns[x].options.opened = true;
                            obj.options.columns[x].options.onclose = function(el, value) {
                                obj.closeEditor(cell, true);
                            };
                            // Current value
                            if (obj.options.columns[x].type == 'color') {
                                jSuites.color(editor, obj.options.columns[x].options);
                            } else {
                                jSuites.calendar(editor, obj.options.columns[x].options);
                            }
                            // Focus on editor
                            editor.focus();
                        } else if (obj.options.columns[x].type == 'html') {
                            var value = obj.options.data[y][x];
                            // Create editor
                            var editor = createEditor('div');
                            editor.style.position = 'relative';
                            var div = document.createElement('div');
                            div.classList.add('jexcel_richtext');
                            editor.appendChild(div);
                            jSuites.editor(div, {
                                focus: true,
                                value: value,
                            });
                            var rect = cell.getBoundingClientRect();
                            var rectContent = div.getBoundingClientRect();
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                div.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                            } else {
                                div.style.top = (rect.top) + 'px';
                            }
                        } else if (obj.options.columns[x].type == 'image') {
                            // Value
                            var img = cell.children[0];
                            // Create editor
                            var editor = createEditor('div');
                            editor.style.position = 'relative';
                            var div = document.createElement('div');
                            div.classList.add('jclose');
                            if (img && img.src) {
                                div.appendChild(img);
                            }
                            editor.appendChild(div);
                            jSuites.image(div, obj.options.imageOptions);
                            var rect = cell.getBoundingClientRect();
                            var rectContent = div.getBoundingClientRect();
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                div.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                            } else {
                                div.style.top = (rect.top) + 'px';
                            }
                        } else {
                            // Value
                            var value = empty == true ? '' : obj.options.data[y][x];
        
                            // Basic editor
                            if (obj.options.columns[x].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[x].wordWrap == true)) {
                                var editor = createEditor('textarea');
                            } else {
                                var editor = createEditor('input');
                                // Mask
                                if (obj.options.columns[x].mask) {
                                    editor.setAttribute('data-mask', obj.options.columns[x].mask);
                                }
                            }
        
                            editor.onblur = function() {
                                obj.closeEditor(cell, true);
                            };
                            editor.focus();
                            editor.value = value;
                            editor.scrollLeft = editor.scrollWidth;
                        }
                    }
                }
            };
        
            /**
             * Close the editor and save the information
             * 
             * @param object cell
             * @param boolean save
             * @return void
             */
            obj.closeEditor = function(cell, save) {
                var x = parseInt(cell.getAttribute('data-x'));
                var y = parseInt(cell.getAttribute('data-y'));

                // Get cell properties
                if (save == true) {
                    // If custom editor
                    if (obj.options.columns[x].editor) {
                        // Custom editor
                        var value = obj.options.columns[x].editor.closeEditor(cell, save);
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio' || obj.options.columns[x].type == 'hidden') ; else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            var value = cell.children[0].dropdown.close(true);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            var value = cell.children[0].calendar.close(true);
                        } else if (obj.options.columns[x].type == 'color') {
                            var value = cell.children[0].color.close(true);
                        } else if (obj.options.columns[x].type == 'html') {
                            var value = cell.children[0].children[0].editor.getData();
                        } else if (obj.options.columns[x].type == 'image') {
                            var img = cell.children[0].children[0].children[0];
                            var value = img && img.tagName == 'IMG' ? img.src : '';
                        } else if (obj.options.columns[x].type == 'numeric') {
                            var value = cell.children[0].value;
                            if (value.substr(0,1) != '=') {
                                if (value == '') {
                                    value = obj.options.columns[x].allowEmpty ? '' : 0;
                                }
                            }
                            cell.children[0].onblur = null;
                        } else {
                            var value = cell.children[0].value;
                            cell.children[0].onblur = null;
                        }
                    }

                    // Ignore changes if the value is the same
                    if (obj.options.data[y][x] == value) {
                        cell.innerHTML = obj.edition[1];
                    } else {
                        obj.setValue(cell, value);
                    }
                } else {
                    if (obj.options.columns[x].editor) {
                        // Custom editor
                        obj.options.columns[x].editor.closeEditor(cell, save);
                    } else {
                        if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            cell.children[0].dropdown.close(true);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            cell.children[0].calendar.close(true);
                        } else if (obj.options.columns[x].type == 'color') {
                            cell.children[0].color.close(true);
                        } else {
                            cell.children[0].onblur = null;
                        }
                    }
        
                    // Restore value
                    cell.innerHTML = obj.edition && obj.edition[1] ? obj.edition[1] : '';
                }
        
                // On edition end
                obj.dispatch('oneditionend', el, cell, x, y, value, save);

                // Remove editor class
                cell.classList.remove('editor');
        
                // Finish edition
                obj.edition = null;
            };
        
            /**
             * Get the cell object
             * 
             * @param object cell
             * @return string value
             */
            obj.getCell = function(cell) {
                // Convert in case name is excel liked ex. A10, BB92
                cell = jexcel.getIdFromColumnName(cell, true);
                var x = cell[0];
                var y = cell[1];
        
                return obj.records[y][x];
            };
        
            /**
             * Get the cell object from coords
             * 
             * @param object cell
             * @return string value
             */
            obj.getCellFromCoords = function(x, y) {
                return obj.records[y][x];
            };
        
            /**
             * Get label
             * 
             * @param object cell
             * @return string value
             */
            obj.getLabel = function(cell) {
                // Convert in case name is excel liked ex. A10, BB92
                cell = jexcel.getIdFromColumnName(cell, true);
                var x = cell[0];
                var y = cell[1];
        
                return obj.records[y][x].innerHTML;
            };
        
            /**
             * Get labelfrom coords
             * 
             * @param object cell
             * @return string value
             */
            obj.getLabelFromCoords = function(x, y) {
                return obj.records[y][x].innerHTML;
            };
        
            /**
             * Get the value from a cell
             * 
             * @param object cell
             * @return string value
             */
            obj.getValue = function(cell, processedValue) {
                if (typeof(cell) == 'object') {
                    var x = cell.getAttribute('data-x');
                    var y = cell.getAttribute('data-y');
                } else {
                    cell = jexcel.getIdFromColumnName(cell, true);
                    var x = cell[0];
                    var y = cell[1];
                }
        
                var value = null;
        
                if (x != null && y != null) {
                    if (obj.records[y] && obj.records[y][x] && (processedValue || obj.options.copyCompatibility == true)) {
                        value = obj.records[y][x].innerHTML;
                    } else {
                        if (obj.options.data[y] && obj.options.data[y][x] != 'undefined') {
                            value = obj.options.data[y][x];
                        }
                    }
                }
        
                return value;
            };
        
            /**
             * Get the value from a coords
             * 
             * @param int x
             * @param int y
             * @return string value
             */
            obj.getValueFromCoords = function(x, y, processedValue) {
                var value = null;
        
                if (x != null && y != null) {
                    if ((obj.records[y] && obj.records[y][x]) && processedValue || obj.options.copyCompatibility == true) {
                        value = obj.records[y][x].innerHTML;
                    } else {
                        if (obj.options.data[y] && obj.options.data[y][x] != 'undefined') {
                            value = obj.options.data[y][x];
                        }
                    }
                }
        
                return value;
            };
        
            /**
             * Set a cell value
             * 
             * @param mixed cell destination cell
             * @param string value value
             * @return void
             */
            obj.setValue = function(cell, value, force) {
                var records = [];
        
                if (typeof(cell) == 'string') {
                    var columnId = jexcel.getIdFromColumnName(cell, true);
                    var x = columnId[0];
                    var y = columnId[1];
        
                    // Update cell
                    records.push(obj.updateCell(x, y, value, force));
        
                    // Update all formulas in the chain
                    obj.updateFormulaChain(x, y, records);
                } else {
                    var x = null;
                    var y = null;
                    if (cell && cell.getAttribute) {
                        var x = cell.getAttribute('data-x');
                        var y = cell.getAttribute('data-y');
                    }
        
                    // Update cell
                    if (x != null && y != null) {
                        records.push(obj.updateCell(x, y, value, force));
        
                        // Update all formulas in the chain
                        obj.updateFormulaChain(x, y, records);
                    } else {
                        var keys = Object.keys(cell);
                        if (keys.length > 0) {
                            for (var i = 0; i < keys.length; i++) {
                                if (typeof(cell[i]) == 'string') {
                                    var columnId = jexcel.getIdFromColumnName(cell[i], true);
                                    var x = columnId[0];
                                    var y = columnId[1];
                                } else {
                                    if (cell[i].x != null && cell[i].y != null) {
                                        var x = cell[i].x;
                                        var y = cell[i].y;
                                        // Flexible setup
                                        if (cell[i].newValue != null) {
                                            value = cell[i].newValue;
                                        } else if (cell[i].value != null) {
                                            value = cell[i].value;
                                        }
                                    } else {
                                        var x = cell[i].getAttribute('data-x');
                                        var y = cell[i].getAttribute('data-y');
                                    }
                                }
        
                                 // Update cell
                                if (x != null && y != null) {
                                    records.push(obj.updateCell(x, y, value, force));
        
                                    // Update all formulas in the chain
                                    obj.updateFormulaChain(x, y, records);
                                }
                            }
                        }
                    }
                }
        
                // Update history
                obj.setHistory({
                    action:'setValue',
                    records:records,
                    selection:obj.selectedCell,
                });
        
                // Update table with custom configurations if applicable
                obj.updateTable();
        
                // On after changes
                obj.onafterchanges(el, records);
            };
        
            /**
             * Set a cell value based on coordinates
             * 
             * @param int x destination cell
             * @param int y destination cell
             * @param string value
             * @return void
             */
            obj.setValueFromCoords = function(x, y, value, force) {
                var records = [];
                records.push(obj.updateCell(x, y, value, force));
        
                // Update all formulas in the chain
                obj.updateFormulaChain(x, y, records);
        
                // Update history
                obj.setHistory({
                    action:'setValue',
                    records:records,
                    selection:obj.selectedCell,
                });
        
                // Update table with custom configurations if applicable
                obj.updateTable();
        
                // On after changes
                obj.onafterchanges(el, records);
            };
        
            /**
             * Toogle
             */
            obj.setCheckRadioValue = function() {
                var records = [];
                var keys = Object.keys(obj.highlighted);
                for (var i = 0; i < keys.length; i++) {
                    var x = obj.highlighted[i].getAttribute('data-x');
                    var y = obj.highlighted[i].getAttribute('data-y');
        
                    if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                        // Update cell
                        records.push(obj.updateCell(x, y, ! obj.options.data[y][x]));
                    }
                }
        
                if (records.length) {
                    // Update history
                    obj.setHistory({
                        action:'setValue',
                        records:records,
                        selection:obj.selectedCell,
                    });
        
                    // On after changes
                    obj.onafterchanges(el, records);
                }
            };
            /**
             * Strip tags
             */
            var stripScript = function(a) {
                var b = new Option;
                b.innerHTML = a;
                var c = null;
                for (a = b.getElementsByTagName('script'); c=a[0];) c.parentNode.removeChild(c);
                return b.innerHTML;
            };

            /**
             * Update cell content
             * 
             * @param object cell
             * @return void
             */
            obj.updateCell = function(x, y, value, force) {
                // Changing value depending on the column type
                if (obj.records[y][x].classList.contains('readonly') == true && ! force) {
                    // Do nothing
                    var record = {
                        x: x,
                        y: y,
                        col: x,
                        row: y
                    };
                } else {
                    // Security
                    if ((''+value).substr(0,1) == '=' && obj.options.secureFormulas == true) {
                        var val = secureFormula(value);
                        if (val != value) {
                            // Update the data container
                            value = val;
                        }
                    }

                    // On change
                    var val = obj.dispatch('onbeforechange', el, obj.records[y][x], x, y, value);

                    // If you return something this will overwrite the value
                    if (val != undefined) {
                        value = val;
                    }

                    if (obj.options.columns[x].editor && typeof(obj.options.columns[x].editor.updateCell) == 'function') {
                        value = obj.options.columns[x].editor.updateCell(obj.records[y][x], value, force);
                    }

                    // History format
                    var record = {
                        x: x,
                        y: y,
                        col: x,
                        row: y,
                        newValue: value,
                        oldValue: obj.options.data[y][x],
                    };

                    if (obj.options.columns[x].editor) {
                        // Update data and cell
                        obj.options.data[y][x] = value;
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                            // Unchecked all options
                            if (obj.options.columns[x].type == 'radio') {
                                for (var j = 0; j < obj.options.data.length; j++) {
                                    obj.options.data[j][x] = false;
                                }
                            }

                            // Update data and cell
                            obj.records[y][x].children[0].checked = (value == 1 || value == true || value == 'true' || value == 'TRUE') ? true : false;
                            obj.options.data[y][x] = obj.records[y][x].children[0].checked;
                        } else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            // Update data and cell
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerText = obj.getDropDownValue(x, value);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            // Update calendar
                            var formatted = jSuites.calendar.extractDateFromString(value, obj.options.columns[x].options.format);
                            // Update data and cell
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerText = jSuites.calendar.getDateString(formatted ? formatted : value, obj.options.columns[x].options.format);
                        } else if (obj.options.columns[x].type == 'color') {
                            // Update color
                            obj.options.data[y][x] = value;
                            // Render
                            if (obj.options.columns[x].render == 'square') {
                                var color = document.createElement('div');
                                color.className = 'color';
                                color.style.backgroundColor = value;
                                obj.records[y][x].innerText = '';
                                obj.records[y][x].appendChild(color);
                            } else {
                                obj.records[y][x].style.color = value;
                                obj.records[y][x].innerText = value;
                            }
                        } else if (obj.options.columns[x].type == 'image') {
                            value = ''+value;
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerHTML = '';
                            if (value && value.substr(0, 10) == 'data:image') {
                                var img = document.createElement('img');
                                img.src = value;
                                obj.records[y][x].appendChild(img);
                            }
                        } else {
                            // Update data and cell
                            obj.options.data[y][x] = value;
                            // Label
                            if (obj.options.columns[x].type == 'html') {
                                obj.records[y][x].innerHTML = stripScript(obj.parseValue(x, y, value));
                            } else {
                                if (obj.options.stripHTML === false || obj.options.columns[x].stripHTML === false) {
                                    obj.records[y][x].innerHTML = stripScript(obj.parseValue(x, y, value));
                                } else {
                                    obj.records[y][x].innerText = obj.parseValue(x, y, value);
                                }
                            }
                            // Handle big text inside a cell
                            if (obj.options.columns[x].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[x].wordWrap == true || obj.records[y][x].innerHTML.length > 200)) {
                                obj.records[y][x].style.whiteSpace = 'pre-wrap';
                            } else {
                                obj.records[y][x].style.whiteSpace = '';
                            }
                        }
                    }

                    // Overflow
                    if (x > 0) {
                        if (value) {
                            obj.records[y][x-1].style.overflow = 'hidden';
                        } else {
                            obj.records[y][x-1].style.overflow = '';
                        }
                    }

                    // On change
                    obj.dispatch('onchange', el, (obj.records[y] && obj.records[y][x] ? obj.records[y][x] : null), x, y, value, record.oldValue);
                }

                return record;
            };

            /**
             * Helper function to copy data using the corner icon
             */
            obj.copyData = function(o, d) {
                // Get data from all selected cells
                var data = obj.getData(true, true);

                // Selected cells
                var h = obj.selectedContainer;

                // Cells
                var x1 = parseInt(o.getAttribute('data-x'));
                var y1 = parseInt(o.getAttribute('data-y'));
                var x2 = parseInt(d.getAttribute('data-x'));
                var y2 = parseInt(d.getAttribute('data-y'));

                // Records
                var records = [];
                var breakControl = false;

                if (h[0] == x1) {
                    // Vertical copy
                    if (y1 < h[1]) {
                        var rowNumber = y1 - h[1];
                    } else {
                        var rowNumber = 1;
                    }
                    var colNumber = 0;
                } else {
                    if (x1 < h[0]) {
                        var colNumber = x1 - h[0];
                    } else {
                        var colNumber = 1;
                    }
                    var rowNumber = 0;
                }

                // Copy data procedure
                var posx = 0;
                var posy = 0;

                for (var j = y1; j <= y2; j++) {
                    // Skip hidden rows
                    if (obj.rows[j] && obj.rows[j].style.display == 'none') {
                        continue;
                    }

                    // Controls
                    if (data[posy] == undefined) {
                        posy = 0;
                    }
                    posx = 0;

                    // Data columns
                    if (h[0] != x1) {
                        if (x1 < h[0]) {
                            var colNumber = x1 - h[0];
                        } else {
                            var colNumber = 1;
                        }
                    }
                    // Data columns
                    for (var i = x1; i <= x2; i++) {
                        // Update non-readonly
                        if (obj.records[j][i] && ! obj.records[j][i].classList.contains('readonly') && obj.records[j][i].style.display != 'none' && breakControl == false) {
                            // Stop if contains value
                            if (! obj.selection.length) {
                                if (obj.options.data[j][i] != '') {
                                    breakControl = true;
                                    continue;
                                }
                            }
        
                            // Column
                            if (data[posy] == undefined) {
                                posx = 0;
                            } else if (data[posy][posx] == undefined) {
                                posx = 0;
                            }

                            // Value
                            var value = data[posy][posx];
        
                            if (value && ! data[1] && obj.options.autoIncrement == true) {
                                if (obj.options.columns[i].type == 'text' || obj.options.columns[i].type == 'number') {
                                    if ((''+value).substr(0,1) == '=') {
                                        var tokens = value.match(/([A-Z]+[0-9]+)/g);
        
                                        if (tokens) {
                                            var affectedTokens = [];
                                            for (var index = 0; index < tokens.length; index++) {
                                                var position = jexcel.getIdFromColumnName(tokens[index], 1);
                                                position[0] += colNumber;
                                                position[1] += rowNumber;
                                                if (position[1] < 0) {
                                                    position[1] = 0;
                                                }
                                                var token = jexcel.getColumnNameFromId([position[0], position[1]]);
        
                                                if (token != tokens[index]) {
                                                    affectedTokens[tokens[index]] = token;
                                                }
                                            }
                                            // Update formula
                                            if (affectedTokens) {
                                                value = obj.updateFormula(value, affectedTokens);
                                            }
                                        }
                                    } else {
                                        if (value == Number(value)) {
                                            value = Number(value) + rowNumber;
                                        }
                                    }
                                } else if (obj.options.columns[i].type == 'calendar') {
                                    var date = new Date(value);
                                    date.setDate(date.getDate() + rowNumber);
                                    value = date.getFullYear() + '-' + jexcel.doubleDigitFormat(parseInt(date.getMonth() + 1)) + '-' + jexcel.doubleDigitFormat(date.getDate()) + ' ' + '00:00:00';
                                }
                            }
        
                            records.push(obj.updateCell(i, j, value));
        
                            // Update all formulas in the chain
                            obj.updateFormulaChain(i, j, records);
                        }
                        posx++;
                        if (h[0] != x1) {
                            colNumber++;
                        }
                    }
                    posy++;
                    rowNumber++;
                }
        
                // Update history
                obj.setHistory({
                    action:'setValue',
                    records:records,
                    selection:obj.selectedCell,
                });
        
                // Update table with custom configuration if applicable
                obj.updateTable();
        
                // On after changes
                obj.onafterchanges(el, records);
            };
        
            /**
             * Refresh current selection
             */
            obj.refreshSelection = function() {
                if (obj.selectedCell) {
                    obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                }
            };
        
            /**
             * Move coords to A1 in case ovelaps with an excluded cell
             */
            obj.conditionalSelectionUpdate = function(type, o, d) {
                if (type == 1) {
                    if (obj.selectedCell && ((o >= obj.selectedCell[1] && o <= obj.selectedCell[3]) || (d >= obj.selectedCell[1] && d <= obj.selectedCell[3]))) {
                        obj.resetSelection();
                        return;
                    }
                } else {
                    if (obj.selectedCell && ((o >= obj.selectedCell[0] && o <= obj.selectedCell[2]) || (d >= obj.selectedCell[0] && d <= obj.selectedCell[2]))) {
                        obj.resetSelection();
                        return;
                    }
                }
            };
        
            /**
             * Clear table selection
             */
            obj.resetSelection = function(blur) {
                // Remove style
                if (! obj.highlighted.length) {
                    var previousStatus = 0;
                } else {
                    var previousStatus = 1;
        
                    for (var i = 0; i < obj.highlighted.length; i++) {
                        obj.highlighted[i].classList.remove('highlight');
                        obj.highlighted[i].classList.remove('highlight-left');
                        obj.highlighted[i].classList.remove('highlight-right');
                        obj.highlighted[i].classList.remove('highlight-top');
                        obj.highlighted[i].classList.remove('highlight-bottom');
                        obj.highlighted[i].classList.remove('highlight-selected');
        
                        var px = parseInt(obj.highlighted[i].getAttribute('data-x'));
                        var py = parseInt(obj.highlighted[i].getAttribute('data-y'));
        
                        // Check for merged cells
                        if (obj.highlighted[i].getAttribute('data-merged')) {
                            var colspan = parseInt(obj.highlighted[i].getAttribute('colspan'));
                            var rowspan = parseInt(obj.highlighted[i].getAttribute('rowspan'));
                            var ux = colspan > 0 ? px + (colspan - 1) : px;
                            var uy = rowspan > 0 ? py + (rowspan - 1): py;
                        } else {
                            var ux = px;
                            var uy = py;
                        }
        
                        // Remove selected from headers
                        for (var j = px; j <= ux; j++) {
                            if (obj.headers[j]) {
                                obj.headers[j].classList.remove('selected');
                            }
                        }
        
                        // Remove selected from rows
                        for (var j = py; j <= uy; j++) {
                            if (obj.rows[j]) {
                                obj.rows[j].classList.remove('selected');
                            }
                        }
                    }
                }
        
                // Reset highlighed cells
                obj.highlighted = [];
        
                // Reset
                obj.selectedCell = null;
        
                // Hide corner
                obj.corner.style.top = '-2000px';
                obj.corner.style.left = '-2000px';
        
                if (blur == true && previousStatus == 1) {
                    obj.dispatch('onblur', el);
                }
        
                return previousStatus;
            };
        
            /**
             * Update selection based on two cells
             */
            obj.updateSelection = function(el1, el2, origin) {
                var x1 = el1.getAttribute('data-x');
                var y1 = el1.getAttribute('data-y');
                if (el2) {
                    var x2 = el2.getAttribute('data-x');
                    var y2 = el2.getAttribute('data-y');
                } else {
                    var x2 = x1;
                    var y2 = y1;
                }
        
                obj.updateSelectionFromCoords(x1, y1, x2, y2, origin);
            };
        
            /**
             * Update selection from coords
             */
            obj.updateSelectionFromCoords = function(x1, y1, x2, y2, origin) {
                var previousState = obj.resetSelection();
        
                // select column
                if (y1 == null) {
                    y1 = 0;
                    y2 = obj.rows.length - 1; 
                }

                // Same element
                if (x2 == null) {
                    x2 = x1;
                }
                if (y2 == null) {
                    y2 = y1;
                }
        
                // Selection must be within the existing data
                if (x1 >= obj.headers.length) {
                    x1 = obj.headers.length - 1;
                }
                if (y1 >= obj.rows.length) {
                    y1 = obj.rows.length - 1;
                }
                if (x2 >= obj.headers.length) {
                    x2 = obj.headers.length - 1;
                }
                if (y2 >= obj.rows.length) {
                    y2 = obj.rows.length - 1;
                }
        
                // Keep selected cell
                obj.selectedCell = [x1, y1, x2, y2];
        
                // Select cells
                if (x1 != null) {
                    // Add selected cell
                    if (obj.records[y1][x1]) {
                        obj.records[y1][x1].classList.add('highlight-selected');
                    }
        
                    // Origin & Destination
                    if (parseInt(x1) < parseInt(x2)) {
                        var px = parseInt(x1);
                        var ux = parseInt(x2);
                    } else {
                        var px = parseInt(x2);
                        var ux = parseInt(x1);
                    }
        
                    if (parseInt(y1) < parseInt(y2)) {
                        var py = parseInt(y1);
                        var uy = parseInt(y2);
                    } else {
                        var py = parseInt(y2);
                        var uy = parseInt(y1);
                    }
        
                    // Verify merged columns
                    for (var i = px; i <= ux; i++) {
                        for (var j = py; j <= uy; j++) {
                            if (obj.records[j][i] && obj.records[j][i].getAttribute('data-merged')) {
                                var x = parseInt(obj.records[j][i].getAttribute('data-x'));
                                var y = parseInt(obj.records[j][i].getAttribute('data-y'));
                                var colspan = parseInt(obj.records[j][i].getAttribute('colspan'));
                                var rowspan = parseInt(obj.records[j][i].getAttribute('rowspan'));
        
                                if (colspan > 1) {
                                    if (x < px) {
                                        px = x;
                                    }
                                    if (x + colspan > ux) {
                                        ux = x + colspan - 1;
                                    }
                                }
        
                                if (rowspan) {
                                    if (y < py) {
                                        py = y;
        
                                    }
                                    if (y + rowspan > uy) {
                                        uy = y + rowspan - 1;
                                    }
                                }
                            }
                        }
                    }
        
                    // Limits
                    var borderLeft = null;
                    var borderRight = null;
                    var borderTop = null;
                    var borderBottom = null;
        
                    // Vertical limits
                    for (var j = py; j <= uy; j++) {
                        if (obj.rows[j].style.display != 'none') {
                            if (borderTop == null) {
                                borderTop = j;
                            }
                            borderBottom = j;
                        }
                    }
        
                    // Redefining styles
                    for (var i = px; i <= ux; i++) {
                        for (var j = py; j <= uy; j++) {
                            if (obj.rows[j].style.display != 'none' && obj.records[j][i].style.display != 'none') {
                                obj.records[j][i].classList.add('highlight');
                                obj.highlighted.push(obj.records[j][i]);
                            }
                        }
        
                        // Horizontal limits
                        if (obj.options.columns[i].type != 'hidden') {
                            if (borderLeft == null) {
                                borderLeft = i;
                            }
                            borderRight = i;
                        }
                    }
        
                    // Create borders
                    if (! borderLeft) {
                        borderLeft = 0;
                    }
                    if (! borderRight) {
                        borderRight = 0;
                    }
                    for (var i = borderLeft; i <= borderRight; i++) {
                        if (obj.options.columns[i].type != 'hidden') {
                            // Top border
                            if (obj.records[borderTop] && obj.records[borderTop][i]) {
                                obj.records[borderTop][i].classList.add('highlight-top');
                            }
                            // Bottom border
                            if (obj.records[borderBottom] && obj.records[borderBottom][i]) {
                                obj.records[borderBottom][i].classList.add('highlight-bottom');
                            }
                            // Add selected from headers
                            obj.headers[i].classList.add('selected');
                        }
                    }
        
                    for (var j = borderTop; j <= borderBottom; j++) {
                        if (obj.rows[j] && obj.rows[j].style.display != 'none') {
                            // Left border
                            obj.records[j][borderLeft].classList.add('highlight-left');
                            // Right border
                            obj.records[j][borderRight].classList.add('highlight-right');
                            // Add selected from rows
                            obj.rows[j].classList.add('selected');
                        }
                    }
        
                    obj.selectedContainer = [ borderLeft, borderTop, borderRight, borderBottom ];
                }
        
                // Handle events
                if (previousState == 0) {
                    obj.dispatch('onfocus', el);

                    obj.removeCopyingSelection();
                }

                obj.dispatch('onselection', el, borderLeft, borderTop, borderRight, borderBottom, origin);

                // Find corner cell
                obj.updateCornerPosition();
            };
        
            /**
             * Remove copy selection
             * 
             * @return void
             */
            obj.removeCopySelection = function() {
                // Remove current selection
                for (var i = 0; i < obj.selection.length; i++) {
                    obj.selection[i].classList.remove('selection');
                    obj.selection[i].classList.remove('selection-left');
                    obj.selection[i].classList.remove('selection-right');
                    obj.selection[i].classList.remove('selection-top');
                    obj.selection[i].classList.remove('selection-bottom');
                }
        
                obj.selection = [];
            };
        
            /**
             * Update copy selection
             * 
             * @param int x, y
             * @return void
             */
            obj.updateCopySelection = function(x3, y3) {
                // Remove selection
                obj.removeCopySelection();
        
                // Get elements first and last
                var x1 = obj.selectedContainer[0];
                var y1 = obj.selectedContainer[1];
                var x2 = obj.selectedContainer[2];
                var y2 = obj.selectedContainer[3];
        
                if (x3 != null && y3 != null) {
                    if (x3 - x2 > 0) {
                        var px = parseInt(x2) + 1;
                        var ux = parseInt(x3);
                    } else {
                        var px = parseInt(x3);
                        var ux = parseInt(x1) - 1;
                    }
        
                    if (y3 - y2 > 0) {
                        var py = parseInt(y2) + 1;
                        var uy = parseInt(y3);
                    } else {
                        var py = parseInt(y3);
                        var uy = parseInt(y1) - 1;
                    }
        
                    if (ux - px <= uy - py) {
                        var px = parseInt(x1);
                        var ux = parseInt(x2);
                    } else {
                        var py = parseInt(y1);
                        var uy = parseInt(y2);
                    }
        
                    for (var j = py; j <= uy; j++) {
                        for (var i = px; i <= ux; i++) {
                            if (obj.records[j][i] && obj.rows[j].style.display != 'none' && obj.records[j][i].style.display != 'none') {
                                obj.records[j][i].classList.add('selection');
                                obj.records[py][i].classList.add('selection-top');
                                obj.records[uy][i].classList.add('selection-bottom');
                                obj.records[j][px].classList.add('selection-left');
                                obj.records[j][ux].classList.add('selection-right');
        
                                // Persist selected elements
                                obj.selection.push(obj.records[j][i]);
                            }
                        }
                    }
                }
            };
        
            /**
             * Update corner position
             * 
             * @return void
             */
            obj.updateCornerPosition = function() {
                // If any selected cells
                if (! obj.highlighted.length) {
                    obj.corner.style.top = '-2000px';
                    obj.corner.style.left = '-2000px';
                } else {
                    // Get last cell
                    var last = obj.highlighted[obj.highlighted.length-1];

                    var contentRect = obj.content.getBoundingClientRect();
                    var x1 = contentRect.left;
                    var y1 = contentRect.top;

                    var lastRect = last.getBoundingClientRect();
                    var x2 = lastRect.left;
                    var y2 = lastRect.top;
                    var w2 = lastRect.width;
                    var h2 = lastRect.height;

                    var x = (x2 - x1) + obj.content.scrollLeft + w2 - 4;
                    var y = (y2 - y1) + obj.content.scrollTop + h2 - 4;

                    // Place the corner in the correct place
                    obj.corner.style.top = y + 'px';
                    obj.corner.style.left = x + 'px';

                    if (obj.options.freezeColumns) {
                        var width = obj.getFreezeWidth();
                        if (x2 - x1 + w2 < width) {
                            obj.corner.style.display = 'none';
                        } else {
                            if (obj.options.selectionCopy == true) {
                                obj.corner.style.display = '';
                            }
                        }
                    } else {
                        if (obj.options.selectionCopy == true) {
                            obj.corner.style.display = '';
                        }
                    }
                }
            };
        
            /**
             * Update scroll position based on the selection
             */
            obj.updateScroll = function(direction) {
                // Jspreadsheet Container information
                var contentRect = obj.content.getBoundingClientRect();
                var x1 = contentRect.left;
                var y1 = contentRect.top;
                var w1 = contentRect.width;
                var h1 = contentRect.height;

                // Direction Left or Up
                var reference = obj.records[obj.selectedCell[3]][obj.selectedCell[2]];
        
                // Reference
                var referenceRect = reference.getBoundingClientRect();
                var x2 = referenceRect.left;
                var y2 = referenceRect.top;
                var w2 = referenceRect.width;
                var h2 = referenceRect.height;
        
                // Direction
                if (direction == 0 || direction == 1) {
                    var x = (x2 - x1) + obj.content.scrollLeft;
                    var y = (y2 - y1) + obj.content.scrollTop - 2;
                } else {
                    var x = (x2 - x1) + obj.content.scrollLeft + w2;
                    var y = (y2 - y1) + obj.content.scrollTop + h2;
                }
        
                // Top position check
                if (y > (obj.content.scrollTop + 30) && y < (obj.content.scrollTop + h1)) ; else {
                    // Out of viewport
                    if (y < obj.content.scrollTop + 30) {
                        obj.content.scrollTop = y - h2;
                    } else {
                        obj.content.scrollTop = y - (h1 - 2);
                    }
                }
        
                // Freeze columns? 
                var freezed = obj.getFreezeWidth();

                // Left position check - TODO: change that to the bottom border of the element
                if (x > (obj.content.scrollLeft + freezed) && x < (obj.content.scrollLeft + w1)) ; else {
                    // Out of viewport
                    if (x < obj.content.scrollLeft + 30) {
                        obj.content.scrollLeft = x;
                        if (obj.content.scrollLeft < 50) {
                            obj.content.scrollLeft = 0;
                        }
                    } else if (x < obj.content.scrollLeft + freezed) {
                        obj.content.scrollLeft = x - freezed - 1;
                    } else {
                        obj.content.scrollLeft = x - (w1 - 20);
                    }
                }
            };
        
            /**
             * Get the column width
             * 
             * @param int column column number (first column is: 0)
             * @return int current width
             */
            obj.getWidth = function(column) {
                if (! column) {
                    // Get all headers
                    var data = [];
                    for (var i = 0; i < obj.headers.length; i++) {
                        data.push(obj.options.columns[i].width);
                    }
                } else {
                    // In case the column is an object
                    if (typeof(column) == 'object') {
                        column = $(column).getAttribute('data-x');
                    }
        
                    data = obj.colgroup[column].getAttribute('width');
                }
        
                return data;
            };


            /**
             * Set the column width
             * 
             * @param int column number (first column is: 0)
             * @param int new column width
             * @param int old column width
             */
            obj.setWidth = function (column, width, oldWidth) {
                if (width) {
                    if (Array.isArray(column)) {
                        // Oldwidth
                        if (! oldWidth) {
                            var oldWidth = [];
                        }
                        // Set width
                        for (var i = 0; i < column.length; i++) {
                            if (! oldWidth[i]) {
                                oldWidth[i] = obj.colgroup[column[i]].getAttribute('width');
                            }
                            var w = Array.isArray(width) && width[i] ? width[i] : width;
                            obj.colgroup[column[i]].setAttribute('width', w);
                            obj.options.columns[column[i]].width = w;
                        }
                    } else {
                        // Oldwidth
                        if (! oldWidth) {
                            oldWidth = obj.colgroup[column].getAttribute('width');
                        }
                        // Set width
                        obj.colgroup[column].setAttribute('width', width);
                        obj.options.columns[column].width = width;
                    }

                    // Keeping history of changes
                    obj.setHistory({
                        action:'setWidth',
                        column:column,
                        oldValue:oldWidth,
                        newValue:width,
                    });

                    // On resize column
                    obj.dispatch('onresizecolumn', el, column, width, oldWidth);

                    // Update corner position
                    obj.updateCornerPosition();
                }
            };

            /**
             * Set the row height
             * 
             * @param row - row number (first row is: 0)
             * @param height - new row height
             * @param oldHeight - old row height
             */
            obj.setHeight = function (row, height, oldHeight) {
                if (height > 0) {
                    // In case the column is an object
                    if (typeof(row) == 'object') {
                        row = row.getAttribute('data-y');
                    }
        
                    // Oldwidth
                    if (! oldHeight) {
                        oldHeight = obj.rows[row].getAttribute('height');

                        if (! oldHeight) {
                            var rect = obj.rows[row].getBoundingClientRect();
                            oldHeight = rect.height;
                        }
                    }

                    // Integer
                    height = parseInt(height);

                    // Set width
                    obj.rows[row].style.height = height + 'px';
        
                    // Keep options updated
                    if (! obj.options.rows[row]) {
                        obj.options.rows[row] = {};
                    }
                    obj.options.rows[row].height = height;
        
                    // Keeping history of changes
                    obj.setHistory({
                        action:'setHeight',
                        row:row,
                        oldValue:oldHeight,
                        newValue:height,
                    });

                    // On resize column
                    obj.dispatch('onresizerow', el, row, height, oldHeight);

                    // Update corner position
                    obj.updateCornerPosition();
                }
            };
        
            /**
             * Get the row height
             * 
             * @param row - row number (first row is: 0)
             * @return height - current row height
             */
            obj.getHeight = function(row) {
                if (! row) {
                    // Get height of all rows
                    var data = [];
                    for (var j = 0; j < obj.rows.length; j++) {
                        var h = obj.rows[j].style.height;
                        if (h) {
                            data[j] = h;
                        }
                    }
                } else {
                    // In case the row is an object
                    if (typeof(row) == 'object') {
                        row = $(row).getAttribute('data-y');
                    }
        
                    var data = obj.rows[row].style.height;
                }
        
                return data;
            };
        
            obj.setFooter = function(data) {
                if (data) {
                    obj.options.footers = data;
                }

                if (obj.options.footers) {
                    if (! obj.tfoot) {
                        obj.tfoot = document.createElement('tfoot');
                        obj.table.appendChild(obj.tfoot);
                    } 

                    for (var j = 0; j < obj.options.footers.length; j++) {
                        if (obj.tfoot.children[j]) {
                            var tr = obj.tfoot.children[j];
                        } else {
                            var tr = document.createElement('tr');
                            var td = document.createElement('td');
                            tr.appendChild(td);
                            obj.tfoot.appendChild(tr);
                        }
                        for (var i = 0; i < obj.headers.length; i++) {
                            if (! obj.options.footers[j][i]) {
                                obj.options.footers[j][i] = '';
                            }
                            if (obj.tfoot.children[j].children[i+1]) {
                                var td = obj.tfoot.children[j].children[i+1];
                            } else {
                                var td = document.createElement('td');
                                tr.appendChild(td);

                                // Text align
                                var colAlign = obj.options.columns[i].align ? obj.options.columns[i].align : 'center';
                                td.style.textAlign = colAlign;
                            }
                            td.innerText = obj.parseValue(i, j, obj.options.footers[j][i]);
                        }
                    }
                }
            };

            /**
             * Get the column title
             * 
             * @param column - column number (first column is: 0)
             * @param title - new column title
             */
            obj.getHeader = function(column) {
                return obj.headers[column].innerText;
            };
        
            /**
             * Set the column title
             * 
             * @param column - column number (first column is: 0)
             * @param title - new column title
             */
            obj.setHeader = function(column, newValue) {
                if (obj.headers[column]) {
                    var oldValue = obj.headers[column].innerText;
        
                    if (! newValue) {
                        newValue = prompt(obj.options.text.columnName, oldValue);
                    }
        
                    if (newValue) {
                        obj.headers[column].innerText = newValue;
                        // Keep the title property
                        obj.headers[column].setAttribute('title', newValue);
                        // Update title
                        obj.options.columns[column].title = newValue;
                    }
        
                    obj.setHistory({
                        action: 'setHeader',
                        column: column,
                        oldValue: oldValue,
                        newValue: newValue
                    });
        
                    // On onchange header
                    obj.dispatch('onchangeheader', el, column, oldValue, newValue);
                }
            };
        
            /**
             * Get the headers
             * 
             * @param asArray
             * @return mixed
             */
            obj.getHeaders = function (asArray) {
                var title = [];
        
                for (var i = 0; i < obj.headers.length; i++) {
                    title.push(obj.getHeader(i));
                }
        
                return asArray ? title : title.join(obj.options.csvDelimiter);
            };
        
            /**
             * Get meta information from cell(s)
             * 
             * @return integer
             */
            obj.getMeta = function(cell, key) {
                if (! cell) {
                    return obj.options.meta;
                } else {
                    if (key) {
                        return obj.options.meta[cell] && obj.options.meta[cell][key] ? obj.options.meta[cell][key] : null;
                    } else {
                        return obj.options.meta[cell] ? obj.options.meta[cell] : null;
                    }
                }
            };
        
            /**
             * Set meta information to cell(s)
             * 
             * @return integer
             */
            obj.setMeta = function(o, k, v) {
                if (! obj.options.meta) {
                    obj.options.meta = {};
                }
        
                if (k && v) {
                    // Set data value
                    if (! obj.options.meta[o]) {
                        obj.options.meta[o] = {};
                    }
                    obj.options.meta[o][k] = v;
                } else {
                    // Apply that for all cells
                    var keys = Object.keys(o);
                    for (var i = 0; i < keys.length; i++) {
                        if (! obj.options.meta[keys[i]]) {
                            obj.options.meta[keys[i]] = {};
                        }
        
                        var prop = Object.keys(o[keys[i]]);
                        for (var j = 0; j < prop.length; j++) {
                            obj.options.meta[keys[i]][prop[j]] = o[keys[i]][prop[j]];
                        }
                    }
                }
        
                obj.dispatch('onchangemeta', el, o, k, v);
            };
        
            /**
             * Update meta information
             * 
             * @return integer
             */
            obj.updateMeta = function(affectedCells) {
                if (obj.options.meta) {
                    var newMeta = {};
                    var keys = Object.keys(obj.options.meta);
                    for (var i = 0; i < keys.length; i++) {
                        if (affectedCells[keys[i]]) {
                            newMeta[affectedCells[keys[i]]] = obj.options.meta[keys[i]];
                        } else {
                            newMeta[keys[i]] = obj.options.meta[keys[i]];
                        }
                    }
                    // Update meta information
                    obj.options.meta = newMeta;
                }
            };
        
            /**
             * Get style information from cell(s)
             * 
             * @return integer
             */
            obj.getStyle = function(cell, key) {
                // Cell
                if (! cell) {
                    // Control vars
                    var data = {};
        
                    // Column and row length
                    var x = obj.options.data[0].length;
                    var y = obj.options.data.length;
        
                    // Go through the columns to get the data
                    for (var j = 0; j < y; j++) {
                        for (var i = 0; i < x; i++) {
                            // Value
                            var v = key ? obj.records[j][i].style[key] : obj.records[j][i].getAttribute('style');
        
                            // Any meta data for this column?
                            if (v) {
                                // Column name
                                var k = jexcel.getColumnNameFromId([i, j]);
                                // Value
                                data[k] = v;
                            }
                        }
                    }
        
                   return data;
                } else {
                    cell = jexcel.getIdFromColumnName(cell, true);
        
                    return key ? obj.records[cell[1]][cell[0]].style[key] : obj.records[cell[1]][cell[0]].getAttribute('style');
                }
            },
        
            obj.resetStyle = function(o, ignoreHistoryAndEvents) {
                var keys = Object.keys(o);
                for (var i = 0; i < keys.length; i++) {
                    // Position
                    var cell = jexcel.getIdFromColumnName(keys[i], true);
                    if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]]) {
                        obj.records[cell[1]][cell[0]].setAttribute('style', '');
                    }
                }
                obj.setStyle(o, null, null, null, ignoreHistoryAndEvents);
            };
        
            /**
             * Set meta information to cell(s)
             * 
             * @return integer
             */
            obj.setStyle = function(o, k, v, force, ignoreHistoryAndEvents) {
                var newValue = {};
                var oldValue = {};
        
                // Apply style
                var applyStyle = function(cellId, key, value) {
                    // Position
                    var cell = jexcel.getIdFromColumnName(cellId, true);
        
                    if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]] && (obj.records[cell[1]][cell[0]].classList.contains('readonly')==false || force)) {
                        // Current value
                        var currentValue = obj.records[cell[1]][cell[0]].style[key];
        
                        // Change layout
                        if (currentValue == value && ! force) {
                            value = '';
                            obj.records[cell[1]][cell[0]].style[key] = '';
                        } else {
                            obj.records[cell[1]][cell[0]].style[key] = value;
                        }
        
                        // History
                        if (! oldValue[cellId]) {
                            oldValue[cellId] = [];
                        }
                        if (! newValue[cellId]) {
                            newValue[cellId] = [];
                        }
        
                        oldValue[cellId].push([key + ':' + currentValue]);
                        newValue[cellId].push([key + ':' + value]);
                    }
                };
        
                if (k && v) {
                    // Get object from string
                    if (typeof(o) == 'string') {
                        applyStyle(o, k, v);
                    } else {
                        // Avoid duplications
                        var oneApplication = [];
                        // Apply that for all cells
                        for (var i = 0; i < o.length; i++) {
                            var x = o[i].getAttribute('data-x');
                            var y = o[i].getAttribute('data-y');
                            var cellName = jexcel.getColumnNameFromId([x, y]);
                            // This happens when is a merged cell
                            if (! oneApplication[cellName]) {
                                applyStyle(cellName, k, v);
                                oneApplication[cellName] = true;
                            }
                        }
                    }
                } else {
                    var keys = Object.keys(o);
                    for (var i = 0; i < keys.length; i++) {
                        var style = o[keys[i]];
                        if (typeof(style) == 'string') {
                            style = style.split(';');
                        }
                        for (var j = 0; j < style.length; j++) {
                            if (typeof(style[j]) == 'string') {
                                style[j] = style[j].split(':');
                            }
                            // Apply value
                            if (style[j][0].trim()) {
                                applyStyle(keys[i], style[j][0].trim(), style[j][1]);
                            }
                        }
                    }
                }
        
                var keys = Object.keys(oldValue);
                for (var i = 0; i < keys.length; i++) {
                    oldValue[keys[i]] = oldValue[keys[i]].join(';');
                }
                var keys = Object.keys(newValue);
                for (var i = 0; i < keys.length; i++) {
                    newValue[keys[i]] = newValue[keys[i]].join(';');
                }
        
                if (! ignoreHistoryAndEvents) {
                    // Keeping history of changes
                    obj.setHistory({
                        action: 'setStyle',
                        oldValue: oldValue,
                        newValue: newValue,
                    });
                }

                obj.dispatch('onchangestyle', el, o, k, v);
            };

            /**
             * Get cell comments, null cell for all
             */
            obj.getComments = function(cell, withAuthor) {
                if (cell) {
                    if (typeof(cell) == 'string') {
                        var cell = jexcel.getIdFromColumnName(cell, true);
                    }

                    if (withAuthor) {
                        return [obj.records[cell[1]][cell[0]].getAttribute('title'), obj.records[cell[1]][cell[0]].getAttribute('author')];
                    } else {
                        return obj.records[cell[1]][cell[0]].getAttribute('title') || '';
                    }
                } else {
                    var data = {};
                    for (var j = 0; j < obj.options.data.length; j++) {
                        for (var i = 0; i < obj.options.columns.length; i++) {
                            var comments = obj.records[j][i].getAttribute('title');
                            if (comments) {
                                var cell = jexcel.getColumnNameFromId([i, j]);
                                data[cell] = comments;
                            }
                        }
                    }
                    return data;
                }
            };

            /**
             * Set cell comments
             */
            obj.setComments = function(cellId, comments, author) {
                if (typeof(cellId) == 'string') {
                    var cell = jexcel.getIdFromColumnName(cellId, true);
                } else {
                    var cell = cellId;
                }
        
                // Keep old value
                var title = obj.records[cell[1]][cell[0]].getAttribute('title');
                var author = obj.records[cell[1]][cell[0]].getAttribute('data-author');
                var oldValue = [ title, author ];
        
                // Set new values
                obj.records[cell[1]][cell[0]].setAttribute('title', comments ? comments : '');
                obj.records[cell[1]][cell[0]].setAttribute('data-author', author ? author : '');
        
                // Remove class if there is no comment
                if (comments) {
                    obj.records[cell[1]][cell[0]].classList.add('jexcel_comments');
                } else {
                    obj.records[cell[1]][cell[0]].classList.remove('jexcel_comments');
                }
        
                // Save history
                obj.setHistory({
                    action:'setComments',
                    column: cellId,
                    newValue: [ comments, author ],
                    oldValue: oldValue,
                });
                // Set comments
                obj.dispatch('oncomments', el, comments, title);
            };
        
            /**
             * Get table config information
             */
            obj.getConfig = function() {
                var options = obj.options;
                options.style = obj.getStyle();
                options.mergeCells = obj.getMerge();
                options.comments = obj.getComments();
        
                return options;
            };
        
            /**
             * Sort data and reload table
             */
            obj.orderBy = function(column, order) {
                if (column >= 0) {
                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            // Remove merged cells
                            obj.destroyMerged();
                        }
                    }
        
                    // Direction
                    if (order == null) {
                        order = obj.headers[column].classList.contains('arrow-down') ? 1 : 0;
                    } else {
                        order = order ? 1 : 0;
                    }
        
                    // Test order
                    var temp = [];
                    if (obj.options.columns[column].type == 'number' || obj.options.columns[column].type == 'percentage' || obj.options.columns[column].type == 'autonumber' || obj.options.columns[column].type == 'color') {
                        for (var j = 0; j < obj.options.data.length; j++) {
                            temp[j] = [ j, Number(obj.options.data[j][column]) ];
                        }
                    } else if (obj.options.columns[column].type == 'calendar' || obj.options.columns[column].type == 'checkbox' || obj.options.columns[column].type == 'radio') {
                        for (var j = 0; j < obj.options.data.length; j++) {
                            temp[j] = [ j, obj.options.data[j][column] ];
                        }
                    } else {
                        for (var j = 0; j < obj.options.data.length; j++) {
                            temp[j] = [ j, obj.records[j][column].innerText.toLowerCase() ];
                        }
                    }
        
                    // Default sorting method
                    if (typeof(obj.options.sorting) !== 'function') {
                        obj.options.sorting = function(direction) {
                            return function(a, b) {
                                var valueA = a[1];
                                var valueB = b[1];

                                if (! direction) {
                                    return (valueA === '' && valueB !== '') ? 1 : (valueA !== '' && valueB === '') ? -1 : (valueA > valueB) ? 1 : (valueA < valueB) ? -1 :  0;
                                } else {
                                    return (valueA === '' && valueB !== '') ? 1 : (valueA !== '' && valueB === '') ? -1 : (valueA > valueB) ? -1 : (valueA < valueB) ? 1 :  0;
                                }
                            }
                        };
                    }

                    temp = temp.sort(obj.options.sorting(order));
        
                    // Save history
                    var newValue = [];
                    for (var j = 0; j < temp.length; j++) {
                        newValue[j] = temp[j][0];
                    }
        
                    // Save history
                    obj.setHistory({
                        action: 'orderBy',
                        rows: newValue,
                        column: column,
                        order: order,
                    });
        
                    // Update order
                    obj.updateOrderArrow(column, order);
                    obj.updateOrder(newValue);
        
                    // On sort event
                    obj.dispatch('onsort', el, column, order);
        
                    return true;
                }
            };
        
            /**
             * Update order arrow
             */
            obj.updateOrderArrow = function(column, order) {
                // Remove order
                for (var i = 0; i < obj.headers.length; i++) {
                    obj.headers[i].classList.remove('arrow-up');
                    obj.headers[i].classList.remove('arrow-down');
                }
        
                // No order specified then toggle order
                if (order) {
                    obj.headers[column].classList.add('arrow-up');
                } else {
                    obj.headers[column].classList.add('arrow-down');
                }
            };
        
            /**
             * Update rows position
             */
            obj.updateOrder = function(rows) {
                // History
                var data = [];
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.options.data[rows[j]];
                }
                obj.options.data = data;
        
                var data = [];
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.records[rows[j]];
                }
                obj.records = data;
        
                var data = [];
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.rows[rows[j]];
                }
                obj.rows = data;
        
                // Update references
                obj.updateTableReferences();
        
                // Redo search
                if (obj.results && obj.results.length) {
                    if (obj.searchInput.value) {
                        obj.search(obj.searchInput.value);
                    } else {
                        obj.closeFilter();
                    }
                } else {
                    // Create page
                    obj.results = null;
                    obj.pageNumber = 0;
        
                    if (obj.options.pagination > 0) {
                        obj.page(0);
                    } else if (obj.options.lazyLoading == true) {
                        obj.loadPage(0);
                    } else {
                        for (var j = 0; j < obj.rows.length; j++) {
                            obj.tbody.appendChild(obj.rows[j]);
                        }
                    }
                }
            };
        
            /**
             * Move row
             * 
             * @return void
             */
            obj.moveRow = function(o, d, ignoreDom) {
                if (Object.keys(obj.options.mergeCells).length > 0) {
                    if (o > d) {
                        var insertBefore = 1;
                    } else {
                        var insertBefore = 0;
                    }

                    if (obj.isRowMerged(o).length || obj.isRowMerged(d, insertBefore).length) {
                        if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            obj.destroyMerged();
                        }
                    }
                }
        
                if (obj.options.search == true) {
                    if (obj.results && obj.results.length != obj.rows.length) {
                        if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                            obj.resetSearch();
                        } else {
                            return false;
                        }
                    }
        
                    obj.results = null;
                }
        
                if (! ignoreDom) {
                    if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[d]) >= 0) {
                        if (o > d) {
                            obj.tbody.insertBefore(obj.rows[o], obj.rows[d]);
                        } else {
                            obj.tbody.insertBefore(obj.rows[o], obj.rows[d].nextSibling);
                        }
                    } else {
                        obj.tbody.removeChild(obj.rows[o]);
                    }
                }
        
                // Place references in the correct position
                obj.rows.splice(d, 0, obj.rows.splice(o, 1)[0]);
                obj.records.splice(d, 0, obj.records.splice(o, 1)[0]);
                obj.options.data.splice(d, 0, obj.options.data.splice(o, 1)[0]);
        
                // Respect pagination
                if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
                    obj.page(obj.pageNumber);
                }
        
                // Keeping history of changes
                obj.setHistory({
                    action:'moveRow',
                    oldValue: o,
                    newValue: d,
                });
        
                // Update table references
                obj.updateTableReferences();
        
                // Events
                obj.dispatch('onmoverow', el, o, d);
            };

            /**
             * Insert a new row
             * 
             * @param mixed - number of blank lines to be insert or a single array with the data of the new row
             * @param rowNumber
             * @param insertBefore
             * @return void
             */
            obj.insertRow = function(mixed, rowNumber, insertBefore) {
                // Configuration
                if (obj.options.allowInsertRow == true) {
        
                    // Data to be insert
                    var data = [];
        
                    // The insert could be lead by number of rows or the array of data
                    if (mixed > 0) {
                        var numOfRows = mixed;
                    } else {
                        var numOfRows = 1;
        
                        if (mixed) {
                            data = mixed;
                        }
                    }
        
                    // Direction
                    var insertBefore = insertBefore ? true : false;
        
                    // Current column number
                    var lastRow = obj.options.data.length - 1;
        
                    if (rowNumber == undefined || rowNumber >= parseInt(lastRow) || rowNumber < 0) {
                        rowNumber = lastRow;
                    }
        
                    // Onbeforeinsertrow
                    if (obj.dispatch('onbeforeinsertrow', el, rowNumber, numOfRows, insertBefore) === false) {
                        console.log('onbeforeinsertrow returned false');

                        return false;
                    }
        
                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (obj.isRowMerged(rowNumber, insertBefore).length) {
                            if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                return false;
                            } else {
                                obj.destroyMerged();
                            }
                        }
                    }
        
                    // Clear any search
                    if (obj.options.search == true) {
                        if (obj.results && obj.results.length != obj.rows.length) {
                            if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                                obj.resetSearch();
                            } else {
                                return false;
                            }
                        }
        
                        obj.results = null;
                    }
        
                    // Insertbefore
                    var rowIndex = (! insertBefore) ? rowNumber + 1 : rowNumber;

                    // Keep the current data
                    var currentRecords = obj.records.splice(rowIndex);
                    var currentData = obj.options.data.splice(rowIndex);
                    var currentRows = obj.rows.splice(rowIndex);
        
                    // Adding lines
                    var rowRecords = [];
                    var rowData = [];
                    var rowNode = [];

                    for (var row = rowIndex; row < (numOfRows + rowIndex); row++) {
                        // Push data to the data container
                        obj.options.data[row] = [];
                        for (var col = 0; col < obj.options.columns.length; col++) {
                            obj.options.data[row][col]  = data[col] ? data[col] : '';
                        }
                        // Create row
                        var tr = obj.createRow(row, obj.options.data[row]);
                        // Append node
                        if (currentRows[0]) {
                            if (Array.prototype.indexOf.call(obj.tbody.children, currentRows[0]) >= 0) {
                                obj.tbody.insertBefore(tr, currentRows[0]);
                            }
                        } else {
                            if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[rowNumber]) >= 0) {
                                obj.tbody.appendChild(tr);
                            }
                        }
                        // Record History
                        rowRecords.push(obj.records[row]);
                        rowData.push(obj.options.data[row]);
                        rowNode.push(tr);
                    }
        
                    // Copy the data back to the main data
                    Array.prototype.push.apply(obj.records, currentRecords);
                    Array.prototype.push.apply(obj.options.data, currentData);
                    Array.prototype.push.apply(obj.rows, currentRows);
        
                    // Respect pagination
                    if (obj.options.pagination > 0) {
                        obj.page(obj.pageNumber);
                    }
        
                    // Keep history
                    obj.setHistory({
                        action: 'insertRow',
                        rowNumber: rowNumber,
                        numOfRows: numOfRows,
                        insertBefore: insertBefore,
                        rowRecords: rowRecords,
                        rowData: rowData,
                        rowNode: rowNode,
                    });
        
                    // Remove table references
                    obj.updateTableReferences();
        
                    // Events
                    obj.dispatch('oninsertrow', el, rowNumber, numOfRows, rowRecords, insertBefore);
                }
            };
        
            /**
             * Delete a row by number
             * 
             * @param integer rowNumber - row number to be excluded
             * @param integer numOfRows - number of lines
             * @return void
             */
            obj.deleteRow = function(rowNumber, numOfRows) {
                // Global Configuration
                if (obj.options.allowDeleteRow == true) {
                    if (obj.options.allowDeletingAllRows == true || obj.options.data.length > 1) {
                        // Delete row definitions
                        if (rowNumber == undefined) {
                            var number = obj.getSelectedRows();
        
                            if (! number[0]) {
                                rowNumber = obj.options.data.length - 1;
                                numOfRows = 1;
                            } else {
                                rowNumber = parseInt(number[0].getAttribute('data-y'));
                                numOfRows = number.length;
                            }
                        }
        
                        // Last column
                        var lastRow = obj.options.data.length - 1;
        
                        if (rowNumber == undefined || rowNumber > lastRow || rowNumber < 0) {
                            rowNumber = lastRow;
                        }
        
                        if (! numOfRows) {
                            numOfRows = 1;
                        }
        
                        // Do not delete more than the number of recoreds
                        if (rowNumber + numOfRows >= obj.options.data.length) {
                            numOfRows = obj.options.data.length - rowNumber;
                        }

                        // Onbeforedeleterow
                        if (obj.dispatch('onbeforedeleterow', el, rowNumber, numOfRows) === false) {
                            console.log('onbeforedeleterow returned false');
                            return false;
                        }
        
                        if (parseInt(rowNumber) > -1) {
                            // Merged cells
                            var mergeExists = false;
                            if (Object.keys(obj.options.mergeCells).length > 0) {
                                for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                                    if (obj.isRowMerged(row, false).length) {
                                        mergeExists = true;
                                    }
                                }
                            }
                            if (mergeExists) {
                                if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                    return false;
                                } else {
                                    obj.destroyMerged();
                                }
                            }
        
                            // Clear any search
                            if (obj.options.search == true) {
                                if (obj.results && obj.results.length != obj.rows.length) {
                                    if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                                        obj.resetSearch();
                                    } else {
                                        return false;
                                    }
                                }
        
                                obj.results = null;
                            }
        
                            // If delete all rows, and set allowDeletingAllRows false, will stay one row
                            if (obj.options.allowDeletingAllRows == false && lastRow + 1 === numOfRows) {
                                numOfRows--;
                                console.error('Jspreadsheet: It is not possible to delete the last row');
                            }
        
                            // Remove node
                            for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                                if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[row]) >= 0) {
                                    obj.rows[row].className = '';
                                    obj.rows[row].parentNode.removeChild(obj.rows[row]);
                                }
                            }
        
                            // Remove data
                            var rowRecords = obj.records.splice(rowNumber, numOfRows);
                            var rowData = obj.options.data.splice(rowNumber, numOfRows);
                            var rowNode = obj.rows.splice(rowNumber, numOfRows);
        
                            // Respect pagination
                            if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
                                obj.page(obj.pageNumber);
                            }
        
                            // Remove selection
                            obj.conditionalSelectionUpdate(1, rowNumber, (rowNumber + numOfRows) - 1);
        
                            // Keep history
                            obj.setHistory({
                                action: 'deleteRow',
                                rowNumber: rowNumber,
                                numOfRows: numOfRows,
                                insertBefore: 1,
                                rowRecords: rowRecords,
                                rowData: rowData,
                                rowNode: rowNode
                            });
        
                            // Remove table references
                            obj.updateTableReferences();
        
                            // Events
                            obj.dispatch('ondeleterow', el, rowNumber, numOfRows, rowRecords);
                        }
                    } else {
                        console.error('Jspreadsheet: It is not possible to delete the last row');
                    }
                }
            };
        
        
            /**
             * Move column
             * 
             * @return void
             */
            obj.moveColumn = function(o, d) {
                if (Object.keys(obj.options.mergeCells).length > 0) {
                    if (o > d) {
                        var insertBefore = 1;
                    } else {
                        var insertBefore = 0;
                    }

                    if (obj.isColMerged(o).length || obj.isColMerged(d, insertBefore).length) {
                        if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            obj.destroyMerged();
                        }
                    }
                }
        
                var o = parseInt(o);
                var d = parseInt(d);
        
                if (o > d) {
                    obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d]);
                    obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d]);
        
                    for (var j = 0; j < obj.rows.length; j++) {
                        obj.rows[j].insertBefore(obj.records[j][o], obj.records[j][d]);
                    }
                } else {
                    obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d].nextSibling);
                    obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d].nextSibling);
        
                    for (var j = 0; j < obj.rows.length; j++) {
                        obj.rows[j].insertBefore(obj.records[j][o], obj.records[j][d].nextSibling);
                    }
                }
        
                obj.options.columns.splice(d, 0, obj.options.columns.splice(o, 1)[0]);
                obj.headers.splice(d, 0, obj.headers.splice(o, 1)[0]);
                obj.colgroup.splice(d, 0, obj.colgroup.splice(o, 1)[0]);
        
                for (var j = 0; j < obj.rows.length; j++) {
                    obj.options.data[j].splice(d, 0, obj.options.data[j].splice(o, 1)[0]);
                    obj.records[j].splice(d, 0, obj.records[j].splice(o, 1)[0]);
                }
        
                // Update footers position
                if (obj.options.footers) {
                    for (var j = 0; j < obj.options.footers.length; j++) {
                        obj.options.footers[j].splice(d, 0, obj.options.footers[j].splice(o, 1)[0]);
                    }
                }

                // Keeping history of changes
                obj.setHistory({
                    action:'moveColumn',
                    oldValue: o,
                    newValue: d,
                });
        
                // Update table references
                obj.updateTableReferences();
        
                // Events
                obj.dispatch('onmovecolumn', el, o, d);
            };

            /**
             * Insert a new column
             * 
             * @param mixed - num of columns to be added or data to be added in one single column
             * @param int columnNumber - number of columns to be created
             * @param bool insertBefore
             * @param object properties - column properties
             * @return void
             */
            obj.insertColumn = function(mixed, columnNumber, insertBefore, properties) {
                // Configuration
                if (obj.options.allowInsertColumn == true) {
        
                    // Data to be insert
                    var data = [];
        
                    // The insert could be lead by number of rows or the array of data
                    if (mixed > 0) {
                        var numOfColumns = mixed;
                    } else {
                        var numOfColumns = 1;
        
                        if (mixed) {
                            data = mixed;
                        }
                    }
        
                    // Direction
                    var insertBefore = insertBefore ? true : false;
        
                    // Current column number
                    var lastColumn = obj.options.columns.length - 1;
        
                    // Confirm position
                    if (columnNumber == undefined || columnNumber >= parseInt(lastColumn) || columnNumber < 0) {
                        columnNumber = lastColumn;
                    }
        
                    // Onbeforeinsertcolumn
                    if (obj.dispatch('onbeforeinsertcolumn', el, columnNumber, numOfColumns, insertBefore) === false) {
                        console.log('onbeforeinsertcolumn returned false');

                        return false;
                    }
        
                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (obj.isColMerged(columnNumber, insertBefore).length) {
                            if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                return false;
                            } else {
                                obj.destroyMerged();
                            }
                        }
                    }
        
                    // Create default properties
                    if (! properties) {
                        properties = [];
                    }
        
                    for (var i = 0; i < numOfColumns; i++) {
                        if (! properties[i]) {
                            properties[i] = { type:'text', source:[], options:[], width:obj.options.defaultColWidth, align:obj.options.defaultColAlign };
                        }
                    }
        
                    // Insert before
                    var columnIndex = (! insertBefore) ? columnNumber + 1 : columnNumber;
                    obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, properties);
        
                    // Open space in the containers
                    var currentHeaders = obj.headers.splice(columnIndex);
                    var currentColgroup = obj.colgroup.splice(columnIndex);
        
                    // History
                    var historyHeaders = [];
                    var historyColgroup = [];
                    var historyRecords = [];
                    var historyData = [];
                    var historyFooters = [];
        
                    // Add new headers
                    for (var col = columnIndex; col < (numOfColumns + columnIndex); col++) {
                        obj.createCellHeader(col);
                        obj.headerContainer.insertBefore(obj.headers[col], obj.headerContainer.children[col+1]);
                        obj.colgroupContainer.insertBefore(obj.colgroup[col], obj.colgroupContainer.children[col+1]);
        
                        historyHeaders.push(obj.headers[col]);
                        historyColgroup.push(obj.colgroup[col]);
                    }
        
                    // Add new footer cells
                    if (obj.options.footers) {
                        for (var j = 0; j < obj.options.footers.length; j++) {
                            historyFooters[j] = [];
                            for (var i = 0; i < numOfColumns; i++) {
                                historyFooters[j].push('');
                            }
                            obj.options.footers[j].splice(columnIndex, 0, historyFooters[j]);
                        }
                    }

                    // Adding visual columns
                    for (var row = 0; row < obj.options.data.length; row++) {
                        // Keep the current data
                        var currentData = obj.options.data[row].splice(columnIndex);
                        var currentRecord = obj.records[row].splice(columnIndex);
        
                        // History
                        historyData[row] = [];
                        historyRecords[row] = [];
        
                        for (var col = columnIndex; col < (numOfColumns + columnIndex); col++) {
                            // New value
                            var value = data[row] ? data[row] : '';
                            obj.options.data[row][col] = value;
                            // New cell
                            var td = obj.createCell(col, row, obj.options.data[row][col]);
                            obj.records[row][col] = td;
                            // Add cell to the row
                            if (obj.rows[row]) {
                                obj.rows[row].insertBefore(td, obj.rows[row].children[col+1]);
                            }
        
                            // Record History
                            historyData[row].push(value);
                            historyRecords[row].push(td);
                        }
        
                        // Copy the data back to the main data
                        Array.prototype.push.apply(obj.options.data[row], currentData);
                        Array.prototype.push.apply(obj.records[row], currentRecord);
                    }
        
                    Array.prototype.push.apply(obj.headers, currentHeaders);
                    Array.prototype.push.apply(obj.colgroup, currentColgroup);
        
                    // Adjust nested headers
                    if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                        // Flexible way to handle nestedheaders
                        if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                            for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan) + numOfColumns;
                                obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan = colspan;
                                obj.thead.children[j].children[obj.thead.children[j].children.length-1].setAttribute('colspan', colspan);
                                var o = obj.thead.children[j].children[obj.thead.children[j].children.length-1].getAttribute('data-column');
                                o = o.split(',');
                                for (var col = columnIndex; col < (numOfColumns + columnIndex); col++) {
                                    o.push(col);
                                }
                                obj.thead.children[j].children[obj.thead.children[j].children.length-1].setAttribute('data-column', o);
                            }
                        } else {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + numOfColumns;
                            obj.options.nestedHeaders[0].colspan = colspan;
                            obj.thead.children[0].children[obj.thead.children[0].children.length-1].setAttribute('colspan', colspan);
                        }
                    }
        
                    // Keep history
                    obj.setHistory({
                        action: 'insertColumn',
                        columnNumber:columnNumber,
                        numOfColumns:numOfColumns,
                        insertBefore:insertBefore,
                        columns:properties,
                        headers:historyHeaders,
                        colgroup:historyColgroup,
                        records:historyRecords,
                        footers:historyFooters,
                        data:historyData,
                    });
        
                    // Remove table references
                    obj.updateTableReferences();
        
                    // Events
                    obj.dispatch('oninsertcolumn', el, columnNumber, numOfColumns, historyRecords, insertBefore);
                }
            };
        
            /**
             * Delete a column by number
             * 
             * @param integer columnNumber - reference column to be excluded
             * @param integer numOfColumns - number of columns to be excluded from the reference column
             * @return void
             */
            obj.deleteColumn = function(columnNumber, numOfColumns) {
                // Global Configuration
                if (obj.options.allowDeleteColumn == true) {
                    if (obj.headers.length > 1) {
                        // Delete column definitions
                        if (columnNumber == undefined) {
                            var number = obj.getSelectedColumns(true);
        
                            if (! number.length) {
                                // Remove last column
                                columnNumber = obj.headers.length - 1;
                                numOfColumns = 1;
                            } else {
                                // Remove selected
                                columnNumber = parseInt(number[0]);
                                numOfColumns = parseInt(number.length);
                            }
                        }
        
                        // Lasat column
                        var lastColumn = obj.options.data[0].length - 1;
        
                        if (columnNumber == undefined || columnNumber > lastColumn || columnNumber < 0) {
                            columnNumber = lastColumn;
                        }
        
                        // Minimum of columns to be delete is 1
                        if (! numOfColumns) {
                            numOfColumns = 1;
                        }
        
                        // Can't delete more than the limit of the table
                        if (numOfColumns > obj.options.data[0].length - columnNumber) {
                            numOfColumns = obj.options.data[0].length - columnNumber;
                        }
        
                        // onbeforedeletecolumn
                       if (obj.dispatch('onbeforedeletecolumn', el, columnNumber, numOfColumns) === false) {
                          console.log('onbeforedeletecolumn returned false');
                          return false;
                       }
        
                        // Can't remove the last column
                        if (parseInt(columnNumber) > -1) {
                            // Merged cells
                            var mergeExists = false;
                            if (Object.keys(obj.options.mergeCells).length > 0) {
                                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                    if (obj.isColMerged(col, false).length) {
                                        mergeExists = true;
                                    }
                                }
                            }
                            if (mergeExists) {
                                if (! confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                    return false;
                                } else {
                                    obj.destroyMerged();
                                }
                            }
        
                            // Delete the column properties
                            var columns = obj.options.columns.splice(columnNumber, numOfColumns);
        
                            for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                obj.colgroup[col].className = '';
                                obj.headers[col].className = '';
                                obj.colgroup[col].parentNode.removeChild(obj.colgroup[col]);
                                obj.headers[col].parentNode.removeChild(obj.headers[col]);
                            }
        
                            var historyHeaders = obj.headers.splice(columnNumber, numOfColumns);
                            var historyColgroup = obj.colgroup.splice(columnNumber, numOfColumns);
                            var historyRecords = [];
                            var historyData = [];
                            var historyFooters = [];

                            for (var row = 0; row < obj.options.data.length; row++) {
                                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                    obj.records[row][col].className = '';
                                    obj.records[row][col].parentNode.removeChild(obj.records[row][col]);
                                }
                            }
        
                            // Delete headers
                            for (var row = 0; row < obj.options.data.length; row++) {
                                // History
                                historyData[row] = obj.options.data[row].splice(columnNumber, numOfColumns);
                                historyRecords[row] = obj.records[row].splice(columnNumber, numOfColumns);
                            }

                            // Delete footers
                            if (obj.options.footers) {
                                for (var row = 0; row < obj.options.footers.length; row++) {
                                    historyFooters[row] = obj.options.footers[row].splice(columnNumber, numOfColumns);
                                }
                            }

                            // Remove selection
                            obj.conditionalSelectionUpdate(0, columnNumber, (columnNumber + numOfColumns) - 1);
        
                            // Adjust nested headers
                            if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                                // Flexible way to handle nestedheaders
                                if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                                    for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                                        var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan) - numOfColumns;
                                        obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan = colspan;
                                        obj.thead.children[j].children[obj.thead.children[j].children.length-1].setAttribute('colspan', colspan);
                                    }
                                } else {
                                    var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - numOfColumns;
                                    obj.options.nestedHeaders[0].colspan = colspan;
                                    obj.thead.children[0].children[obj.thead.children[0].children.length-1].setAttribute('colspan', colspan);
                                }
                            }
        
                            // Keeping history of changes
                            obj.setHistory({
                                action:'deleteColumn',
                                columnNumber:columnNumber,
                                numOfColumns:numOfColumns,
                                insertBefore: 1,
                                columns:columns,
                                headers:historyHeaders,
                                colgroup:historyColgroup,
                                records:historyRecords,
                                footers:historyFooters,
                                data:historyData,
                            });
        
                            // Update table references
                            obj.updateTableReferences();
        
                            // Delete
                            obj.dispatch('ondeletecolumn', el, columnNumber, numOfColumns, historyRecords);
                        }
                    } else {
                        console.error('Jspreadsheet: It is not possible to delete the last column');
                    }
                }
            };
        
            /**
             * Get seleted rows numbers
             * 
             * @return array
             */
            obj.getSelectedRows = function(asIds) {
                var rows = [];
                // Get all selected rows
                for (var j = 0; j < obj.rows.length; j++) {
                    if (obj.rows[j].classList.contains('selected')) {
                        if (asIds) {
                            rows.push(j);
                        } else {
                            rows.push(obj.rows[j]);
                        }
                    }
                }
        
                return rows;
            },
        
            /**
             * Get seleted column numbers
             * 
             * @return array
             */
            obj.getSelectedColumns = function() {
                var cols = [];
                // Get all selected cols
                for (var i = 0; i < obj.headers.length; i++) {
                    if (obj.headers[i].classList.contains('selected')) {
                        cols.push(i);
                    }
                }
        
                return cols;
            };
        
            /**
             * Get highlighted
             * 
             * @return array
             */
            obj.getHighlighted = function() {
                return obj.highlighted;
            };
        
            /**
             * Update cell references
             * 
             * @return void
             */
            obj.updateTableReferences = function() {
                // Update headers
                for (var i = 0; i < obj.headers.length; i++) {
                    var x = obj.headers[i].getAttribute('data-x');
        
                    if (x != i) {
                        // Update coords
                        obj.headers[i].setAttribute('data-x', i);
                        // Title
                        if (! obj.headers[i].getAttribute('title')) {
                            obj.headers[i].innerHTML = jexcel.getColumnName(i);
                        }
                    }
                }
        
                // Update all rows
                for (var j = 0; j < obj.rows.length; j++) {
                    if (obj.rows[j]) {
                        var y = obj.rows[j].getAttribute('data-y');
        
                        if (y != j) {
                            // Update coords
                            obj.rows[j].setAttribute('data-y', j);
                            obj.rows[j].children[0].setAttribute('data-y', j);
                            // Row number
                            obj.rows[j].children[0].innerHTML = j + 1;
                        }
                    }
                }
        
                // Regular cells affected by this change
                var affectedTokens = [];
                var mergeCellUpdates = [];
        
                // Update cell
                var updatePosition = function(x,y,i,j) {
                    if (x != i) {
                        obj.records[j][i].setAttribute('data-x', i);
                    }
                    if (y != j) {
                        obj.records[j][i].setAttribute('data-y', j);
                    }
        
                    // Other updates
                    if (x != i || y != j) {
                        var columnIdFrom = jexcel.getColumnNameFromId([x, y]);
                        var columnIdTo = jexcel.getColumnNameFromId([i, j]);
                        affectedTokens[columnIdFrom] = columnIdTo;
                    }
                };
        
                for (var j = 0; j < obj.records.length; j++) {
                    for (var i = 0; i < obj.records[0].length; i++) {
                        if (obj.records[j][i]) {
                            // Current values
                            var x = obj.records[j][i].getAttribute('data-x');
                            var y = obj.records[j][i].getAttribute('data-y');
        
                            // Update column
                            if (obj.records[j][i].getAttribute('data-merged')) {
                                var columnIdFrom = jexcel.getColumnNameFromId([x, y]);
                                var columnIdTo = jexcel.getColumnNameFromId([i, j]);
                                if (mergeCellUpdates[columnIdFrom] == null) {
                                    if (columnIdFrom == columnIdTo) {
                                        mergeCellUpdates[columnIdFrom] = false;
                                    } else {
                                        var totalX = parseInt(i - x);
                                        var totalY = parseInt(j - y);
                                        mergeCellUpdates[columnIdFrom] = [ columnIdTo, totalX, totalY ];
                                    }
                                }
                            } else {
                                updatePosition(x,y,i,j);
                            }
                        }
                    }
                }
        
                // Update merged if applicable
                var keys = Object.keys(mergeCellUpdates);
                if (keys.length) {
                    for (var i = 0; i < keys.length; i++) {
                        if (mergeCellUpdates[keys[i]]) {
                            var info = jexcel.getIdFromColumnName(keys[i], true);
                            var x = info[0];
                            var y = info[1];
                            updatePosition(x,y,x + mergeCellUpdates[keys[i]][1],y + mergeCellUpdates[keys[i]][2]);
        
                            var columnIdFrom = keys[i];
                            var columnIdTo = mergeCellUpdates[keys[i]][0];
                            for (var j = 0; j < obj.options.mergeCells[columnIdFrom][2].length; j++) {
                                var x = parseInt(obj.options.mergeCells[columnIdFrom][2][j].getAttribute('data-x'));
                                var y = parseInt(obj.options.mergeCells[columnIdFrom][2][j].getAttribute('data-y'));
                                obj.options.mergeCells[columnIdFrom][2][j].setAttribute('data-x', x + mergeCellUpdates[keys[i]][1]);
                                obj.options.mergeCells[columnIdFrom][2][j].setAttribute('data-y', y + mergeCellUpdates[keys[i]][2]);
                            }
        
                            obj.options.mergeCells[columnIdTo] = obj.options.mergeCells[columnIdFrom];
                            delete(obj.options.mergeCells[columnIdFrom]);
                        }
                    }
                }
        
                // Update formulas
                obj.updateFormulas(affectedTokens);
        
                // Update meta data
                obj.updateMeta(affectedTokens);
        
                // Refresh selection
                obj.refreshSelection();
        
                // Update table with custom configuration if applicable
                obj.updateTable();
            };
        
            /**
             * Custom settings for the cells
             */
            obj.updateTable = function() {
                // Check for spare
                if (obj.options.minSpareRows > 0) {
                    var numBlankRows = 0;
                    for (var j = obj.rows.length - 1; j >= 0; j--) {
                        var test = false;
                        for (var i = 0; i < obj.headers.length; i++) {
                            if (obj.options.data[j][i]) {
                                test = true;
                            }
                        }
                        if (test) {
                            break;
                        } else {
                            numBlankRows++;
                        }
                    }
        
                    if (obj.options.minSpareRows - numBlankRows > 0) {
                        obj.insertRow(obj.options.minSpareRows - numBlankRows);
                    }
                }
        
                if (obj.options.minSpareCols > 0) {
                    var numBlankCols = 0;
                    for (var i = obj.headers.length - 1; i >= 0 ; i--) {
                        var test = false;
                        for (var j = 0; j < obj.rows.length; j++) {
                            if (obj.options.data[j][i]) {
                                test = true;
                            }
                        }
                        if (test) {
                            break;
                        } else {
                            numBlankCols++;
                        }
                    }
        
                    if (obj.options.minSpareCols - numBlankCols > 0) {
                        obj.insertColumn(obj.options.minSpareCols - numBlankCols);
                    }
                }
        
                // Customizations by the developer
                if (typeof(obj.options.updateTable) == 'function') {
                    if (obj.options.detachForUpdates) {
                        el.removeChild(obj.content);
                    }

                    for (var j = 0; j < obj.rows.length; j++) {
                        for (var i = 0; i < obj.headers.length; i++) {
                            obj.options.updateTable(el, obj.records[j][i], i, j, obj.options.data[j][i], obj.records[j][i].innerText, jexcel.getColumnNameFromId([i, j]));
                        }
                    }

                    if (obj.options.detachForUpdates) {
                        el.insertBefore(obj.content, obj.pagination);
                    }
                }
        
                // Update footers
                if (obj.options.footers) {
                    obj.setFooter();
                }

                // Update corner position
                setTimeout(function() {
                    obj.updateCornerPosition();
                },0);
            };

            /**
             * Readonly
             */
            obj.isReadOnly = function(cell) {
                if (cell = obj.getCell(cell)) {
                    return cell.classList.contains('readonly') ? true : false;
                }
            };

            /**
             * Readonly
             */
            obj.setReadOnly = function(cell, state) {
                if (cell = obj.getCell(cell)) {
                    if (state) {
                        cell.classList.add('readonly');
                    } else {
                        cell.classList.remove('readonly');
                    }
                }
            };

            /**
             * Show row
             */
            obj.showRow = function(rowNumber) {
                obj.rows[rowNumber].style.display = '';
            };

            /**
             * Hide row
             */
            obj.hideRow = function(rowNumber) {
                obj.rows[rowNumber].style.display = 'none';
            };

            /**
             * Show column
             */
            obj.showColumn = function(colNumber) {
                obj.headers[colNumber].style.display = '';
                obj.colgroup[colNumber].style.display = '';
                for (var j = 0; j < obj.options.data.length; j++) {
                    obj.records[j][colNumber].style.display = '';
                }
            };

            /**
             * Hide column
             */
            obj.hideColumn = function(colNumber) {
                obj.headers[colNumber].style.display = 'none';
                obj.colgroup[colNumber].style.display = 'none';
                for (var j = 0; j < obj.options.data.length; j++) {
                    obj.records[j][colNumber].style.display = 'none';
                }
            };

            /**
             * Show index column
             */
            obj.showIndex = function() {
                obj.table.classList.remove('jexcel_hidden_index');
            };
        
            /**
             * Hide index column
             */
            obj.hideIndex = function() {
                obj.table.classList.add('jexcel_hidden_index');
            };
        
            /**
             * Update all related cells in the chain
             */
            var chainLoopProtection = [];
        
            obj.updateFormulaChain = function(x, y, records) {
                var cellId = jexcel.getColumnNameFromId([x, y]);
                if (obj.formula[cellId] && obj.formula[cellId].length > 0) {
                    if (chainLoopProtection[cellId]) {
                        obj.records[y][x].innerHTML = '#ERROR';
                        obj.formula[cellId] = '';
                    } else {
                        // Protection
                        chainLoopProtection[cellId] = true;
        
                        for (var i = 0; i < obj.formula[cellId].length; i++) {
                            var cell = jexcel.getIdFromColumnName(obj.formula[cellId][i], true);
                            // Update cell
                            var value = ''+obj.options.data[cell[1]][cell[0]];
                            if (value.substr(0,1) == '=') {
                                records.push(obj.updateCell(cell[0], cell[1], value, true));
                            } else {
                                // No longer a formula, remove from the chain
                                Object.keys(obj.formula)[i] = null;
                            }
                            obj.updateFormulaChain(cell[0], cell[1], records);
                        }
                    }
                }
        
                chainLoopProtection = [];
            };
        
            /**
             * Update formulas
             */
            obj.updateFormulas = function(referencesToUpdate) {
                // Update formulas
                for (var j = 0; j < obj.options.data.length; j++) {
                    for (var i = 0; i < obj.options.data[0].length; i++) {
                        var value = '' + obj.options.data[j][i];
                        // Is formula
                        if (value.substr(0,1) == '=') {
                            // Replace tokens
                            var newFormula = obj.updateFormula(value, referencesToUpdate);
                            if (newFormula != value) {
                                obj.options.data[j][i] = newFormula;
                            }
                        }
                    }
                }
        
                // Update formula chain
                var formula = [];
                var keys = Object.keys(obj.formula);
                for (var j = 0; j < keys.length; j++) {
                    // Current key and values
                    var key = keys[j];
                    var value = obj.formula[key];
                    // Update key
                    if (referencesToUpdate[key]) {
                        key = referencesToUpdate[key];
                    }
                    // Update values
                    formula[key] = [];
                    for (var i = 0; i < value.length; i++) {
                        var letter = value[i];
                        if (referencesToUpdate[letter]) {
                            letter = referencesToUpdate[letter];
                        }
                        formula[key].push(letter);
                    }
                }
                obj.formula = formula;
            };
        
            /**
             * Update formula
             */
            obj.updateFormula = function(formula, referencesToUpdate) {
                var testLetter = /[A-Z]/;
                var testNumber = /[0-9]/;
        
                var newFormula = '';
                var letter = null;
                var number = null;
                var token = '';
        
                for (var index = 0; index < formula.length; index++) {
                    if (testLetter.exec(formula[index])) {
                        letter = 1;
                        number = 0;
                        token += formula[index];
                    } else if (testNumber.exec(formula[index])) {
                        number = letter ? 1 : 0;
                        token += formula[index];
                    } else {
                        if (letter && number) {
                            token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
                        }
                        newFormula += token;
                        newFormula += formula[index];
                        letter = 0;
                        number = 0;
                        token = '';
                    }
                }
        
                if (token) {
                    if (letter && number) {
                        token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
                    }
                    newFormula += token;
                }
        
                return newFormula;
            };
        
            /**
             * Secure formula
             */
            var secureFormula = function(oldValue) {
                var newValue = '';
                var inside = 0;

                for (var i = 0; i < oldValue.length; i++) {
                    if (oldValue[i] == '"') {
                        if (inside == 0) {
                            inside = 1;
                        } else {
                            inside = 0;
                        }
                    }

                    if (inside == 1) {
                        newValue += oldValue[i];
                    } else {
                        newValue += oldValue[i].toUpperCase();
                    }
                }

                return newValue;
            };

            /**
             * Parse formulas
             */
            obj.executeFormula = function(expression, x, y) {
        
                var formulaResults = [];
                var formulaLoopProtection = [];
        
                // Execute formula with loop protection
                var execute = function(expression, x, y) {
                 // Parent column identification
                    var parentId = jexcel.getColumnNameFromId([x, y]);
        
                    // Code protection
                    if (formulaLoopProtection[parentId]) {
                        console.error('Reference loop detected');
                        return '#ERROR';
                    }
        
                    formulaLoopProtection[parentId] = true;
        
                    // Convert range tokens
                    var tokensUpdate = function(tokens) {
                        for (var index = 0; index < tokens.length; index++) {
                            var f = [];
                            var token = tokens[index].split(':');
                            var e1 = jexcel.getIdFromColumnName(token[0], true);
                            var e2 = jexcel.getIdFromColumnName(token[1], true);
        
                            if (e1[0] <= e2[0]) {
                                var x1 = e1[0];
                                var x2 = e2[0];
                            } else {
                                var x1 = e2[0];
                                var x2 = e1[0];
                            }
        
                            if (e1[1] <= e2[1]) {
                                var y1 = e1[1];
                                var y2 = e2[1];
                            } else {
                                var y1 = e2[1];
                                var y2 = e1[1];
                            }
        
                            for (var j = y1; j <= y2; j++) {
                                for (var i = x1; i <= x2; i++) {
                                    f.push(jexcel.getColumnNameFromId([i, j]));
                                }
                            }
        
                            expression = expression.replace(tokens[index], f.join(','));
                        }
                    };
        
                    // Range with $ remove $
                    expression = expression.replace(/\$?([A-Z]+)\$?([0-9]+)/g, "$1$2");

                    var tokens = expression.match(/([A-Z]+[0-9]+)\:([A-Z]+[0-9]+)/g);
                    if (tokens && tokens.length) {
                        tokensUpdate(tokens);
                    }
        
                    // String
                    var evalstring = '';
        
                    // Get tokens
                    var tokens = expression.match(/([A-Z]+[0-9]+)/g);
        
                    // Direct self-reference protection
                    if (tokens && tokens.indexOf(parentId) > -1) {
                        console.error('Self Reference detected');
                        return '#ERROR';
                    } else {
                        if (tokens) {
                            for (var i = 0; i < tokens.length; i++) {
                                // Keep chain
                                if (! obj.formula[tokens[i]]) {
                                    obj.formula[tokens[i]] = [];
                                }
                                // Is already in the register
                                if (obj.formula[tokens[i]].indexOf(parentId) < 0) {
                                    obj.formula[tokens[i]].push(parentId);
                                }
        
                                // Do not calculate again
                                if (eval('typeof(' + tokens[i] + ') == "undefined"')) {
                                    // Coords
                                    var position = jexcel.getIdFromColumnName(tokens[i], 1);
                                    // Get value
                                    if (typeof(obj.options.data[position[1]]) != 'undefined' && typeof(obj.options.data[position[1]][position[0]]) != 'undefined') {
                                        var value = obj.options.data[position[1]][position[0]];
                                    } else {
                                        var value = '';
                                    }
                                    // Get column data
                                    if ((''+value).substr(0,1) == '=') {
                                        if (formulaResults[tokens[i]]) {
                                            value = formulaResults[tokens[i]];
                                        } else {
                                            value = execute(value, position[0], position[1]);
                                            formulaResults[tokens[i]] = value;
                                        }
                                    }
                                    // Type!
                                    if ((''+value).trim() == '') {
                                        // Null
                                        evalstring += "var " + tokens[i] + " = null;";
                                    } else {
                                        if (value == Number(value) && obj.options.autoCasting == true) {
                                            // Number
                                            evalstring += "var " + tokens[i] + " = " + Number(value) + ";";
                                        } else {
                                            // Trying any formatted number
                                            var number = obj.parseNumber(value, position[0]);
                                            if (obj.options.autoCasting == true && number) {
                                                // Render as number
                                                evalstring += "var " + tokens[i] + " = " + number + ";";
                                            } else {
                                                // Render as string
                                                evalstring += "var " + tokens[i] + " = '" + value + "';";
                                            }
                                        }
                                    }
                                }
                            }
                        }
        
                        // Convert formula to javascript
                        try {
                            evalstring += "function COLUMN() { return parseInt(x) + 1; }; function ROW() { return parseInt(y) + 1; }; function CELL() { return parentId; }; function TABLE() { return obj; }; function VALUE(col, row) { return obj.records[row-1][col-1].innerHTML; }; function THISROWCELL(col) { var id = jexcel.getIdFromColumnName(col+(parseInt(y)+1), true); return obj.records[id[1]][id[0]].innerHTML; }";
        
                            var res = eval(evalstring + expression.substr(1));
                        } catch (e) {
                            var res = '#ERROR';
                        }
        
                        return res;
                    }
                };
        
                return execute(expression, x, y);
            };
        
            /**
             * Trying to extract a number from a string
             */
            obj.parseNumber = function(value, columnNumber) {
                // Decimal point
                var decimal = columnNumber && obj.options.columns[columnNumber].decimal ? obj.options.columns[columnNumber].decimal : '.';
        
                // Parse both parts of the number
                var number = ('' + value);
                number = number.split(decimal);
                number[0] = number[0].match(/[+-]?[0-9]/g);
                if (number[0]) {
                    number[0] = number[0].join('');
                }
                if (number[1]) {
                    number[1] = number[1].match(/[0-9]*/g).join('');
                }
        
                // Is a valid number
                if (number[0] && Number(number[0]) >= 0) {
                    if (! number[1]) {
                        var value = Number(number[0] + '.00');
                    } else {
                        var value = Number(number[0] + '.' + number[1]);
                    }
                } else {
                    var value = null;
                }
        
                return value;
            };
        
            /**
             * Get row number
             */
            obj.row = function(cell) {
            };
        
            /**
             * Get col number
             */
            obj.col = function(cell) {
            };
        
            obj.up = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[3] > 0) {
                        obj.up.visible(1, ctrlKey ? 0 : 1);
                    }
                } else {
                    if (obj.selectedCell[1] > 0) {
                        obj.up.visible(0, ctrlKey ? 0 : 1);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                // Update selection
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        
                // Change page
                if (obj.options.lazyLoading == true) {
                    if (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0) {
                        obj.loadPage(0);
                        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                    } else {
                        if (obj.loadValidation()) {
                            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                        } else {
                            var item = parseInt(obj.tbody.firstChild.getAttribute('data-y'));
                            if (obj.selectedCell[1] - item < 30) {
                                obj.loadUp();
                                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                            }
                        }
                    }
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }
        
                obj.updateScroll(1);
            };
        
            obj.up.visible = function(group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }
        
                if (direction == 0) {
                    for (var j = 0; j < y; j++) {
                        if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                            y = j;
                            break;
                        }
                    }
                } else {
                    y = obj.up.get(x, y);
                }
        
                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            };
        
            obj.up.get = function(x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var j = (y - 1); j >= 0; j--) {
                    if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                        if (obj.records[j][x].getAttribute('data-merged')) {
                            if (obj.records[j][x] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        y = j;
                        break;
                    }
                }
        
                return y;
            };
        
            obj.down = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[3] < obj.records.length - 1) {
                        obj.down.visible(1, ctrlKey ? 0 : 1);
                    }
                } else {
                    if (obj.selectedCell[1] < obj.records.length - 1) {
                        obj.down.visible(0, ctrlKey ? 0 : 1);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        
                // Change page
                if (obj.options.lazyLoading == true) {
                    if ((obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1)) {
                        obj.loadPage(-1);
                        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                    } else {
                        if (obj.loadValidation()) {
                            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                        } else {
                            var item = parseInt(obj.tbody.lastChild.getAttribute('data-y'));
                            if (item - obj.selectedCell[3] < 30) {
                                obj.loadDown();
                                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                            }
                        }
                    }
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }
        
                obj.updateScroll(3);
            };
        
            obj.down.visible = function(group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }
        
                if (direction == 0) {
                    for (var j = obj.rows.length - 1; j > y; j--) {
                        if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                            y = j;
                            break;
                        }
                    }
                } else {
                    y = obj.down.get(x, y);
                }
        
                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            };
        
            obj.down.get = function(x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var j = (y + 1); j < obj.rows.length; j++) {
                    if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                        if (obj.records[j][x].getAttribute('data-merged')) {
                            if (obj.records[j][x] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        y = j;
                        break;
                    }
                }
        
                return y;
            };
        
            obj.right = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[2] < obj.headers.length - 1) {
                        obj.right.visible(1, ctrlKey ? 0 : 1);
                    }
                } else {
                    if (obj.selectedCell[0] < obj.headers.length - 1) {
                        obj.right.visible(0, ctrlKey ? 0 : 1);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(2);
            };
        
            obj.right.visible = function(group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }
        
                if (direction == 0) {
                    for (var i = obj.headers.length - 1; i > x; i--) {
                        if (obj.records[y][i].style.display != 'none') {
                            x = i;
                            break;
                        }
                    }
                } else {
                    x = obj.right.get(x, y);
                }
        
                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            };
        
            obj.right.get = function(x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
        
                for (var i = (x + 1); i < obj.headers.length; i++) {
                    if (obj.records[y][i].style.display != 'none') {
                        if (obj.records[y][i].getAttribute('data-merged')) {
                            if (obj.records[y][i] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        x = i;
                        break;
                    }
                }
        
                return x;
            };
        
            obj.left = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[2] > 0) {
                        obj.left.visible(1, ctrlKey ? 0 : 1);
                    }
                } else {
                    if (obj.selectedCell[0] > 0) {
                        obj.left.visible(0, ctrlKey ? 0 : 1);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(0);
            };
        
            obj.left.visible = function(group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }
        
                if (direction == 0) {
                    for (var i = 0; i < x; i++) {
                        if (obj.records[y][i].style.display != 'none') {
                            x = i;
                            break;
                        }
                    }
                } else {
                    x = obj.left.get(x, y);
                }
        
                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            };
        
            obj.left.get = function(x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var i = (x - 1); i >= 0; i--) {
                    if (obj.records[y][i].style.display != 'none') {
                        if (obj.records[y][i].getAttribute('data-merged')) {
                            if (obj.records[y][i] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        x = i;
                        break;
                    }
                }
        
                return x;
            };
        
            obj.first = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (ctrlKey) {
                        obj.selectedCell[3] = 0;
                    } else {
                        obj.left.visible(1, 0);
                    }
                } else {
                    if (ctrlKey) {
                        obj.selectedCell[1] = 0;
                    } else {
                        obj.left.visible(0, 0);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                // Change page
                if (obj.options.lazyLoading == true && (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0)) {
                    obj.loadPage(0);
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(1);
            };
        
            obj.last = function(shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (ctrlKey) {
                        obj.selectedCell[3] = obj.records.length - 1;
                    } else {
                        obj.right.visible(1, 0);
                    }
                } else {
                    if (ctrlKey) {
                        obj.selectedCell[1] = obj.records.length - 1;
                    } else {
                        obj.right.visible(0, 0);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }
        
                // Change page
                if (obj.options.lazyLoading == true && (obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1)) {
                    obj.loadPage(-1);
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(3);
            };
        
            obj.selectAll = function() {
                if (! obj.selectedCell) {
                    obj.selectedCell = [];
                }
        
                obj.selectedCell[0] = 0;
                obj.selectedCell[1] = 0;
                obj.selectedCell[2] = obj.headers.length - 1;
                obj.selectedCell[3] = obj.records.length - 1;
        
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
            };
        
            /**
             * Go to a page in a lazyLoading
             */
            obj.loadPage = function(pageNumber) {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
        
                // Per page
                var quantityPerPage = 100;
        
                // pageNumber
                if (pageNumber == null || pageNumber == -1) {
                    // Last page
                    pageNumber = Math.ceil(results.length / quantityPerPage) - 1; 
                }
        
                var startRow = (pageNumber * quantityPerPage);
                var finalRow = (pageNumber * quantityPerPage) + quantityPerPage;
                if (finalRow > results.length) {
                    finalRow = results.length;
                }
                startRow = finalRow - 100;
                if (startRow < 0) {
                    startRow = 0;
                }
        
                // Appeding items
                for (var j = startRow; j < finalRow; j++) {
                    if (obj.options.search == true && obj.results) {
                        obj.tbody.appendChild(obj.rows[results[j]]);
                    } else {
                        obj.tbody.appendChild(obj.rows[j]);
                    }
        
                    if (obj.tbody.children.length > quantityPerPage) {
                        obj.tbody.removeChild(obj.tbody.firstChild);
                    }
                }
            };
        
            obj.loadUp = function() {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
                var test = 0;
                if (results.length > 100) {
                    // Get the first element in the page
                    var item = parseInt(obj.tbody.firstChild.getAttribute('data-y'));
                    if (obj.options.search == true && obj.results) {
                        item = results.indexOf(item);
                    }
                    if (item > 0) {
                        for (var j = 0; j < 30; j++) {
                            item = item - 1;
                            if (item > -1) {
                                if (obj.options.search == true && obj.results) {
                                    obj.tbody.insertBefore(obj.rows[results[item]], obj.tbody.firstChild);
                                } else {
                                    obj.tbody.insertBefore(obj.rows[item], obj.tbody.firstChild);
                                }
                                if (obj.tbody.children.length > 100) {
                                    obj.tbody.removeChild(obj.tbody.lastChild);
                                    test = 1;
                                }
                            }
                        }
                    }
                }
                return test;
            };
        
            obj.loadDown = function() {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
                var test = 0;
                if (results.length > 100) {
                    // Get the last element in the page
                    var item = parseInt(obj.tbody.lastChild.getAttribute('data-y'));
                    if (obj.options.search == true && obj.results) {
                        item = results.indexOf(item);
                    }
                    if (item < obj.rows.length - 1) {
                        for (var j = 0; j <= 30; j++) {
                            if (item < results.length) {
                                if (obj.options.search == true && obj.results) {
                                    obj.tbody.appendChild(obj.rows[results[item]]);
                                } else {
                                    obj.tbody.appendChild(obj.rows[item]);
                                }
                                if (obj.tbody.children.length > 100) {
                                    obj.tbody.removeChild(obj.tbody.firstChild);
                                    test = 1;
                                }
                            }
                            item = item + 1;
                        }
                    }
                }
        
                return test;
            };
        
            obj.loadValidation = function() {
                if (obj.selectedCell) {
                    var currentPage = parseInt(obj.tbody.firstChild.getAttribute('data-y')) / 100;
                    var selectedPage = parseInt(obj.selectedCell[3] / 100);
                    var totalPages = parseInt(obj.rows.length / 100);
        
                    if (currentPage != selectedPage && selectedPage <= totalPages) {
                        if (! Array.prototype.indexOf.call(obj.tbody.children, obj.rows[obj.selectedCell[3]])) {
                            obj.loadPage(selectedPage);
                            return true;
                        }
                    }
                }
        
                return false;
            };
        
            /**
             * Reset search
             */
            obj.resetSearch = function() {
                obj.searchInput.value = '';
                obj.search('');
                obj.results = null;
            };

            /**
             * Search
             */
            obj.search = function(query) {
                // Query
                if (query) {
                    var query = query.toLowerCase();
                }
        
                // Reset any filter
                if (obj.options.filters) {
                    obj.resetFilters();
                }

                // Reset selection
                obj.resetSelection();
        
                // Total of results
                obj.pageNumber = 0;
                obj.results = [];
        
                if (query) {
                    // Search filter
                    var search = function(item, query, index) {
                        for (var i = 0; i < item.length; i++) {
                            if ((''+item[i]).toLowerCase().search(query) >= 0 ||
                                (''+obj.records[index][i].innerHTML).toLowerCase().search(query) >= 0) {
                                return true;
                            }
                        }
                        return false;
                    };
        
                    // Result
                    var addToResult = function(k) {
                        if (obj.results.indexOf(k) == -1) {
                            obj.results.push(k);
                        }
                    };
        
                    // Filter
                    obj.options.data.filter(function(v, k) {
                        if (search(v, query, k)) {
                            // Merged rows found
                            var rows = obj.isRowMerged(k);
                            if (rows.length) {
                                for (var i = 0; i < rows.length; i++) {
                                    var row = jexcel.getIdFromColumnName(rows[i], true);
                                    for (var j = 0; j < obj.options.mergeCells[rows[i]][1]; j++) {
                                        addToResult(row[1]+j);
                                    }
                                }
                            } else {
                                // Normal row found
                                addToResult(k);
                            }
                            return true;
                        } else {
                            return false;
                        }
                    });
                } else {
                    obj.results = null;
                }

                return obj.updateResult();
            };
        
            obj.updateResult = function() {
                var total = 0;
                var index = 0;
        
                // Page 1
                if (obj.options.lazyLoading == true) {
                    total = 100;
                } else if (obj.options.pagination > 0) {
                    total = obj.options.pagination;
                } else {
                    if (obj.results) {
                        total = obj.results.length;
                    } else {
                        total = obj.rows.length;
                    }
                }
        
                // Reset current nodes
                while (obj.tbody.firstChild) {
                    obj.tbody.removeChild(obj.tbody.firstChild);
                }
        
                // Hide all records from the table
                for (var j = 0; j < obj.rows.length; j++) {
                    if (! obj.results || obj.results.indexOf(j) > -1) {
                        if (index < total) {
                            obj.tbody.appendChild(obj.rows[j]);
                            index++;
                        }
                        obj.rows[j].style.display = '';
                    } else {
                        obj.rows[j].style.display = 'none';
                    }
                }
        
                // Update pagination
                if (obj.options.pagination > 0) {
                    obj.updatePagination();
                }

                obj.updateCornerPosition();
        
                return total;
            };

            /**
             * Which page the cell is
             */
            obj.whichPage = function(cell) {
                // Search
                if (obj.options.search == true && obj.results) {
                    cell = obj.results.indexOf(cell);
                }
        
                return (Math.ceil((parseInt(cell) + 1) / parseInt(obj.options.pagination))) - 1;
            };
        
            /**
             * Go to page
             */
            obj.page = function(pageNumber) {
                var oldPage = obj.pageNumber;

                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
        
                // Per page
                var quantityPerPage = parseInt(obj.options.pagination);
        
                // pageNumber
                if (pageNumber == null || pageNumber == -1) {
                    // Last page
                    pageNumber = Math.ceil(results.length / quantityPerPage) - 1;
                }
        
                // Page number
                obj.pageNumber = pageNumber;
        
                var startRow = (pageNumber * quantityPerPage);
                var finalRow = (pageNumber * quantityPerPage) + quantityPerPage;
                if (finalRow > results.length) {
                    finalRow = results.length;
                }
                if (startRow < 0) {
                    startRow = 0;
                }
        
                // Reset container
                while (obj.tbody.firstChild) {
                    obj.tbody.removeChild(obj.tbody.firstChild);
                }
        
                // Appeding items
                for (var j = startRow; j < finalRow; j++) {
                    if (obj.options.search == true && obj.results) {
                        obj.tbody.appendChild(obj.rows[results[j]]);
                    } else {
                        obj.tbody.appendChild(obj.rows[j]);
                    }
                }
        
                if (obj.options.pagination > 0) {
                    obj.updatePagination();
                }
        
                // Update corner position
                obj.updateCornerPosition();

                // Events
                obj.dispatch('onchangepage', el, pageNumber, oldPage);
            };
        
            /**
             * Update the pagination
             */
            obj.updatePagination = function() {
                // Reset container
                obj.pagination.children[0].innerHTML = '';
                obj.pagination.children[1].innerHTML = '';
        
                // Start pagination
                if (obj.options.pagination) {
                    // Searchable
                    if (obj.options.search == true && obj.results) {
                        var results = obj.results.length;
                    } else {
                        var results = obj.rows.length;
                    }
        
                    if (! results) {
                        // No records found
                        obj.pagination.children[0].innerHTML = obj.options.text.noRecordsFound;
                    } else {
                        // Pagination container
                        var quantyOfPages = Math.ceil(results / obj.options.pagination);
        
                        if (obj.pageNumber < 6) {
                            var startNumber = 1;
                            var finalNumber = quantyOfPages < 10 ? quantyOfPages : 10;
                        } else if (quantyOfPages - obj.pageNumber < 5) {
                            var startNumber = quantyOfPages - 9;
                            var finalNumber = quantyOfPages;
                            if (startNumber < 1) {
                                startNumber = 1;
                            }
                        } else {
                            var startNumber = obj.pageNumber - 4;
                            var finalNumber = obj.pageNumber + 5;
                        }
        
                        // First
                        if (startNumber > 1) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = '<';
                            paginationItem.title = 1;
                            obj.pagination.children[1].appendChild(paginationItem);
                        }
        
                        // Get page links
                        for (var i = startNumber; i <= finalNumber; i++) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = i;
                            obj.pagination.children[1].appendChild(paginationItem);
        
                            if (obj.pageNumber == (i-1)) {
                                paginationItem.classList.add('jexcel_page_selected');
                            }
                        }
        
                        // Last
                        if (finalNumber < quantyOfPages) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = '>';
                            paginationItem.title = quantyOfPages;
                            obj.pagination.children[1].appendChild(paginationItem);
                        }
        
                        // Text
                        var format = function(format) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            return format.replace(/{(\d+)}/g, function(match, number) {
                              return typeof args[number] != 'undefined'
                                ? args[number]
                                : match
                              ;
                            });
                        };
        
                        obj.pagination.children[0].innerHTML = format(obj.options.text.showingPage, obj.pageNumber + 1, quantyOfPages);
                    }
                }
            };
        
            /**
             * Download CSV table
             * 
             * @return null
             */
            obj.download = function(includeHeaders) {
                if (obj.options.allowExport == false) {
                    console.error('Export not allowed');
                } else {
                    // Data
                    var data = '';

                    // Get data
                    data += obj.copy(false, obj.options.csvDelimiter, true, includeHeaders, true);

                    // Download element
                    var blob = new Blob(["\uFEFF"+data], {type: 'text/csv;charset=utf-8;'});

                    // IE Compatibility
                    if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                        window.navigator.msSaveOrOpenBlob(blob, obj.options.csvFileName + '.csv');
                    } else {
                        // Download element
                        var pom = document.createElement('a');
                        var url = URL.createObjectURL(blob);
                        pom.href = url;
                        pom.setAttribute('download', obj.options.csvFileName + '.csv');
                        document.body.appendChild(pom);
                        pom.click();
                        pom.parentNode.removeChild(pom);
                    }
                }
            };
        
            /**
             * Initializes a new history record for undo/redo
             * 
             * @return null
             */
            obj.setHistory = function(changes) {
                if (obj.ignoreHistory != true) {
                    // Increment and get the current history index
                    var index = ++obj.historyIndex;
        
                    // Slice the array to discard undone changes
                    obj.history = (obj.history = obj.history.slice(0, index + 1));
        
                    // Keep history
                    obj.history[index] = changes;
                }
            };
        
            /**
             * Copy method
             * 
             * @param bool highlighted - Get only highlighted cells
             * @param delimiter - \t default to keep compatibility with excel
             * @return string value
             */
            obj.copy = function(highlighted, delimiter, returnData, includeHeaders, download) {
                if (! delimiter) {
                    delimiter = "\t";
                }
        
                var div = new RegExp(delimiter, 'ig');

                // Controls
                var header = [];
                var col = [];
                var colLabel = [];
                var row = [];
                var rowLabel = [];
                var x = obj.options.data[0].length;
                var y = obj.options.data.length;
                var tmp = '';
                var copyHeader = false;
                var headers = '';
                var nestedHeaders = '';
                var numOfCols = 0;
                var numOfRows = 0;

                if ((download && obj.options.includeHeadersOnDownload == true) ||
                    (! download && obj.options.includeHeadersOnCopy == true) ||
                    (includeHeaders)) {
                    // Nested headers
                    if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                        // Flexible way to handle nestedheaders
                        if (! (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0])) {
                            tmp = [obj.options.nestedHeaders];
                        } else {
                            tmp = obj.options.nestedHeaders;
                        }

                        for (var j = 0; j < tmp.length; j++) {
                            var nested = [];
                            for (var i = 0; i < tmp[j].length; i++) {
                                var colspan = parseInt(tmp[j][i].colspan);
                                nested.push(tmp[j][i].title);
                                for (var c = 0; c < colspan - 1; c++) {
                                    nested.push('');
                                }
                            }
                            nestedHeaders += nested.join(delimiter) + "\r\n";
                        }
                    }

                    copyHeader = true;
                }

                // Reset container
                obj.style = [];
        
                // Go through the columns to get the data
                for (var j = 0; j < y; j++) {
                    col = [];
                    colLabel = [];
        
                    for (var i = 0; i < x; i++) {
                        // If cell is highlighted
                        if (! highlighted || obj.records[j][i].classList.contains('highlight')) {
                            if (copyHeader == true) {
                                header.push(obj.headers[i].innerText);
                            }
                            // Values
                            var value = obj.options.data[j][i];
                            if (value.match && (value.match(div) || value.match(/,/g) || value.match(/\n/) || value.match(/\"/))) {
                                value = value.replace(new RegExp('"', 'g'), '""');
                                value = '"' + value + '"';
                            }
                            col.push(value);
        
                            // Labels
                            if (obj.options.columns[i].type == 'checkbox' || obj.options.columns[i].type == 'radio') {
                                var label = value;
                            } else {
                                if (obj.options.stripHTMLOnCopy == true) {
                                    var label = obj.records[j][i].innerText;
                                } else {
                                    var label = obj.records[j][i].innerHTML;
                                }
                                if (label.match && (label.match(div) || label.match(/,/g) || label.match(/\n/) || label.match(/\"/))) {
                                    // Scape double quotes
                                    label = label.replace(new RegExp('"', 'g'), '""');
                                    label = '"' + label + '"';
                                }
                            }
                            colLabel.push(label);
        
                            // Get style
                            tmp = obj.records[j][i].getAttribute('style');
                            tmp = tmp.replace('display: none;', '');
                            obj.style.push(tmp ? tmp : '');
                        }
                    }
        
                    if (col.length) {
                        if (copyHeader) {
                            numOfCols = col.length;
                            row.push(header.join(delimiter));
                        }
                        row.push(col.join(delimiter));
                    }
                    if (colLabel.length) {
                        numOfRows++;
                        if (copyHeader) {
                            rowLabel.push(header.join(delimiter));
                            copyHeader = false;
                        }
                        rowLabel.push(colLabel.join(delimiter));
                    }
                }

                if (x == numOfCols &&  y == numOfRows) {
                    headers = nestedHeaders;
                }

                // Final string
                var str = headers + row.join("\r\n");
                var strLabel = headers + rowLabel.join("\r\n");

                // Create a hidden textarea to copy the values
                if (! returnData) {
                    if (obj.options.copyCompatibility == true) {
                        obj.textarea.value = strLabel;
                    } else {
                        obj.textarea.value = str;
                    }
                    obj.textarea.select();
                    document.execCommand("copy");
                }
        
                // Keep data
                if (obj.options.copyCompatibility == true) {
                    obj.data = strLabel;
                } else {
                    obj.data = str;
                }
                // Keep non visible information
                obj.hashString = obj.hash(obj.data);
        
                // Any exiting border should go
                if (! returnData) {
                    obj.removeCopyingSelection();
        
                    // Border
                    if (obj.highlighted) {
                        for (var i = 0; i < obj.highlighted.length; i++) {
                            obj.highlighted[i].classList.add('copying');
                            if (obj.highlighted[i].classList.contains('highlight-left')) {
                                obj.highlighted[i].classList.add('copying-left');
                            }
                            if (obj.highlighted[i].classList.contains('highlight-right')) {
                                obj.highlighted[i].classList.add('copying-right');
                            }
                            if (obj.highlighted[i].classList.contains('highlight-top')) {
                                obj.highlighted[i].classList.add('copying-top');
                            }
                            if (obj.highlighted[i].classList.contains('highlight-bottom')) {
                                obj.highlighted[i].classList.add('copying-bottom');
                            }
                        }
                    }
        
                    // Paste event
                    obj.dispatch('oncopy', el, obj.options.copyCompatibility == true ? rowLabel : row, obj.hashString);
                }

                return obj.data;
            };
        
            /**
             * Jspreadsheet paste method
             * 
             * @param integer row number
             * @return string value
             */
            obj.paste = function(x, y, data) {
                // Paste filter
                var ret = obj.dispatch('onbeforepaste', el, data, x, y);

                if (ret === false) {
                    return false;
                } else if (ret) {
                    var data = ret;
                }
        
                // Controls
                var hash = obj.hash(data);
                var style = (hash == obj.hashString) ? obj.style : null;
        
                // Depending on the behavior
                if (obj.options.copyCompatibility == true && hash == obj.hashString) {
                    var data = obj.data;
                }
        
                // Split new line
                var data = obj.parseCSV(data, "\t");
        
                if (x != null && y != null && data) {
                    // Records
                    var i = 0;
                    var j = 0;
                    var records = [];
                    var newStyle = {};
                    var oldStyle = {};
                    var styleIndex = 0;
        
                    // Index
                    var colIndex = parseInt(x);
                    var rowIndex = parseInt(y);
                    var row = null;
        
                    // Go through the columns to get the data
                    while (row = data[j]) {
                        i = 0;
                        colIndex = parseInt(x);
        
                        while (row[i] != null) {
                            // Update and keep history
                            var record = obj.updateCell(colIndex, rowIndex, row[i]);
                            // Keep history
                            records.push(record);
                            // Update all formulas in the chain
                            obj.updateFormulaChain(colIndex, rowIndex, records);
                            // Style
                            if (style && style[styleIndex]) {
                                var columnName = jexcel.getColumnNameFromId([colIndex, rowIndex]);
                                newStyle[columnName] = style[styleIndex];
                                oldStyle[columnName] = obj.getStyle(columnName);
                                obj.records[rowIndex][colIndex].setAttribute('style', style[styleIndex]);
                                styleIndex++;
                            }
                            i++;
                            if (row[i] != null) {
                                if (colIndex >= obj.headers.length - 1) {
                                    obj.insertColumn();
                                }
                                colIndex = obj.right.get(colIndex, rowIndex);
                            }
                        }
        
                        j++;
                        if (data[j]) {
                            if (rowIndex >= obj.rows.length-1) {
                                obj.insertRow();
                            }
                            rowIndex = obj.down.get(x, rowIndex);
                        }
                    }
        
                    // Select the new cells
                    obj.updateSelectionFromCoords(x, y, colIndex, rowIndex);
        
                    // Update history
                    obj.setHistory({
                        action:'setValue',
                        records:records,
                        selection:obj.selectedCell,
                        newStyle:newStyle,
                        oldStyle:oldStyle,
                    });
        
                    // Update table
                    obj.updateTable();
        
                    // Paste event
                    obj.dispatch('onpaste', el, data);
        
                    // On after changes
                    obj.onafterchanges(el, records);
                }

                obj.removeCopyingSelection();
            };

            /**
             * Remove copying border
             */
            obj.removeCopyingSelection = function() {
                var copying = document.querySelectorAll('.jexcel .copying');
                for (var i = 0; i < copying.length; i++) {
                    copying[i].classList.remove('copying');
                    copying[i].classList.remove('copying-left');
                    copying[i].classList.remove('copying-right');
                    copying[i].classList.remove('copying-top');
                    copying[i].classList.remove('copying-bottom');
                }
            };

            /**
             * Process row
             */
            obj.historyProcessRow = function(type, historyRecord) {
                var rowIndex = (! historyRecord.insertBefore) ? historyRecord.rowNumber + 1 : historyRecord.rowNumber;
        
                if (obj.options.search == true) {
                    if (obj.results && obj.results.length != obj.rows.length) {
                        obj.resetSearch();
                    }
                }
        
                // Remove row
                if (type == 1) {
                    var numOfRows = historyRecord.numOfRows;
                    // Remove nodes
                    for (var j = rowIndex; j < (numOfRows + rowIndex); j++) {
                        obj.rows[j].parentNode.removeChild(obj.rows[j]);
                    }
                    // Remove references
                    obj.records.splice(rowIndex, numOfRows);
                    obj.options.data.splice(rowIndex, numOfRows);
                    obj.rows.splice(rowIndex, numOfRows);
        
                    obj.conditionalSelectionUpdate(1, rowIndex, (numOfRows + rowIndex) - 1);
                } else {
                    // Insert data
                    obj.records = jexcel.injectArray(obj.records, rowIndex, historyRecord.rowRecords);
                    obj.options.data = jexcel.injectArray(obj.options.data, rowIndex, historyRecord.rowData);
                    obj.rows = jexcel.injectArray(obj.rows, rowIndex, historyRecord.rowNode);
                    // Insert nodes
                    var index = 0;
                    for (var j = rowIndex; j < (historyRecord.numOfRows + rowIndex); j++) {
                        obj.tbody.insertBefore(historyRecord.rowNode[index], obj.tbody.children[j]);
                        index++;
                    }
                }
        
                // Respect pagination
                if (obj.options.pagination > 0) {
                    obj.page(obj.pageNumber);
                }
        
                obj.updateTableReferences();
            };
        
            /**
             * Process column
             */
            obj.historyProcessColumn = function(type, historyRecord) {
                var columnIndex = (! historyRecord.insertBefore) ? historyRecord.columnNumber + 1 : historyRecord.columnNumber;
        
                // Remove column
                if (type == 1) {
                    var numOfColumns = historyRecord.numOfColumns;
        
                    obj.options.columns.splice(columnIndex, numOfColumns);
                    for (var i = columnIndex; i < (numOfColumns + columnIndex); i++) {
                        obj.headers[i].parentNode.removeChild(obj.headers[i]);
                        obj.colgroup[i].parentNode.removeChild(obj.colgroup[i]);
                    }
                    obj.headers.splice(columnIndex, numOfColumns);
                    obj.colgroup.splice(columnIndex, numOfColumns);
                    for (var j = 0; j < historyRecord.data.length; j++) {
                        for (var i = columnIndex; i < (numOfColumns + columnIndex); i++) {
                            obj.records[j][i].parentNode.removeChild(obj.records[j][i]);
                        }
                        obj.records[j].splice(columnIndex, numOfColumns);
                        obj.options.data[j].splice(columnIndex, numOfColumns);
                    }
                    // Process footers
                    if (obj.options.footers) {
                        for (var j = 0; j < obj.options.footers.length; j++) {
                            obj.options.footers[j].splice(columnIndex, numOfColumns);
                        }
                    }
                } else {
                    // Insert data
                    obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, historyRecord.columns);
                    obj.headers = jexcel.injectArray(obj.headers, columnIndex, historyRecord.headers);
                    obj.colgroup = jexcel.injectArray(obj.colgroup, columnIndex, historyRecord.colgroup);
        
                    var index = 0;
                    for (var i = columnIndex; i < (historyRecord.numOfColumns + columnIndex); i++) {
                        obj.headerContainer.insertBefore(historyRecord.headers[index], obj.headerContainer.children[i+1]);
                        obj.colgroupContainer.insertBefore(historyRecord.colgroup[index], obj.colgroupContainer.children[i+1]);
                        index++;
                    }
        
                    for (var j = 0; j < historyRecord.data.length; j++) {
                        obj.options.data[j] = jexcel.injectArray(obj.options.data[j], columnIndex, historyRecord.data[j]);
                        obj.records[j] = jexcel.injectArray(obj.records[j], columnIndex, historyRecord.records[j]);
                        var index = 0;
                        for (var i = columnIndex; i < (historyRecord.numOfColumns + columnIndex); i++) {
                            obj.rows[j].insertBefore(historyRecord.records[j][index], obj.rows[j].children[i+1]);
                            index++;
                        }
                    }
                    // Process footers
                    if (obj.options.footers) {
                        for (var j = 0; j < obj.options.footers.length; j++) {
                            obj.options.footers[j] = jexcel.injectArray(obj.options.footers[j], columnIndex, historyRecord.footers[j]);
                        }
                    }
                }
        
                // Adjust nested headers
                if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                    // Flexible way to handle nestedheaders
                    if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                        for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                            if (type == 1) {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan) - historyRecord.numOfColumns;
                            } else {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan) + historyRecord.numOfColumns;
                            }
                            obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length-1].colspan = colspan;
                            obj.thead.children[j].children[obj.thead.children[j].children.length-1].setAttribute('colspan', colspan);
                        }
                    } else {
                        if (type == 1) {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - historyRecord.numOfColumns;
                        } else {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + historyRecord.numOfColumns;
                        }
                        obj.options.nestedHeaders[0].colspan = colspan;
                        obj.thead.children[0].children[obj.thead.children[0].children.length-1].setAttribute('colspan', colspan);
                    }
                }
        
                obj.updateTableReferences();
            };
        
            /**
             * Undo last action
             */
            obj.undo = function() {
                // Ignore events and history
                var ignoreEvents = obj.ignoreEvents ? true : false;
                var ignoreHistory = obj.ignoreHistory ? true : false;
        
                obj.ignoreEvents = true;
                obj.ignoreHistory = true;
        
                // Records
                var records = [];
        
                // Update cells
                if (obj.historyIndex >= 0) {
                    // History
                    var historyRecord = obj.history[obj.historyIndex--];
        
                    if (historyRecord.action == 'insertRow') {
                        obj.historyProcessRow(1, historyRecord);
                    } else if (historyRecord.action == 'deleteRow') {
                        obj.historyProcessRow(0, historyRecord);
                    } else if (historyRecord.action == 'insertColumn') {
                        obj.historyProcessColumn(1, historyRecord);
                    } else if (historyRecord.action == 'deleteColumn') {
                        obj.historyProcessColumn(0, historyRecord);
                    } else if (historyRecord.action == 'moveRow') {
                        obj.moveRow(historyRecord.newValue, historyRecord.oldValue);
                    } else if (historyRecord.action == 'moveColumn') {
                        obj.moveColumn(historyRecord.newValue, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setMerge') {
                        obj.removeMerge(historyRecord.column, historyRecord.data);
                    } else if (historyRecord.action == 'setStyle') {
                        obj.setStyle(historyRecord.oldValue, null, null, 1);
                    } else if (historyRecord.action == 'setWidth') {
                        obj.setWidth(historyRecord.column, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setHeight') {
                        obj.setHeight(historyRecord.row, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setHeader') {
                        obj.setHeader(historyRecord.column, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setComments') {
                        obj.setComments(historyRecord.column, historyRecord.oldValue[0], historyRecord.oldValue[1]);
                    } else if (historyRecord.action == 'orderBy') {
                        var rows = [];
                        for (var j = 0; j < historyRecord.rows.length; j++) {
                            rows[historyRecord.rows[j]] = j;
                        }
                        obj.updateOrderArrow(historyRecord.column, historyRecord.order ? 0 : 1);
                        obj.updateOrder(rows);
                    } else if (historyRecord.action == 'setValue') {
                        // Redo for changes in cells
                        for (var i = 0; i < historyRecord.records.length; i++) {
                            records.push({
                                x: historyRecord.records[i].x,
                                y: historyRecord.records[i].y,
                                newValue: historyRecord.records[i].oldValue,
                            });

                            if (historyRecord.oldStyle) {
                                obj.resetStyle(historyRecord.oldStyle);
                            }
                        }
                        // Update records
                        obj.setValue(records);

                        // Update selection
                        if (historyRecord.selection) {
                            obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
                        }
                    }
                }
                obj.ignoreEvents = ignoreEvents;
                obj.ignoreHistory = ignoreHistory;
        
                // Events
                obj.dispatch('onundo', el, historyRecord);
            };
        
            /**
             * Redo previously undone action
             */
            obj.redo = function() {
                // Ignore events and history
                var ignoreEvents = obj.ignoreEvents ? true : false;
                var ignoreHistory = obj.ignoreHistory ? true : false;
        
                obj.ignoreEvents = true;
                obj.ignoreHistory = true;
        
                // Update cells
                if (obj.historyIndex < obj.history.length - 1) {
                    // History
                    var historyRecord = obj.history[++obj.historyIndex];
        
                    if (historyRecord.action == 'insertRow') {
                        obj.historyProcessRow(0, historyRecord);
                    } else if (historyRecord.action == 'deleteRow') {
                        obj.historyProcessRow(1, historyRecord);
                    } else if (historyRecord.action == 'insertColumn') {
                        obj.historyProcessColumn(0, historyRecord);
                    } else if (historyRecord.action == 'deleteColumn') {
                        obj.historyProcessColumn(1, historyRecord);
                    } else if (historyRecord.action == 'moveRow') {
                        obj.moveRow(historyRecord.oldValue, historyRecord.newValue);
                    } else if (historyRecord.action == 'moveColumn') {
                        obj.moveColumn(historyRecord.oldValue, historyRecord.newValue);
                    } else if (historyRecord.action == 'setMerge') {
                        obj.setMerge(historyRecord.column, historyRecord.colspan, historyRecord.rowspan, 1);
                    } else if (historyRecord.action == 'setStyle') {
                        obj.setStyle(historyRecord.newValue, null, null, 1);
                    } else if (historyRecord.action == 'setWidth') {
                        obj.setWidth(historyRecord.column, historyRecord.newValue);
                    } else if (historyRecord.action == 'setHeight') {
                        obj.setHeight(historyRecord.row, historyRecord.newValue);
                    } else if (historyRecord.action == 'setHeader') {
                        obj.setHeader(historyRecord.column, historyRecord.newValue);
                    } else if (historyRecord.action == 'setComments') {
                        obj.setComments(historyRecord.column, historyRecord.newValue[0], historyRecord.newValue[1]);
                    } else if (historyRecord.action == 'orderBy') {
                        obj.updateOrderArrow(historyRecord.column, historyRecord.order);
                        obj.updateOrder(historyRecord.rows);
                    } else if (historyRecord.action == 'setValue') {
                        obj.setValue(historyRecord.records);
                        // Redo for changes in cells
                        for (var i = 0; i < historyRecord.records.length; i++) {
                            if (historyRecord.oldStyle) {
                                obj.resetStyle(historyRecord.newStyle);
                            }
                        }
                        // Update selection
                        if (historyRecord.selection) {
                            obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
                        }
                    }
                }
                obj.ignoreEvents = ignoreEvents;
                obj.ignoreHistory = ignoreHistory;
        
                // Events
                obj.dispatch('onredo', el, historyRecord);
            };
        
            /**
             * Get dropdown value from key
             */
            obj.getDropDownValue = function(column, key) {
                var value = [];
        
                if (obj.options.columns[column] && obj.options.columns[column].source) {
                    // Create array from source
                    var combo = [];
                    var source = obj.options.columns[column].source;
        
                    for (var i = 0; i < source.length; i++) {
                        if (typeof(source[i]) == 'object') {
                            combo[source[i].id] = source[i].name;
                        } else {
                            combo[source[i]] = source[i];
                        }
                    }
        
                    // Guarantee single multiple compatibility
                    var keys = Array.isArray(key) ? key : ('' + key).split(';');
        
                    for (var i = 0; i < keys.length; i++) {
                        if (typeof(keys[i]) === 'object') {
                            value.push(combo[keys[i].id]);
                        } else {
                            if (combo[keys[i]]) {
                                value.push(combo[keys[i]]);
                            }
                        }
                    }
                } else {
                    console.error('Invalid column');
                }
        
                return (value.length > 0) ? value.join('; ') : '';
            };
        
            /**
             * From starckoverflow contributions
             */
            obj.parseCSV = function(str, delimiter) {
                // Remove last line break
                str = str.replace(/\r?\n$|\r$|\n$/g, "");
                // Last caracter is the delimiter
                if (str.charCodeAt(str.length-1) == 9) {
                    str += "\0";
                }
                // user-supplied delimeter or default comma
                delimiter = (delimiter || ",");
        
                var arr = [];
                var quote = false;  // true means we're inside a quoted field
                // iterate over each character, keep track of current row and column (of the returned array)
                for (var row = 0, col = 0, c = 0; c < str.length; c++) {
                    var cc = str[c], nc = str[c+1];
                    arr[row] = arr[row] || [];
                    arr[row][col] = arr[row][col] || '';
        
                    // If the current character is a quotation mark, and we're inside a quoted field, and the next character is also a quotation mark, add a quotation mark to the current column and skip the next character
                    if (cc == '"' && quote && nc == '"') { arr[row][col] += cc; ++c; continue; }  
        
                    // If it's just one quotation mark, begin/end quoted field
                    if (cc == '"') { quote = !quote; continue; }
        
                    // If it's a comma and we're not in a quoted field, move on to the next column
                    if (cc == delimiter && !quote) { ++col; continue; }
        
                    // If it's a newline (CRLF) and we're not in a quoted field, skip the next character and move on to the next row and move to column 0 of that new row
                    if (cc == '\r' && nc == '\n' && !quote) { ++row; col = 0; ++c; continue; }
        
                    // If it's a newline (LF or CR) and we're not in a quoted field, move on to the next row and move to column 0 of that new row
                    if (cc == '\n' && !quote) { ++row; col = 0; continue; }
                    if (cc == '\r' && !quote) { ++row; col = 0; continue; }
        
                    // Otherwise, append the current character to the current column
                    arr[row][col] += cc;
                }
                return arr;
            };
        
            obj.hash = function(str) {
                var hash = 0, i, chr;
        
                if (str.length === 0) {
                    return hash;
                } else {
                    for (i = 0; i < str.length; i++) {
                      chr = str.charCodeAt(i);
                      hash = ((hash << 5) - hash) + chr;
                      hash |= 0;
                    }
                }
                return hash;
            };
        
            obj.onafterchanges = function(el, records) {
                // Events
                obj.dispatch('onafterchanges', el, records);
            };
        
            obj.destroy = function() {
                jexcel.destroy(el);
            };

            /**
             * Initialization method
             */
            obj.init = function() {
                jexcel.current = obj;
        
                // Build handlers
                if (typeof(jexcel.build) == 'function') {
                    if (obj.options.root) {
                        jexcel.build(obj.options.root);
                    } else {
                        jexcel.build(document);
                        jexcel.build = null;
                    }
                }
        
                // Event
                el.setAttribute('tabindex', 1);
                el.addEventListener('focus', function(e) {
                    if (jexcel.current && ! obj.selectedCell) {
                        obj.updateSelectionFromCoords(0,0,0,0);
                        obj.left();
                    }
                });

                // Load the table data based on an CSV file
                if (obj.options.csv) {
                    // Loading
                    if (obj.options.loadingSpin == true) {
                        jSuites.loading.show();
                    }
        
                    // Load CSV file
                    jSuites.ajax({
                        url: obj.options.csv,
                        method: obj.options.method,
                        data: obj.options.requestVariables,
                        dataType: 'text',
                        success: function(result) {
                            // Convert data
                            var newData = obj.parseCSV(result, obj.options.csvDelimiter);
        
                            // Headers
                            if (obj.options.csvHeaders == true && newData.length > 0) {
                                var headers = newData.shift();
                                for(var i = 0; i < headers.length; i++) {
                                    if (! obj.options.columns[i]) {
                                        obj.options.columns[i] = { type:'text', align:obj.options.defaultColAlign, width:obj.options.defaultColWidth };
                                    }
                                    // Precedence over pre-configurated titles
                                    if (typeof obj.options.columns[i].title === 'undefined') {
                                      obj.options.columns[i].title = headers[i];
                                    }
                                }
                            }
                            // Data
                            obj.options.data = newData;
                            // Prepare table
                            obj.prepareTable();
                            // Hide spin
                            if (obj.options.loadingSpin == true) {
                                jSuites.loading.hide();
                            }
                        }
                    });
                } else if (obj.options.url) {
                    // Loading
                    if (obj.options.loadingSpin == true) {
                        jSuites.loading.show();
                    }
        
                    jSuites.ajax({
                        url: obj.options.url,
                        method: obj.options.method,
                        data: obj.options.requestVariables,
                        dataType: 'json',
                        success: function(result) {
                            // Data
                            obj.options.data = (result.data) ? result.data : result;
                            // Prepare table
                            obj.prepareTable();
                            // Hide spin
                            if (obj.options.loadingSpin == true) {
                                jSuites.loading.hide();
                            }
                        }
                    });
                } else {
                    // Prepare table
                    obj.prepareTable();
                }
            };
        
            // Context menu
            if (options && options.contextMenu != null) {
                obj.options.contextMenu = options.contextMenu;
            } else {
                obj.options.contextMenu = function(el, x, y, e) {
                    var items = [];
        
                    if (y == null) {
                        // Insert a new column
                        if (obj.options.allowInsertColumn == true) {
                            items.push({
                                title:obj.options.text.insertANewColumnBefore,
                                onclick:function() {
                                    obj.insertColumn(1, parseInt(x), 1);
                                }
                            });
                        }
        
                        if (obj.options.allowInsertColumn == true) {
                            items.push({
                                title:obj.options.text.insertANewColumnAfter,
                                onclick:function() {
                                    obj.insertColumn(1, parseInt(x), 0);
                                }
                            });
                        }
        
                        // Delete a column
                        if (obj.options.allowDeleteColumn == true) {
                            items.push({
                                title:obj.options.text.deleteSelectedColumns,
                                onclick:function() {
                                    obj.deleteColumn(obj.getSelectedColumns().length ? undefined : parseInt(x));
                                }
                            });
                        }
        
                        // Rename column
                        if (obj.options.allowRenameColumn == true) {
                            items.push({
                                title:obj.options.text.renameThisColumn,
                                onclick:function() {
                                    obj.setHeader(x);
                                }
                            });
                        }
        
                        // Sorting
                        if (obj.options.columnSorting == true) {
                            // Line
                            items.push({ type:'line' });
        
                            items.push({
                                title:obj.options.text.orderAscending,
                                onclick:function() {
                                    obj.orderBy(x, 0);
                                }
                            });
                            items.push({
                                title:obj.options.text.orderDescending,
                                onclick:function() {
                                    obj.orderBy(x, 1);
                                }
                            });
                        }
                    } else {
                        // Insert new row
                        if (obj.options.allowInsertRow == true) {
                            items.push({
                                title:obj.options.text.insertANewRowBefore,
                                onclick:function() {
                                    obj.insertRow(1, parseInt(y), 1);
                                }
                            });
        
                            items.push({
                                title:obj.options.text.insertANewRowAfter,
                                onclick:function() {
                                    obj.insertRow(1, parseInt(y));
                                }
                            });
                        }
        
                        if (obj.options.allowDeleteRow == true) {
                            items.push({
                                title:obj.options.text.deleteSelectedRows,
                                onclick:function() {
                                    obj.deleteRow(obj.getSelectedRows().length ? undefined : parseInt(y));
                                }
                            });
                        }
        
                        if (x) {
                            if (obj.options.allowComments == true) {
                                items.push({ type:'line' });
        
                                var title = obj.records[y][x].getAttribute('title') || '';

                                items.push({
                                    title: title ? obj.options.text.editComments : obj.options.text.addComments,
                                    onclick:function() {
                                        var comment = prompt(obj.options.text.comments, title);
                                        if (comment) {
                                            obj.setComments([ x, y ], comment);
                                        }
                                    }
                                });
        
                                if (title) {
                                    items.push({
                                        title:obj.options.text.clearComments,
                                        onclick:function() {
                                            obj.setComments([ x, y ], '');
                                        }
                                    });
                                }
                            }
                        }
                    }
        
                    // Line
                    items.push({ type:'line' });
        
                    // Copy
                    items.push({
                        title:obj.options.text.copy,
                        shortcut:'Ctrl + C',
                        onclick:function() {
                            obj.copy(true);
                        }
                    });
        
                    // Paste
                    if (navigator && navigator.clipboard) {
                        items.push({
                            title:obj.options.text.paste,
                            shortcut:'Ctrl + V',
                            onclick:function() {
                                if (obj.selectedCell) {
                                    navigator.clipboard.readText().then(function(text) {
                                        if (text) {
                                            jexcel.current.paste(obj.selectedCell[0], obj.selectedCell[1], text);
                                        }
                                    });
                                }
                            }
                        });
                    }
        
                    // Save
                    if (obj.options.allowExport) {
                        items.push({
                            title: obj.options.text.saveAs,
                            shortcut: 'Ctrl + S',
                            onclick: function () {
                                obj.download();
                            }
                        });
                    }
        
                    // About
                    if (obj.options.about) {
                        items.push({
                            title:obj.options.text.about,
                            onclick:function() {
                                if (obj.options.about === true) {
                                    alert(Version().print());
                                } else {
                                    alert(obj.options.about);
                                }
                            }
                        });
                    }
        
                    return items;
                };
            }
        
            obj.scrollControls = function(e) {
                obj.wheelControls();

                if (obj.options.freezeColumns > 0 && obj.content.scrollLeft != scrollLeft) {
                    obj.updateFreezePosition();
                }

                // Close editor
                if (obj.options.lazyLoading == true || obj.options.tableOverflow == true) {
                    if (obj.edition && e.target.className.substr(0,9) != 'jdropdown') {
                        obj.closeEditor(obj.edition[0], true);
                    }
                }
            };

            obj.wheelControls = function(e) {
                if (obj.options.lazyLoading == true) {
                    if (jexcel.timeControlLoading == null) {
                        jexcel.timeControlLoading = setTimeout(function() {
                            if (obj.content.scrollTop + obj.content.clientHeight >= obj.content.scrollHeight - 10) {
                                if (obj.loadDown()) {
                                    if (obj.content.scrollTop + obj.content.clientHeight > obj.content.scrollHeight - 10) {
                                        obj.content.scrollTop = obj.content.scrollTop - obj.content.clientHeight;
                                    }
                                    obj.updateCornerPosition();
                                }
                            } else if (obj.content.scrollTop <= obj.content.clientHeight) {
                                if (obj.loadUp()) {
                                    if (obj.content.scrollTop < 10) {
                                        obj.content.scrollTop = obj.content.scrollTop + obj.content.clientHeight;
                                    }
                                    obj.updateCornerPosition();
                                }
                            }
        
                            jexcel.timeControlLoading = null;
                        }, 100);
                    }
                }
            };

            // Get width of all freezed cells together
            obj.getFreezeWidth = function() {
                var width = 0;
                if (obj.options.freezeColumns > 0) {
                    for (var i = 0; i < obj.options.freezeColumns; i++) {
                        width += parseInt(obj.options.columns[i].width);
                    }
                }
                return width;
            };

            var scrollLeft = 0;

            obj.updateFreezePosition = function() {
                scrollLeft = obj.content.scrollLeft;
                var width = 0;
                if (scrollLeft > 50) {
                    for (var i = 0; i < obj.options.freezeColumns; i++) {
                        if (i > 0) {
                            width += parseInt(obj.options.columns[i-1].width);
                        }
                        obj.headers[i].classList.add('jexcel_freezed');
                        obj.headers[i].style.left = width + 'px';
                        for (var j = 0; j < obj.rows.length; j++) {
                            if (obj.rows[j] && obj.records[j][i]) {
                                var shifted = (scrollLeft + (i > 0 ? obj.records[j][i-1].style.width : 0)) - 51 + 'px';
                                obj.records[j][i].classList.add('jexcel_freezed');
                                obj.records[j][i].style.left = shifted;
                            }
                        }
                    }
                } else {
                    for (var i = 0; i < obj.options.freezeColumns; i++) {
                        obj.headers[i].classList.remove('jexcel_freezed');
                        obj.headers[i].style.left = '';
                        for (var j = 0; j < obj.rows.length; j++) {
                            if (obj.records[j][i]) {
                                obj.records[j][i].classList.remove('jexcel_freezed');
                                obj.records[j][i].style.left = '';
                            }
                        }
                    }
                }

                // Place the corner in the correct place
                obj.updateCornerPosition();
            };

            el.addEventListener("DOMMouseScroll", obj.wheelControls);
            el.addEventListener("mousewheel", obj.wheelControls);
        
            el.jexcel = obj;
            el.jspreadsheet = obj;
        
            obj.init();
        
            return obj;
        });
        
        jexcel.version = Version;

        jexcel.current = null;
        jexcel.timeControl = null;
        jexcel.timeControlLoading = null;
        
        jexcel.destroy = function(element, destroyEventHandlers) {
            if (element.jexcel) {
                var root = element.jexcel.options.root ? element.jexcel.options.root : document;
                element.removeEventListener("DOMMouseScroll", element.jexcel.scrollControls);
                element.removeEventListener("mousewheel", element.jexcel.scrollControls);
                element.jexcel = null;
                element.innerHTML = '';
        
                if (destroyEventHandlers) {
                    root.removeEventListener("mouseup", jexcel.mouseUpControls);
                    root.removeEventListener("mousedown", jexcel.mouseDownControls);
                    root.removeEventListener("mousemove", jexcel.mouseMoveControls);
                    root.removeEventListener("mouseover", jexcel.mouseOverControls);
                    root.removeEventListener("dblclick", jexcel.doubleClickControls);
                    root.removeEventListener("paste", jexcel.pasteControls);
                    root.removeEventListener("contextmenu", jexcel.contextMenuControls);
                    root.removeEventListener("touchstart", jexcel.touchStartControls);
                    root.removeEventListener("touchend", jexcel.touchEndControls);
                    root.removeEventListener("touchcancel", jexcel.touchEndControls);
                    document.removeEventListener("keydown", jexcel.keyDownControls);
                    jexcel = null;
                }
            }
        };
        
        jexcel.build = function(root) {
            root.addEventListener("mouseup", jexcel.mouseUpControls);
            root.addEventListener("mousedown", jexcel.mouseDownControls);
            root.addEventListener("mousemove", jexcel.mouseMoveControls);
            root.addEventListener("mouseover", jexcel.mouseOverControls);
            root.addEventListener("dblclick", jexcel.doubleClickControls);
            root.addEventListener("paste", jexcel.pasteControls);
            root.addEventListener("contextmenu", jexcel.contextMenuControls);
            root.addEventListener("touchstart", jexcel.touchStartControls);
            root.addEventListener("touchend", jexcel.touchEndControls);
            root.addEventListener("touchcancel", jexcel.touchEndControls);
            root.addEventListener("touchmove", jexcel.touchEndControls);
            document.addEventListener("keydown", jexcel.keyDownControls);
        };
        
        /**
         * Events
         */
        jexcel.keyDownControls = function(e) {
            if (jexcel.current) {
                if (jexcel.current.edition) {
                    if (e.which == 27) {
                        // Escape
                        if (jexcel.current.edition) {
                            // Exit without saving
                            jexcel.current.closeEditor(jexcel.current.edition[0], false);
                        }
                        e.preventDefault();
                    } else if (e.which == 13) {
                        // Enter
                        if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'calendar') {
                            jexcel.current.closeEditor(jexcel.current.edition[0], true);
                        } else if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'dropdown' ||
                                   jexcel.current.options.columns[jexcel.current.edition[2]].type == 'autocomplete') ; else {
                            // Alt enter -> do not close editor
                            if ((jexcel.current.options.wordWrap == true ||
                                 jexcel.current.options.columns[jexcel.current.edition[2]].wordWrap == true ||
                                 jexcel.current.options.data[jexcel.current.edition[3]][jexcel.current.edition[2]].length > 200) && e.altKey) {
                                // Add new line to the editor
                                var editorTextarea = jexcel.current.edition[0].children[0];
                                var editorValue = jexcel.current.edition[0].children[0].value;
                                var editorIndexOf = editorTextarea.selectionStart;
                                editorValue = editorValue.slice(0, editorIndexOf) + "\n" + editorValue.slice(editorIndexOf);
                                editorTextarea.value = editorValue;
                                editorTextarea.focus();
                                editorTextarea.selectionStart = editorIndexOf + 1;
                                editorTextarea.selectionEnd = editorIndexOf + 1;
                            } else {
                                jexcel.current.edition[0].children[0].blur();
                            }
                        }
                    } else if (e.which == 9) {
                        // Tab
                        if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'calendar') {
                            jexcel.current.closeEditor(jexcel.current.edition[0], true);
                        } else {
                            jexcel.current.edition[0].children[0].blur();
                        }
                    }
                }
        
                if (! jexcel.current.edition && jexcel.current.selectedCell) {
                    // Which key
                    if (e.which == 37) {
                        jexcel.current.left(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 39) {
                        jexcel.current.right(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 38) {
                        jexcel.current.up(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 40) {
                        jexcel.current.down(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 36) {
                        jexcel.current.first(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 35) {
                        jexcel.current.last(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 32) {
                        if (jexcel.current.options.editable == true) {
                            jexcel.current.setCheckRadioValue();
                        }
                        e.preventDefault();
                    } else if (e.which == 46) {
                        // Delete
                        if (jexcel.current.options.editable == true) {
                            if (jexcel.current.selectedRow) {
                                if (jexcel.current.options.allowDeleteRow == true) {
                                    if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedRows)) {
                                        jexcel.current.deleteRow();
                                    }
                                }
                            } else if (jexcel.current.selectedHeader) {
                                if (jexcel.current.options.allowDeleteColumn == true) {
                                    if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedColumns)) {
                                        jexcel.current.deleteColumn();
                                    }
                                }
                            } else {
                                // Change value
                                jexcel.current.setValue(jexcel.current.highlighted, '');
                            }
                        }
                    } else if (e.which == 13) {
                        // Move cursor
                        if (e.shiftKey) {
                            jexcel.current.up();
                        } else {
                            if (jexcel.current.options.allowInsertRow == true) {
                                if (jexcel.current.options.allowManualInsertRow == true) {
                                    if (jexcel.current.selectedCell[1] == jexcel.current.options.data.length - 1) {
                                        // New record in case selectedCell in the last row
                                        jexcel.current.insertRow();
                                    }
                                }
                            }
        
                            jexcel.current.down();
                        }
                        e.preventDefault();
                    } else if (e.which == 9) {
                        // Tab
                        if (e.shiftKey) {
                            jexcel.current.left();
                        } else {
                            if (jexcel.current.options.allowInsertColumn == true) {
                                if (jexcel.current.options.allowManualInsertColumn == true) {
                                    if (jexcel.current.selectedCell[0] == jexcel.current.options.data[0].length - 1) {
                                        // New record in case selectedCell in the last column
                                        jexcel.current.insertColumn();
                                    }
                                }
                            }
        
                            jexcel.current.right();
                        }
                        e.preventDefault();
                    } else {
                        if ((e.ctrlKey || e.metaKey) && ! e.shiftKey) {
                            if (e.which == 65) {
                                // Ctrl + A
                                jexcel.current.selectAll();
                                e.preventDefault();
                            } else if (e.which == 83) {
                                // Ctrl + S
                                jexcel.current.download();
                                e.preventDefault();
                            } else if (e.which == 89) {
                                // Ctrl + Y
                                jexcel.current.redo();
                                e.preventDefault();
                            } else if (e.which == 90) {
                                // Ctrl + Z
                                jexcel.current.undo();
                                e.preventDefault();
                            } else if (e.which == 67) {
                                // Ctrl + C
                                jexcel.current.copy(true);
                                e.preventDefault();
                                   } else if (e.which == 88) {
                                // Ctrl + X
                                if (jexcel.current.options.editable == true) {
                                    jexcel.cutControls();
                                } else {
                                    jexcel.copyControls();
                                }
                                e.preventDefault();
                            } else if (e.which == 86) {
                                // Ctrl + V
                                jexcel.pasteControls();
                            }
                        } else {
                            if (jexcel.current.selectedCell) {
                                if (jexcel.current.options.editable == true) {
                                    var rowId = jexcel.current.selectedCell[1];
                                    var columnId = jexcel.current.selectedCell[0];
        
                                    // If is not readonly
                                    if (jexcel.current.options.columns[columnId].type != 'readonly') {
                                        // Characters able to start a edition
                                        if (e.keyCode == 32) {
                                            // Space
                                            if (jexcel.current.options.columns[columnId].type == 'checkbox' ||
                                                jexcel.current.options.columns[columnId].type == 'radio') {
                                                e.preventDefault();
                                            } else {
                                                // Start edition
                                                jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                                            }
                                        } else if (e.keyCode == 113) {
                                            // Start edition with current content F2
                                            jexcel.current.openEditor(jexcel.current.records[rowId][columnId], false);
                                        } else if ((e.keyCode == 8) ||
                                                   (e.keyCode >= 48 && e.keyCode <= 57) ||
                                                   (e.keyCode >= 96 && e.keyCode <= 111) ||
                                                   (e.keyCode >= 187 && e.keyCode <= 190) ||
                                                   ((String.fromCharCode(e.keyCode) == e.key || String.fromCharCode(e.keyCode).toLowerCase() == e.key.toLowerCase()) && jexcel.validLetter(String.fromCharCode(e.keyCode)))) {
                                            // Start edition
                                            jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                                            // Prevent entries in the calendar
                                            if (jexcel.current.options.columns[columnId].type == 'calendar') {
                                                e.preventDefault();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (e.target.classList.contains('jexcel_search')) {
                        if (jexcel.timeControl) {
                            clearTimeout(jexcel.timeControl);
                        }
        
                        jexcel.timeControl = setTimeout(function() {
                            jexcel.current.search(e.target.value);
                        }, 200);
                    }
                }
            }
        };
        
        jexcel.isMouseAction = false;
        
        jexcel.mouseDownControls = function(e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }

            // Get elements
            var jexcelTable = jexcel.getElement(e.target);

            if (jexcelTable[0]) {
                if (jexcel.current != jexcelTable[0].jexcel) {
                    if (jexcel.current) {
                        if (jexcel.current.edition) {
                            jexcel.current.closeEditor(jexcel.current.edition[0], true);
                        }
                        jexcel.current.resetSelection();
                    }
                    jexcel.current = jexcelTable[0].jexcel;
                }
            } else {
                if (jexcel.current) {
                    if (jexcel.current.edition) {
                        jexcel.current.closeEditor(jexcel.current.edition[0], true);
                    }
                    
                    jexcel.current.resetSelection(true);
                    jexcel.current = null;
                }
            }
        
            if (jexcel.current && mouseButton == 1) {
                if (e.target.classList.contains('jexcel_selectall')) {
                    if (jexcel.current) {
                        jexcel.current.selectAll();
                    }
                } else if (e.target.classList.contains('jexcel_corner')) {
                    if (jexcel.current.options.editable == true) {
                        jexcel.current.selectedCorner = true;
                    }
                } else {
                    // Header found
                    if (jexcelTable[1] == 1) {
                        var columnId = e.target.getAttribute('data-x');
                        if (columnId) {
                            // Update cursor
                            var info = e.target.getBoundingClientRect();
                            if (jexcel.current.options.columnResize == true && info.width - e.offsetX < 6) {
                                // Resize helper
                                jexcel.current.resizing = {
                                    mousePosition: e.pageX,
                                    column: columnId,
                                    width: info.width,
                                };
        
                                // Border indication
                                jexcel.current.headers[columnId].classList.add('resizing');
                                for (var j = 0; j < jexcel.current.records.length; j++) {
                                    if (jexcel.current.records[j][columnId]) {
                                        jexcel.current.records[j][columnId].classList.add('resizing');
                                    }
                                }
                            } else if (jexcel.current.options.columnDrag == true && info.height - e.offsetY < 6) {
                                if (jexcel.current.isColMerged(columnId).length) {
                                    console.error('Jspreadsheet: This column is part of a merged cell.');
                                } else {
                                    // Reset selection
                                    jexcel.current.resetSelection();
                                    // Drag helper
                                    jexcel.current.dragging = {
                                        element: e.target,
                                        column:columnId,
                                        destination:columnId,
                                    };
                                    // Border indication
                                    jexcel.current.headers[columnId].classList.add('dragging');
                                    for (var j = 0; j < jexcel.current.records.length; j++) {
                                        if (jexcel.current.records[j][columnId]) {
                                            jexcel.current.records[j][columnId].classList.add('dragging');
                                        }
                                    }
                                }
                            } else {
                                if (jexcel.current.selectedHeader && (e.shiftKey || e.ctrlKey)) {
                                    var o = jexcel.current.selectedHeader;
                                    var d = columnId;
                                } else {
                                    // Press to rename
                                    if (jexcel.current.selectedHeader == columnId && jexcel.current.options.allowRenameColumn == true) {
                                        jexcel.timeControl = setTimeout(function() {
                                            jexcel.current.setHeader(columnId);
                                        }, 800);
                                    }
        
                                    // Keep track of which header was selected first
                                    jexcel.current.selectedHeader = columnId;
        
                                    // Update selection single column
                                    var o = columnId;
                                    var d = columnId;
                                }
        
                                // Update selection
                                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
                            }
                        } else {
                            if (e.target.parentNode.classList.contains('jexcel_nested')) {
                                if (e.target.getAttribute('data-column')) {
                                    var column = e.target.getAttribute('data-column').split(',');
                                    var c1 = parseInt(column[0]);
                                    var c2 = parseInt(column[column.length-1]);
                                } else {
                                    var c1 = 0;
                                    var c2 = jexcel.current.options.columns.length - 1;
                                }
                                jexcel.current.updateSelectionFromCoords(c1, 0, c2, jexcel.current.options.data.length - 1);
                            }
                        }
                    } else {
                        jexcel.current.selectedHeader = false;
                    }
        
                    // Body found
                    if (jexcelTable[1] == 2) {
                        var rowId = e.target.getAttribute('data-y');
                        
                        if (e.target.classList.contains('jexcel_row')) {
                            var info = e.target.getBoundingClientRect();
                            if (jexcel.current.options.rowResize == true && info.height - e.offsetY < 6) {
                                // Resize helper
                                jexcel.current.resizing = {
                                    element: e.target.parentNode,
                                    mousePosition: e.pageY,
                                    row: rowId,
                                    height: info.height,
                                };
                                // Border indication
                                e.target.parentNode.classList.add('resizing');
                            } else if (jexcel.current.options.rowDrag == true && info.width - e.offsetX < 6) {
                                if (jexcel.current.isRowMerged(rowId).length) {
                                    console.error('Jspreadsheet: This row is part of a merged cell');
                                } else if (jexcel.current.options.search == true && jexcel.current.results) {
                                    console.error('Jspreadsheet: Please clear your search before perform this action');
                                } else {
                                    // Reset selection
                                    jexcel.current.resetSelection();
                                    // Drag helper
                                    jexcel.current.dragging = {
                                        element: e.target.parentNode,
                                        row:rowId,
                                        destination:rowId,
                                    };
                                    // Border indication
                                    e.target.parentNode.classList.add('dragging');
                                }
                            } else {
                                if (jexcel.current.selectedRow && (e.shiftKey || e.ctrlKey)) {
                                    var o = jexcel.current.selectedRow;
                                    var d = rowId;
                                } else {
                                    // Keep track of which header was selected first
                                    jexcel.current.selectedRow = rowId;
        
                                    // Update selection single column
                                    var o = rowId;
                                    var d = rowId;
                                }
        
                                // Update selection
                                jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
                            }
                        } else {
                            // Jclose
                            if (e.target.classList.contains('jclose') && e.target.clientWidth - e.offsetX < 50 && e.offsetY < 50) {
                                jexcel.current.closeEditor(jexcel.current.edition[0], true);
                            } else {
                                var getCellCoords = function(element) {
                                    var x = element.getAttribute('data-x');
                                    var y = element.getAttribute('data-y');
                                    if (x && y) {
                                        return [x, y];
                                    } else {
                                        if (element.parentNode) {
                                            return getCellCoords(element.parentNode);
                                        }
                                    }
                                };

                                var position = getCellCoords(e.target);
                                if (position) {

                                    var columnId = position[0];
                                    var rowId = position[1];
                                    // Close edition
                                    if (jexcel.current.edition) {
                                        if (jexcel.current.edition[2] != columnId || jexcel.current.edition[3] != rowId) {
                                            jexcel.current.closeEditor(jexcel.current.edition[0], true);
                                        }
                                    }

                                    if (! jexcel.current.edition) {
                                        // Update cell selection
                                        if (e.shiftKey) {
                                            jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                                        } else {
                                            jexcel.current.updateSelectionFromCoords(columnId, rowId);
                                        }
                                    }

                                    // No full row selected
                                    jexcel.current.selectedHeader = null;
                                    jexcel.current.selectedRow = null;
                                }
                            }
                        }
                    } else {
                        jexcel.current.selectedRow = false;
                    }
        
                    // Pagination
                    if (e.target.classList.contains('jexcel_page')) {
                        if (e.target.innerText == '<') {
                            jexcel.current.page(0);
                        } else if (e.target.innerText == '>') {
                            jexcel.current.page(e.target.getAttribute('title') - 1);
                        } else {
                            jexcel.current.page(e.target.innerText - 1);
                        }
                    }
                }
        
                if (jexcel.current.edition) {
                    jexcel.isMouseAction = false;
                } else {
                    jexcel.isMouseAction = true;
                }
            } else {
                jexcel.isMouseAction = false;
            }
        };
        
        jexcel.mouseUpControls = function(e) {
            if (jexcel.current) {
                // Update cell size
                if (jexcel.current.resizing) {
                    // Columns to be updated
                    if (jexcel.current.resizing.column) {
                        // New width
                        var newWidth = jexcel.current.colgroup[jexcel.current.resizing.column].getAttribute('width');
                        // Columns
                        var columns = jexcel.current.getSelectedColumns();
                        if (columns.length > 1) {
                            var currentWidth = [];
                            for (var i = 0; i < columns.length; i++) {
                                currentWidth.push(parseInt(jexcel.current.colgroup[columns[i]].getAttribute('width')));
                            }
                            // Previous width
                            var index = columns.indexOf(parseInt(jexcel.current.resizing.column));
                            currentWidth[index] = jexcel.current.resizing.width;
                            jexcel.current.setWidth(columns, newWidth, currentWidth);
                        } else {
                            jexcel.current.setWidth(jexcel.current.resizing.column, newWidth, jexcel.current.resizing.width);
                        }
                        // Remove border
                        jexcel.current.headers[jexcel.current.resizing.column].classList.remove('resizing');
                        for (var j = 0; j < jexcel.current.records.length; j++) {
                            if (jexcel.current.records[j][jexcel.current.resizing.column]) {
                                jexcel.current.records[j][jexcel.current.resizing.column].classList.remove('resizing');
                            }
                        }
                    } else {
                        // Remove Class
                        jexcel.current.rows[jexcel.current.resizing.row].children[0].classList.remove('resizing');
                        var newHeight = jexcel.current.rows[jexcel.current.resizing.row].getAttribute('height');
                        jexcel.current.setHeight(jexcel.current.resizing.row, newHeight, jexcel.current.resizing.height);
                        // Remove border
                        jexcel.current.resizing.element.classList.remove('resizing');
                    }
                    // Reset resizing helper
                    jexcel.current.resizing = null;
                } else if (jexcel.current.dragging) {
                    // Reset dragging helper
                    if (jexcel.current.dragging) {
                        if (jexcel.current.dragging.column) {
                            // Target
                            var columnId = e.target.getAttribute('data-x');
                            // Remove move style
                            jexcel.current.headers[jexcel.current.dragging.column].classList.remove('dragging');
                            for (var j = 0; j < jexcel.current.rows.length; j++) {
                                if (jexcel.current.records[j][jexcel.current.dragging.column]) {
                                    jexcel.current.records[j][jexcel.current.dragging.column].classList.remove('dragging');
                                }
                            }
                            for (var i = 0; i < jexcel.current.headers.length; i++) {
                                jexcel.current.headers[i].classList.remove('dragging-left');
                                jexcel.current.headers[i].classList.remove('dragging-right');
                            }
                            // Update position
                            if (columnId) {
                                if (jexcel.current.dragging.column != jexcel.current.dragging.destination) {
                                    jexcel.current.moveColumn(jexcel.current.dragging.column, jexcel.current.dragging.destination);
                                }
                            }
                        } else {
                            if (jexcel.current.dragging.element.nextSibling) {
                                var position = parseInt(jexcel.current.dragging.element.nextSibling.getAttribute('data-y'));
                                if (jexcel.current.dragging.row < position) {
                                    position -= 1;
                                }
                            } else {
                                var position = parseInt(jexcel.current.dragging.element.previousSibling.getAttribute('data-y'));
                            }
                            if (jexcel.current.dragging.row != jexcel.current.dragging.destination) {
                                jexcel.current.moveRow(jexcel.current.dragging.row, position, true);
                            }
                            jexcel.current.dragging.element.classList.remove('dragging');
                        }
                        jexcel.current.dragging = null;
                    }
                } else {
                    // Close any corner selection
                    if (jexcel.current.selectedCorner) {
                        jexcel.current.selectedCorner = false;
        
                        // Data to be copied
                        if (jexcel.current.selection.length > 0) {
                            // Copy data
                            jexcel.current.copyData(jexcel.current.selection[0], jexcel.current.selection[jexcel.current.selection.length - 1]);
        
                            // Remove selection
                            jexcel.current.removeCopySelection();
                        }
                    }
                }
            }

            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
            }
        
            // Mouse up
            jexcel.isMouseAction = false;
        };
        
        // Mouse move controls
        jexcel.mouseMoveControls = function(e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }
        
            if (! mouseButton) {
                jexcel.isMouseAction = false;
            }
        
            if (jexcel.current) {
                if (jexcel.isMouseAction == true) {
                    // Resizing is ongoing
                    if (jexcel.current.resizing) {
                        if (jexcel.current.resizing.column) {
                            var width = e.pageX - jexcel.current.resizing.mousePosition;
        
                            if (jexcel.current.resizing.width + width > 0) {
                                var tempWidth = jexcel.current.resizing.width + width;
                                jexcel.current.colgroup[jexcel.current.resizing.column].setAttribute('width', tempWidth);
        
                                jexcel.current.updateCornerPosition();
                            }
                        } else {
                            var height = e.pageY - jexcel.current.resizing.mousePosition;
        
                            if (jexcel.current.resizing.height + height > 0) {
                                var tempHeight = jexcel.current.resizing.height + height;
                                jexcel.current.rows[jexcel.current.resizing.row].setAttribute('height', tempHeight);
        
                                jexcel.current.updateCornerPosition();
                            }
                        }
                    }
                } else {
                    var x = e.target.getAttribute('data-x');
                    var y = e.target.getAttribute('data-y');
                    var rect = e.target.getBoundingClientRect();
        
                    if (jexcel.current.cursor) {
                        jexcel.current.cursor.style.cursor = '';
                        jexcel.current.cursor = null;
                    }

                    if (e.target.parentNode.parentNode && e.target.parentNode.parentNode.className) {
                        if (e.target.parentNode.parentNode.classList.contains('resizable')) {
                            if (e.target && x && ! y && (rect.width - (e.clientX - rect.left) < 6)) {
                                jexcel.current.cursor = e.target;
                                jexcel.current.cursor.style.cursor = 'col-resize';
                            } else if (e.target && ! x && y && (rect.height - (e.clientY - rect.top) < 6)) {
                                jexcel.current.cursor = e.target;
                                jexcel.current.cursor.style.cursor = 'row-resize';
                            }
                        }
        
                        if (e.target.parentNode.parentNode.classList.contains('draggable')) {
                            if (e.target && ! x && y && (rect.width - (e.clientX - rect.left) < 6)) {
                                jexcel.current.cursor = e.target;
                                jexcel.current.cursor.style.cursor = 'move';
                            } else if (e.target && x && ! y && (rect.height - (e.clientY - rect.top) < 6)) {
                                jexcel.current.cursor = e.target;
                                jexcel.current.cursor.style.cursor = 'move';
                            }
                        }
                    }
                }
            }
        };
        
        jexcel.mouseOverControls = function(e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }
        
            if (! mouseButton) {
                jexcel.isMouseAction = false;
            }
        
            if (jexcel.current && jexcel.isMouseAction == true) {
                // Get elements
                var jexcelTable = jexcel.getElement(e.target);
        
                if (jexcelTable[0]) {
                    // Avoid cross reference
                    if (jexcel.current != jexcelTable[0].jexcel) {
                        if (jexcel.current) {
                            return false;
                        }
                    }
        
                    var columnId = e.target.getAttribute('data-x');
                    var rowId = e.target.getAttribute('data-y');
        
                    if (jexcel.current.dragging) {
                        if (jexcel.current.dragging.column) {
                            if (columnId) {
                                if (jexcel.current.isColMerged(columnId).length) {
                                    console.error('Jspreadsheet: This column is part of a merged cell.');
                                } else {
                                    for (var i = 0; i < jexcel.current.headers.length; i++) {
                                        jexcel.current.headers[i].classList.remove('dragging-left');
                                        jexcel.current.headers[i].classList.remove('dragging-right');
                                    }
        
                                    if (jexcel.current.dragging.column == columnId) {
                                        jexcel.current.dragging.destination = parseInt(columnId);
                                    } else {
                                        if (e.target.clientWidth / 2 > e.offsetX) {
                                            if (jexcel.current.dragging.column < columnId) {
                                                jexcel.current.dragging.destination = parseInt(columnId) - 1;
                                            } else {
                                                jexcel.current.dragging.destination = parseInt(columnId);
                                            }
                                            jexcel.current.headers[columnId].classList.add('dragging-left');
                                        } else {
                                            if (jexcel.current.dragging.column < columnId) {
                                                jexcel.current.dragging.destination = parseInt(columnId);
                                            } else {
                                                jexcel.current.dragging.destination = parseInt(columnId) + 1;
                                            }
                                            jexcel.current.headers[columnId].classList.add('dragging-right');
                                        }
                                    }
                                }
                            }
                        } else {
                            if (rowId) {
                                if (jexcel.current.isRowMerged(rowId).length) {
                                    console.error('Jspreadsheet: This row is part of a merged cell.');
                                } else {
                                    var target = (e.target.clientHeight / 2 > e.offsetY) ? e.target.parentNode.nextSibling : e.target.parentNode;
                                    if (jexcel.current.dragging.element != target) {
                                        e.target.parentNode.parentNode.insertBefore(jexcel.current.dragging.element, target);
                                        jexcel.current.dragging.destination = Array.prototype.indexOf.call(jexcel.current.dragging.element.parentNode.children, jexcel.current.dragging.element);
                                    }
                                }
                            }
                        }
                    } else if (jexcel.current.resizing) ; else {
                        // Header found
                        if (jexcelTable[1] == 1) {
                            if (jexcel.current.selectedHeader) {
                                var columnId = e.target.getAttribute('data-x');
                                var o = jexcel.current.selectedHeader;
                                var d = columnId;
                                // Update selection
                                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
                            }
                        }
        
                        // Body found
                        if (jexcelTable[1] == 2) {
                            if (e.target.classList.contains('jexcel_row')) {
                                if (jexcel.current.selectedRow) {
                                    var o = jexcel.current.selectedRow;
                                    var d = rowId;
                                    // Update selection
                                    jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
                                }
                            } else {
                                // Do not select edtion is in progress
                                if (! jexcel.current.edition) {
                                    if (columnId && rowId) {
                                        if (jexcel.current.selectedCorner) {
                                            jexcel.current.updateCopySelection(columnId, rowId);
                                        } else {
                                            if (jexcel.current.selectedCell) {
                                                jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        
            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
            }
        };
        
        /**
         * Double click event handler: controls the double click in the corner, cell edition or column re-ordering.
         */
        jexcel.doubleClickControls = function(e) {
            // Jexcel is selected
            if (jexcel.current) {
                // Corner action
                if (e.target.classList.contains('jexcel_corner')) {
                    // Any selected cells
                    if (jexcel.current.highlighted.length > 0) {
                        // Copy from this
                        var x1 = jexcel.current.highlighted[0].getAttribute('data-x');
                        var y1 = parseInt(jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute('data-y')) + 1;
                        // Until this
                        var x2 = jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute('data-x');
                        var y2 = jexcel.current.records.length - 1;
                        // Execute copy
                        jexcel.current.copyData(jexcel.current.records[y1][x1], jexcel.current.records[y2][x2]);
                    }
                } else if (e.target.classList.contains('jexcel_column_filter')) {
                    // Column
                    var columnId = e.target.getAttribute('data-x');
                    // Open filter
                    jexcel.current.openFilter(columnId);
                    
                } else {
                    // Get table
                    var jexcelTable = jexcel.getElement(e.target);
        
                    // Double click over header
                    if (jexcelTable[1] == 1 && jexcel.current.options.columnSorting == true) {
                        // Check valid column header coords
                        var columnId = e.target.getAttribute('data-x');
                        if (columnId) {
                            jexcel.current.orderBy(columnId);
                        }
                    }
        
                    // Double click over body
                    if (jexcelTable[1] == 2 && jexcel.current.options.editable == true) {
                        if (! jexcel.current.edition) {
                            var getCellCoords = function(element) {
                                if (element.parentNode) {
                                    var x = element.getAttribute('data-x');
                                    var y = element.getAttribute('data-y');
                                    if (x && y) {
                                        return element;
                                    } else {
                                        return getCellCoords(element.parentNode);
                                    }
                                }
                            };
                            var cell = getCellCoords(e.target);
                            if (cell && cell.classList.contains('highlight')) {
                                jexcel.current.openEditor(cell);
                            }
                        }
                    }
                }
            }
        };
        
        jexcel.copyControls = function(e) {
            if (jexcel.current && jexcel.copyControls.enabled) {
                if (! jexcel.current.edition) {
                    jexcel.current.copy(true);
                }
            }
        };
        
        jexcel.cutControls = function(e) {
            if (jexcel.current) {
                if (! jexcel.current.edition) {
                    jexcel.current.copy(true);
                    if (jexcel.current.options.editable == true) {
                        jexcel.current.setValue(jexcel.current.highlighted, '');
                    }
                }
            }
        };
        
        jexcel.pasteControls = function(e) {
            if (jexcel.current && jexcel.current.selectedCell) {
                if (! jexcel.current.edition) {
                    if (jexcel.current.options.editable == true) {
                        if (e && e.clipboardData) {
                            jexcel.current.paste(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], e.clipboardData.getData('text'));
                            e.preventDefault();
                        } else if (window.clipboardData) {
                            jexcel.current.paste(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], window.clipboardData.getData('text'));
                        }
                    }
                }
            }
        };
        
        jexcel.contextMenuControls = function(e) {
            e = e || window.event;
            if ("buttons" in e) {
                e.buttons;
            } else {
                e.which || e.button;
            }
        
            if (jexcel.current) {
                if (jexcel.current.edition) {
                    e.preventDefault();
                } else if (jexcel.current.options.contextMenu) {
                    jexcel.current.contextMenu.contextmenu.close();
        
                    if (jexcel.current) {
                        var x = e.target.getAttribute('data-x');
                        var y = e.target.getAttribute('data-y');
        
                        if (x || y) {
                            if ((x < parseInt(jexcel.current.selectedCell[0])) || (x > parseInt(jexcel.current.selectedCell[2])) ||
                                (y < parseInt(jexcel.current.selectedCell[1])) || (y > parseInt(jexcel.current.selectedCell[3])))
                            {
                                jexcel.current.updateSelectionFromCoords(x, y, x, y);
                            }

                            // Table found
                            var items = jexcel.current.options.contextMenu(jexcel.current, x, y, e);
                            // The id is depending on header and body
                            jexcel.current.contextMenu.contextmenu.open(e, items);
                            // Avoid the real one
                            e.preventDefault();
                        }
                    }
                }
            }
        };

        jexcel.touchStartControls = function(e) {
            var jexcelTable = jexcel.getElement(e.target);
        
            if (jexcelTable[0]) {
                if (jexcel.current != jexcelTable[0].jexcel) {
                    if (jexcel.current) {
                        jexcel.current.resetSelection();
                    }
                    jexcel.current = jexcelTable[0].jexcel;
                }
            } else {
                if (jexcel.current) {
                    jexcel.current.resetSelection();
                    jexcel.current = null;
                }
            }
        
            if (jexcel.current) {
                if (! jexcel.current.edition) {
                    var columnId = e.target.getAttribute('data-x');
                    var rowId = e.target.getAttribute('data-y');
        
                    if (columnId && rowId) {
                        jexcel.current.updateSelectionFromCoords(columnId, rowId);
        
                        jexcel.timeControl = setTimeout(function() {
                            // Keep temporary reference to the element
                            if (jexcel.current.options.columns[columnId].type == 'color') {
                                jexcel.tmpElement = null;
                            } else {
                                jexcel.tmpElement = e.target;
                            }
                            jexcel.current.openEditor(e.target, false, e);
                        }, 500);
                    }
                }
            }
        };
        
        jexcel.touchEndControls = function(e) {
            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
                // Element
                if (jexcel.tmpElement && jexcel.tmpElement.children[0].tagName == 'INPUT') {
                    jexcel.tmpElement.children[0].focus();
                }
                jexcel.tmpElement = null;
            }
        };
        
        /**
         * Jexcel extensions
         */
        
        jexcel.tabs = function(tabs, result) {
            var instances = [];
            // Create tab container
            if (! tabs.classList.contains('jexcel_tabs')) {
                tabs.innerHTML = '';
                tabs.classList.add('jexcel_tabs');
                tabs.jexcel = [];

                var div = document.createElement('div');
                var headers = tabs.appendChild(div);
                var div = document.createElement('div');
                var content = tabs.appendChild(div);
            } else {
                var headers = tabs.children[0];
                var content = tabs.children[1];
            }

            var spreadsheet = [];
            var link = [];
            for (var i = 0; i < result.length; i++) {
                // Spreadsheet container
                spreadsheet[i] = document.createElement('div');
                spreadsheet[i].classList.add('jexcel_tab');
                var worksheet = jexcel(spreadsheet[i], result[i]);
                content.appendChild(spreadsheet[i]);
                instances[i] = tabs.jexcel.push(worksheet);

                // Tab link
                link[i] = document.createElement('div');
                link[i].classList.add('jexcel_tab_link');
                link[i].setAttribute('data-spreadsheet', tabs.jexcel.length-1);
                link[i].innerHTML = result[i].sheetName;
                link[i].onclick = function() {
                    for (var j = 0; j < headers.children.length; j++) {
                        headers.children[j].classList.remove('selected');
                        content.children[j].style.display = 'none';
                    }
                    var i = this.getAttribute('data-spreadsheet');
                    content.children[i].style.display = 'block';
                    headers.children[i].classList.add('selected');
                };
                headers.appendChild(link[i]);
            }

            // First tab
            for (var j = 0; j < headers.children.length; j++) {
                headers.children[j].classList.remove('selected');
                content.children[j].style.display = 'none';
            }
            headers.children[headers.children.length - 1].classList.add('selected');
            content.children[headers.children.length - 1].style.display = 'block';

            return instances;
        };

        // Compability to older versions
        jexcel.createTabs = jexcel.tabs;

        jexcel.fromSpreadsheet = function(file, __callback) {
            var convert = function(workbook) {
                var spreadsheets = [];
                workbook.SheetNames.forEach(function(sheetName) {
                    var spreadsheet = {};
                    spreadsheet.rows = [];
                    spreadsheet.columns = [];
                    spreadsheet.data = [];
                    spreadsheet.style = {};
                    spreadsheet.sheetName = sheetName;
        
                    // Column widths
                    var temp = workbook.Sheets[sheetName]['!cols'];
                    if (temp && temp.length) {
                        for (var i = 0; i < temp.length; i++) {
                            spreadsheet.columns[i] = {};
                            if (temp[i] && temp[i].wpx) {
                                spreadsheet.columns[i].width = temp[i].wpx + 'px';
                            }
                         }
                    }
                    // Rows heights
                    var temp = workbook.Sheets[sheetName]['!rows'];
                    if (temp && temp.length) {
                        for (var i = 0; i < temp.length; i++) {
                            if (temp[i] && temp[i].hpx) {
                                spreadsheet.rows[i] = {};
                                spreadsheet.rows[i].height = temp[i].hpx + 'px';
                            }
                        }
                    }
                    // Merge cells
                    var temp = workbook.Sheets[sheetName]['!merges'];
                    if (temp && temp.length > 0) {
                        spreadsheet.mergeCells = [];
                        for (var i = 0; i < temp.length; i++) {
                            var x1 = temp[i].s.c;
                            var y1 = temp[i].s.r;
                            var x2 = temp[i].e.c;
                            var y2 = temp[i].e.r;
                            var key = jexcel.getColumnNameFromId([x1,y1]);
                            spreadsheet.mergeCells[key] = [ x2-x1+1, y2-y1+1 ];
                        }
                    }
                    // Data container
                    var max_x = 0;
                    var max_y = 0;
                    var temp = Object.keys(workbook.Sheets[sheetName]);
                    for (var i = 0; i < temp.length; i++) {
                        if (temp[i].substr(0,1) != '!') {
                            var cell = workbook.Sheets[sheetName][temp[i]];
                            var info = jexcel.getIdFromColumnName(temp[i], true);
                            if (! spreadsheet.data[info[1]]) {
                                spreadsheet.data[info[1]] = [];
                            }
                            spreadsheet.data[info[1]][info[0]] = cell.f ? '=' + cell.f : cell.w;
                            if (max_x < info[0]) {
                                max_x = info[0];
                            }
                            if (max_y < info[1]) {
                                max_y = info[1];
                            }
                            // Style
                            if (cell.style && Object.keys(cell.style).length > 0) {
                                spreadsheet.style[temp[i]] = cell.style;
                            }
                            if (cell.s && cell.s.fgColor) {
                                if (spreadsheet.style[temp[i]]) {
                                    spreadsheet.style[temp[i]] += ';';
                                }
                                spreadsheet.style[temp[i]] += 'background-color:#' + cell.s.fgColor.rgb;
                            }
                        }
                    }
                    var numColumns = spreadsheet.columns;
                    for (var j = 0; j <= max_y; j++) {
                        for (var i = 0; i <= max_x; i++) {
                            if (! spreadsheet.data[j]) {
                                spreadsheet.data[j] = [];
                            }
                            if (! spreadsheet.data[j][i]) {
                                if (numColumns < i) {
                                    spreadsheet.data[j][i] = '';
                                }
                            }
                        }
                    }
                    spreadsheets.push(spreadsheet);
                });
        
                return spreadsheets;
            };
        
            var oReq;
            oReq = new XMLHttpRequest();
            oReq.open("GET", file, true);
        
            if(typeof Uint8Array !== 'undefined') {
                oReq.responseType = "arraybuffer";
                oReq.onload = function(e) {
                    var arraybuffer = oReq.response;
                    var data = new Uint8Array(arraybuffer);
                    var wb = XLSX.read(data, {type:"array", cellFormula:true, cellStyles:true });
                    __callback(convert(wb));
                };
            } else {
                oReq.setRequestHeader("Accept-Charset", "x-user-defined");  
                oReq.onreadystatechange = function() { if(oReq.readyState == 4 && oReq.status == 200) {
                    var ff = convertResponseBodyToText(oReq.responseBody);
                    var wb = XLSX.read(ff, {type:"binary", cellFormula:true, cellStyles:true });
                    __callback(convert(wb));
                }};
            }
        
            oReq.send();
        };
        
        /**
         * Valid international letter
         */
        
        jexcel.validLetter = function (text) {
            var regex = /([\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC-\u0400-\u04FF']+)/g;
            return text.match(regex) ? 1 : 0;
        };
        
        /**
         * Helper injectArray
         */
        jexcel.injectArray = function(o, idx, arr) {
            return o.slice(0, idx).concat(arr).concat(o.slice(idx));
        };
        
        /**
         * Get letter based on a number
         * 
         * @param integer i
         * @return string letter
         */
        jexcel.getColumnName = function(i) {
            var letter = '';
            if (i > 701) {
                letter += String.fromCharCode(64 + parseInt(i / 676));
                letter += String.fromCharCode(64 + parseInt((i % 676) / 26));
            } else if (i > 25) {
                letter += String.fromCharCode(64 + parseInt(i / 26));
            }
            letter += String.fromCharCode(65 + (i % 26));
        
            return letter;
        };
        
        /**
         * Convert excel like column to jexcel id
         * 
         * @param string id
         * @return string id
         */
        jexcel.getIdFromColumnName = function (id, arr) {
            // Get the letters
            var t = /^[a-zA-Z]+/.exec(id);
        
            if (t) {
                // Base 26 calculation
                var code = 0;
                for (var i = 0; i < t[0].length; i++) {
                    code += parseInt(t[0].charCodeAt(i) - 64) * Math.pow(26, (t[0].length - 1 - i));
                }
                code--;
                // Make sure jexcel starts on zero
                if (code < 0) {
                    code = 0;
                }
        
                // Number
                var number = parseInt(/[0-9]+$/.exec(id));
                if (number > 0) {
                    number--;
                }
        
                if (arr == true) {
                    id = [ code, number ];
                } else {
                    id = code + '-' + number;
                }
            }
        
            return id;
        };
        
        /**
         * Convert jexcel id to excel like column name
         * 
         * @param string id
         * @return string id
         */
        jexcel.getColumnNameFromId = function (cellId) {
            if (! Array.isArray(cellId)) {
                cellId = cellId.split('-');
            }
        
            return jexcel.getColumnName(parseInt(cellId[0])) + (parseInt(cellId[1]) + 1);
        };
        
        /**
         * Verify element inside jexcel table
         * 
         * @param string id
         * @return string id
         */
        jexcel.getElement = function(element) {
            var jexcelSection = 0;
            var jexcelElement = 0;
        
            function path (element) {
                if (element.className) {
                    if (element.classList.contains('jexcel_container')) {
                        jexcelElement = element;
                    }
                }
        
                if (element.tagName == 'THEAD') {
                    jexcelSection = 1;
                } else if (element.tagName == 'TBODY') {
                    jexcelSection = 2;
                }
        
                if (element.parentNode) {
                    if (! jexcelElement) {
                        path(element.parentNode);
                    }
                }
            }
        
            path(element);
        
            return [ jexcelElement, jexcelSection ];
        };

        jexcel.doubleDigitFormat = function(v) {
            v = ''+v;
            if (v.length == 1) {
                v = '0'+v;
            }
            return v;
        };

        jexcel.createFromTable = function(el, options) {
            if (el.tagName != 'TABLE') {
                console.log('Element is not a table');
            } else {
                // Configuration
                if (! options) {
                    options = {};
                }
                options.columns = [];
                options.data = [];

                // Colgroup
                var colgroup = el.querySelectorAll('colgroup > col');
                if (colgroup.length) {
                    // Get column width
                    for (var i = 0; i < colgroup.length; i++) {
                        var width = colgroup[i].style.width;
                        if (! width) {
                            var width = colgroup[i].getAttribute('width');
                        }
                        // Set column width
                        if (width) {
                            if (! options.columns[i]) {
                                options.columns[i] = {};
                            }
                            options.columns[i].width = width;
                        }
                    }
                }

                // Parse header
                var parseHeader = function(header) {
                    // Get width information
                    var info = header.getBoundingClientRect();
                    var width = info.width > 50 ? info.width : 50;

                    // Create column option
                    if (! options.columns[i]) {
                        options.columns[i] = {};
                    } 
                    if (header.getAttribute('data-celltype')) {
                        options.columns[i].type = header.getAttribute('data-celltype');
                    } else {
                        options.columns[i].type = 'text';
                    }
                    options.columns[i].width = width + 'px';
                    options.columns[i].title = header.innerHTML;
                    options.columns[i].align = header.style.textAlign || 'center';

                    if (info = header.getAttribute('name')) {
                        options.columns[i].name = info;
                }
                    if (info = header.getAttribute('id')) {
                        options.columns[i].id = info;
                    }
                };

                // Headers
                var nested = [];
                var headers = el.querySelectorAll(':scope > thead > tr');
                if (headers.length) {
                    for (var j = 0; j < headers.length - 1; j++) {
                        var cells = [];
                        for (var i = 0; i < headers[j].children.length; i++) {
                            var row = {
                                title: headers[j].children[i].innerText,
                                colspan: headers[j].children[i].getAttribute('colspan') || 1,
                            };
                            cells.push(row);
                        }
                        nested.push(cells);
                    }
                    // Get the last row in the thead
                    headers = headers[headers.length-1].children;
                    // Go though the headers
                    for (var i = 0; i < headers.length; i++) {
                        parseHeader(headers[i]);
                    }
                }

                // Content
                var rowNumber = 0;
                var mergeCells = {};
                var rows = {};
                var style = {};
                var classes = {};

                var content = el.querySelectorAll(':scope > tr, :scope > tbody > tr');
                for (var j = 0; j < content.length; j++) {
                    options.data[rowNumber] = [];
                    if (options.parseTableFirstRowAsHeader == true && ! headers.length && j == 0) {
                        for (var i = 0; i < content[j].children.length; i++) {
                            parseHeader(content[j].children[i]);
                        }
                    } else {
                        for (var i = 0; i < content[j].children.length; i++) {
                            // WickedGrid formula compatibility
                            var value = content[j].children[i].getAttribute('data-formula');
                            if (value) {
                                if (value.substr(0,1) != '=') {
                                    value = '=' + value;
                                }
                            } else {
                                var value = content[j].children[i].innerHTML;
                            }
                            options.data[rowNumber].push(value);

                            // Key
                            var cellName = jexcel.getColumnNameFromId([ i, j ]);

                            // Classes
                            var tmp = content[j].children[i].getAttribute('class');
                            if (tmp) {
                                classes[cellName] = tmp;
                            }

                            // Merged cells
                            var mergedColspan = parseInt(content[j].children[i].getAttribute('colspan')) || 0;
                            var mergedRowspan = parseInt(content[j].children[i].getAttribute('rowspan')) || 0;
                            if (mergedColspan || mergedRowspan) {
                                mergeCells[cellName] = [ mergedColspan || 1, mergedRowspan || 1 ];
                            }

                            // Avoid problems with hidden cells
                            if (s = content[j].children[i].style && content[j].children[i].style.display == 'none') {
                                content[j].children[i].style.display = '';
                            }
                            // Get style
                            var s = content[j].children[i].getAttribute('style');
                            if (s) {
                                style[cellName] = s;
                            }
                            // Bold
                            if (content[j].children[i].classList.contains('styleBold')) {
                                if (style[cellName]) {
                                    style[cellName] += '; font-weight:bold;';
                                } else {
                                    style[cellName] = 'font-weight:bold;';
                                }
                            }
                        }

                        // Row Height
                        if (content[j].style && content[j].style.height) {
                            rows[j] = { height: content[j].style.height };
                        }

                        // Index
                        rowNumber++;
                    }
                }

                // Nested
                if (Object.keys(nested).length > 0) {
                    options.nestedHeaders = nested;
                }
                // Style
                if (Object.keys(style).length > 0) {
                    options.style = style;
                }
                // Merged
                if (Object.keys(mergeCells).length > 0) {
                    options.mergeCells = mergeCells;
                }
                // Row height
                if (Object.keys(rows).length > 0) {
                    options.rows = rows;
                }
                // Classes
                if (Object.keys(classes).length > 0) {
                    options.classes = classes;
                }

                var content = el.querySelectorAll('tfoot tr');
                if (content.length) {
                    var footers = [];
                    for (var j = 0; j < content.length; j++) {
                        var footer = [];
                        for (var i = 0; i < content[j].children.length; i++) {
                            footer.push(content[j].children[i].innerText);
                        }
                        footers.push(footer);
                    }
                    if (Object.keys(footers).length > 0) {
                        options.footers = footers;
                    }
                }
                // TODO: data-hiddencolumns="3,4"
                
                // I guess in terms the better column type
                if (options.parseTableAutoCellType == true) {
                    var pattern = [];
                    for (var i = 0; i < options.columns.length; i++) {
                        var test = true;
                        var testCalendar = true;
                        pattern[i] = [];
                        for (var j = 0; j < options.data.length; j++) {
                            var value = options.data[j][i];
                            if (! pattern[i][value]) {
                                pattern[i][value] = 0;
                            }
                            pattern[i][value]++;
                            if (value.length > 25) {
                                test = false;
                            }
                            if (value.length == 10) {
                                if (! (value.substr(4,1) == '-' && value.substr(7,1) == '-')) {
                                    testCalendar = false;
                                }
                            } else {
                                testCalendar = false;
                            }
                        }

                        var keys = Object.keys(pattern[i]).length;
                        if (testCalendar) {
                            options.columns[i].type = 'calendar';
                        } else if (test == true && keys > 1 && keys <= parseInt(options.data.length * 0.1)) {
                            options.columns[i].type = 'dropdown';
                            options.columns[i].source = Object.keys(pattern[i]);
                        }
                    }
                }

                return options;
            }
        };

        /**
         * Jquery Support
         */
        if (typeof(jQuery) != 'undefined') {
            (function($){
                $.fn.jspreadsheet = $.fn.jexcel = function(mixed) {
                    var spreadsheetContainer = $(this).get(0);
                    if (! spreadsheetContainer.jexcel) {
                        return jexcel($(this).get(0), arguments[0]);
                    } else {
                        if (Array.isArray(spreadsheetContainer.jexcel)) {
                            return spreadsheetContainer.jexcel[mixed][arguments[1]].apply(this, Array.prototype.slice.call( arguments, 2 ));
                        } else {
                            return spreadsheetContainer.jexcel[mixed].apply(this, Array.prototype.slice.call( arguments, 1 ));
                        }
                    }
                };
        
            })(jQuery);
        }
        
        
        // Based on sutoiku work (https://github.com/sutoiku)
        
        var error = (function() {
            var exports = {};
        
            exports.nil = new Error('#NULL!');
            exports.div0 = new Error('#DIV/0!');
            exports.value = new Error('#VALUE!');
            exports.ref = new Error('#REF!');
            exports.name = new Error('#NAME?');
            exports.num = new Error('#NUM!');
            exports.na = new Error('#N/A');
            exports.error = new Error('#ERROR!');
            exports.data = new Error('#GETTING_DATA');
        
            return exports;
        })();
        
        var utils = (function() {
            var exports = {};
        
            exports.flattenShallow = function(array) {
                if (!array || !array.reduce) {
                    return array;
                }
        
                return array.reduce(function(a, b) {
                    var aIsArray = Array.isArray(a);
                    var bIsArray = Array.isArray(b);
        
                    if (aIsArray && bIsArray) {
                        return a.concat(b);
                    }
                    if (aIsArray) {
                        a.push(b);
        
                        return a;
                    }
                    if (bIsArray) {
                        return [ a ].concat(b);
                    }
        
                    return [ a, b ];
                });
            };
        
            exports.isFlat = function(array) {
                if (!array) {
                    return false;
                }
        
                for (var i = 0; i < array.length; ++i) {
                    if (Array.isArray(array[i])) {
                        return false;
                    }
                }
        
                return true;
            };
        
            exports.flatten = function() {
                var result = exports.argsToArray.apply(null, arguments);
        
                while (!exports.isFlat(result)) {
                    result = exports.flattenShallow(result);
                }
        
                return result;
            };
        
            exports.argsToArray = function(args) {
                var result = [];
        
                exports.arrayEach(args, function(value) {
                    result.push(value);
                });
        
                return result;
            };
        
            exports.numbers = function() {
                var possibleNumbers = this.flatten.apply(null, arguments);
                return possibleNumbers.filter(function(el) {
                    return typeof el === 'number';
                });
            };
        
            exports.cleanFloat = function(number) {
                var power = 1e14;
                return Math.round(number * power) / power;
            };
        
            exports.parseBool = function(bool) {
                if (typeof bool === 'boolean') {
                    return bool;
                }
        
                if (bool instanceof Error) {
                    return bool;
                }
        
                if (typeof bool === 'number') {
                    return bool !== 0;
                }
        
                if (typeof bool === 'string') {
                    var up = bool.toUpperCase();
                    if (up === 'TRUE') {
                        return true;
                    }
        
                    if (up === 'FALSE') {
                        return false;
                    }
                }
        
                if (bool instanceof Date && !isNaN(bool)) {
                    return true;
                }
        
                return error.value;
            };
        
            exports.parseNumber = function(string) {
                if (string === undefined || string === '') {
                    return error.value;
                }
                if (!isNaN(string)) {
                    return parseFloat(string);
                }
        
                return error.value;
            };
        
            exports.parseNumberArray = function(arr) {
                var len;
        
                if (!arr || (len = arr.length) === 0) {
                    return error.value;
                }
        
                var parsed;
        
                while (len--) {
                    parsed = exports.parseNumber(arr[len]);
                    if (parsed === error.value) {
                        return parsed;
                    }
                    arr[len] = parsed;
                }
        
                return arr;
            };
        
            exports.parseMatrix = function(matrix) {
        
                if (!matrix || (matrix.length) === 0) {
                    return error.value;
                }
                var pnarr;
        
                for (var i = 0; i < matrix.length; i++) {
                    pnarr = exports.parseNumberArray(matrix[i]);
                    matrix[i] = pnarr;
        
                    if (pnarr instanceof Error) {
                        return pnarr;
                    }
                }
        
                return matrix;
            };
        
            var d1900 = new Date(Date.UTC(1900, 0, 1));
            exports.parseDate = function(date) {
                if (!isNaN(date)) {
                    if (date instanceof Date) {
                        return new Date(date);
                    }
                    var d = parseInt(date, 10);
                    if (d < 0) {
                        return error.num;
                    }
                    if (d <= 60) {
                        return new Date(d1900.getTime() + (d - 1) * 86400000);
                    }
                    return new Date(d1900.getTime() + (d - 2) * 86400000);
                }
                if (typeof date === 'string') {
                    date = new Date(date);
                    if (!isNaN(date)) {
                        return date;
                    }
                }
                return error.value;
            };
        
            exports.parseDateArray = function(arr) {
                var len = arr.length;
                var parsed;
                while (len--) {
                    parsed = this.parseDate(arr[len]);
                    if (parsed === error.value) {
                        return parsed;
                    }
                    arr[len] = parsed;
                }
                return arr;
            };
        
            exports.anyIsError = function() {
                var n = arguments.length;
                while (n--) {
                    if (arguments[n] instanceof Error) {
                        return true;
                    }
                }
                return false;
            };
        
            exports.arrayValuesToNumbers = function(arr) {
                var n = arr.length;
                var el;
                while (n--) {
                    el = arr[n];
                    if (typeof el === 'number') {
                        continue;
                    }
                    if (el === true) {
                        arr[n] = 1;
                        continue;
                    }
                    if (el === false) {
                        arr[n] = 0;
                        continue;
                    }
                    if (typeof el === 'string') {
                        var number = this.parseNumber(el);
                        if (number instanceof Error) {
                            arr[n] = 0;
                        } else {
                            arr[n] = number;
                        }
                    }
                }
                return arr;
            };
        
            exports.rest = function(array, idx) {
                idx = idx || 1;
                if (!array || typeof array.slice !== 'function') {
                    return array;
                }
                return array.slice(idx);
            };
        
            exports.initial = function(array, idx) {
                idx = idx || 1;
                if (!array || typeof array.slice !== 'function') {
                    return array;
                }
                return array.slice(0, array.length - idx);
            };
        
            exports.arrayEach = function(array, iteratee) {
                var index = -1, length = array.length;
        
                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break;
                    }
                }
        
                return array;
            };
        
            exports.transpose = function(matrix) {
                if (!matrix) {
                    return error.value;
                }
        
                return matrix[0].map(function(col, i) {
                    return matrix.map(function(row) {
                        return row[i];
                    });
                });
            };
        
            return exports;
        })();
        
        jexcel.methods = {};
        
        jexcel.methods.datetime = (function() {
            var exports = {};
        
            var d1900 = new Date(1900, 0, 1);
            var WEEK_TYPES = [
                [],
                [1, 2, 3, 4, 5, 6, 7],
                [7, 1, 2, 3, 4, 5, 6],
                [6, 0, 1, 2, 3, 4, 5],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [7, 1, 2, 3, 4, 5, 6],
                [6, 7, 1, 2, 3, 4, 5],
                [5, 6, 7, 1, 2, 3, 4],
                [4, 5, 6, 7, 1, 2, 3],
                [3, 4, 5, 6, 7, 1, 2],
                [2, 3, 4, 5, 6, 7, 1],
                [1, 2, 3, 4, 5, 6, 7]
            ];
        
            exports.DATE = function(year, month, day) {
                year = utils.parseNumber(year);
                month = utils.parseNumber(month);
                day = utils.parseNumber(day);
                if (utils.anyIsError(year, month, day)) {
                    return error.value;
                }
                if (year < 0 || month < 0 || day < 0) {
                    return error.num;
                }
                var date = new Date(year, month - 1, day);
                return date;
            };
        
            exports.DATEVALUE = function(date_text) {
                if (typeof date_text !== 'string') {
                    return error.value;
                }
                var date = Date.parse(date_text);
                if (isNaN(date)) {
                    return error.value;
                }
                if (date <= -2203891200000) {
                    return (date - d1900) / 86400000 + 1;
                }
                return (date - d1900) / 86400000 + 2;
            };
        
            exports.DAY = function(serial_number) {
                var date = utils.parseDate(serial_number);
                if (date instanceof Error) {
                    return date;
                }
                return date.getDate();
            };
        
            exports.DAYS = function(end_date, start_date) {
                end_date = utils.parseDate(end_date);
                start_date = utils.parseDate(start_date);
                if (end_date instanceof Error) {
                    return end_date;
                }
                if (start_date instanceof Error) {
                    return start_date;
                }
                return serial(end_date) - serial(start_date);
            };
        
            exports.DAYS360 = function(start_date, end_date, method) {
            };
        
            exports.EDATE = function(start_date, months) {
                start_date = utils.parseDate(start_date);
                if (start_date instanceof Error) {
                    return start_date;
                }
                if (isNaN(months)) {
                    return error.value;
                }
                months = parseInt(months, 10);
                start_date.setMonth(start_date.getMonth() + months);
                return serial(start_date);
            };
        
            exports.EOMONTH = function(start_date, months) {
                start_date = utils.parseDate(start_date);
                if (start_date instanceof Error) {
                    return start_date;
                }
                if (isNaN(months)) {
                    return error.value;
                }
                months = parseInt(months, 10);
                return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
            };
        
            exports.HOUR = function(serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getHours();
            };
        
            exports.INTERVAL = function(second) {
                if (typeof second !== 'number' && typeof second !== 'string') {
                    return error.value;
                } else {
                    second = parseInt(second, 10);
                }
        
                var year  = Math.floor(second/946080000);
                second    = second%946080000;
                var month = Math.floor(second/2592000);
                second    = second%2592000;
                var day   = Math.floor(second/86400);
                second    = second%86400;
        
                var hour  = Math.floor(second/3600);
                second    = second%3600;
                var min   = Math.floor(second/60);
                second    = second%60;
                var sec   = second;
        
                year  = (year  > 0) ? year  + 'Y' : '';
                month = (month > 0) ? month + 'M' : '';
                day   = (day   > 0) ? day   + 'D' : '';
                hour  = (hour  > 0) ? hour  + 'H' : '';
                min   = (min   > 0) ? min   + 'M' : '';
                sec   = (sec   > 0) ? sec   + 'S' : '';
        
                return 'P' + year + month + day + 'T' + hour + min + sec;
            };
        
            exports.ISOWEEKNUM = function(date) {
                date = utils.parseDate(date);
                if (date instanceof Error) {
                    return date;
                }
        
                date.setHours(0, 0, 0);
                date.setDate(date.getDate() + 4 - (date.getDay() || 7));
                var yearStart = new Date(date.getFullYear(), 0, 1);
                return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
            };
        
            exports.MINUTE = function(serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getMinutes();
            };
        
            exports.MONTH = function(serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getMonth() + 1;
            };
        
            exports.NETWORKDAYS = function(start_date, end_date, holidays) {
            };
        
            exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
            };
        
            exports.NOW = function() {
                return new Date();
            };
        
            exports.SECOND = function(serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getSeconds();
            };
        
            exports.TIME = function(hour, minute, second) {
                hour = utils.parseNumber(hour);
                minute = utils.parseNumber(minute);
                second = utils.parseNumber(second);
                if (utils.anyIsError(hour, minute, second)) {
                    return error.value;
                }
                if (hour < 0 || minute < 0 || second < 0) {
                    return error.num;
                }
                return (3600 * hour + 60 * minute + second) / 86400;
            };
        
            exports.TIMEVALUE = function(time_text) {
                time_text = utils.parseDate(time_text);
                if (time_text instanceof Error) {
                    return time_text;
                }
                return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;
            };
        
            exports.TODAY = function() {
                return new Date();
            };
        
            exports.WEEKDAY = function(serial_number, return_type) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                if (return_type === undefined) {
                    return_type = 1;
                }
                var day = serial_number.getDay();
                return WEEK_TYPES[return_type][day];
            };
        
            exports.WEEKNUM = function(serial_number, return_type) {
            };
        
            exports.WORKDAY = function(start_date, days, holidays) {
            };
        
            exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
            };
        
            exports.YEAR = function(serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getFullYear();
            };
        
            exports.YEARFRAC = function(start_date, end_date, basis) {
            };
        
            function serial(date) {
                var addOn = (date > -2203891200000)?2:1;
                return (date - d1900) / 86400000 + addOn;
            }
        
            return exports;
        })();
        
        jexcel.methods.database = (function() {
            var exports = {};
        
            function compact(array) {
                if (!array) {
                    return array;
                }
                var result = [];
                for (var i = 0; i < array.length; ++i) {
                    if (!array[i]) {
                        continue;
                    }
                    result.push(array[i]);
                }
                return result;
            }
        
            exports.FINDFIELD = function(database, title) {
                var index = null;
                for (var i = 0; i < database.length; i++) {
                    if (database[i][0] === title) {
                        index = i;
                        break;
                    }
                }
        
                // Return error if the input field title is incorrect
                if (index == null) {
                    return error.value;
                }
                return index;
            };
        
            function findResultIndex(database, criterias) {
                var matches = {};
                for (var i = 1; i < database[0].length; ++i) {
                    matches[i] = true;
                }
                var maxCriteriaLength = criterias[0].length;
                for (i = 1; i < criterias.length; ++i) {
                    if (criterias[i].length > maxCriteriaLength) {
                        maxCriteriaLength = criterias[i].length;
                    }
                }
        
                for (var k = 1; k < database.length; ++k) {
                    for (var l = 1; l < database[k].length; ++l) {
                        var currentCriteriaResult = false;
                        var hasMatchingCriteria = false;
                        for (var j = 0; j < criterias.length; ++j) {
                            var criteria = criterias[j];
                            if (criteria.length < maxCriteriaLength) {
                                continue;
                            }
        
                            var criteriaField = criteria[0];
                            if (database[k][0] !== criteriaField) {
                                continue;
                            }
                            hasMatchingCriteria = true;
                            for (var p = 1; p < criteria.length; ++p) {
                                currentCriteriaResult = currentCriteriaResult
                                        || eval(database[k][l] + criteria[p]); // jshint
                                                                                // ignore:line
                            }
                        }
                        if (hasMatchingCriteria) {
                            matches[l] = matches[l] && currentCriteriaResult;
                        }
                    }
                }
        
                var result = [];
                for (var n = 0; n < database[0].length; ++n) {
                    if (matches[n]) {
                        result.push(n - 1);
                    }
                }
                return result;
            }
        
            // Database functions
            exports.DAVERAGE = function(database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var sum = 0;
                for (var i = 0; i < resultIndexes.length; i++) {
                    sum += targetFields[resultIndexes[i]];
                }
                return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
            };
        
            exports.DCOUNT = function(database, field, criteria) {
            };
        
            exports.DCOUNTA = function(database, field, criteria) {
            };
        
            exports.DGET = function(database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                // Return error if no record meets the criteria
                if (resultIndexes.length === 0) {
                    return error.value;
                }
                // Returns the #NUM! error value because more than one record meets the
                // criteria
                if (resultIndexes.length > 1) {
                    return error.num;
                }
        
                return targetFields[resultIndexes[0]];
            };
        
            exports.DMAX = function(database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var maxValue = targetFields[resultIndexes[0]];
                for (var i = 1; i < resultIndexes.length; i++) {
                    if (maxValue < targetFields[resultIndexes[i]]) {
                        maxValue = targetFields[resultIndexes[i]];
                    }
                }
                return maxValue;
            };
        
            exports.DMIN = function(database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var minValue = targetFields[resultIndexes[0]];
                for (var i = 1; i < resultIndexes.length; i++) {
                    if (minValue > targetFields[resultIndexes[i]]) {
                        minValue = targetFields[resultIndexes[i]];
                    }
                }
                return minValue;
            };
        
            exports.DPRODUCT = function(database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var targetValues = [];
                for (var i = 0; i < resultIndexes.length; i++) {
                    targetValues[i] = targetFields[resultIndexes[i]];
                }
                targetValues = compact(targetValues);
                var result = 1;
                for (i = 0; i < targetValues.length; i++) {
                    result *= targetValues[i];
                }
                return result;
            };
        
            exports.DSTDEV = function(database, field, criteria) {
            };
        
            exports.DSTDEVP = function(database, field, criteria) {
            };
        
            exports.DSUM = function(database, field, criteria) {
            };
        
            exports.DVAR = function(database, field, criteria) {
            };
        
            exports.DVARP = function(database, field, criteria) {
            };
        
            exports.MATCH = function(lookupValue, lookupArray, matchType) {
                if (!lookupValue && !lookupArray) {
                    return error.na;
                }
                if (arguments.length === 2) {
                    matchType = 1;
                }
                if (!(lookupArray instanceof Array)) {
                    return error.na;
                }
                if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
                    return error.na;
                }
        
                var index;
                var indexValue;
        
                for (var idx = 0; idx < lookupArray.length; idx++) {
                    if (matchType === 1) {
                        if (lookupArray[idx] === lookupValue) {
                            return idx + 1;
                        } else if (lookupArray[idx] < lookupValue) {
                            if (!indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            } else if (lookupArray[idx] > indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            }
                        }
                    } else if (matchType === 0) {
                        if (typeof lookupValue === 'string') {
                            lookupValue = lookupValue.replace(/\?/g, '.');
                            if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
                                return idx + 1;
                            }
                        } else {
                            if (lookupArray[idx] === lookupValue) {
                                return idx + 1;
                            }
                        }
                    } else if (matchType === -1) {
                        if (lookupArray[idx] === lookupValue) {
                            return idx + 1;
                        } else if (lookupArray[idx] > lookupValue) {
                            if (!indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            } else if (lookupArray[idx] < indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            }
                        }
                    }
                }
        
                return index ? index : error.na;
            };
        
            return exports;
        })();
        
        jexcel.methods.engineering = (function() {
            var exports = {};
        
            function isValidBinaryNumber(number) {
                return (/^[01]{1,10}$/).test(number);
            }
        
            exports.BESSELI = function(x, n) {
            };
        
            exports.BESSELJ = function(x, n) {
            };
        
            exports.BESSELK = function(x, n) {
            };
        
            exports.BESSELY = function(x, n) {
            };
        
            exports.BIN2DEC = function(number) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }
        
                // Convert binary number to decimal
                var result = parseInt(number, 2);
        
                // Handle negative numbers
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return parseInt(stringified.substring(1), 2) - 512;
                } else {
                    return result;
                }
            };
        
            exports.BIN2HEX = function(number, places) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character hexadecimal number if number
                // is negative
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
                }
        
                // Convert binary number to hexadecimal
                var result = parseInt(number, 2).toString(16);
        
                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.BIN2OCT = function(number, places) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character octal number if number is
                // negative
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
                }
        
                // Convert binary number to octal
                var result = parseInt(number, 2).toString(8);
        
                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.BITAND = function(number1, number2) {
                // Return error if either number is a non-numeric value
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }
        
                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }
        
                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }
        
                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }
        
                // Return bitwise AND of two numbers
                return number1 & number2;
            };
        
            exports.BITLSHIFT = function(number, shift) {
                number = utils.parseNumber(number);
                shift = utils.parseNumber(shift);
                if (utils.anyIsError(number, shift)) {
                    return error.value;
                }
        
                // Return error if number is less than 0
                if (number < 0) {
                    return error.num;
                }
        
                // Return error if number is a non-integer
                if (Math.floor(number) !== number) {
                    return error.num;
                }
        
                // Return error if number is greater than (2^48)-1
                if (number > 281474976710655) {
                    return error.num;
                }
        
                // Return error if the absolute value of shift is greater than 53
                if (Math.abs(shift) > 53) {
                    return error.num;
                }
        
                // Return number shifted by shift bits to the left or to the right if
                // shift is negative
                return (shift >= 0) ? number << shift : number >> -shift;
            };
        
            exports.BITOR = function(number1, number2) {
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }
        
                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }
        
                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }
        
                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }
        
                // Return bitwise OR of two numbers
                return number1 | number2;
            };
        
            exports.BITRSHIFT = function(number, shift) {
                number = utils.parseNumber(number);
                shift = utils.parseNumber(shift);
                if (utils.anyIsError(number, shift)) {
                    return error.value;
                }
        
                // Return error if number is less than 0
                if (number < 0) {
                    return error.num;
                }
        
                // Return error if number is a non-integer
                if (Math.floor(number) !== number) {
                    return error.num;
                }
        
                // Return error if number is greater than (2^48)-1
                if (number > 281474976710655) {
                    return error.num;
                }
        
                // Return error if the absolute value of shift is greater than 53
                if (Math.abs(shift) > 53) {
                    return error.num;
                }
        
                // Return number shifted by shift bits to the right or to the left if
                // shift is negative
                return (shift >= 0) ? number >> shift : number << -shift;
            };
        
            exports.BITXOR = function(number1, number2) {
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }
        
                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }
        
                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }
        
                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }
        
                // Return bitwise XOR of two numbers
                return number1 ^ number2;
            };
        
            exports.COMPLEX = function(real, imaginary, suffix) {
                real = utils.parseNumber(real);
                imaginary = utils.parseNumber(imaginary);
                if (utils.anyIsError(real, imaginary)) {
                    return real;
                }
        
                // Set suffix
                suffix = (suffix === undefined) ? 'i' : suffix;
        
                // Return error if suffix is neither "i" nor "j"
                if (suffix !== 'i' && suffix !== 'j') {
                    return error.value;
                }
        
                // Return complex number
                if (real === 0 && imaginary === 0) {
                    return 0;
                } else if (real === 0) {
                    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
                } else if (imaginary === 0) {
                    return real.toString();
                } else {
                    var sign = (imaginary > 0) ? '+' : '';
                    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
                }
            };
        
            exports.CONVERT = function(number, from_unit, to_unit) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
        
                // List of units supported by CONVERT and units defined by the
                // International System of Units
                // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion
                // ratio]
                var units = [
                    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
                    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
                    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
                    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
                    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
                    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
                    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
                    ["ampere", "A", null, "electric_current", true, false, 1],
                    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
                    ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
                    ["are", "ar", null, "area", false, true, 100],
                    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
                    ["bar", "bar", null, "pressure", false, false, 100000],
                    ["barn", "b", null, "area", false, false, 1e-28],
                    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
                    ["bit", "bit", ["b"], "information", false, true, 1],
                    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
                    ["byte", "byte", null, "information", false, true, 8],
                    ["candela", "cd", null, "luminous_intensity", true, false, 1],
                    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
                    ["coulomb", "C", null, "electric_charge", true, false, 1],
                    ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
                    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
                    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
                    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
                    ["cubic metre", "m?", null, "volume", true, true, 1],
                    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
                    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
                    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
                    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
                    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
                    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
                    ["day", "d", ["day"], "time", false, true, 86400],
                    ["degree", "°", null, "angle", false, false, 0.0174532925199433],
                    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
                    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
                    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
                    ["ell", "ell", null, "length", false, true, 1.143],
                    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
                    ["farad", "F", null, "electric_capacitance", true, false, 1],
                    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
                    ["foot", "ft", null, "length", false, true, 0.3048],
                    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
                    ["gal", "Gal", null, "acceleration", false, false, 0.01],
                    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
                    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
                    ["grain", "grain", null, "mass", false, true, 0.0000647989],
                    ["gram", "g", null, "mass", false, true, 0.001],
                    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
                    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
                    ["hectare", "ha", null, "area", false, true, 10000],
                    ["henry", "H", null, "inductance", true, false, 1],
                    ["hertz", "Hz", null, "frequency", true, false, 1],
                    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
                    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
                    ["hour", "h", ["hr"], "time", false, true, 3600],
                    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
                    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
                    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
                    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
                    ["inch", "in", null, "length", false, true, 0.0254],
                    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
                    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
                    ["joule", "J", null, "energy", true, true, 1],
                    ["katal", "kat", null, "catalytic_activity", true, false, 1],
                    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
                    ["kilogram", "kg", null, "mass", true, true, 1],
                    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
                    ["light-year", "ly", null, "length", false, true, 9460730472580800],
                    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
                    ["lumen", "lm", null, "luminous_flux", true, false, 1],
                    ["lux", "lx", null, "illuminance", true, false, 1],
                    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
                    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
                    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
                    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
                    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
                    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
                    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
                    ["metre", "m", null, "length", true, true, 1],
                    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
                    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
                    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
                    ["minute", "min", ["mn"], "time", false, true, 60],
                    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
                    ["mole", "mol", null, "amount_of_substance", true, false, 1],
                    ["morgen", "Morgen", null, "area", false, true, 2500],
                    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
                    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
                    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
                    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
                    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
                    ["newton", "N", null, "force", true, true, 1],
                    ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
                    ["ohm", "Ω", null, "electric_resistance", true, false, 1],
                    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
                    ["pascal", "Pa", null, "pressure", true, false, 1],
                    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
                    ["pferdestärke", "PS", null, "power", false, true, 735.49875],
                    ["phot", "ph", null, "illuminance", false, false, 0.0001],
                    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
                    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
                    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
                    ["pond", "pond", null, "force", false, true, 0.00980665],
                    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
                    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
                    ["quart", "qt", null, "volume", false, true, 0.000946352946],
                    ["radian", "rad", null, "angle", true, false, 1],
                    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
                    ["second", "s", ["sec"], "time", true, true, 1],
                    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
                    ["siemens", "S", null, "electrical_conductance", true, false, 1],
                    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
                    ["slug", "sg", null, "mass", false, true, 14.59390294],
                    ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
                    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
                    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
                    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
                    ["square meter", "m?", null, "area", true, true, 1],
                    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
                    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
                    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
                    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
                    ["statute mile", "mi", null, "length", false, true, 1609.344],
                    ["steradian", "sr", null, "solid_angle", true, false, 1],
                    ["stilb", "sb", null, "luminance", false, false, 0.0001],
                    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
                    ["stone", "stone", null, "mass", false, true, 6.35029318],
                    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
                    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
                    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
                    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
                    ["ton", "ton", null, "mass", false, true, 907.18474],
                    ["tonne", "t", null, "mass", false, false, 1000],
                    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
                    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
                    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
                    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
                    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
                    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
                    ["volt", "V", null, "voltage", true, false, 1],
                    ["watt", "W", null, "power", true, true, 1],
                    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
                    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
                    ["yard", "yd", null, "length", false, true, 0.9144],
                    ["year", "yr", null, "time", false, true, 31557600]
                ];
        
                // Binary prefixes
                // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived
                // from]
                var binary_prefixes = {
                    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
                    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
                    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
                    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
                    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
                    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
                    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
                    ki: ["kibi", 10, 1024, "ki", "kilo"]
                };
        
                // Unit prefixes
                // [Name, Multiplier, Abbreviation]
                var unit_prefixes = {
                    Y: ["yotta", 1e+24, "Y"],
                    Z: ["zetta", 1e+21, "Z"],
                    E: ["exa", 1e+18, "E"],
                    P: ["peta", 1e+15, "P"],
                    T: ["tera", 1e+12, "T"],
                    G: ["giga", 1e+09, "G"],
                    M: ["mega", 1e+06, "M"],
                    k: ["kilo", 1e+03, "k"],
                    h: ["hecto", 1e+02, "h"],
                    e: ["dekao", 1e+01, "e"],
                    d: ["deci", 1e-01, "d"],
                    c: ["centi", 1e-02, "c"],
                    m: ["milli", 1e-03, "m"],
                    u: ["micro", 1e-06, "u"],
                    n: ["nano", 1e-09, "n"],
                    p: ["pico", 1e-12, "p"],
                    f: ["femto", 1e-15, "f"],
                    a: ["atto", 1e-18, "a"],
                    z: ["zepto", 1e-21, "z"],
                    y: ["yocto", 1e-24, "y"]
                };
        
                // Initialize units and multipliers
                var from = null;
                var to = null;
                var base_from_unit = from_unit;
                var base_to_unit = to_unit;
                var from_multiplier = 1;
                var to_multiplier = 1;
                var alt;
        
                // Lookup from and to units
                for (var i = 0; i < units.length; i++) {
                    alt = (units[i][2] === null) ? [] : units[i][2];
                    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
                      from = units[i];
                    }
                    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
                      to = units[i];
                    }
                }
        
                // Lookup from prefix
                if (from === null) {
                    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
                    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];
        
                    // Handle dekao unit prefix (only unit prefix with two characters)
                    if (from_unit.substring(0, 2) === 'da') {
                      from_unit_prefix = ["dekao", 1e+01, "da"];
                    }
        
                    // Handle binary prefixes first (so that 'Yi' is processed before
                    // 'Y')
                    if (from_binary_prefix) {
                      from_multiplier = from_binary_prefix[2];
                      base_from_unit = from_unit.substring(2);
                    } else if (from_unit_prefix) {
                      from_multiplier = from_unit_prefix[1];
                      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
                    }
        
                    // Lookup from unit
                    for (var j = 0; j < units.length; j++) {
                      alt = (units[j][2] === null) ? [] : units[j][2];
                      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
                          from = units[j];
                      }
                    }
                }
        
                // Lookup to prefix
                if (to === null) {
                    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
                    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];
        
                    // Handle dekao unit prefix (only unit prefix with two characters)
                    if (to_unit.substring(0, 2) === 'da') {
                      to_unit_prefix = ["dekao", 1e+01, "da"];
                    }
        
                    // Handle binary prefixes first (so that 'Yi' is processed before
                    // 'Y')
                    if (to_binary_prefix) {
                      to_multiplier = to_binary_prefix[2];
                      base_to_unit = to_unit.substring(2);
                    } else if (to_unit_prefix) {
                      to_multiplier = to_unit_prefix[1];
                      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
                    }
        
                    // Lookup to unit
                    for (var k = 0; k < units.length; k++) {
                      alt = (units[k][2] === null) ? [] : units[k][2];
                      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
                          to = units[k];
                      }
                    }
                }
        
                // Return error if a unit does not exist
                if (from === null || to === null) {
                    return error.na;
                }
        
                // Return error if units represent different quantities
                if (from[3] !== to[3]) {
                    return error.na;
                }
        
                // Return converted number
                return number * from[6] * from_multiplier / (to[6] * to_multiplier);
            };
        
            exports.DEC2BIN = function(number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
        
                // Return error if number is not decimal, is lower than -512, or is
                // greater than 511
                if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character binary number if number is
                // negative
                if (number < 0) {
                    return '1' + REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
                }
        
                // Convert decimal number to binary
                var result = parseInt(number, 10).toString(2);
        
                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.DEC2HEX = function(number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
        
                // Return error if number is not decimal, is lower than -549755813888,
                // or is greater than 549755813887
                if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character hexadecimal number if number
                // is negative
                if (number < 0) {
                    return (1099511627776 + number).toString(16);
                }
        
                // Convert decimal number to hexadecimal
                var result = parseInt(number, 10).toString(16);
        
                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.DEC2OCT = function(number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
        
                // Return error if number is not decimal, is lower than -549755813888,
                // or is greater than 549755813887
                if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character octal number if number is
                // negative
                if (number < 0) {
                    return (1073741824 + number).toString(8);
                }
        
                // Convert decimal number to octal
                var result = parseInt(number, 10).toString(8);
        
                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.DELTA = function(number1, number2) {
                // Set number2 to zero if undefined
                number2 = (number2 === undefined) ? 0 : number2;
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }
        
                // Return delta
                return (number1 === number2) ? 1 : 0;
            };
        
            exports.ERF = function(lower_bound, upper_bound) {
            };
        
            exports.ERF.PRECISE = function() {
            };
        
            exports.ERFC = function(x) {
            };
        
            exports.ERFC.PRECISE = function() {
            };
        
            exports.GESTEP = function(number, step) {
                step = step || 0;
                number = utils.parseNumber(number);
                if (utils.anyIsError(step, number)) {
                    return number;
                }
        
                // Return delta
                return (number >= step) ? 1 : 0;
            };
        
            exports.HEX2BIN = function(number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Check if number is negative
                var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;
        
                // Convert hexadecimal number to decimal
                var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);
        
                // Return error if number is lower than -512 or greater than 511
                if (decimal < -512 || decimal > 511) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character binary number if number is
                // negative
                if (negative) {
                    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
                }
        
                // Convert decimal number to binary
                var result = decimal.toString(2);
        
                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.HEX2DEC = function(number) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Convert hexadecimal number to decimal
                var decimal = parseInt(number, 16);
        
                // Return decimal number
                return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
            };
        
            exports.HEX2OCT = function(number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Convert hexadecimal number to decimal
                var decimal = parseInt(number, 16);
        
                // Return error if number is positive and greater than 0x1fffffff
                // (536870911)
                if (decimal > 536870911 && decimal < 1098974756864) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character octal number if number is
                // negative
                if (decimal >= 1098974756864) {
                    return (decimal - 1098437885952).toString(8);
                }
        
                // Convert decimal number to octal
                var result = decimal.toString(8);
        
                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.IMABS = function(inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return absolute value of complex number
                return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            };
        
            exports.IMAGINARY = function(inumber) {
                if (inumber === undefined || inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Return 0 if inumber is equal to 0
                if (inumber === 0 || inumber === '0') {
                    return 0;
                }
        
                // Handle special cases
                if (['i', 'j'].indexOf(inumber) >= 0) {
                    return 1;
                }
        
                // Normalize imaginary coefficient
                inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');
        
                // Lookup sign
                var plus = inumber.indexOf('+');
                var minus = inumber.indexOf('-');
                if (plus === 0) {
                    plus = inumber.indexOf('+', 1);
                }
        
                if (minus === 0) {
                    minus = inumber.indexOf('-', 1);
                }
        
                // Lookup imaginary unit
                var last = inumber.substring(inumber.length - 1, inumber.length);
                var unit = (last === 'i' || last === 'j');
        
                if (plus >= 0 || minus >= 0) {
                    // Return error if imaginary unit is neither i nor j
                    if (!unit) {
                      return error.num;
                    }
        
                    // Return imaginary coefficient of complex number
                    if (plus >= 0) {
                      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
                          error.num :
                          Number(inumber.substring(plus + 1, inumber.length - 1));
                    } else {
                      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
                          error.num :
                          -Number(inumber.substring(minus + 1, inumber.length - 1));
                    }
                } else {
                    if (unit) {
                      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
                    } else {
                      return (isNaN(inumber)) ? error.num : 0;
                    }
                }
            };
        
            exports.IMARGUMENT = function(inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return error if inumber is equal to zero
                if (x === 0 && y === 0) {
                    return error.div0;
                }
        
                // Return PI/2 if x is equal to zero and y is positive
                if (x === 0 && y > 0) {
                    return Math.PI / 2;
                }
        
                // Return -PI/2 if x is equal to zero and y is negative
                if (x === 0 && y < 0) {
                    return -Math.PI / 2;
                }
        
                // Return zero if x is negative and y is equal to zero
                if (y === 0 && x > 0) {
                    return 0;
                }
        
                // Return zero if x is negative and y is equal to zero
                if (y === 0 && x < 0) {
                    return -Math.PI;
                }
        
                // Return argument of complex number
                if (x > 0) {
                    return Math.atan(y / x);
                } else if (x < 0 && y >= 0) {
                    return Math.atan(y / x) + Math.PI;
                } else {
                    return Math.atan(y / x) - Math.PI;
                }
            };
        
            exports.IMCONJUGATE = function(inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return conjugate of complex number
                return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
            };
        
            exports.IMCOS = function(inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return cosine of complex number
                return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
            };
        
            exports.IMCOSH = function(inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return hyperbolic cosine of complex number
                return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
            };
        
            exports.IMCOT = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return cotangent of complex number
                return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
            };
        
            exports.IMDIV = function(inumber1, inumber2) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var a = exports.IMREAL(inumber1);
                var b = exports.IMAGINARY(inumber1);
                var c = exports.IMREAL(inumber2);
                var d = exports.IMAGINARY(inumber2);
        
                if (utils.anyIsError(a, b, c, d)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit1 = inumber1.substring(inumber1.length - 1);
                var unit2 = inumber2.substring(inumber2.length - 1);
                var unit = 'i';
                if (unit1 === 'j') {
                    unit = 'j';
                } else if (unit2 === 'j') {
                    unit = 'j';
                }
        
                // Return error if inumber2 is null
                if (c === 0 && d === 0) {
                    return error.num;
                }
        
                // Return exponential of complex number
                var den = c * c + d * d;
                return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
            };
        
            exports.IMEXP = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return exponential of complex number
                var e = Math.exp(x);
                return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
            };
        
            exports.IMLN = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
            };
        
            exports.IMLOG10 = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
            };
        
            exports.IMLOG2 = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
            };
        
            exports.IMPOWER = function(inumber, number) {
                number = utils.parseNumber(number);
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
                if (utils.anyIsError(number, x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Calculate power of modulus
                var p = Math.pow(exports.IMABS(inumber), number);
        
                // Calculate argument
                var t = exports.IMARGUMENT(inumber);
        
                // Return exponential of complex number
                return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
            };
        
            exports.IMPRODUCT = function() {
                // Initialize result
                var result = arguments[0];
        
                // Loop on all numbers
                for (var i = 1; i < arguments.length; i++) {
                    // Lookup coefficients of two complex numbers
                    var a = exports.IMREAL(result);
                    var b = exports.IMAGINARY(result);
                    var c = exports.IMREAL(arguments[i]);
                    var d = exports.IMAGINARY(arguments[i]);
        
                    if (utils.anyIsError(a, b, c, d)) {
                      return error.value;
                    }
        
                    // Complute product of two complex numbers
                    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
                }
        
                // Return product of complex numbers
                return result;
            };
        
            exports.IMREAL = function(inumber) {
                if (inumber === undefined || inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Return 0 if inumber is equal to 0
                if (inumber === 0 || inumber === '0') {
                    return 0;
                }
        
                // Handle special cases
                if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
                    return 0;
                }
        
                // Lookup sign
                var plus = inumber.indexOf('+');
                var minus = inumber.indexOf('-');
                if (plus === 0) {
                    plus = inumber.indexOf('+', 1);
                }
                if (minus === 0) {
                    minus = inumber.indexOf('-', 1);
                }
        
                // Lookup imaginary unit
                var last = inumber.substring(inumber.length - 1, inumber.length);
                var unit = (last === 'i' || last === 'j');
        
                if (plus >= 0 || minus >= 0) {
                    // Return error if imaginary unit is neither i nor j
                    if (!unit) {
                      return error.num;
                    }
        
                    // Return real coefficient of complex number
                    if (plus >= 0) {
                      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
                          error.num :
                          Number(inumber.substring(0, plus));
                    } else {
                      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
                          error.num :
                          Number(inumber.substring(0, minus));
                    }
                } else {
                    if (unit) {
                      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
                    } else {
                      return (isNaN(inumber)) ? error.num : inumber;
                    }
                }
            };
        
            exports.IMSEC = function(inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return secant of complex number
                return exports.IMDIV('1', exports.IMCOS(inumber));
            };
        
            exports.IMSECH = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return hyperbolic secant of complex number
                return exports.IMDIV('1', exports.IMCOSH(inumber));
            };
        
            exports.IMSIN = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return sine of complex number
                return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
            };
        
            exports.IMSINH = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Return hyperbolic sine of complex number
                return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
            };
        
            exports.IMSQRT = function(inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';
        
                // Calculate power of modulus
                var s = Math.sqrt(exports.IMABS(inumber));
        
                // Calculate argument
                var t = exports.IMARGUMENT(inumber);
        
                // Return exponential of complex number
                return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
            };
        
            exports.IMCSC = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.num;
                }
        
                // Return cosecant of complex number
                return exports.IMDIV('1', exports.IMSIN(inumber));
            };
        
            exports.IMCSCH = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.num;
                }
        
                // Return hyperbolic cosecant of complex number
                return exports.IMDIV('1', exports.IMSINH(inumber));
            };
        
            exports.IMSUB = function(inumber1, inumber2) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var a = this.IMREAL(inumber1);
                var b = this.IMAGINARY(inumber1);
                var c = this.IMREAL(inumber2);
                var d = this.IMAGINARY(inumber2);
        
                if (utils.anyIsError(a, b, c, d)) {
                    return error.value;
                }
        
                // Lookup imaginary unit
                var unit1 = inumber1.substring(inumber1.length - 1);
                var unit2 = inumber2.substring(inumber2.length - 1);
                var unit = 'i';
                if (unit1 === 'j') {
                    unit = 'j';
                } else if (unit2 === 'j') {
                    unit = 'j';
                }
        
                // Return _ of two complex numbers
                return this.COMPLEX(a - c, b - d, unit);
            };
        
            exports.IMSUM = function() {
                var args = utils.flatten(arguments);
        
                // Initialize result
                var result = args[0];
        
                // Loop on all numbers
                for (var i = 1; i < args.length; i++) {
                    // Lookup coefficients of two complex numbers
                    var a = this.IMREAL(result);
                    var b = this.IMAGINARY(result);
                    var c = this.IMREAL(args[i]);
                    var d = this.IMAGINARY(args[i]);
        
                    if (utils.anyIsError(a, b, c, d)) {
                      return error.value;
                    }
        
                    // Complute product of two complex numbers
                    result = this.COMPLEX(a + c, b + d);
                }
        
                // Return sum of complex numbers
                return result;
            };
        
            exports.IMTAN = function(inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }
        
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
        
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }
        
                // Return tangent of complex number
                return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
            };
        
            exports.OCT2BIN = function(number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Check if number is negative
                var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;
        
                // Convert octal number to decimal
                var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);
        
                // Return error if number is lower than -512 or greater than 511
                if (decimal < -512 || decimal > 511) {
                    return error.num;
                }
        
                // Ignore places and return a 10-character binary number if number is
                // negative
                if (negative) {
                    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
                }
        
                // Convert decimal number to binary
                var result = decimal.toString(2);
        
                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            exports.OCT2DEC = function(number) {
                // Return error if number is not octal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Convert octal number to decimal
                var decimal = parseInt(number, 8);
        
                // Return decimal number
                return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
            };
        
            exports.OCT2HEX = function(number, places) {
                // Return error if number is not octal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }
        
                // Convert octal number to decimal
                var decimal = parseInt(number, 8);
        
                // Ignore places and return a 10-character octal number if number is
                // negative
                if (decimal >= 536870912) {
                    return 'ff' + (decimal + 3221225472).toString(16);
                }
        
                // Convert decimal number to hexadecimal
                var result = decimal.toString(16);
        
                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                      return error.value;
                    }
        
                    // Return error if places is negative
                    if (places < 0) {
                      return error.num;
                    }
        
                    // Truncate places in case it is not an integer
                    places = Math.floor(places);
        
                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };
        
            return exports;
        })();
        
        jexcel.methods.financial = (function() {
            var exports = {};
        
            function validDate(d) {
                return d && d.getTime && !isNaN(d.getTime());
            }
        
            function ensureDate(d) {
                return (d instanceof Date)?d:new Date(d);
            }
        
            exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
                // Return error if either date is invalid
                issue        = ensureDate(issue);
                first        = ensureDate(first);
                settlement = ensureDate(settlement);
                if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
                    return '#VALUE!';
                }
        
                // Return error if either rate or par are lower than or equal to zero
                if (rate <= 0 || par <= 0) {
                    return '#NUM!';
                }
        
                // Return error if frequency is neither 1, 2, or 4
                if ([1, 2, 4].indexOf(frequency) === -1) {
                    return '#NUM!';
                }
        
                // Return error if basis is neither 0, 1, 2, 3, or 4
                if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
                    return '#NUM!';
                }
        
                // Return error if settlement is before or equal to issue
                if (settlement <= issue) {
                    return '#NUM!';
                }
        
                // Set default values
                par   = par   || 0;
                basis = basis || 0;
        
                // Compute accrued interest
                return par * rate * YEARFRAC(issue, settlement, basis);
            };
        
            exports.ACCRINTM = null;
        
            exports.AMORDEGRC = null;
        
            exports.AMORLINC = null;
        
            exports.COUPDAYBS = null;
        
            exports.COUPDAYS = null;
        
            exports.COUPDAYSNC = null;
        
            exports.COUPNCD = null;
        
            exports.COUPNUM = null;
        
            exports.COUPPCD = null;
        
            exports.CUMIPMT = function(rate, periods, value, start, end, type) {
                // Credits: algorithm inspired by Apache OpenOffice
                // Credits: Hannes Stiebitzhofer for the translations of function and
                    // variable names
                // Requires exports.FV() and exports.PMT() from exports.js
                    // [http://stoic.com/exports/]
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, periods, value)) {
                    return error.value;
                }
        
                // Return error if either rate, periods, or value are lower than or
                    // equal to zero
                if (rate <= 0 || periods <= 0 || value <= 0) {
                    return error.num;
                }
        
                // Return error if start < 1, end < 1, or start > end
                if (start < 1 || end < 1 || start > end) {
                    return error.num;
                }
        
                // Return error if type is neither 0 nor 1
                if (type !== 0 && type !== 1) {
                    return error.num;
                }
        
                // Compute cumulative interest
                var payment = exports.PMT(rate, periods, value, 0, type);
                var interest = 0;
        
                if (start === 1) {
                    if (type === 0) {
                        interest = -value;
                        start++;
                    }
                }
        
                for (var i = start; i <= end; i++) {
                    if (type === 1) {
                        interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
                    } else {
                        interest += exports.FV(rate, i - 1, payment, value, 0);
                    }
                }
                interest *= rate;
        
                // Return cumulative interest
                return interest;
            };
        
            exports.CUMPRINC = function(rate, periods, value, start, end, type) {
                // Credits: algorithm inspired by Apache OpenOffice
                // Credits: Hannes Stiebitzhofer for the translations of function and
                    // variable names
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, periods, value)) {
                    return error.value;
                }
        
                // Return error if either rate, periods, or value are lower than or
                    // equal to zero
                if (rate <= 0 || periods <= 0 || value <= 0) {
                    return error.num;
                }
        
                // Return error if start < 1, end < 1, or start > end
                if (start < 1 || end < 1 || start > end) {
                    return error.num;
                }
        
                // Return error if type is neither 0 nor 1
                if (type !== 0 && type !== 1) {
                    return error.num;
                }
        
                // Compute cumulative principal
                var payment = exports.PMT(rate, periods, value, 0, type);
                var principal = 0;
                if (start === 1) {
                    if (type === 0) {
                        principal = payment + value * rate;
                    } else {
                        principal = payment;
                    }
                    start++;
                }
                for (var i = start; i <= end; i++) {
                    if (type > 0) {
                        principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
                    } else {
                        principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
                    }
                }
        
                // Return cumulative principal
                return principal;
            };
        
            exports.DB = function(cost, salvage, life, period, month) {
                // Initialize month
                month = (month === undefined) ? 12 : month;
        
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                month = utils.parseNumber(month);
                if (utils.anyIsError(cost, salvage, life, period, month)) {
                    return error.value;
                }
        
                // Return error if any of the parameters is negative
                if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
                    return error.num;
                }
        
                // Return error if month is not an integer between 1 and 12
                if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
                    return error.num;
                }
        
                // Return error if period is greater than life
                if (period > life) {
                    return error.num;
                }
        
                // Return 0 (zero) if salvage is greater than or equal to cost
                if (salvage >= cost) {
                    return 0;
                }
        
                // Rate is rounded to three decimals places
                var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);
        
                // Compute initial depreciation
                var initial = cost * rate * month / 12;
        
                // Compute total depreciation
                var total = initial;
                var current = 0;
                var ceiling = (period === life) ? life - 1 : period;
                for (var i = 2; i <= ceiling; i++) {
                    current = (cost - total) * rate;
                    total += current;
                }
        
                // Depreciation for the first and last periods are special cases
                if (period === 1) {
                    // First period
                    return initial;
                } else if (period === life) {
                    // Last period
                    return (cost - total) * rate;
                } else {
                    return current;
                }
            };
        
            exports.DDB = function(cost, salvage, life, period, factor) {
                // Initialize factor
                factor = (factor === undefined) ? 2 : factor;
        
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                factor = utils.parseNumber(factor);
                if (utils.anyIsError(cost, salvage, life, period, factor)) {
                    return error.value;
                }
        
                // Return error if any of the parameters is negative or if factor is
                    // null
                if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
                    return error.num;
                }
        
                // Return error if period is greater than life
                if (period > life) {
                    return error.num;
                }
        
                // Return 0 (zero) if salvage is greater than or equal to cost
                if (salvage >= cost) {
                    return 0;
                }
        
                // Compute depreciation
                var total = 0;
                var current = 0;
                for (var i = 1; i <= period; i++) {
                    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
                    total += current;
                }
        
                // Return depreciation
                return current;
            };
        
            exports.DISC = null;
        
            exports.DOLLARDE = function(dollar, fraction) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                dollar = utils.parseNumber(dollar);
                fraction = utils.parseNumber(fraction);
                if (utils.anyIsError(dollar, fraction)) {
                    return error.value;
                }
        
                // Return error if fraction is negative
                if (fraction < 0) {
                    return error.num;
                }
        
                // Return error if fraction is greater than or equal to 0 and less than
                    // 1
                if (fraction >= 0 && fraction < 1) {
                    return error.div0;
                }
        
                // Truncate fraction if it is not an integer
                fraction = parseInt(fraction, 10);
        
                // Compute integer part
                var result = parseInt(dollar, 10);
        
                // Add decimal part
                result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;
        
                // Round result
                var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
                result = Math.round(result * power) / power;
        
                // Return converted dollar price
                return result;
            };
        
            exports.DOLLARFR = function(dollar, fraction) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                dollar = utils.parseNumber(dollar);
                fraction = utils.parseNumber(fraction);
                if (utils.anyIsError(dollar, fraction)) {
                    return error.value;
                }
        
                // Return error if fraction is negative
                if (fraction < 0) {
                    return error.num;
                }
        
                // Return error if fraction is greater than or equal to 0 and less than
                    // 1
                if (fraction >= 0 && fraction < 1) {
                    return error.div0;
                }
        
                // Truncate fraction if it is not an integer
                fraction = parseInt(fraction, 10);
        
                // Compute integer part
                var result = parseInt(dollar, 10);
        
                // Add decimal part
                result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;
        
                // Return converted dollar price
                return result;
            };
        
            exports.DURATION = null;
        
            exports.EFFECT = function(rate, periods) {
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                if (utils.anyIsError(rate, periods)) {
                    return error.value;
                }
        
                // Return error if rate <=0 or periods < 1
                if (rate <= 0 || periods < 1) {
                    return error.num;
                }
        
                // Truncate periods if it is not an integer
                periods = parseInt(periods, 10);
        
                // Return effective annual interest rate
                return Math.pow(1 + rate / periods, periods) - 1;
            };
        
            exports.FV = function(rate, periods, payment, value, type) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                value = value || 0;
                type = type || 0;
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                value = utils.parseNumber(value);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, payment, value, type)) {
                    return error.value;
                }
        
                // Return future value
                var result;
                if (rate === 0) {
                    result = value + payment * periods;
                } else {
                    var term = Math.pow(1 + rate, periods);
                    if (type === 1) {
                        result = value * term + payment * (1 + rate) * (term - 1) / rate;
                    } else {
                        result = value * term + payment * (term - 1) / rate;
                    }
                }
                return -result;
            };
        
            exports.FVSCHEDULE = function(principal, schedule) {
                principal = utils.parseNumber(principal);
                schedule = utils.parseNumberArray(utils.flatten(schedule));
                if (utils.anyIsError(principal, schedule)) {
                    return error.value;
                }
        
                var n = schedule.length;
                var future = principal;
        
                // Apply all interests in schedule
                for (var i = 0; i < n; i++) {
                    // Apply scheduled interest
                    future *= 1 + schedule[i];
                }
        
                // Return future value
                return future;
            };
        
            exports.INTRATE = null;
        
            exports.IPMT = function(rate, period, periods, present, future, type) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                future = future || 0;
                type = type || 0;
        
                rate = utils.parseNumber(rate);
                period = utils.parseNumber(period);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, period, periods, present, future, type)) {
                    return error.value;
                }
        
                // Compute payment
                var payment = exports.PMT(rate, periods, present, future, type);
        
                // Compute interest
                var interest;
                if (period === 1) {
                    if (type === 1) {
                        interest = 0;
                    } else {
                        interest = -present;
                    }
                } else {
                    if (type === 1) {
                        interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
                    } else {
                        interest = exports.FV(rate, period - 1, payment, present, 0);
                    }
                }
        
                // Return interest
                return interest * rate;
            };
        
            exports.IRR = function(values, guess) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                guess = guess || 0;
        
                values = utils.parseNumberArray(utils.flatten(values));
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(values, guess)) {
                    return error.value;
                }
        
                // Calculates the resulting amount
                var irrResult = function(values, dates, rate) {
                    var r = rate + 1;
                    var result = values[0];
                    for (var i = 1; i < values.length; i++) {
                        result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
                    }
                    return result;
                };
        
                // Calculates the first derivation
                var irrResultDeriv = function(values, dates, rate) {
                    var r = rate + 1;
                    var result = 0;
                    for (var i = 1; i < values.length; i++) {
                        var frac = (dates[i] - dates[0]) / 365;
                        result -= frac * values[i] / Math.pow(r, frac + 1);
                    }
                    return result;
                };
        
                // Initialize dates and check that values contains at least one positive
                    // value and one negative value
                var dates = [];
                var positive = false;
                var negative = false;
                for (var i = 0; i < values.length; i++) {
                    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
                    if (values[i] > 0) {
                        positive = true;
                    }
                    if (values[i] < 0) {
                        negative = true;
                    }
                }
        
                // Return error if values does not contain at least one positive value
                    // and one negative value
                if (!positive || !negative) {
                    return error.num;
                }
        
                // Initialize guess and resultRate
                guess = (guess === undefined) ? 0.1 : guess;
                var resultRate = guess;
        
                // Set maximum epsilon for end of iteration
                var epsMax = 1e-10;
        
                // Implement Newton's method
                var newRate, epsRate, resultValue;
                var contLoop = true;
                do {
                    resultValue = irrResult(values, dates, resultRate);
                    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
                    epsRate = Math.abs(newRate - resultRate);
                    resultRate = newRate;
                    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
                } while (contLoop);
        
                // Return internal rate of return
                return resultRate;
            };
        
            exports.ISPMT = function(rate, period, periods, value) {
                rate = utils.parseNumber(rate);
                period = utils.parseNumber(period);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, period, periods, value)) {
                    return error.value;
                }
        
                // Return interest
                return value * rate * (period / periods - 1);
            };
        
            exports.MDURATION = null;
        
            exports.MIRR = function(values, finance_rate, reinvest_rate) {
                values = utils.parseNumberArray(utils.flatten(values));
                finance_rate = utils.parseNumber(finance_rate);
                reinvest_rate = utils.parseNumber(reinvest_rate);
                if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
                    return error.value;
                }
        
                // Initialize number of values
                var n = values.length;
        
                // Lookup payments (negative values) and incomes (positive values)
                var payments = [];
                var incomes = [];
                for (var i = 0; i < n; i++) {
                    if (values[i] < 0) {
                        payments.push(values[i]);
                    } else {
                        incomes.push(values[i]);
                    }
                }
        
                // Return modified internal rate of return
                var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
                var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
                return Math.pow(num / den, 1 / (n - 1)) - 1;
            };
        
            exports.NOMINAL = function(rate, periods) {
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                if (utils.anyIsError(rate, periods)) {
                    return error.value;
                }
        
                // Return error if rate <=0 or periods < 1
                if (rate <= 0 || periods < 1) {
                    return error.num;
                }
        
                // Truncate periods if it is not an integer
                periods = parseInt(periods, 10);
        
                // Return nominal annual interest rate
                return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
            };
        
            exports.NPER = function(rate, payment, present, future, type) {
                type = (type === undefined) ? 0 : type;
                future = (future === undefined) ? 0 : future;
        
                rate = utils.parseNumber(rate);
                payment = utils.parseNumber(payment);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, payment, present, future, type)) {
                    return error.value;
                }
        
                // Return number of periods
                var num = payment * (1 + rate * type) - future * rate;
                var den = (present * rate + payment * (1 + rate * type));
                return Math.log(num / den) / Math.log(1 + rate);
            };
        
            exports.NPV = function() {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }
        
                // Lookup rate
                var rate = args[0];
        
                // Initialize net present value
                var value = 0;
        
                // Loop on all values
                for (var j = 1; j < args.length; j++) {
                    value += args[j] / Math.pow(1 + rate, j);
                }
        
                // Return net present value
                return value;
            };
        
            exports.ODDFPRICE = null;
        
            exports.ODDFYIELD = null;
        
            exports.ODDLPRICE = null;
        
            exports.ODDLYIELD = null;
        
            exports.PDURATION = function(rate, present, future) {
                rate = utils.parseNumber(rate);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                if (utils.anyIsError(rate, present, future)) {
                    return error.value;
                }
        
                // Return error if rate <=0
                if (rate <= 0) {
                    return error.num;
                }
        
                // Return number of periods
                return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
            };
        
            exports.PMT = function(rate, periods, present, future, type) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                future = future || 0;
                type = type || 0;
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, present, future, type)) {
                    return error.value;
                }
        
                // Return payment
                var result;
                if (rate === 0) {
                    result = (present + future) / periods;
                } else {
                    var term = Math.pow(1 + rate, periods);
                    if (type === 1) {
                        result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
                    } else {
                        result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
                    }
                }
                return -result;
            };
        
            exports.PPMT = function(rate, period, periods, present, future, type) {
                future = future || 0;
                type = type || 0;
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, present, future, type)) {
                    return error.value;
                }
        
                return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
            };
        
            exports.PRICE = null;
        
            exports.PRICEDISC = null;
        
            exports.PRICEMAT = null;
        
            exports.PV = function(rate, periods, payment, future, type) {
                future = future || 0;
                type = type || 0;
        
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, payment, future, type)) {
                    return error.value;
                }
        
                // Return present value
                if (rate === 0) {
                    return -payment * periods - future;
                } else {
                    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
                }
            };
        
            exports.RATE = function(periods, payment, present, future, type, guess) {
                // Credits: rabugento
        
                guess = (guess === undefined) ? 0.01 : guess;
                future = (future === undefined) ? 0 : future;
                type = (type === undefined) ? 0 : type;
        
                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(periods, payment, present, future, type, guess)) {
                    return error.value;
                }
        
                // Set maximum epsilon for end of iteration
                var epsMax = 1e-6;
        
                // Set maximum number of iterations
                var iterMax = 100;
                var iter = 0;
                var close = false;
                var rate = guess;
        
                while (iter < iterMax && !close) {
                    var t1 = Math.pow(rate + 1, periods);
                    var t2 = Math.pow(rate + 1, periods - 1);
        
                    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
                    var f2 = periods * t2 * present - payment * (t1 - 1) *(rate * type + 1) / Math.pow(rate,2);
                    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;
        
                    var newRate = rate - f1 / (f2 + f3);
        
                    if (Math.abs(newRate - rate) < epsMax) close = true;
                    iter++;
                    rate = newRate;
                }
        
                if (!close) return Number.NaN + rate;
                return rate;
            };
        
            // TODO
            exports.RECEIVED = null;
        
            exports.RRI = function(periods, present, future) {
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                if (utils.anyIsError(periods, present, future)) {
                    return error.value;
                }
        
                // Return error if periods or present is equal to 0 (zero)
                if (periods === 0 || present === 0) {
                    return error.num;
                }
        
                // Return equivalent interest rate
                return Math.pow(future / present, 1 / periods) - 1;
            };
        
            exports.SLN = function(cost, salvage, life) {
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                if (utils.anyIsError(cost, salvage, life)) {
                    return error.value;
                }
        
                // Return error if life equal to 0 (zero)
                if (life === 0) {
                    return error.num;
                }
        
                // Return straight-line depreciation
                return (cost - salvage) / life;
            };
        
            exports.SYD = function(cost, salvage, life, period) {
                // Return error if any of the parameters is not a number
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                if (utils.anyIsError(cost, salvage, life, period)) {
                    return error.value;
                }
        
                // Return error if life equal to 0 (zero)
                if (life === 0) {
                    return error.num;
                }
        
                // Return error if period is lower than 1 or greater than life
                if (period < 1 || period > life) {
                    return error.num;
                }
        
                // Truncate period if it is not an integer
                period = parseInt(period, 10);
        
                // Return straight-line depreciation
                return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
            };
        
            exports.TBILLEQ = function(settlement, maturity, discount) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                discount = utils.parseNumber(discount);
                if (utils.anyIsError(settlement, maturity, discount)) {
                    return error.value;
                }
        
                // Return error if discount is lower than or equal to zero
                if (discount <= 0) {
                    return error.num;
                }
        
                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }
        
                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }
        
                // Return bond-equivalent yield
                return (365 * discount) / (360 - discount * DAYS360(settlement, maturity, false));
            };
        
            exports.TBILLPRICE = function(settlement, maturity, discount) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                discount = utils.parseNumber(discount);
                if (utils.anyIsError(settlement, maturity, discount)) {
                    return error.value;
                }
        
                // Return error if discount is lower than or equal to zero
                if (discount <= 0) {
                    return error.num;
                }
        
                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }
        
                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }
        
                // Return bond-equivalent yield
                return 100 * (1 - discount * DAYS360(settlement, maturity, false) / 360);
            };
        
            exports.TBILLYIELD = function(settlement, maturity, price) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                price = utils.parseNumber(price);
                if (utils.anyIsError(settlement, maturity, price)) {
                    return error.value;
                }
        
                // Return error if price is lower than or equal to zero
                if (price <= 0) {
                    return error.num;
                }
        
                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }
        
                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }
        
                // Return bond-equivalent yield
                return (100 - price) * 360 / (price * DAYS360(settlement, maturity, false));
            };
        
            exports.VDB = null;
        
            exports.XIRR = function(values, dates, guess) {
                // Credits: algorithm inspired by Apache OpenOffice
        
                values = utils.parseNumberArray(utils.flatten(values));
                dates = utils.parseDateArray(utils.flatten(dates));
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(values, dates, guess)) {
                    return error.value;
                }
        
                // Calculates the resulting amount
                var irrResult = function(values, dates, rate) {
                    var r = rate + 1;
                    var result = values[0];
                    for (var i = 1; i < values.length; i++) {
                        result += values[i] / Math.pow(r, DAYS(dates[i], dates[0]) / 365);
                    }
                    return result;
                };
        
                // Calculates the first derivation
                var irrResultDeriv = function(values, dates, rate) {
                    var r = rate + 1;
                    var result = 0;
                    for (var i = 1; i < values.length; i++) {
                        var frac = DAYS(dates[i], dates[0]) / 365;
                        result -= frac * values[i] / Math.pow(r, frac + 1);
                    }
                    return result;
                };
        
                // Check that values contains at least one positive value and one
                    // negative value
                var positive = false;
                var negative = false;
                for (var i = 0; i < values.length; i++) {
                    if (values[i] > 0) {
                        positive = true;
                    }
                    if (values[i] < 0) {
                        negative = true;
                    }
                }
        
                // Return error if values does not contain at least one positive value
                    // and one negative value
                if (!positive || !negative) {
                    return error.num;
                }
        
                // Initialize guess and resultRate
                guess = guess || 0.1;
                var resultRate = guess;
        
                // Set maximum epsilon for end of iteration
                var epsMax = 1e-10;
        
                // Implement Newton's method
                var newRate, epsRate, resultValue;
                var contLoop = true;
                do {
                    resultValue = irrResult(values, dates, resultRate);
                    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
                    epsRate = Math.abs(newRate - resultRate);
                    resultRate = newRate;
                    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
                } while (contLoop);
        
                // Return internal rate of return
                return resultRate;
            };
        
            exports.XNPV = function(rate, values, dates) {
                rate = utils.parseNumber(rate);
                values = utils.parseNumberArray(utils.flatten(values));
                dates = utils.parseDateArray(utils.flatten(dates));
                if (utils.anyIsError(rate, values, dates)) {
                    return error.value;
                }
        
                var result = 0;
                for (var i = 0; i < values.length; i++) {
                    result += values[i] / Math.pow(1 + rate, DAYS(dates[i], dates[0]) / 365);
                }
                return result;
            };
        
            exports.YIELD = null;
        
            exports.YIELDDISC = null;
        
            exports.YIELDMAT = null;
        
            return exports;
        })();
        
        jexcel.methods.information = (function() {
            var exports = {};
            exports.CELL = null;
        
            exports.ERROR = {};
            exports.ERROR.TYPE = function(error_val) {
                switch (error_val) {
                    case error.nil: return 1;
                    case error.div0: return 2;
                    case error.value: return 3;
                    case error.ref: return 4;
                    case error.name: return 5;
                    case error.num: return 6;
                    case error.na: return 7;
                    case error.data: return 8;
                }
                return error.na;
            };
        
            exports.INFO = null;
        
            exports.ISBLANK = function(value) {
                return value === null;
            };
        
            exports.ISBINARY = function (number) {
                return (/^[01]{1,10}$/).test(number);
            };
        
            exports.ISERR = function(value) {
                return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
                    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
            };
        
            exports.ISERROR = function(value) {
                return exports.ISERR(value) || value === error.na;
            };
        
            exports.ISEVEN = function(number) {
                return (Math.floor(Math.abs(number)) & 1) ? false : true;
            };
        
            // TODO
            exports.ISFORMULA = null;
        
            exports.ISLOGICAL = function(value) {
                return value === true || value === false;
            };
        
            exports.ISNA = function(value) {
                return value === error.na;
            };
        
            exports.ISNONTEXT = function(value) {
                return typeof(value) !== 'string';
            };
        
            exports.ISNUMBER = function(value) {
                return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
            };
        
            exports.ISODD = function(number) {
                return (Math.floor(Math.abs(number)) & 1) ? true : false;
            };
        
            exports.ISREF = null;
        
            exports.ISTEXT = function(value) {
                return typeof(value) === 'string';
            };
        
            exports.N = function(value) {
                if (this.ISNUMBER(value)) {
                    return value;
                }
                if (value instanceof Date) {
                    return value.getTime();
                }
                if (value === true) {
                    return 1;
                }
                if (value === false) {
                    return 0;
                }
                if (this.ISERROR(value)) {
                    return value;
                }
                return 0;
            };
        
            exports.NA = function() {
                return error.na;
            };
        
            exports.SHEET = null;
        
            exports.SHEETS = null;
        
            exports.TYPE = function(value) {
                if (this.ISNUMBER(value)) {
                    return 1;
                }
                if (this.ISTEXT(value)) {
                    return 2;
                }
                if (this.ISLOGICAL(value)) {
                    return 4;
                }
                if (this.ISERROR(value)) {
                    return 16;
                }
                if (Array.isArray(value)) {
                    return 64;
                }
            };
        
            return exports;
        })();
        
        jexcel.methods.logical = (function() {
            var exports = {};
        
            exports.AND = function() {
                var args = utils.flatten(arguments);
                var result = true;
                for (var i = 0; i < args.length; i++) {
                    if (!args[i]) {
                        result = false;
                    }
                }
                return result;
            };
        
            exports.CHOOSE = function() {
                if (arguments.length < 2) {
                    return error.na;
                }
        
                var index = arguments[0];
                if (index < 1 || index > 254) {
                    return error.value;
                }
        
                if (arguments.length < index + 1) {
                    return error.value;
                }
        
                return arguments[index];
            };
        
            exports.FALSE = function() {
                return false;
            };
        
            exports.IF = function(test, then_value, otherwise_value) {
                return test ? then_value : otherwise_value;
            };
        
            exports.IFERROR = function(value, valueIfError) {
                if (ISERROR(value)) {
                    return valueIfError;
                }
                return value;
            };
        
            exports.IFNA = function(value, value_if_na) {
                return value === error.na ? value_if_na : value;
            };
        
            exports.NOT = function(logical) {
                return !logical;
            };
        
            exports.OR = function() {
                var args = utils.flatten(arguments);
                var result = false;
                for (var i = 0; i < args.length; i++) {
                    if (args[i]) {
                        result = true;
                    }
                }
                return result;
            };
        
            exports.TRUE = function() {
                return true;
            };
        
            exports.XOR = function() {
                var args = utils.flatten(arguments);
                var result = 0;
                for (var i = 0; i < args.length; i++) {
                    if (args[i]) {
                        result++;
                    }
                }
                return (Math.floor(Math.abs(result)) & 1) ? true : false;
            };
        
            exports.SWITCH = function() {
                var result;
                if (arguments.length > 0)  {
                    var targetValue = arguments[0];
                    var argc = arguments.length - 1;
                    var switchCount = Math.floor(argc / 2);
                    var switchSatisfied = false;
                    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];
        
                    if (switchCount) {
                        for (var index = 0; index < switchCount; index++) {
                            if (targetValue === arguments[index * 2 + 1]) {
                              result = arguments[index * 2 + 2];
                              switchSatisfied = true;
                              break;
                            }
                        }
                    }
        
                    if (!switchSatisfied && defaultClause) {
                        result = defaultClause;
                    }
                }
        
                return result;
            };
        
            return exports;
        })();
        
        jexcel.methods.math = (function() {
            var exports = {};
        
            exports.ABS = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.abs(utils.parseNumber(number));
            };
        
            exports.ACOS = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.acos(number);
            };
        
            exports.ACOSH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number + Math.sqrt(number * number - 1));
            };
        
            exports.ACOT = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.atan(1 / number);
            };
        
            exports.ACOTH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 0.5 * Math.log((number + 1) / (number - 1));
            };
        
            exports.AGGREGATE = null;
        
            exports.ARABIC = function(text) {
                // Credits: Rafa? Kukawski
                if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
                    return error.value;
                }
                var r = 0;
                text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
                    r += {
                        M: 1000,
                        CM: 900,
                        D: 500,
                        CD: 400,
                        C: 100,
                        XC: 90,
                        L: 50,
                        XL: 40,
                        X: 10,
                        IX: 9,
                        V: 5,
                        IV: 4,
                        I: 1
                    }[i];
                });
                return r;
            };
        
            exports.ASIN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.asin(number);
            };
        
            exports.ASINH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number + Math.sqrt(number * number + 1));
            };
        
            exports.ATAN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.atan(number);
            };
        
            exports.ATAN2 = function(number_x, number_y) {
                number_x = utils.parseNumber(number_x);
                number_y = utils.parseNumber(number_y);
                if (utils.anyIsError(number_x, number_y)) {
                    return error.value;
                }
                return Math.atan2(number_x, number_y);
            };
        
            exports.ATANH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log((1 + number) / (1 - number)) / 2;
            };
        
            exports.BASE = function(number, radix, min_length) {
                min_length = min_length || 0;
        
                number = utils.parseNumber(number);
                radix = utils.parseNumber(radix);
                min_length = utils.parseNumber(min_length);
                if (utils.anyIsError(number, radix, min_length)) {
                    return error.value;
                }
                min_length = (min_length === undefined) ? 0 : min_length;
                var result = number.toString(radix);
                return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
            };
        
            exports.CEILING = function(number, significance, mode) {
                significance = (significance === undefined) ? 1 : significance;
                mode = (mode === undefined) ? 0 : mode;
        
                number = utils.parseNumber(number);
                significance = utils.parseNumber(significance);
                mode = utils.parseNumber(mode);
                if (utils.anyIsError(number, significance, mode)) {
                    return error.value;
                }
                if (significance === 0) {
                    return 0;
                }
        
                significance = Math.abs(significance);
                if (number >= 0) {
                    return Math.ceil(number / significance) * significance;
                } else {
                    if (mode === 0) {
                        return -1 * Math.floor(Math.abs(number) / significance) * significance;
                    } else {
                        return -1 * Math.ceil(Math.abs(number) / significance) * significance;
                    }
                }
            };
        
            exports.CEILING.MATH = exports.CEILING;
        
            exports.CEILING.PRECISE = exports.CEILING;
        
            exports.COMBIN = function(number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
            };
        
            exports.COMBINA = function(number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
            };
        
            exports.COS = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.cos(number);
            };
        
            exports.COSH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return (Math.exp(number) + Math.exp(-number)) / 2;
            };
        
            exports.COT = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.tan(number);
            };
        
            exports.COTH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var e2 = Math.exp(2 * number);
                return (e2 + 1) / (e2 - 1);
            };
        
            exports.CSC = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.sin(number);
            };
        
            exports.CSCH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 2 / (Math.exp(number) - Math.exp(-number));
            };
        
            exports.DECIMAL = function(number, radix) {
                if (arguments.length < 1) {
                    return error.value;
                }
        
        
                return parseInt(number, radix);
            };
        
            exports.DEGREES = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return number * 180 / Math.PI;
            };
        
            exports.EVEN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return exports.CEILING(number, -2, -1);
            };
        
            exports.EXP = Math.exp;
        
            var MEMOIZED_FACT = [];
            exports.FACT = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var n = Math.floor(number);
                if (n === 0 || n === 1) {
                    return 1;
                } else if (MEMOIZED_FACT[n] > 0) {
                    return MEMOIZED_FACT[n];
                } else {
                    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
                    return MEMOIZED_FACT[n];
                }
            };
        
            exports.FACTDOUBLE = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var n = Math.floor(number);
                if (n <= 0) {
                    return 1;
                } else {
                    return n * exports.FACTDOUBLE(n - 2);
                }
            };
        
            exports.FLOOR = function(number, significance, mode) {
                significance = (significance === undefined) ? 1 : significance;
                mode = (mode === undefined) ? 0 : mode;
        
                number = utils.parseNumber(number);
                significance = utils.parseNumber(significance);
                mode = utils.parseNumber(mode);
                if (utils.anyIsError(number, significance, mode)) {
                    return error.value;
                }
                if (significance === 0) {
                    return 0;
                }
        
                significance = Math.abs(significance);
                if (number >= 0) {
                    return Math.floor(number / significance) * significance;
                } else {
                    if (mode === 0) {
                        return -1 * Math.ceil(Math.abs(number) / significance) * significance;
                    } else {
                        return -1 * Math.floor(Math.abs(number) / significance) * significance;
                    }
                }
            };
        
            exports.FLOOR.MATH = exports.FLOOR;
        
            exports.GCD = null;
        
            exports.INT = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.floor(number);
            };
        
            exports.LCM = function() {
                // Credits: Jonas Raoni Soares Silva
                var o = utils.parseNumberArray(utils.flatten(arguments));
                if (o instanceof Error) {
                    return o;
                }
                for (var i, j, n, d, r = 1;
                    (n = o.pop()) !== undefined;) {
                    while (n > 1) {
                        if (n % 2) {
                            for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
                              //empty
                            }
                            d = (i <= j) ? i : n;
                        } else {
                            d = 2;
                        }
                        for (n /= d, r *= d, i = o.length; i;
                            (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
                            //empty
                        }
                    }
                }
                return r;
            };
        
            exports.LN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number);
            };
        
            exports.LOG = function(number, base) {
                number = utils.parseNumber(number);
                base = (base === undefined) ? 10 : utils.parseNumber(base);
        
                if (utils.anyIsError(number, base)) {
                    return error.value;
                }
        
                return Math.log(number) / Math.log(base);
            };
        
            exports.LOG10 = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number) / Math.log(10);
            };
        
            exports.MDETERM = null;
        
            exports.MINVERSE = null;
        
            exports.MMULT = null;
        
            exports.MOD = function(dividend, divisor) {
                dividend = utils.parseNumber(dividend);
                divisor = utils.parseNumber(divisor);
                if (utils.anyIsError(dividend, divisor)) {
                    return error.value;
                }
                if (divisor === 0) {
                    return error.div0;
                }
                var modulus = Math.abs(dividend % divisor);
                return (divisor > 0) ? modulus : -modulus;
            };
        
            exports.MROUND = function(number, multiple) {
                number = utils.parseNumber(number);
                multiple = utils.parseNumber(multiple);
                if (utils.anyIsError(number, multiple)) {
                    return error.value;
                }
                if (number * multiple < 0) {
                    return error.num;
                }
        
                return Math.round(number / multiple) * multiple;
            };
        
            exports.MULTINOMIAL = function() {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }
                var sum = 0;
                var divisor = 1;
                for (var i = 0; i < args.length; i++) {
                    sum += args[i];
                    divisor *= exports.FACT(args[i]);
                }
                return exports.FACT(sum) / divisor;
            };
        
            exports.MUNIT = null;
        
            exports.ODD = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var temp = Math.ceil(Math.abs(number));
                temp = (temp & 1) ? temp : temp + 1;
                return (number > 0) ? temp : -temp;
            };
        
            exports.PI = function() {
                return Math.PI;
            };
        
            exports.POWER = function(number, power) {
                number = utils.parseNumber(number);
                power = utils.parseNumber(power);
                if (utils.anyIsError(number, power)) {
                    return error.value;
                }
                var result = Math.pow(number, power);
                if (isNaN(result)) {
                    return error.num;
                }
        
                return result;
            };
        
            exports.PRODUCT = function() {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }
                var result = 1;
                for (var i = 0; i < args.length; i++) {
                    result *= args[i];
                }
                return result;
            };
        
            exports.QUOTIENT = function(numerator, denominator) {
                numerator = utils.parseNumber(numerator);
                denominator = utils.parseNumber(denominator);
                if (utils.anyIsError(numerator, denominator)) {
                    return error.value;
                }
                return parseInt(numerator / denominator, 10);
            };
        
            exports.RADIANS = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return number * Math.PI / 180;
            };
        
            exports.RAND = function() {
                return Math.random();
            };
        
            exports.RANDBETWEEN = function(bottom, top) {
                bottom = utils.parseNumber(bottom);
                top = utils.parseNumber(top);
                if (utils.anyIsError(bottom, top)) {
                    return error.value;
                }
                // Creative Commons Attribution 3.0 License
                // Copyright (c) 2012 eqcode
                return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
            };
        
            exports.ROMAN = null;
        
            exports.ROUND = function(number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
            };
        
            exports.ROUNDDOWN = function(number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };
        
            exports.ROUNDUP = function(number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };
        
            exports.SEC = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.cos(number);
            };
        
            exports.SECH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 2 / (Math.exp(number) + Math.exp(-number));
            };
        
            exports.SERIESSUM = function(x, n, m, coefficients) {
                x = utils.parseNumber(x);
                n = utils.parseNumber(n);
                m = utils.parseNumber(m);
                coefficients = utils.parseNumberArray(coefficients);
                if (utils.anyIsError(x, n, m, coefficients)) {
                    return error.value;
                }
                var result = coefficients[0] * Math.pow(x, n);
                for (var i = 1; i < coefficients.length; i++) {
                    result += coefficients[i] * Math.pow(x, n + i * m);
                }
                return result;
            };
        
            exports.SIGN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                if (number < 0) {
                    return -1;
                } else if (number === 0) {
                    return 0;
                } else {
                    return 1;
                }
            };
        
            exports.SIN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.sin(number);
            };
        
            exports.SINH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return (Math.exp(number) - Math.exp(-number)) / 2;
            };
        
            exports.SQRT = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                if (number < 0) {
                    return error.num;
                }
                return Math.sqrt(number);
            };
        
            exports.SQRTPI = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.sqrt(number * Math.PI);
            };
        
            exports.SUBTOTAL = null;
        
            exports.ADD = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.value;
                }
        
                return num1 + num2;
            };
        
            exports.MINUS = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.value;
                }
        
                return num1 - num2;
            };
        
            exports.DIVIDE = function (dividend, divisor) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                dividend = utils.parseNumber(dividend);
                divisor = utils.parseNumber(divisor);
                if (utils.anyIsError(dividend, divisor)) {
                    return error.value;
                }
        
                if (divisor === 0) {
                    return error.div0;
                }
        
                return dividend / divisor;
            };
        
            exports.MULTIPLY = function (factor1, factor2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                factor1 = utils.parseNumber(factor1);
                factor2 = utils.parseNumber(factor2);
                if (utils.anyIsError(factor1, factor2)) {
                    return error.value;
                }
        
                return factor1 * factor2;
            };
        
            exports.GTE = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }
        
                return num1 >= num2;
            };
        
            exports.LT = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }
        
                return num1 < num2;
            };
        
            exports.LTE = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }
        
                return num1 <= num2;
            };
        
            exports.EQ = function (value1, value2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                return value1 === value2;
            };
        
            exports.NE = function (value1, value2) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                return value1 !== value2;
            };
        
            exports.POW = function (base, exponent) {
                if (arguments.length !== 2) {
                    return error.na;
                }
        
                base = utils.parseNumber(base);
                exponent = utils.parseNumber(exponent);
                if (utils.anyIsError(base, exponent)) {
                    return error.error;
                }
        
                return exports.POWER(base, exponent);
            };
        
            exports.SUM = function() {
                var result = 0;
                var argsKeys = Object.keys(arguments);
                for (var i = 0; i < argsKeys.length; ++i) {
                    var elt = arguments[argsKeys[i]];
                    if (typeof elt === 'number') {
                        result += elt;
                    } else if (typeof elt === 'string') {
                        var parsed = parseFloat(elt);
                        !isNaN(parsed) && (result += parsed);
                    } else if (Array.isArray(elt)) {
                        result += exports.SUM.apply(null, elt);
                    }
                }
                return result;
            };
        
            exports.SUMIF = function(range, criteria) {
                range = utils.parseNumberArray(utils.flatten(range));
                if (range instanceof Error) {
                    return range;
                }
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
                }
                return result;
            };
        
            exports.SUMIFS = function() {
                var args = utils.argsToArray(arguments);
                var range = utils.parseNumberArray(utils.flatten(args.shift()));
                if (range instanceof Error) {
                    return range;
                }
                var criteria = args;
        
                var n_range_elements = range.length;
                var n_criterias = criteria.length;
        
                var result = 0;
                for (var i = 0; i < n_range_elements; i++) {
                    var el = range[i];
                    var condition = '';
                    for (var c = 0; c < n_criterias; c++) {
                        condition += el + criteria[c];
                        if (c !== n_criterias - 1) {
                            condition += '&&';
                        }
                    }
                    if (eval(condition)) { // jshint ignore:line
                        result += el;
                    }
                }
                return result;
            };
        
            exports.SUMPRODUCT = null;
        
            exports.SUMSQ = function() {
                var numbers = utils.parseNumberArray(utils.flatten(arguments));
                if (numbers instanceof Error) {
                    return numbers;
                }
                var result = 0;
                var length = numbers.length;
                for (var i = 0; i < length; i++) {
                    result += (ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
                }
                return result;
            };
        
            exports.SUMX2MY2 = function(array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                for (var i = 0; i < array_x.length; i++) {
                    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
                }
                return result;
            };
        
            exports.SUMX2PY2 = function(array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                for (var i = 0; i < array_x.length; i++) {
                    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
                }
                return result;
            };
        
            exports.SUMXMY2 = function(array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                array_x = utils.flatten(array_x);
                array_y = utils.flatten(array_y);
                for (var i = 0; i < array_x.length; i++) {
                    result += Math.pow(array_x[i] - array_y[i], 2);
                }
                return result;
            };
        
            exports.TAN = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.tan(number);
            };
        
            exports.TANH = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var e2 = Math.exp(2 * number);
                return (e2 - 1) / (e2 + 1);
            };
        
            exports.TRUNC = function(number, digits) {
                digits = (digits === undefined) ? 0 : digits;
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };
        
            return exports;
        })();
        
        jexcel.methods.misc = (function() {
            var exports = {};
        
            exports.UNIQUE = function () {
                var result = [];
                for (var i = 0; i < arguments.length; ++i) {
                    var hasElement = false;
                    var element = arguments[i];
        
                    // Check if we've already seen this element.
                    for (var j = 0; j < result.length; ++j) {
                        hasElement = result[j] === element;
                        if (hasElement) { break; }
                    }
        
                    // If we did not find it, add it to the result.
                    if (!hasElement) {
                        result.push(element);
                    }
                }
                return result;
            };
        
            exports.FLATTEN = utils.flatten;
        
            exports.ARGS2ARRAY = function () {
                return Array.prototype.slice.call(arguments, 0);
            };
        
            exports.REFERENCE = function (context, reference) {
                try {
                    var path = reference.split('.');
                    var result = context;
                    for (var i = 0; i < path.length; ++i) {
                        var step = path[i];
                        if (step[step.length - 1] === ']') {
                            var opening = step.indexOf('[');
                            var index = step.substring(opening + 1, step.length - 1);
                            result = result[step.substring(0, opening)][index];
                        } else {
                            result = result[step];
                        }
                    }
                    return result;
                } catch (error) {}
            };
        
            exports.JOIN = function (array, separator) {
                return array.join(separator);
            };
        
            exports.NUMBERS = function () {
                var possibleNumbers = utils.flatten(arguments);
                return possibleNumbers.filter(function (el) {
                    return typeof el === 'number';
                });
            };
        
            exports.NUMERAL = null;
        
            return exports;
        })();
        
        jexcel.methods.text = (function() {
            var exports = {};
        
            exports.ASC = null;
        
            exports.BAHTTEXT = null;
        
            exports.CHAR = function(number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return String.fromCharCode(number);
            };
        
            exports.CLEAN = function(text) {
                text = text || '';
                var re = /[\0-\x1F]/g;
                return text.replace(re, "");
            };
        
            exports.CODE = function(text) {
                text = text || '';
                return text.charCodeAt(0);
            };
        
            exports.CONCATENATE = function() {
                var args = utils.flatten(arguments);
        
                var trueFound = 0;
                while ((trueFound = args.indexOf(true)) > -1) {
                    args[trueFound] = 'TRUE';
                }
        
                var falseFound = 0;
                while ((falseFound = args.indexOf(false)) > -1) {
                    args[falseFound] = 'FALSE';
                }
        
                return args.join('');
            };
        
            exports.DBCS = null;
        
            exports.DOLLAR = null;
        
            exports.EXACT = function(text1, text2) {
                return text1 === text2;
            };
        
            exports.FIND = function(find_text, within_text, position) {
                position = (position === undefined) ? 0 : position;
                return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
            };
        
            exports.FIXED = null;
        
            exports.HTML2TEXT = function (value) {
                var result = '';
        
                if (value) {
                    if (value instanceof Array) {
                        value.forEach(function (line) {
                            if (result !== '') {
                              result += '\n';
                            }
                            result += (line.replace(/<(?:.|\n)*?>/gm, ''));
                        });
                    } else {
                        result = value.replace(/<(?:.|\n)*?>/gm, '');
                    }
                }
        
                return result;
            };
        
            exports.LEFT = function(text, number) {
                number = (number === undefined) ? 1 : number;
                number = utils.parseNumber(number);
                if (number instanceof Error || typeof text !== 'string') {
                    return error.value;
                }
                return text ? text.substring(0, number) : null;
            };
        
            exports.LEN = function(text) {
                if (arguments.length === 0) {
                    return error.error;
                }
        
                if (typeof text === 'string') {
                    return text ? text.length : 0;
                }
        
                if (text.length) {
                    return text.length;
                }
        
                return error.value;
            };
        
            exports.LOWER = function(text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text ? text.toLowerCase() : text;
            };
        
            exports.MID = function(text, start, number) {
                start = utils.parseNumber(start);
                number = utils.parseNumber(number);
                if (utils.anyIsError(start, number) || typeof text !== 'string') {
                    return number;
                }
        
                var begin = start - 1;
                var end = begin + number;
        
                return text.substring(begin, end);
            };
        
            exports.NUMBERVALUE = null;
        
            exports.PRONETIC = null;
        
            exports.PROPER = function(text) {
                if (text === undefined || text.length === 0) {
                    return error.value;
                }
                if (text === true) {
                    text = 'TRUE';
                }
                if (text === false) {
                    text = 'FALSE';
                }
                if (isNaN(text) && typeof text === 'number') {
                    return error.value;
                }
                if (typeof text === 'number') {
                    text = '' + text;
                }
        
                return text.replace(/\w\S*/g, function(txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            };
        
            exports.REGEXEXTRACT = function (text, regular_expression) {
                var match = text.match(new RegExp(regular_expression));
                return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
            };
        
            exports.REGEXMATCH = function (text, regular_expression, full) {
                var match = text.match(new RegExp(regular_expression));
                return full ? match : !!match;
            };
        
            exports.REGEXREPLACE = function (text, regular_expression, replacement) {
                return text.replace(new RegExp(regular_expression), replacement);
            };
        
            exports.REPLACE = function(text, position, length, new_text) {
                position = utils.parseNumber(position);
                length = utils.parseNumber(length);
                if (utils.anyIsError(position, length) ||
                    typeof text !== 'string' ||
                    typeof new_text !== 'string') {
                    return error.value;
                }
                return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
            };
        
            exports.REPT = function(text, number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return new Array(number + 1).join(text);
            };
        
            exports.RIGHT = function(text, number) {
                number = (number === undefined) ? 1 : number;
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return text ? text.substring(text.length - number) : null;
            };
        
            exports.SEARCH = function(find_text, within_text, position) {
                var foundAt;
                if (typeof find_text !== 'string' || typeof within_text !== 'string') {
                    return error.value;
                }
                position = (position === undefined) ? 0 : position;
                foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;
                return (foundAt === 0)?error.value:foundAt;
            };
        
            exports.SPLIT = function (text, separator) {
                return text.split(separator);
            };
        
            exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
                if (!text || !old_text || !new_text) {
                    return text;
                } else if (occurrence === undefined) {
                    return text.replace(new RegExp(old_text, 'g'), new_text);
                } else {
                    var index = 0;
                    var i = 0;
                    while (text.indexOf(old_text, index) > 0) {
                        index = text.indexOf(old_text, index + 1);
                        i++;
                        if (i === occurrence) {
                            return text.substring(0, index) + new_text + text.substring(index + old_text.length);
                        }
                    }
                }
            };
        
            exports.T = function(value) {
                return (typeof value === "string") ? value : '';
            };
        
            exports.TEXT = null;
        
            exports.TRIM = function(text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text.replace(/ +/g, ' ').trim();
            };
        
            exports.UNICHAR = exports.CHAR;
        
            exports.UNICODE = exports.CODE;
        
            exports.UPPER = function(text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text.toUpperCase();
            };
        
            exports.VALUE = null;
        
            return exports;
        })();
        
        jexcel.methods.stats = (function() {
            var exports = {};
        
            var SQRT2PI = 2.5066282746310002;
        
            exports.AVEDEV = null;
        
            exports.AVERAGE = function() {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sum = 0;
                var count = 0;
                for (var i = 0; i < n; i++) {
                    sum += range[i];
                    count += 1;
                }
                return sum / count;
            };
        
            exports.AVERAGEA = function() {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sum = 0;
                var count = 0;
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sum += el;
                    }
                    if (el === true) {
                        sum++;
                    }
                    if (el !== null) {
                        count++;
                    }
                }
                return sum / count;
            };
        
            exports.AVERAGEIF = function(range, criteria, average_range) {
                average_range = average_range || range;
                range = utils.flatten(range);
                average_range = utils.parseNumberArray(utils.flatten(average_range));
                if (average_range instanceof Error) {
                    return average_range;
                }
                var average_count = 0;
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    if (eval(range[i] + criteria)) { // jshint ignore:line
                        result += average_range[i];
                        average_count++;
                    }
                }
                return result / average_count;
            };
        
            exports.AVERAGEIFS = null;
        
            exports.COUNT = function() {
                return utils.numbers(utils.flatten(arguments)).length;
            };
        
            exports.COUNTA = function() {
                var range = utils.flatten(arguments);
                return range.length - exports.COUNTBLANK(range);
            };
        
            exports.COUNTIN = function (range, value) {
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    if (range[i] === value) {
                        result++;
                    }
                }
                return result;
            };
        
            exports.COUNTBLANK = function() {
                var range = utils.flatten(arguments);
                var blanks = 0;
                var element;
                for (var i = 0; i < range.length; i++) {
                    element = range[i];
                    if (element === null || element === '') {
                        blanks++;
                    }
                }
                return blanks;
            };
        
            exports.COUNTIF = function(range, criteria) {
                range = utils.flatten(range);
                if (!/[<>=!]/.test(criteria)) {
                    criteria = '=="' + criteria + '"';
                }
                var matches = 0;
                for (var i = 0; i < range.length; i++) {
                    if (typeof range[i] !== 'string') {
                        if (eval(range[i] + criteria)) { // jshint ignore:line
                            matches++;
                        }
                    } else {
                        if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
                            matches++;
                        }
                    }
                }
                return matches;
            };
        
            exports.COUNTIFS = function() {
                var args = utils.argsToArray(arguments);
                var results = new Array(utils.flatten(args[0]).length);
                for (var i = 0; i < results.length; i++) {
                    results[i] = true;
                }
                for (i = 0; i < args.length; i += 2) {
                    var range = utils.flatten(args[i]);
                    var criteria = args[i + 1];
                    if (!/[<>=!]/.test(criteria)) {
                        criteria = '=="' + criteria + '"';
                    }
                    for (var j = 0; j < range.length; j++) {
                        if (typeof range[j] !== 'string') {
                            results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
                        } else {
                            results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
                        }
                    }
                }
                var result = 0;
                for (i = 0; i < results.length; i++) {
                    if (results[i]) {
                        result++;
                    }
                }
                return result;
            };
        
            exports.COUNTUNIQUE = function () {
                return UNIQUE.apply(null, utils.flatten(arguments)).length;
            };
        
            exports.FISHER = function(x) {
                x = utils.parseNumber(x);
                if (x instanceof Error) {
                    return x;
                }
                return Math.log((1 + x) / (1 - x)) / 2;
            };
        
            exports.FISHERINV = function(y) {
                y = utils.parseNumber(y);
                if (y instanceof Error) {
                    return y;
                }
                var e2y = Math.exp(2 * y);
                return (e2y - 1) / (e2y + 1);
            };
        
            exports.FREQUENCY = function(data, bins) {
                data = utils.parseNumberArray(utils.flatten(data));
                bins = utils.parseNumberArray(utils.flatten(bins));
                if (utils.anyIsError(data, bins)) {
                    return error.value;
                }
                var n = data.length;
                var b = bins.length;
                var r = [];
                for (var i = 0; i <= b; i++) {
                    r[i] = 0;
                    for (var j = 0; j < n; j++) {
                        if (i === 0) {
                            if (data[j] <= bins[0]) {
                                r[0] += 1;
                            }
                        } else if (i < b) {
                            if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
                                r[i] += 1;
                            }
                        } else if (i === b) {
                            if (data[j] > bins[b - 1]) {
                                r[b] += 1;
                            }
                        }
                    }
                }
                return r;
            };
        
            exports.LARGE = function(range, k) {
                range = utils.parseNumberArray(utils.flatten(range));
                k = utils.parseNumber(k);
                if (utils.anyIsError(range, k)) {
                    return range;
                }
                return range.sort(function(a, b) {
                    return b - a;
                })[k - 1];
            };
        
            exports.MAX = function() {
                var range = utils.numbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.max.apply(Math, range);
            };
        
            exports.MAXA = function() {
                var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.max.apply(Math, range);
            };
        
            exports.MIN = function() {
                var range = utils.numbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.min.apply(Math, range);
            };
        
            exports.MINA = function() {
                var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.min.apply(Math, range);
            };
        
            exports.MODE = {};
        
            exports.MODE.MULT = function() {
                // Credits: Roönaän
                var range = utils.parseNumberArray(utils.flatten(arguments));
                if (range instanceof Error) {
                    return range;
                }
                var n = range.length;
                var count = {};
                var maxItems = [];
                var max = 0;
                var currentItem;
        
                for (var i = 0; i < n; i++) {
                    currentItem = range[i];
                    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
                    if (count[currentItem] > max) {
                        max = count[currentItem];
                        maxItems = [];
                    }
                    if (count[currentItem] === max) {
                        maxItems[maxItems.length] = currentItem;
                    }
                }
                return maxItems;
            };
        
            exports.MODE.SNGL = function() {
                var range = utils.parseNumberArray(utils.flatten(arguments));
                if (range instanceof Error) {
                    return range;
                }
                return exports.MODE.MULT(range).sort(function(a, b) {
                    return a - b;
                })[0];
            };
        
            exports.PERCENTILE = {};
        
            exports.PERCENTILE.EXC = function(array, k) {
                array = utils.parseNumberArray(utils.flatten(array));
                k = utils.parseNumber(k);
                if (utils.anyIsError(array, k)) {
                    return error.value;
                }
                array = array.sort(function(a, b) {
                    {
                        return a - b;
                    }
                });
                var n = array.length;
                if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
                    return error.num;
                }
                var l = k * (n + 1) - 1;
                var fl = Math.floor(l);
                return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
            };
        
            exports.PERCENTILE.INC = function(array, k) {
                array = utils.parseNumberArray(utils.flatten(array));
                k = utils.parseNumber(k);
                if (utils.anyIsError(array, k)) {
                    return error.value;
                }
                array = array.sort(function(a, b) {
                    return a - b;
                });
                var n = array.length;
                var l = k * (n - 1);
                var fl = Math.floor(l);
                return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
            };
        
            exports.PERCENTRANK = {};
        
            exports.PERCENTRANK.EXC = function(array, x, significance) {
                significance = (significance === undefined) ? 3 : significance;
                array = utils.parseNumberArray(utils.flatten(array));
                x = utils.parseNumber(x);
                significance = utils.parseNumber(significance);
                if (utils.anyIsError(array, x, significance)) {
                    return error.value;
                }
                array = array.sort(function(a, b) {
                    return a - b;
                });
                var uniques = UNIQUE.apply(null, array);
                var n = array.length;
                var m = uniques.length;
                var power = Math.pow(10, significance);
                var result = 0;
                var match = false;
                var i = 0;
                while (!match && i < m) {
                    if (x === uniques[i]) {
                        result = (array.indexOf(uniques[i]) + 1) / (n + 1);
                        match = true;
                    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
                        result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
                        match = true;
                    }
                    i++;
                }
                return Math.floor(result * power) / power;
            };
        
            exports.PERCENTRANK.INC = function(array, x, significance) {
                significance = (significance === undefined) ? 3 : significance;
                array = utils.parseNumberArray(utils.flatten(array));
                x = utils.parseNumber(x);
                significance = utils.parseNumber(significance);
                if (utils.anyIsError(array, x, significance)) {
                    return error.value;
                }
                array = array.sort(function(a, b) {
                    return a - b;
                });
                var uniques = UNIQUE.apply(null, array);
                var n = array.length;
                var m = uniques.length;
                var power = Math.pow(10, significance);
                var result = 0;
                var match = false;
                var i = 0;
                while (!match && i < m) {
                    if (x === uniques[i]) {
                        result = array.indexOf(uniques[i]) / (n - 1);
                        match = true;
                    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
                        result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
                        match = true;
                    }
                    i++;
                }
                return Math.floor(result * power) / power;
            };
        
            exports.PERMUT = function(number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return FACT(number) / FACT(number - number_chosen);
            };
        
            exports.PERMUTATIONA = function(number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return Math.pow(number, number_chosen);
            };
        
            exports.PHI = function(x) {
                x = utils.parseNumber(x);
                if (x instanceof Error) {
                    return error.value;
                }
                return Math.exp(-0.5 * x * x) / SQRT2PI;
            };
        
            exports.PROB = function(range, probability, lower, upper) {
                if (lower === undefined) {
                    return 0;
                }
                upper = (upper === undefined) ? lower : upper;
        
                range = utils.parseNumberArray(utils.flatten(range));
                probability = utils.parseNumberArray(utils.flatten(probability));
                lower = utils.parseNumber(lower);
                upper = utils.parseNumber(upper);
                if (utils.anyIsError(range, probability, lower, upper)) {
                    return error.value;
                }
        
                if (lower === upper) {
                    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
                }
        
                var sorted = range.sort(function(a, b) {
                    return a - b;
                });
                var n = sorted.length;
                var result = 0;
                for (var i = 0; i < n; i++) {
                    if (sorted[i] >= lower && sorted[i] <= upper) {
                        result += probability[range.indexOf(sorted[i])];
                    }
                }
                return result;
            };
        
            exports.QUARTILE = {};
        
            exports.QUARTILE.EXC = function(range, quart) {
                range = utils.parseNumberArray(utils.flatten(range));
                quart = utils.parseNumber(quart);
                if (utils.anyIsError(range, quart)) {
                    return error.value;
                }
                switch (quart) {
                    case 1:
                        return exports.PERCENTILE.EXC(range, 0.25);
                    case 2:
                        return exports.PERCENTILE.EXC(range, 0.5);
                    case 3:
                        return exports.PERCENTILE.EXC(range, 0.75);
                    default:
                        return error.num;
                }
            };
        
            exports.QUARTILE.INC = function(range, quart) {
                range = utils.parseNumberArray(utils.flatten(range));
                quart = utils.parseNumber(quart);
                if (utils.anyIsError(range, quart)) {
                    return error.value;
                }
                switch (quart) {
                    case 1:
                        return exports.PERCENTILE.INC(range, 0.25);
                    case 2:
                        return exports.PERCENTILE.INC(range, 0.5);
                    case 3:
                        return exports.PERCENTILE.INC(range, 0.75);
                    default:
                        return error.num;
                }
            };
        
            exports.RANK = {};
        
            exports.RANK.AVG = function(number, range, order) {
                number = utils.parseNumber(number);
                range = utils.parseNumberArray(utils.flatten(range));
                if (utils.anyIsError(number, range)) {
                    return error.value;
                }
                range = utils.flatten(range);
                order = order || false;
                var sort = (order) ? function(a, b) {
                    return a - b;
                } : function(a, b) {
                    return b - a;
                };
                range = range.sort(sort);
        
                var length = range.length;
                var count = 0;
                for (var i = 0; i < length; i++) {
                    if (range[i] === number) {
                        count++;
                    }
                }
        
                return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
            };
        
            exports.RANK.EQ = function(number, range, order) {
                number = utils.parseNumber(number);
                range = utils.parseNumberArray(utils.flatten(range));
                if (utils.anyIsError(number, range)) {
                    return error.value;
                }
                order = order || false;
                var sort = (order) ? function(a, b) {
                    return a - b;
                } : function(a, b) {
                    return b - a;
                };
                range = range.sort(sort);
                return range.indexOf(number) + 1;
            };
        
            exports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that
                data_x = utils.parseNumberArray(utils.flatten(data_x));
                data_y = utils.parseNumberArray(utils.flatten(data_y));
                if (utils.anyIsError(data_x, data_y)) {
                    return error.value;
                }
                return Math.pow(exports.PEARSON(data_x, data_y), 2);
            };
        
            exports.SMALL = function(range, k) {
                range = utils.parseNumberArray(utils.flatten(range));
                k = utils.parseNumber(k);
                if (utils.anyIsError(range, k)) {
                    return range;
                }
                return range.sort(function(a, b) {
                    return a - b;
                })[k - 1];
            };
        
            exports.STANDARDIZE = function(x, mean, sd) {
                x = utils.parseNumber(x);
                mean = utils.parseNumber(mean);
                sd = utils.parseNumber(sd);
                if (utils.anyIsError(x, mean, sd)) {
                    return error.value;
                }
                return (x - mean) / sd;
            };
        
            exports.STDEV = {};
        
            exports.STDEV.P = function() {
                var v = exports.VAR.P.apply(this, arguments);
                return Math.sqrt(v);
            };
        
            exports.STDEV.S = function() {
                var v = exports.VAR.S.apply(this, arguments);
                return Math.sqrt(v);
            };
        
            exports.STDEVA = function() {
                var v = exports.VARA.apply(this, arguments);
                return Math.sqrt(v);
            };
        
            exports.STDEVPA = function() {
                var v = exports.VARPA.apply(this, arguments);
                return Math.sqrt(v);
            };
        
            exports.VAR = {};
        
            exports.VAR.P = function() {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sigma = 0;
                var mean = exports.AVERAGE(range);
                for (var i = 0; i < n; i++) {
                    sigma += Math.pow(range[i] - mean, 2);
                }
                return sigma / n;
            };
        
            exports.VAR.S = function() {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sigma = 0;
                var mean = exports.AVERAGE(range);
                for (var i = 0; i < n; i++) {
                    sigma += Math.pow(range[i] - mean, 2);
                }
                return sigma / (n - 1);
            };
        
            exports.VARA = function() {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sigma = 0;
                var count = 0;
                var mean = exports.AVERAGEA(range);
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sigma += Math.pow(el - mean, 2);
                    } else if (el === true) {
                        sigma += Math.pow(1 - mean, 2);
                    } else {
                        sigma += Math.pow(0 - mean, 2);
                    }
        
                    if (el !== null) {
                        count++;
                    }
                }
                return sigma / (count - 1);
            };
        
            exports.VARPA = function() {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sigma = 0;
                var count = 0;
                var mean = exports.AVERAGEA(range);
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sigma += Math.pow(el - mean, 2);
                    } else if (el === true) {
                        sigma += Math.pow(1 - mean, 2);
                    } else {
                        sigma += Math.pow(0 - mean, 2);
                    }
        
                    if (el !== null) {
                        count++;
                    }
                }
                return sigma / count;
            };
        
            exports.WEIBULL = {};
        
            exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
                x = utils.parseNumber(x);
                alpha = utils.parseNumber(alpha);
                beta = utils.parseNumber(beta);
                if (utils.anyIsError(x, alpha, beta)) {
                    return error.value;
                }
                return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
            };
        
            exports.Z = {};
        
            exports.Z.TEST = function(range, x, sd) {
                range = utils.parseNumberArray(utils.flatten(range));
                x = utils.parseNumber(x);
                if (utils.anyIsError(range, x)) {
                    return error.value;
                }
        
                sd = sd || exports.STDEV.S(range);
                var n = range.length;
                return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
            };
        
            return exports;
        })();

        jexcel.methods.utils = (function() {
            var exports = {};

            exports.PROGRESS = function(p, c) {
                var color = c ? c : 'red';
                var value = p ? p : '0';

                return '<div style="width:' + value + '%;height:4px;background-color:' + color + ';margin-top:1px;"></div>';
            };

            exports.RATING = function(v) {
                var html = '<div class="jrating">';
                for (var i = 0; i < 5; i++) {
                    if (i < v) {
                        html += '<div class="jrating-selected"></div>';
                    } else {
                        html += '<div></div>';
                    }
                }
                html += '</div>';
                return html;
            };

            return exports;
        })();

        for (var i = 0; i < Object.keys(jexcel.methods).length; i++) {
            var methods = jexcel.methods[Object.keys(jexcel.methods)[i]];
            for (var j = 0; j < Object.keys(methods).length; j++) {
                if (typeof(methods[Object.keys(methods)[j]]) == 'function') {
                    window[Object.keys(methods)[j]] = methods[Object.keys(methods)[j]];
                } else {
                    window[Object.keys(methods)[j]] = function() {
                        return Object.keys(methods)[j] + 'Not implemented';
                    };
                }
            }
        }

        return jexcel;
    })));
    });

    function mapTranslationsToSpreadsheet(translations) {
        let _columns = [{ name: 'messageID', title: 'message ID', type: 'text', width: 150 }];
        let _data = [];
        const entries = Object.entries(translations).sort(([a], [b]) => {
            if (a === 'messageID')
                return -1;
            if (a === 'en')
                return -1;
            return a < b ? -1 : 1;
        });
        for (const [lang, data] of entries) {
            _columns = [..._columns, { name: lang, title: lang, type: 'text', width: 150 }];
            for (const [messageID, value] of Object.entries(data)) {
                const entry = _data.find((i) => i.messageID === messageID);
                if (entry) {
                    entry[lang] = value;
                }
                else {
                    _data = [..._data, { messageID, [lang]: value }];
                }
            }
        }
        return {
            columns: _columns,
            data: _data
        };
    }
    function mapSpreadsheetToTranslations(instance) {
        const _headers = instance.getHeaders();
        const headers = _headers.split(',');
        let output = {};
        for (const header of headers.slice(1)) {
            output[header] = {};
        }
        for (const row of instance.getData()) {
            const messageID = row[0];
            if (messageID) {
                for (const [index, cellValue] of Object.entries(row.slice(1))) {
                    const langCol = headers[parseInt(index) + 1];
                    if (langCol) {
                        const langData = output[langCol];
                        if (langData) {
                            langData[messageID] = cellValue;
                        }
                    }
                }
            }
        }
        return output;
    }

    /* src\components\TranslationSheet.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$1 } = globals;

    const file$7 = "src\\components\\TranslationSheet.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let initiate_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spreadsheet");
    			add_location(div, file$7, 43, 0, 1542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(initiate_action = /*initiate*/ ctx[1].call(null, div, /*columns*/ ctx[0])),
    					listen_dev(div, "keyup", /*handleChangeinstance*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (initiate_action && is_function(initiate_action.update) && dirty & /*columns*/ 1) initiate_action.update.call(null, /*columns*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TranslationSheet", slots, []);
    	let { translations } = $$props;
    	const dispatch = createEventDispatcher();
    	let data = [];
    	let columns = [];
    	let instance;

    	const eventHanlders = {
    		onchange: handleChangeinstance,
    		ondeleterow: handleChangeinstance,
    		ondeletecolumn: handleChangeinstance,
    		onpaste: handleChangeinstance,
    		oninsertrow: handleChangeinstance,
    		oninsertcolumn: handleChangeinstance,
    		onfocus: handleChangeinstance,
    		onblur: handleChangeinstance,
    		oneditionstart: handleChangeinstance,
    		oneditionend: handleChangeinstance
    	};

    	function initiate(target, columns) {
    		instance = dist(target, Object.assign({ data, columns: [...columns] }, eventHanlders));

    		return {
    			update(langCols) {
    				instance && instance.destroy();
    				instance = dist(target, Object.assign({ data, columns: [...langCols] }, eventHanlders));
    			}
    		};
    	}

    	function handleChangeinstance() {
    		const output = mapSpreadsheetToTranslations(instance);
    		dispatch("change", output);
    	}

    	const writable_props = ["translations"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TranslationSheet> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("translations" in $$props) $$invalidate(3, translations = $$props.translations);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		jspreadsheet: dist,
    		mapSpreadsheetToTranslations,
    		mapTranslationsToSpreadsheet,
    		translations,
    		dispatch,
    		data,
    		columns,
    		instance,
    		eventHanlders,
    		initiate,
    		handleChangeinstance
    	});

    	$$self.$inject_state = $$props => {
    		if ("translations" in $$props) $$invalidate(3, translations = $$props.translations);
    		if ("data" in $$props) data = $$props.data;
    		if ("columns" in $$props) $$invalidate(0, columns = $$props.columns);
    		if ("instance" in $$props) instance = $$props.instance;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*translations*/ 8) {
    			{
    				const { data: _data, columns: _columns } = mapTranslationsToSpreadsheet(translations);
    				data = _data;
    				$$invalidate(0, columns = _columns);
    			}
    		}
    	};

    	return [columns, initiate, handleChangeinstance, translations];
    }

    class TranslationSheet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance_1, create_fragment$a, safe_not_equal, { translations: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TranslationSheet",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*translations*/ ctx[3] === undefined && !("translations" in props)) {
    			console.warn("<TranslationSheet> was created without expected prop 'translations'");
    		}
    	}

    	get translations() {
    		throw new Error("<TranslationSheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set translations(value) {
    		throw new Error("<TranslationSheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetFields\OpenBookIcon.svelte generated by Svelte v3.38.2 */

    const file$6 = "src\\components\\WidgetFields\\OpenBookIcon.svelte";

    function create_fragment$9(ctx) {
    	let svg;
    	let g2;
    	let g1;
    	let g0;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let g3;
    	let g4;
    	let g5;
    	let g6;
    	let g7;
    	let g8;
    	let g9;
    	let g10;
    	let g11;
    	let g12;
    	let g13;
    	let g14;
    	let g15;
    	let g16;
    	let g17;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			g3 = svg_element("g");
    			g4 = svg_element("g");
    			g5 = svg_element("g");
    			g6 = svg_element("g");
    			g7 = svg_element("g");
    			g8 = svg_element("g");
    			g9 = svg_element("g");
    			g10 = svg_element("g");
    			g11 = svg_element("g");
    			g12 = svg_element("g");
    			g13 = svg_element("g");
    			g14 = svg_element("g");
    			g15 = svg_element("g");
    			g16 = svg_element("g");
    			g17 = svg_element("g");
    			attr_dev(path0, "d", "M45.432,35.049c-0.008,0-0.017,0-0.025,0c-2.809,0-5.451,1.095-7.446,3.085c-2.017,2.012-3.128,4.691-3.128,7.543\r\n\t\t\t\tv159.365c0,5.844,4.773,10.61,10.641,10.625c24.738,0.059,66.184,5.215,94.776,35.136V84.023c0-1.981-0.506-3.842-1.461-5.382\r\n\t\t\t\tC115.322,40.849,70.226,35.107,45.432,35.049z");
    			add_location(path0, file$6, 14, 8, 294);
    			attr_dev(path1, "d", "M262.167,205.042V45.676c0-2.852-1.111-5.531-3.128-7.543c-1.995-1.99-4.639-3.085-7.445-3.085c-0.009,0-0.018,0-0.026,0\r\n\t\t\t\tc-24.793,0.059-69.889,5.801-93.357,43.593c-0.955,1.54-1.46,3.401-1.46,5.382v166.779\r\n\t\t\t\tc28.592-29.921,70.038-35.077,94.776-35.136C257.394,215.651,262.167,210.885,262.167,205.042z");
    			add_location(path1, file$6, 19, 8, 623);
    			attr_dev(path2, "d", "M286.373,71.801h-7.706v133.241c0,14.921-12.157,27.088-27.101,27.125c-20.983,0.05-55.581,4.153-80.084,27.344\r\n\t\t\t\tc42.378-10.376,87.052-3.631,112.512,2.171c3.179,0.724,6.464-0.024,9.011-2.054c2.538-2.025,3.994-5.052,3.994-8.301V82.427\r\n\t\t\t\tC297,76.568,292.232,71.801,286.373,71.801z");
    			add_location(path2, file$6, 24, 8, 968);
    			attr_dev(path3, "d", "M18.332,205.042V71.801h-7.706C4.768,71.801,0,76.568,0,82.427v168.897c0,3.25,1.456,6.276,3.994,8.301\r\n\t\t\t\tc2.545,2.029,5.827,2.78,9.011,2.054c25.46-5.803,70.135-12.547,112.511-2.171c-24.502-23.19-59.1-27.292-80.083-27.342\r\n\t\t\t\tC30.49,232.13,18.332,219.963,18.332,205.042z");
    			add_location(path3, file$6, 29, 8, 1292);
    			add_location(g0, file$6, 13, 6, 281);
    			add_location(g1, file$6, 12, 4, 270);
    			add_location(g2, file$6, 11, 2, 261);
    			add_location(g3, file$6, 37, 2, 1629);
    			add_location(g4, file$6, 38, 2, 1638);
    			add_location(g5, file$6, 39, 2, 1647);
    			add_location(g6, file$6, 40, 2, 1656);
    			add_location(g7, file$6, 41, 2, 1665);
    			add_location(g8, file$6, 42, 2, 1674);
    			add_location(g9, file$6, 43, 2, 1683);
    			add_location(g10, file$6, 44, 2, 1692);
    			add_location(g11, file$6, 45, 2, 1701);
    			add_location(g12, file$6, 46, 2, 1710);
    			add_location(g13, file$6, 47, 2, 1719);
    			add_location(g14, file$6, 48, 2, 1728);
    			add_location(g15, file$6, 49, 2, 1737);
    			add_location(g16, file$6, 50, 2, 1746);
    			add_location(g17, file$6, 51, 2, 1755);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Layer_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 296.999 296.999");
    			set_style(svg, "enable-background", "new 0 0 296.999 296.999");
    			attr_dev(svg, "xml:space", "preserve");
    			attr_dev(svg, "class", "svelte-1foee3b");
    			add_location(svg, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g2);
    			append_dev(g2, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path0);
    			append_dev(g0, path1);
    			append_dev(g0, path2);
    			append_dev(g0, path3);
    			append_dev(svg, g3);
    			append_dev(svg, g4);
    			append_dev(svg, g5);
    			append_dev(svg, g6);
    			append_dev(svg, g7);
    			append_dev(svg, g8);
    			append_dev(svg, g9);
    			append_dev(svg, g10);
    			append_dev(svg, g11);
    			append_dev(svg, g12);
    			append_dev(svg, g13);
    			append_dev(svg, g14);
    			append_dev(svg, g15);
    			append_dev(svg, g16);
    			append_dev(svg, g17);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OpenBookIcon", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OpenBookIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class OpenBookIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenBookIcon",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\components\WidgetFields\WidgetFieldExpression.svelte generated by Svelte v3.38.2 */
    const file$5 = "src\\components\\WidgetFields\\WidgetFieldExpression.svelte";

    // (50:0) {:else}
    function create_else_block$1(ctx) {
    	let fast_text_area;
    	let fast_text_area_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			fast_text_area = element("fast-text-area");
    			set_custom_element_data(fast_text_area, "appearance", "outline");
    			set_custom_element_data(fast_text_area, "cols", "1000");
    			set_custom_element_data(fast_text_area, "resize", "vertical");
    			set_custom_element_data(fast_text_area, "value", fast_text_area_value_value = /*field*/ ctx[0].value || /*field*/ ctx[0].default || "");
    			add_location(fast_text_area, file$5, 50, 2, 1409);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_text_area, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(fast_text_area, "keypress", /*keypress_handler*/ ctx[8], false, false, false),
    					listen_dev(fast_text_area, "change", /*change_handler*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*field*/ 1 && fast_text_area_value_value !== (fast_text_area_value_value = /*field*/ ctx[0].value || /*field*/ ctx[0].default || "")) {
    				set_custom_element_data(fast_text_area, "value", fast_text_area_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_text_area);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(50:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:0) {#if monaco}
    function create_if_block$5(ctx) {
    	let if_block_anchor;
    	let if_block = /*expanded*/ ctx[2][/*index*/ ctx[3]] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*expanded*/ ctx[2][/*index*/ ctx[3]]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(35:0) {#if monaco}",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if expanded[index]}
    function create_if_block_1$3(ctx) {
    	let div;
    	let monacoEdit_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "monaco-container");
    			set_style(div, "height", "100%");
    			set_style(div, "min-height", "100px");
    			add_location(div, file$5, 36, 4, 1059);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = action_destroyer(monacoEdit_action = /*monacoEdit*/ ctx[6].call(null, div, {
    					value: (/*field*/ ctx[0].value || /*field*/ ctx[0].default || "").toString(),
    					language: "",
    					onchange: /*monacoEdit_function*/ ctx[7]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (monacoEdit_action && is_function(monacoEdit_action.update) && dirty & /*field, fields*/ 3) monacoEdit_action.update.call(null, {
    				value: (/*field*/ ctx[0].value || /*field*/ ctx[0].default || "").toString(),
    				language: "",
    				onchange: /*monacoEdit_function*/ ctx[7]
    			});
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(36:2) {#if expanded[index]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*monaco*/ ctx[4]) return create_if_block$5;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetFieldExpression", slots, []);
    	let { fields } = $$props;
    	let { field } = $$props;
    	let { expanded } = $$props;
    	let { index } = $$props;
    	let { monaco = undefined } = $$props;
    	const dispatch = createEventDispatcher();

    	function monacoEdit(target, props) {
    		let editor = monaco.editor.create(target, {
    			value: props.value,
    			language: props.language,
    			theme: "vs-dark",
    			automaticLayout: true
    		});

    		editor.onDidChangeModelContent(e => {
    			props.onchange(editor.getValue());
    		});

    		return {
    			update(props) {
    				if (editor.getValue() !== props.value) {
    					const pos = editor.getPosition();
    					editor.setValue(props.value);
    					editor.setPosition(pos);
    					props.onchange(props.value);
    				}

    				monaco.editor.setModelLanguage(editor.getModel(), props.language);
    			},
    			destroy: () => {
    				editor.dispose();
    			}
    		};
    	}

    	const writable_props = ["fields", "field", "expanded", "index", "monaco"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetFieldExpression> was created with unknown prop '${key}'`);
    	});

    	const monacoEdit_function = value => {
    		$$invalidate(0, field.value = value, field);
    		dispatch("change", fields);
    	};

    	const keypress_handler = event => {
    		if (event.target) {
    			$$invalidate(0, field.value = event.target.value, field);
    			dispatch("keypress", fields);
    		}
    	};

    	const change_handler = event => {
    		if (event.target) {
    			$$invalidate(0, field.value = event.target.value, field);
    			dispatch("change", fields);
    		}
    	};

    	$$self.$$set = $$props => {
    		if ("fields" in $$props) $$invalidate(1, fields = $$props.fields);
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    		if ("expanded" in $$props) $$invalidate(2, expanded = $$props.expanded);
    		if ("index" in $$props) $$invalidate(3, index = $$props.index);
    		if ("monaco" in $$props) $$invalidate(4, monaco = $$props.monaco);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		fields,
    		field,
    		expanded,
    		index,
    		monaco,
    		dispatch,
    		monacoEdit
    	});

    	$$self.$inject_state = $$props => {
    		if ("fields" in $$props) $$invalidate(1, fields = $$props.fields);
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    		if ("expanded" in $$props) $$invalidate(2, expanded = $$props.expanded);
    		if ("index" in $$props) $$invalidate(3, index = $$props.index);
    		if ("monaco" in $$props) $$invalidate(4, monaco = $$props.monaco);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		field,
    		fields,
    		expanded,
    		index,
    		monaco,
    		dispatch,
    		monacoEdit,
    		monacoEdit_function,
    		keypress_handler,
    		change_handler
    	];
    }

    class WidgetFieldExpression extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			fields: 1,
    			field: 0,
    			expanded: 2,
    			index: 3,
    			monaco: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetFieldExpression",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*fields*/ ctx[1] === undefined && !("fields" in props)) {
    			console.warn("<WidgetFieldExpression> was created without expected prop 'fields'");
    		}

    		if (/*field*/ ctx[0] === undefined && !("field" in props)) {
    			console.warn("<WidgetFieldExpression> was created without expected prop 'field'");
    		}

    		if (/*expanded*/ ctx[2] === undefined && !("expanded" in props)) {
    			console.warn("<WidgetFieldExpression> was created without expected prop 'expanded'");
    		}

    		if (/*index*/ ctx[3] === undefined && !("index" in props)) {
    			console.warn("<WidgetFieldExpression> was created without expected prop 'index'");
    		}
    	}

    	get fields() {
    		throw new Error("<WidgetFieldExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fields(value) {
    		throw new Error("<WidgetFieldExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get field() {
    		throw new Error("<WidgetFieldExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<WidgetFieldExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expanded() {
    		throw new Error("<WidgetFieldExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expanded(value) {
    		throw new Error("<WidgetFieldExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<WidgetFieldExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<WidgetFieldExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monaco() {
    		throw new Error("<WidgetFieldExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monaco(value) {
    		throw new Error("<WidgetFieldExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetFields\WidgetFieldTranslation.svelte generated by Svelte v3.38.2 */

    const file$4 = "src\\components\\WidgetFields\\WidgetFieldTranslation.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let span;
    	let t1;
    	let button;
    	let t2_value = (/*field*/ ctx[1].messageId || "Select Message ID") + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Message ID";
    			t1 = space();
    			button = element("button");
    			t2 = text(t2_value);
    			add_location(span, file$4, 5, 2, 110);
    			attr_dev(button, "class", "svelte-ctut85");
    			add_location(button, file$4, 6, 2, 137);
    			attr_dev(div, "class", "translation svelte-ctut85");
    			add_location(div, file$4, 4, 0, 81);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			append_dev(div, button);
    			append_dev(button, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*field*/ 2 && t2_value !== (t2_value = (/*field*/ ctx[1].messageId || "Select Message ID") + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetFieldTranslation", slots, []);
    	let { field } = $$props;
    	let { choosingMessageId } = $$props;
    	const writable_props = ["field", "choosingMessageId"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetFieldTranslation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, choosingMessageId = field);

    	$$self.$$set = $$props => {
    		if ("field" in $$props) $$invalidate(1, field = $$props.field);
    		if ("choosingMessageId" in $$props) $$invalidate(0, choosingMessageId = $$props.choosingMessageId);
    	};

    	$$self.$capture_state = () => ({ field, choosingMessageId });

    	$$self.$inject_state = $$props => {
    		if ("field" in $$props) $$invalidate(1, field = $$props.field);
    		if ("choosingMessageId" in $$props) $$invalidate(0, choosingMessageId = $$props.choosingMessageId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [choosingMessageId, field, click_handler];
    }

    class WidgetFieldTranslation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { field: 1, choosingMessageId: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetFieldTranslation",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*field*/ ctx[1] === undefined && !("field" in props)) {
    			console.warn("<WidgetFieldTranslation> was created without expected prop 'field'");
    		}

    		if (/*choosingMessageId*/ ctx[0] === undefined && !("choosingMessageId" in props)) {
    			console.warn("<WidgetFieldTranslation> was created without expected prop 'choosingMessageId'");
    		}
    	}

    	get field() {
    		throw new Error("<WidgetFieldTranslation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<WidgetFieldTranslation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get choosingMessageId() {
    		throw new Error("<WidgetFieldTranslation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set choosingMessageId(value) {
    		throw new Error("<WidgetFieldTranslation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetFields\WidgetField.svelte generated by Svelte v3.38.2 */
    const file$3 = "src\\components\\WidgetFields\\WidgetField.svelte";

    // (42:2) {#if expanded[index]}
    function create_if_block$4(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = typeof /*field*/ ctx[0].messageId === "string" && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*field*/ ctx[0].messageId === "string") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*field*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(42:2) {#if expanded[index]}",
    		ctx
    	});

    	return block;
    }

    // (43:4) {#if typeof field.messageId === 'string'}
    function create_if_block_1$2(ctx) {
    	let fast_tabs;
    	let fast_tab0;
    	let span;
    	let t1;
    	let t2;
    	let fast_tab1;
    	let openbookicon;
    	let t3;
    	let defaultTab_action;
    	let t4;
    	let fast_tab_panel0;
    	let t5;
    	let fast_tab_panel1;
    	let widgetfieldtranslation;
    	let updating_choosingMessageId;
    	let updating_field;
    	let current;
    	let mounted;
    	let dispose;
    	openbookicon = new OpenBookIcon({ $$inline: true });

    	function widgetfieldtranslation_choosingMessageId_binding(value) {
    		/*widgetfieldtranslation_choosingMessageId_binding*/ ctx[10](value);
    	}

    	function widgetfieldtranslation_field_binding(value) {
    		/*widgetfieldtranslation_field_binding*/ ctx[11](value);
    	}

    	let widgetfieldtranslation_props = {};

    	if (/*choosingMessageId*/ ctx[2] !== void 0) {
    		widgetfieldtranslation_props.choosingMessageId = /*choosingMessageId*/ ctx[2];
    	}

    	if (/*field*/ ctx[0] !== void 0) {
    		widgetfieldtranslation_props.field = /*field*/ ctx[0];
    	}

    	widgetfieldtranslation = new WidgetFieldTranslation({
    			props: widgetfieldtranslation_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(widgetfieldtranslation, "choosingMessageId", widgetfieldtranslation_choosingMessageId_binding));
    	binding_callbacks.push(() => bind(widgetfieldtranslation, "field", widgetfieldtranslation_field_binding));

    	const block = {
    		c: function create() {
    			fast_tabs = element("fast-tabs");
    			fast_tab0 = element("fast-tab");
    			span = element("span");
    			span.textContent = "f(x)";
    			t1 = text("\r\n          Expression");
    			t2 = space();
    			fast_tab1 = element("fast-tab");
    			create_component(openbookicon.$$.fragment);
    			t3 = text("\r\n          Translated Message");
    			t4 = space();
    			fast_tab_panel0 = element("fast-tab-panel");
    			t5 = space();
    			fast_tab_panel1 = element("fast-tab-panel");
    			create_component(widgetfieldtranslation.$$.fragment);
    			attr_dev(span, "class", "icon svelte-1gtpujl");
    			add_location(span, file$3, 45, 10, 1652);
    			set_custom_element_data(fast_tab0, "slot", "tab");
    			add_location(fast_tab0, file$3, 44, 8, 1585);
    			set_custom_element_data(fast_tab1, "slot", "tab");
    			add_location(fast_tab1, file$3, 48, 8, 1735);
    			set_custom_element_data(fast_tab_panel0, "slot", "tabpanel");
    			add_location(fast_tab_panel0, file$3, 52, 8, 1907);
    			set_custom_element_data(fast_tab_panel1, "slot", "tabpanel");
    			add_location(fast_tab_panel1, file$3, 53, 8, 1951);
    			add_location(fast_tabs, file$3, 43, 6, 1514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_tabs, anchor);
    			append_dev(fast_tabs, fast_tab0);
    			append_dev(fast_tab0, span);
    			append_dev(fast_tab0, t1);
    			append_dev(fast_tabs, t2);
    			append_dev(fast_tabs, fast_tab1);
    			mount_component(openbookicon, fast_tab1, null);
    			append_dev(fast_tab1, t3);
    			append_dev(fast_tabs, t4);
    			append_dev(fast_tabs, fast_tab_panel0);
    			append_dev(fast_tabs, t5);
    			append_dev(fast_tabs, fast_tab_panel1);
    			mount_component(widgetfieldtranslation, fast_tab_panel1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(fast_tab0, "click", /*click_handler*/ ctx[8], false, false, false),
    					action_destroyer(defaultTab_action = defaultTab.call(null, fast_tab1, { field: /*field*/ ctx[0] })),
    					listen_dev(fast_tab1, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(fast_tabs, "click", tabClicked, false, false, false),
    					listen_dev(fast_tabs, "pointerdown", tabClicked, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (defaultTab_action && is_function(defaultTab_action.update) && dirty & /*field*/ 1) defaultTab_action.update.call(null, { field: /*field*/ ctx[0] });
    			const widgetfieldtranslation_changes = {};

    			if (!updating_choosingMessageId && dirty & /*choosingMessageId*/ 4) {
    				updating_choosingMessageId = true;
    				widgetfieldtranslation_changes.choosingMessageId = /*choosingMessageId*/ ctx[2];
    				add_flush_callback(() => updating_choosingMessageId = false);
    			}

    			if (!updating_field && dirty & /*field*/ 1) {
    				updating_field = true;
    				widgetfieldtranslation_changes.field = /*field*/ ctx[0];
    				add_flush_callback(() => updating_field = false);
    			}

    			widgetfieldtranslation.$set(widgetfieldtranslation_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(openbookicon.$$.fragment, local);
    			transition_in(widgetfieldtranslation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(openbookicon.$$.fragment, local);
    			transition_out(widgetfieldtranslation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_tabs);
    			destroy_component(openbookicon);
    			destroy_component(widgetfieldtranslation);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(43:4) {#if typeof field.messageId === 'string'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let fast_accordion_item;
    	let t0;
    	let div0;
    	let widgetfieldexpression;
    	let updating_monaco;
    	let updating_field;
    	let updating_fields;
    	let t1;
    	let div1;
    	let t2_value = /*field*/ ctx[0].name + "";
    	let t2;
    	let t3;
    	let t4_value = (/*field*/ ctx[0].required ? "(required)" : "") + "";
    	let t4;
    	let fast_accordion_item_resize_listener;
    	let current;
    	let if_block = /*expanded*/ ctx[4][/*index*/ ctx[5]] && create_if_block$4(ctx);

    	function widgetfieldexpression_monaco_binding(value) {
    		/*widgetfieldexpression_monaco_binding*/ ctx[12](value);
    	}

    	function widgetfieldexpression_field_binding(value) {
    		/*widgetfieldexpression_field_binding*/ ctx[13](value);
    	}

    	function widgetfieldexpression_fields_binding(value) {
    		/*widgetfieldexpression_fields_binding*/ ctx[14](value);
    	}

    	let widgetfieldexpression_props = {
    		expanded: /*expanded*/ ctx[4],
    		index: /*index*/ ctx[5]
    	};

    	if (/*monaco*/ ctx[3] !== void 0) {
    		widgetfieldexpression_props.monaco = /*monaco*/ ctx[3];
    	}

    	if (/*field*/ ctx[0] !== void 0) {
    		widgetfieldexpression_props.field = /*field*/ ctx[0];
    	}

    	if (/*fields*/ ctx[1] !== void 0) {
    		widgetfieldexpression_props.fields = /*fields*/ ctx[1];
    	}

    	widgetfieldexpression = new WidgetFieldExpression({
    			props: widgetfieldexpression_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(widgetfieldexpression, "monaco", widgetfieldexpression_monaco_binding));
    	binding_callbacks.push(() => bind(widgetfieldexpression, "field", widgetfieldexpression_field_binding));
    	binding_callbacks.push(() => bind(widgetfieldexpression, "fields", widgetfieldexpression_fields_binding));
    	widgetfieldexpression.$on("change", /*change_handler*/ ctx[15]);
    	let fast_accordion_item_levels = [{ slot: "item" }];
    	let fast_accordion_item_data = {};

    	for (let i = 0; i < fast_accordion_item_levels.length; i += 1) {
    		fast_accordion_item_data = assign(fast_accordion_item_data, fast_accordion_item_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			fast_accordion_item = element("fast-accordion-item");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			create_component(widgetfieldexpression.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			attr_dev(div0, "class", "expression-wrapper svelte-1gtpujl");
    			set_style(div0, "max-width", /*clientWidth*/ ctx[7] - 8 + "px");
    			toggle_class(div0, "hidden", !/*editing*/ ctx[6]);
    			add_location(div0, file$3, 59, 2, 2126);
    			attr_dev(div1, "slot", "heading");
    			add_location(div1, file$3, 62, 2, 2331);
    			set_attributes(fast_accordion_item, fast_accordion_item_data);
    			add_render_callback(() => /*fast_accordion_item_elementresize_handler*/ ctx[16].call(fast_accordion_item));
    			toggle_class(fast_accordion_item, "svelte-1gtpujl", true);
    			add_location(fast_accordion_item, file$3, 40, 0, 1374);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_accordion_item, anchor);
    			if (if_block) if_block.m(fast_accordion_item, null);
    			append_dev(fast_accordion_item, t0);
    			append_dev(fast_accordion_item, div0);
    			mount_component(widgetfieldexpression, div0, null);
    			append_dev(fast_accordion_item, t1);
    			append_dev(fast_accordion_item, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			fast_accordion_item_resize_listener = add_resize_listener(fast_accordion_item, /*fast_accordion_item_elementresize_handler*/ ctx[16].bind(fast_accordion_item));
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*expanded*/ ctx[4][/*index*/ ctx[5]]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*expanded, index*/ 48) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(fast_accordion_item, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const widgetfieldexpression_changes = {};
    			if (dirty & /*expanded*/ 16) widgetfieldexpression_changes.expanded = /*expanded*/ ctx[4];
    			if (dirty & /*index*/ 32) widgetfieldexpression_changes.index = /*index*/ ctx[5];

    			if (!updating_monaco && dirty & /*monaco*/ 8) {
    				updating_monaco = true;
    				widgetfieldexpression_changes.monaco = /*monaco*/ ctx[3];
    				add_flush_callback(() => updating_monaco = false);
    			}

    			if (!updating_field && dirty & /*field*/ 1) {
    				updating_field = true;
    				widgetfieldexpression_changes.field = /*field*/ ctx[0];
    				add_flush_callback(() => updating_field = false);
    			}

    			if (!updating_fields && dirty & /*fields*/ 2) {
    				updating_fields = true;
    				widgetfieldexpression_changes.fields = /*fields*/ ctx[1];
    				add_flush_callback(() => updating_fields = false);
    			}

    			widgetfieldexpression.$set(widgetfieldexpression_changes);

    			if (!current || dirty & /*clientWidth*/ 128) {
    				set_style(div0, "max-width", /*clientWidth*/ ctx[7] - 8 + "px");
    			}

    			if (dirty & /*editing*/ 64) {
    				toggle_class(div0, "hidden", !/*editing*/ ctx[6]);
    			}

    			if ((!current || dirty & /*field*/ 1) && t2_value !== (t2_value = /*field*/ ctx[0].name + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*field*/ 1) && t4_value !== (t4_value = (/*field*/ ctx[0].required ? "(required)" : "") + "")) set_data_dev(t4, t4_value);
    			set_attributes(fast_accordion_item, fast_accordion_item_data = get_spread_update(fast_accordion_item_levels, [{ slot: "item" }]));
    			toggle_class(fast_accordion_item, "svelte-1gtpujl", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(widgetfieldexpression.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(widgetfieldexpression.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_accordion_item);
    			if (if_block) if_block.d();
    			destroy_component(widgetfieldexpression);
    			fast_accordion_item_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getAccordionItem(node) {
    	while (node && node.tagName !== "FAST-ACCORDION-ITEM" && node.tagName !== "BODY") {
    		node = node.parentElement;
    	}

    	if (node.tagName === "FAST-ACCORDION-ITEM") {
    		return node;
    	}
    }

    function tabClicked(e) {
    	let elm = getAccordionItem(e.target);

    	if (elm) {
    		elm["expanded"] = true;
    		setTimeout(() => elm["expanded"] = true);
    	}
    }

    function defaultTab(target, { field }) {
    	const { messageId } = field;

    	if (typeof messageId === "string" && messageId) {
    		const accord = getAccordionItem(target);
    		setTimeout(() => accord && accord["expanded"] && target.click(), 800);
    	}
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetField", slots, []);
    	let { field } = $$props;
    	let { fields } = $$props;
    	let { expanded } = $$props;
    	let { index } = $$props;
    	let { choosingMessageId } = $$props;
    	let { monaco = undefined } = $$props;

    	let editing = true;
    	let clientWidth = 0;
    	const dispatch = createEventDispatcher();
    	const writable_props = ["field", "fields", "expanded", "index", "choosingMessageId", "monaco"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetField> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(6, editing = true);
    	const click_handler_1 = () => $$invalidate(6, editing = false);

    	function widgetfieldtranslation_choosingMessageId_binding(value) {
    		choosingMessageId = value;
    		$$invalidate(2, choosingMessageId);
    	}

    	function widgetfieldtranslation_field_binding(value) {
    		field = value;
    		$$invalidate(0, field);
    	}

    	function widgetfieldexpression_monaco_binding(value) {
    		monaco = value;
    		$$invalidate(3, monaco);
    	}

    	function widgetfieldexpression_field_binding(value) {
    		field = value;
    		$$invalidate(0, field);
    	}

    	function widgetfieldexpression_fields_binding(value) {
    		fields = value;
    		$$invalidate(1, fields);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function fast_accordion_item_elementresize_handler() {
    		clientWidth = this.clientWidth;
    		$$invalidate(7, clientWidth);
    	}

    	$$self.$$set = $$props => {
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    		if ("fields" in $$props) $$invalidate(1, fields = $$props.fields);
    		if ("expanded" in $$props) $$invalidate(4, expanded = $$props.expanded);
    		if ("index" in $$props) $$invalidate(5, index = $$props.index);
    		if ("choosingMessageId" in $$props) $$invalidate(2, choosingMessageId = $$props.choosingMessageId);
    		if ("monaco" in $$props) $$invalidate(3, monaco = $$props.monaco);
    	};

    	$$self.$capture_state = () => ({
    		FASTAccordionItem: exports.FASTAccordionItem,
    		createEventDispatcher,
    		OpenBookIcon,
    		WidgetFieldExpression,
    		WidgetFieldTranslation,
    		field,
    		fields,
    		expanded,
    		index,
    		choosingMessageId,
    		monaco,
    		editing,
    		clientWidth,
    		dispatch,
    		getAccordionItem,
    		tabClicked,
    		defaultTab
    	});

    	$$self.$inject_state = $$props => {
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    		if ("fields" in $$props) $$invalidate(1, fields = $$props.fields);
    		if ("expanded" in $$props) $$invalidate(4, expanded = $$props.expanded);
    		if ("index" in $$props) $$invalidate(5, index = $$props.index);
    		if ("choosingMessageId" in $$props) $$invalidate(2, choosingMessageId = $$props.choosingMessageId);
    		if ("monaco" in $$props) $$invalidate(3, monaco = $$props.monaco);
    		if ("editing" in $$props) $$invalidate(6, editing = $$props.editing);
    		if ("clientWidth" in $$props) $$invalidate(7, clientWidth = $$props.clientWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		field,
    		fields,
    		choosingMessageId,
    		monaco,
    		expanded,
    		index,
    		editing,
    		clientWidth,
    		click_handler,
    		click_handler_1,
    		widgetfieldtranslation_choosingMessageId_binding,
    		widgetfieldtranslation_field_binding,
    		widgetfieldexpression_monaco_binding,
    		widgetfieldexpression_field_binding,
    		widgetfieldexpression_fields_binding,
    		change_handler,
    		fast_accordion_item_elementresize_handler
    	];
    }

    class WidgetField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			field: 0,
    			fields: 1,
    			expanded: 4,
    			index: 5,
    			choosingMessageId: 2,
    			monaco: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetField",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*field*/ ctx[0] === undefined && !("field" in props)) {
    			console.warn("<WidgetField> was created without expected prop 'field'");
    		}

    		if (/*fields*/ ctx[1] === undefined && !("fields" in props)) {
    			console.warn("<WidgetField> was created without expected prop 'fields'");
    		}

    		if (/*expanded*/ ctx[4] === undefined && !("expanded" in props)) {
    			console.warn("<WidgetField> was created without expected prop 'expanded'");
    		}

    		if (/*index*/ ctx[5] === undefined && !("index" in props)) {
    			console.warn("<WidgetField> was created without expected prop 'index'");
    		}

    		if (/*choosingMessageId*/ ctx[2] === undefined && !("choosingMessageId" in props)) {
    			console.warn("<WidgetField> was created without expected prop 'choosingMessageId'");
    		}
    	}

    	get field() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fields() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fields(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expanded() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expanded(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get choosingMessageId() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set choosingMessageId(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monaco() {
    		throw new Error("<WidgetField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monaco(value) {
    		throw new Error("<WidgetField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\WidgetFields.svelte generated by Svelte v3.38.2 */
    const file$2 = "src\\components\\WidgetFields.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (50:6) {#each fields as field, index}
    function create_each_block$1(ctx) {
    	let widgetfield;
    	let updating_choosingMessageId;
    	let current;

    	function widgetfield_choosingMessageId_binding(value) {
    		/*widgetfield_choosingMessageId_binding*/ ctx[10](value);
    	}

    	let widgetfield_props = {
    		field: /*field*/ ctx[16],
    		fields: /*fields*/ ctx[0],
    		index: /*index*/ ctx[18],
    		monaco: /*monaco*/ ctx[2],
    		expanded: /*expanded*/ ctx[3]
    	};

    	if (/*choosingMessageId*/ ctx[6] !== void 0) {
    		widgetfield_props.choosingMessageId = /*choosingMessageId*/ ctx[6];
    	}

    	widgetfield = new WidgetField({ props: widgetfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(widgetfield, "choosingMessageId", widgetfield_choosingMessageId_binding));
    	widgetfield.$on("change", /*change_handler*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(widgetfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(widgetfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const widgetfield_changes = {};
    			if (dirty & /*fields*/ 1) widgetfield_changes.field = /*field*/ ctx[16];
    			if (dirty & /*fields*/ 1) widgetfield_changes.fields = /*fields*/ ctx[0];
    			if (dirty & /*monaco*/ 4) widgetfield_changes.monaco = /*monaco*/ ctx[2];
    			if (dirty & /*expanded*/ 8) widgetfield_changes.expanded = /*expanded*/ ctx[3];

    			if (!updating_choosingMessageId && dirty & /*choosingMessageId*/ 64) {
    				updating_choosingMessageId = true;
    				widgetfield_changes.choosingMessageId = /*choosingMessageId*/ ctx[6];
    				add_flush_callback(() => updating_choosingMessageId = false);
    			}

    			widgetfield.$set(widgetfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widgetfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widgetfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widgetfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(50:6) {#each fields as field, index}",
    		ctx
    	});

    	return block;
    }

    // (55:2) {#if choosingMessageId}
    function create_if_block$3(ctx) {
    	let div;
    	let translationsheet;
    	let current;
    	let mounted;
    	let dispose;

    	translationsheet = new TranslationSheet({
    			props: { translations: /*translations*/ ctx[1] },
    			$$inline: true
    		});

    	translationsheet.$on("change", /*change_handler_1*/ ctx[13]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(translationsheet.$$.fragment);
    			attr_dev(div, "class", "popup svelte-1yz5ue7");
    			add_location(div, file$2, 55, 4, 2633);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(translationsheet, div, null);
    			/*div_binding*/ ctx[14](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*popupClicked*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const translationsheet_changes = {};
    			if (dirty & /*translations*/ 2) translationsheet_changes.translations = /*translations*/ ctx[1];
    			translationsheet.$set(translationsheet_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(translationsheet.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(translationsheet.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(translationsheet);
    			/*div_binding*/ ctx[14](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(55:2) {#if choosingMessageId}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let fast_design_system_provider;
    	let fast_accordion;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*fields*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*choosingMessageId*/ ctx[6] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			fast_design_system_provider = element("fast-design-system-provider");
    			fast_accordion = element("fast-accordion");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			set_custom_element_data(fast_accordion, "expand-mode", "single");
    			add_location(fast_accordion, file$2, 48, 4, 2350);
    			set_custom_element_data(fast_design_system_provider, "use-defaults", "");
    			add_location(fast_design_system_provider, file$2, 47, 2, 2259);
    			attr_dev(div, "class", "fields svelte-1yz5ue7");
    			add_location(div, file$2, 46, 0, 2235);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, fast_design_system_provider);
    			append_dev(fast_design_system_provider, fast_accordion);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(fast_accordion, null);
    			}

    			/*fast_design_system_provider_binding*/ ctx[12](fast_design_system_provider);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(fast_design_system_provider, "click", /*checkExpand*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*fields, monaco, expanded, choosingMessageId*/ 77) {
    				each_value = /*fields*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(fast_accordion, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*choosingMessageId*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*choosingMessageId*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			/*fast_design_system_provider_binding*/ ctx[12](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetFields", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	const dispatch = createEventDispatcher();
    	let { monaco = undefined } = $$props;
    	let { fields = [] } = $$props;
    	let { translations = {} } = $$props;

    	let expanded = [true];
    	let wrapper;
    	let popupElement;

    	function checkExpand(event) {
    		const accordItems = Array.from(wrapper.querySelectorAll("fast-accordion-item"));

    		setTimeout(() => __awaiter(this, void 0, void 0, function* () {
    			$$invalidate(3, expanded = accordItems.map(elm => elm["expanded"]));
    		}));
    	}

    	let choosingMessageId;

    	function popupClicked(event) {
    		if (event.ctrlKey) {
    			const element = event.target;
    			const dataY = element.getAttribute("data-y");

    			if (dataY) {
    				if (choosingMessageId) {
    					const messageIdCell = popupElement.querySelector(`td[data-x="0"][data-y="${dataY}"]`);
    					$$invalidate(6, choosingMessageId["messageId"] = messageIdCell.innerText, choosingMessageId);
    					dispatch("change", fields);
    					$$invalidate(0, fields);
    				}

    				$$invalidate(6, choosingMessageId = undefined);
    			}
    		}
    	}

    	const writable_props = ["monaco", "fields", "translations"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetFields> was created with unknown prop '${key}'`);
    	});

    	function widgetfield_choosingMessageId_binding(value) {
    		choosingMessageId = value;
    		$$invalidate(6, choosingMessageId);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function fast_design_system_provider_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			wrapper = $$value;
    			$$invalidate(4, wrapper);
    		});
    	}

    	const change_handler_1 = event => {
    		if (JSON.stringify(translations) !== JSON.stringify(event.detail)) {
    			$$invalidate(1, translations = event.detail);
    			dispatch("change", fields);
    		}
    	};

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			popupElement = $$value;
    			$$invalidate(5, popupElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("monaco" in $$props) $$invalidate(2, monaco = $$props.monaco);
    		if ("fields" in $$props) $$invalidate(0, fields = $$props.fields);
    		if ("translations" in $$props) $$invalidate(1, translations = $$props.translations);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		FASTDesignSystemProvider: exports.FASTDesignSystemProvider,
    		FASTTextArea: exports.FASTTextArea,
    		FASTAccordion: exports.FASTAccordion,
    		FASTAccordionItem: exports.FASTAccordionItem,
    		FASTTabs,
    		FASTTab,
    		createEventDispatcher,
    		TranslationSheet,
    		WidgetField,
    		dispatch,
    		monaco,
    		fields,
    		translations,
    		expanded,
    		wrapper,
    		popupElement,
    		checkExpand,
    		choosingMessageId,
    		popupClicked
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("monaco" in $$props) $$invalidate(2, monaco = $$props.monaco);
    		if ("fields" in $$props) $$invalidate(0, fields = $$props.fields);
    		if ("translations" in $$props) $$invalidate(1, translations = $$props.translations);
    		if ("expanded" in $$props) $$invalidate(3, expanded = $$props.expanded);
    		if ("wrapper" in $$props) $$invalidate(4, wrapper = $$props.wrapper);
    		if ("popupElement" in $$props) $$invalidate(5, popupElement = $$props.popupElement);
    		if ("choosingMessageId" in $$props) $$invalidate(6, choosingMessageId = $$props.choosingMessageId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		fields,
    		translations,
    		monaco,
    		expanded,
    		wrapper,
    		popupElement,
    		choosingMessageId,
    		dispatch,
    		checkExpand,
    		popupClicked,
    		widgetfield_choosingMessageId_binding,
    		change_handler,
    		fast_design_system_provider_binding,
    		change_handler_1,
    		div_binding
    	];
    }

    class WidgetFields extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { monaco: 2, fields: 0, translations: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetFields",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get monaco() {
    		throw new Error("<WidgetFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monaco(value) {
    		throw new Error("<WidgetFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fields() {
    		throw new Error("<WidgetFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fields(value) {
    		throw new Error("<WidgetFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get translations() {
    		throw new Error("<WidgetFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set translations(value) {
    		throw new Error("<WidgetFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const schema = {
        "$schema": "http://json-schema.org/schema#",
        "$id": "fast-accordion",
        "id": "fast-accordion",
        "title": "Accordion",
        "description": "The FAST accordion element",
        "type": "object",
        "version": 1,
        "mapsToTagName": "fast-accordion",
        "properties": {
            "expand-mode": {
                "enum": [
                    "single",
                    "multi"
                ],
                "default": "multi",
                "title": "Expand mode",
                "description": "The way items are allowed to expand",
                "mapsToAttribute": "expand-mode",
                "type": "string"
            },
            "SlotItem": {
                "title": "Item slot",
                "description": "The default slot for accordion items",
                "mapsToSlot": "item",
                "@microsoft/fast-tooling/dictionary-link": true,
                "pluginId": "@microsoft/fast-tooling/linked-data",
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "id": {
                            "title": "The ID of the data corresponding to a dictionary key",
                            "type": "string"
                        },
                        "dataLocation": {
                            "title": "The location of the data using lodash path syntax",
                            "type": "string"
                        }
                    }
                }
            }
        }
    };
    const fields = [
        {
            name: "appearance",
            title: "Appearance",
            description: "The text area's visual treatment",
            default: "outline",
            required: true,
            type: "string",
            values: [{ name: "outline" }, { name: "filled" }]
        },
        {
            name: "resize",
            title: "Resize",
            description: "The resize mode of the element",
            required: false,
            type: "string",
            values: [{ name: "none" }, { name: "both" }, { name: "horizontal" }, { name: "vertical" }],
            default: "none"
        },
        {
            name: "autofocus",
            title: "Autofocus",
            description: "Determines if the element should receive document focus on page load",
            required: false,
            type: "boolean",
            default: false
        },
        {
            name: "cols",
            title: "Columns",
            description: "Sizes the element vertically by a number of character columns",
            required: false,
            type: "number",
            default: 20
        },
        {
            name: "form",
            description: "The form attribute",
            required: false,
            type: "string"
        },
        {
            name: "list",
            title: "List ID",
            description: "Allows associating a datalist to the component",
            required: false,
            type: "string",
            default: ""
        },
        {
            name: "maxlength",
            title: "Maximum length",
            description: "The maximum number of characters a user can enter",
            required: false,
            type: "number"
        },
        {
            name: "minlength",
            title: "Minimum length",
            description: "The minimum number of characters a user can enter",
            required: false,
            type: "number"
        },
        {
            name: "placeholder",
            title: "Placeholder",
            description: "Sets the placeholder value of the element, generally used to provide a hint to the user",
            required: false,
            type: "string"
        },
        {
            name: "rows",
            title: "Rows",
            description: "Sizes the element vertically by a number of character rows",
            required: false,
            type: "number"
        },
        {
            name: "spellcheck",
            title: "Spellcheck",
            description: "Controls whether or not to enable spell checking for the input field, or if the default spell checking configuration should be used",
            required: false,
            type: "boolean"
        },
        {
            name: "value",
            title: "Value",
            description: "The HTML value attribute of the text area",
            required: false,
            type: "string"
        },
        {
            name: "name",
            title: "Name",
            description: "This element's value will be surfaced during form submission under the provided name",
            type: "string",
            default: "",
            required: false
        },
        {
            name: "required",
            title: "Required",
            description: "Require the field to be completed prior to form submission",
            type: "boolean",
            default: false,
            required: false
        },
        {
            name: "disabled",
            title: "Disabled",
            description: "Sets the disabled state of the text area",
            type: "boolean",
            default: false,
            required: false
        },
        {
            name: "readonly",
            title: "Readonly",
            description: "When true, the control will be immutable by user interaction",
            type: "boolean",
            default: false,
            required: false
        }
    ];

    /* src\components\WidgetFieldsDialog.svelte generated by Svelte v3.38.2 */

    function create_fragment$4(ctx) {
    	let winbox;
    	let current;

    	winbox = new Winbox_1({
    			props: {
    				component: WidgetFields,
    				props: { fields: /*fields*/ ctx[0] },
    				events: {
    					change: /*change*/ ctx[4],
    					keypress: /*keypress*/ ctx[5]
    				},
    				x: /*x*/ ctx[1],
    				y: /*y*/ ctx[2],
    				title: /*title*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(winbox.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(winbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const winbox_changes = {};
    			if (dirty & /*fields*/ 1) winbox_changes.props = { fields: /*fields*/ ctx[0] };
    			if (dirty & /*x*/ 2) winbox_changes.x = /*x*/ ctx[1];
    			if (dirty & /*y*/ 4) winbox_changes.y = /*y*/ ctx[2];
    			if (dirty & /*title*/ 8) winbox_changes.title = /*title*/ ctx[3];
    			winbox.$set(winbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(winbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(winbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(winbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WidgetFieldsDialog", slots, []);
    	let { fields: fields$1 = fields } = $$props;
    	let { x = "center" } = $$props;
    	let { y = "center" } = $$props;
    	let { title = "Fields" } = $$props;
    	const dispatch = createEventDispatcher();

    	function change(e) {
    		dispatch("change", e);
    	}

    	function keypress(e) {
    		dispatch("keypress", e);
    	}

    	const writable_props = ["fields", "x", "y", "title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WidgetFieldsDialog> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("fields" in $$props) $$invalidate(0, fields$1 = $$props.fields);
    		if ("x" in $$props) $$invalidate(1, x = $$props.x);
    		if ("y" in $$props) $$invalidate(2, y = $$props.y);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({
    		Winbox: Winbox_1,
    		WidgetFields,
    		_fields: fields,
    		schema,
    		createEventDispatcher,
    		onMount,
    		fields: fields$1,
    		x,
    		y,
    		title,
    		dispatch,
    		change,
    		keypress
    	});

    	$$self.$inject_state = $$props => {
    		if ("fields" in $$props) $$invalidate(0, fields$1 = $$props.fields);
    		if ("x" in $$props) $$invalidate(1, x = $$props.x);
    		if ("y" in $$props) $$invalidate(2, y = $$props.y);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fields$1, x, y, title, change, keypress];
    }

    class WidgetFieldsDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { fields: 0, x: 1, y: 2, title: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WidgetFieldsDialog",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get fields() {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fields(value) {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<WidgetFieldsDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    /* src\components\PickField.svelte generated by Svelte v3.38.2 */

    const { Boolean: Boolean_1, Object: Object_1, console: console_1 } = globals;
    const file$1 = "src\\components\\PickField.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (129:0) {:else}
    function create_else_block(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "type prop not passed";
    			add_location(p, file$1, 129, 2, 4253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(129:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (108:15) 
    function create_if_block_1$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*type*/ ctx[2].fields || [];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getId, context, type, $expanded, $selectedFields, itemClicked, typesCollection, fieldsCollection*/ 118) {
    				each_value = /*type*/ ctx[2].fields || [];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean_1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(108:15) ",
    		ctx
    	});

    	return block;
    }

    // (104:0) {#if typeof context === 'undefined'}
    function create_if_block$2(ctx) {
    	let fast_design_system_provider;
    	let pickfield;
    	let current;

    	pickfield = new PickField({
    			props: { context: [], type: /*$rootType*/ ctx[3] },
    			$$inline: true
    		});

    	pickfield.$on("change", /*change_handler*/ ctx[11]);

    	const block = {
    		c: function create() {
    			fast_design_system_provider = element("fast-design-system-provider");
    			create_component(pickfield.$$.fragment);
    			set_custom_element_data(fast_design_system_provider, "use-defaults", "");
    			add_location(fast_design_system_provider, file$1, 104, 2, 3356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_design_system_provider, anchor);
    			mount_component(pickfield, fast_design_system_provider, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pickfield_changes = {};
    			if (dirty & /*$rootType*/ 8) pickfield_changes.type = /*$rootType*/ ctx[3];
    			pickfield.$set(pickfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pickfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pickfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_design_system_provider);
    			destroy_component(pickfield);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(104:0) {#if typeof context === 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts" context="module">import { writable }
    function create_catch_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(1:0) <script lang=\\\"ts\\\" context=\\\"module\\\">import { writable }",
    		ctx
    	});

    	return block;
    }

    // (110:42)         <fast-tree-item          {id}
    function create_then_block(ctx) {
    	let fast_tree_item;
    	let promise;
    	let fast_tree_item_id_value;
    	let fast_tree_item_expanded_value;
    	let fast_tree_item_selected_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block,
    		value: 20,
    		blocks: [,,,]
    	};

    	handle_promise(promise = typesCollection.get(/*field*/ ctx[0].type), info);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[13](/*id*/ ctx[19], ...args);
    	}

    	const block = {
    		c: function create() {
    			fast_tree_item = element("fast-tree-item");
    			info.block.c();
    			t = space();
    			set_custom_element_data(fast_tree_item, "id", fast_tree_item_id_value = /*id*/ ctx[19]);
    			set_custom_element_data(fast_tree_item, "expanded", fast_tree_item_expanded_value = !!/*$expanded*/ ctx[4][/*id*/ ctx[19]]);
    			set_custom_element_data(fast_tree_item, "selected", fast_tree_item_selected_value = /*$selectedFields*/ ctx[5].indexOf(/*id*/ ctx[19]) > -1);
    			add_location(fast_tree_item, file$1, 110, 6, 3600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_tree_item, anchor);
    			info.block.m(fast_tree_item, info.anchor = null);
    			info.mount = () => fast_tree_item;
    			info.anchor = null;
    			insert_dev(target, t, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(fast_tree_item, "click", self$1(click_handler), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*type*/ 4 && promise !== (promise = typesCollection.get(/*field*/ ctx[0].type)) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			if (!current || dirty & /*context, type*/ 6 && fast_tree_item_id_value !== (fast_tree_item_id_value = /*id*/ ctx[19])) {
    				set_custom_element_data(fast_tree_item, "id", fast_tree_item_id_value);
    			}

    			if (!current || dirty & /*$expanded, context, type*/ 22 && fast_tree_item_expanded_value !== (fast_tree_item_expanded_value = !!/*$expanded*/ ctx[4][/*id*/ ctx[19]])) {
    				set_custom_element_data(fast_tree_item, "expanded", fast_tree_item_expanded_value);
    			}

    			if (!current || dirty & /*$selectedFields, context, type*/ 38 && fast_tree_item_selected_value !== (fast_tree_item_selected_value = /*$selectedFields*/ ctx[5].indexOf(/*id*/ ctx[19]) > -1)) {
    				set_custom_element_data(fast_tree_item, "selected", fast_tree_item_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_tree_item);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(110:42)         <fast-tree-item          {id}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts" context="module">import { writable }
    function create_catch_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script lang=\\\"ts\\\" context=\\\"module\\\">import { writable }",
    		ctx
    	});

    	return block;
    }

    // (117:63)             {fieldsCollection.set(id, field) ? '' : ''}
    function create_then_block_1(ctx) {
    	let t0_value = (fieldsCollection.set(/*id*/ ctx[19], /*field*/ ctx[0])
    	? ""
    	: "") + "";

    	let t0;
    	let t1;
    	let t2_value = /*field*/ ctx[0].name + "";
    	let t2;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$1, create_if_block_3$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$expanded*/ ctx[4][/*id*/ ctx[19]]) return 0;
    		if (/*fieldType*/ ctx[20] && /*fieldType*/ ctx[20].fields && /*fieldType*/ ctx[20].fields.length) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*context, type*/ 6) && t0_value !== (t0_value = (fieldsCollection.set(/*id*/ ctx[19], /*field*/ ctx[0])
    			? ""
    			: "") + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*type*/ 4) && t2_value !== (t2_value = /*field*/ ctx[0].name + "")) set_data_dev(t2, t2_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(117:63)             {fieldsCollection.set(id, field) ? '' : ''}",
    		ctx
    	});

    	return block;
    }

    // (122:77) 
    function create_if_block_3$1(ctx) {
    	let fast_tree_item;

    	const block = {
    		c: function create() {
    			fast_tree_item = element("fast-tree-item");
    			add_location(fast_tree_item, file$1, 122, 12, 4137);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_tree_item, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_tree_item);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(122:77) ",
    		ctx
    	});

    	return block;
    }

    // (120:10) {#if $expanded[id]}
    function create_if_block_2$1(ctx) {
    	let pickfield;
    	let current;

    	pickfield = new PickField({
    			props: {
    				context: [.../*context*/ ctx[1], /*field*/ ctx[0].name],
    				type: /*fieldType*/ ctx[20]
    			},
    			$$inline: true
    		});

    	pickfield.$on("change", /*change_handler_1*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(pickfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pickfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pickfield_changes = {};
    			if (dirty & /*context, type*/ 6) pickfield_changes.context = [.../*context*/ ctx[1], /*field*/ ctx[0].name];
    			if (dirty & /*type*/ 4) pickfield_changes.type = /*fieldType*/ ctx[20];
    			pickfield.$set(pickfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pickfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pickfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pickfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(120:10) {#if $expanded[id]}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts" context="module">import { writable }
    function create_pending_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(1:0) <script lang=\\\"ts\\\" context=\\\"module\\\">import { writable }",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts" context="module">import { writable }
    function create_pending_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(1:0) <script lang=\\\"ts\\\" context=\\\"module\\\">import { writable }",
    		ctx
    	});

    	return block;
    }

    // (109:2) {#each type.fields || [] as field}
    function create_each_block(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block_1,
    		value: 19,
    		blocks: [,,,]
    	};

    	handle_promise(promise = getId(/*context*/ ctx[1], /*field*/ ctx[0]), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*context, type*/ 6 && promise !== (promise = getId(/*context*/ ctx[1], /*field*/ ctx[0])) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(109:2) {#each type.fields || [] as field}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_if_block_1$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (typeof /*context*/ ctx[1] === "undefined") return 0;
    		if (/*type*/ ctx[2]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const state = writable({});
    const typesCollection = new Map();
    const fieldsCollection = new Map();
    const rootType = writable(null);
    const expanded = writable({});
    const selectedFields = writable([]);

    function setTypes(es) {
    	for (const e of es) {
    		e.fields = (e.fields || []).map(f => {
    			let type = f.type;
    			while (type.ofType) type = type.ofType;
    			return Object.assign(Object.assign({}, f), { type: type.name });
    		});

    		typesCollection.set(e.name, e);
    	}
    }

    function getId(context, field) {
    	return [...context, field.name].join(".");
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $expanded,
    		$$unsubscribe_expanded = noop;

    	let $selectedFields,
    		$$unsubscribe_selectedFields = noop;

    	let $rootType,
    		$$unsubscribe_rootType = noop;

    	validate_store(expanded, "expanded");
    	component_subscribe($$self, expanded, $$value => $$invalidate(4, $expanded = $$value));
    	validate_store(selectedFields, "selectedFields");
    	component_subscribe($$self, selectedFields, $$value => $$invalidate(5, $selectedFields = $$value));
    	validate_store(rootType, "rootType");
    	component_subscribe($$self, rootType, $$value => $$invalidate(3, $rootType = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_expanded());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedFields());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_rootType());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PickField", slots, []);
    	const dispatch = createEventDispatcher();
    	let { intro = undefined } = $$props;
    	let { rootName = "query_root" } = $$props;
    	let { context = undefined } = $$props;
    	let { types = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let { mode = "one" } = $$props;
    	let { field = undefined } = $$props;

    	function update() {
    		$$invalidate(7, types = JSON.parse(JSON.stringify(intro.types)));
    		setTypes(types);
    		rootType.set(typesCollection.get(rootName));
    	}

    	function itemClicked(event, id) {
    		const element = event.target;

    		if (event.ctrlKey) {
    			const start = element;
    			set_store_value(expanded, $expanded[id] = true, $expanded);
    			setTimeout(() => expand(start), 100);

    			function expand(node) {
    				const list = Array.from(node.querySelectorAll("fast-tree-item"));
    				console.log("PickField", list);

    				for (const element of list) {
    					setTimeout(
    						() => {
    							set_store_value(expanded, $expanded[element.id] = true, $expanded);
    						},
    						100
    					);
    				}
    			}

    			return;
    		}

    		if (mode === "one") {
    			if (element["selected"]) {
    				set_store_value(selectedFields, $selectedFields = [id], $selectedFields);
    			} else if ($selectedFields[0] === id) {
    				set_store_value(selectedFields, $selectedFields = [], $selectedFields);
    			}
    		} else if (mode === "many") {
    			if (element["selected"]) {
    				set_store_value(selectedFields, $selectedFields = [...$selectedFields, id], $selectedFields);
    			} else if ($selectedFields[0] === id) {
    				set_store_value(selectedFields, $selectedFields = $selectedFields.filter(fid => fid !== id), $selectedFields);
    			}
    		}

    		if ($expanded[id] !== !!element["expanded"]) {
    			set_store_value(expanded, $expanded[id] = !!element["expanded"], $expanded);
    			dispatch("expand", $expanded[id]);
    		}

    		notify();
    	}

    	function notify() {
    		let fields = $selectedFields.map(k => fieldsCollection.get(k)).filter(Boolean);

    		const fieldsWithType = fields.map(field => {
    			const type = typesCollection.get(field.type);
    			if (type) Object.assign(field, { $$: type });
    			return field;
    		});

    		if (mode === "one") {
    			$$invalidate(0, field = fieldsWithType[0] || null);
    		} else if (mode === "many") {
    			$$invalidate(0, field = fieldsWithType);
    		}

    		dispatch("change", field);
    	}

    	const writable_props = ["intro", "rootName", "context", "types", "type", "mode", "field"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<PickField> was created with unknown prop '${key}'`);
    	});

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler_1(event) {
    		bubble($$self, event);
    	}

    	const click_handler = (id, e) => itemClicked(e, id);

    	$$self.$$set = $$props => {
    		if ("intro" in $$props) $$invalidate(8, intro = $$props.intro);
    		if ("rootName" in $$props) $$invalidate(9, rootName = $$props.rootName);
    		if ("context" in $$props) $$invalidate(1, context = $$props.context);
    		if ("types" in $$props) $$invalidate(7, types = $$props.types);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("mode" in $$props) $$invalidate(10, mode = $$props.mode);
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		state,
    		typesCollection,
    		fieldsCollection,
    		rootType,
    		expanded,
    		selectedFields,
    		setTypes,
    		getId,
    		FASTDesignSystemProvider: exports.FASTDesignSystemProvider,
    		FASTTreeView: exports.FASTTreeView,
    		FASTTreeItem: exports.FASTTreeItem,
    		createEventDispatcher,
    		dispatch,
    		intro,
    		rootName,
    		context,
    		types,
    		type,
    		mode,
    		field,
    		update,
    		itemClicked,
    		notify,
    		$expanded,
    		$selectedFields,
    		$rootType
    	});

    	$$self.$inject_state = $$props => {
    		if ("intro" in $$props) $$invalidate(8, intro = $$props.intro);
    		if ("rootName" in $$props) $$invalidate(9, rootName = $$props.rootName);
    		if ("context" in $$props) $$invalidate(1, context = $$props.context);
    		if ("types" in $$props) $$invalidate(7, types = $$props.types);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("mode" in $$props) $$invalidate(10, mode = $$props.mode);
    		if ("field" in $$props) $$invalidate(0, field = $$props.field);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*intro*/ 256) {
    			if (intro) update();
    		}

    		if ($$self.$$.dirty & /*$rootType*/ 8) {
    			if ($rootType && $rootType.fields.length === 1) {
    				for (const f of $rootType.fields) {
    					set_store_value(expanded, $expanded[f.name] = true, $expanded);
    				}
    			}
    		}
    	};

    	return [
    		field,
    		context,
    		type,
    		$rootType,
    		$expanded,
    		$selectedFields,
    		itemClicked,
    		types,
    		intro,
    		rootName,
    		mode,
    		change_handler,
    		change_handler_1,
    		click_handler
    	];
    }

    class PickField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			intro: 8,
    			rootName: 9,
    			context: 1,
    			types: 7,
    			type: 2,
    			mode: 10,
    			field: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PickField",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get intro() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set intro(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rootName() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rootName(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get context() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set context(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get types() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set types(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get field() {
    		throw new Error("<PickField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<PickField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\InsertField.svelte generated by Svelte v3.38.2 */
    const file = "src\\components\\InsertField.svelte";

    // (50:8) {#if okButton}
    function create_if_block$1(ctx) {
    	let fast_button;
    	let t;
    	let fast_button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			fast_button = element("fast-button");
    			t = text("OK");
    			set_custom_element_data(fast_button, "disabled", fast_button_disabled_value = !/*isValid*/ ctx[3]);
    			add_location(fast_button, file, 50, 11, 1481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_button, anchor);
    			append_dev(fast_button, t);

    			if (!mounted) {
    				dispose = listen_dev(fast_button, "click", /*handleSelect*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*isValid*/ 8 && fast_button_disabled_value !== (fast_button_disabled_value = !/*isValid*/ ctx[3])) {
    				set_custom_element_data(fast_button, "disabled", fast_button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(50:8) {#if okButton}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let fast_design_system_provider;
    	let table;
    	let tr;
    	let td0;
    	let fast_radio_group;
    	let fast_radio0;
    	let t1;
    	let fast_radio1;
    	let t3;
    	let td1;
    	let t4;
    	let pickfield;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*okButton*/ ctx[1] && create_if_block$1(ctx);

    	pickfield = new PickField({
    			props: { mode: "many", intro: /*intro*/ ctx[0] },
    			$$inline: true
    		});

    	pickfield.$on("change", /*handleChange*/ ctx[5]);

    	const block = {
    		c: function create() {
    			fast_design_system_provider = element("fast-design-system-provider");
    			table = element("table");
    			tr = element("tr");
    			td0 = element("td");
    			fast_radio_group = element("fast-radio-group");
    			fast_radio0 = element("fast-radio");
    			fast_radio0.textContent = "Insert before";
    			t1 = space();
    			fast_radio1 = element("fast-radio");
    			fast_radio1.textContent = "Insert after";
    			t3 = space();
    			td1 = element("td");
    			if (if_block) if_block.c();
    			t4 = space();
    			create_component(pickfield.$$.fragment);
    			set_custom_element_data(fast_radio0, "value", "before");
    			add_location(fast_radio0, file, 44, 10, 1219);
    			set_custom_element_data(fast_radio1, "value", "after");
    			add_location(fast_radio1, file, 45, 10, 1321);
    			set_custom_element_data(fast_radio_group, "value", "before");
    			set_custom_element_data(fast_radio_group, "class", "svelte-1fxqrds");
    			add_location(fast_radio_group, file, 43, 8, 1156);
    			add_location(td0, file, 42, 6, 1142);
    			add_location(td1, file, 48, 6, 1440);
    			add_location(tr, file, 41, 4, 1130);
    			attr_dev(table, "width", "100%");
    			add_location(table, file, 40, 2, 1104);
    			set_custom_element_data(fast_design_system_provider, "use-defaults", "");
    			set_custom_element_data(fast_design_system_provider, "class", "svelte-1fxqrds");
    			add_location(fast_design_system_provider, file, 39, 0, 1058);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fast_design_system_provider, anchor);
    			append_dev(fast_design_system_provider, table);
    			append_dev(table, tr);
    			append_dev(tr, td0);
    			append_dev(td0, fast_radio_group);
    			append_dev(fast_radio_group, fast_radio0);
    			append_dev(fast_radio_group, t1);
    			append_dev(fast_radio_group, fast_radio1);
    			/*fast_radio_group_binding*/ ctx[9](fast_radio_group);
    			append_dev(tr, t3);
    			append_dev(tr, td1);
    			if (if_block) if_block.m(td1, null);
    			append_dev(fast_design_system_provider, t4);
    			mount_component(pickfield, fast_design_system_provider, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(checkByDefault.call(null, fast_radio0)),
    					listen_dev(fast_radio0, "click", /*notify*/ ctx[4], false, false, false),
    					listen_dev(fast_radio1, "click", /*notify*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*okButton*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(td1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const pickfield_changes = {};
    			if (dirty & /*intro*/ 1) pickfield_changes.intro = /*intro*/ ctx[0];
    			pickfield.$set(pickfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pickfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pickfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fast_design_system_provider);
    			/*fast_radio_group_binding*/ ctx[9](null);
    			if (if_block) if_block.d();
    			destroy_component(pickfield);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function checkByDefault(element) {
    	setTimeout(() => {
    		element["checked"] = true;
    	});
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let isValid;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InsertField", slots, []);
    	let { intro } = $$props;
    	let { beforeAfter = "before" } = $$props;
    	let { okButton = false } = $$props;
    	let radio;
    	let fields;
    	const dispatch = createEventDispatcher();

    	function notify() {
    		const value = radio["value"];

    		if (value !== beforeAfter) {
    			$$invalidate(7, beforeAfter = value);
    			handleChange(new CustomEvent("change", { detail: fields }));
    		}
    	}

    	function handleChange(event) {
    		$$invalidate(8, fields = event.detail);
    		dispatch("change", { beforeAfter, fields: event.detail });
    	}

    	function handleSelect() {
    		dispatch("select", { beforeAfter, fields });
    	}

    	const writable_props = ["intro", "beforeAfter", "okButton"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InsertField> was created with unknown prop '${key}'`);
    	});

    	function fast_radio_group_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			radio = $$value;
    			$$invalidate(2, radio);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("intro" in $$props) $$invalidate(0, intro = $$props.intro);
    		if ("beforeAfter" in $$props) $$invalidate(7, beforeAfter = $$props.beforeAfter);
    		if ("okButton" in $$props) $$invalidate(1, okButton = $$props.okButton);
    	};

    	$$self.$capture_state = () => ({
    		FASTDesignSystemProvider: exports.FASTDesignSystemProvider,
    		FASTRadioGroup: exports.FASTRadioGroup,
    		FASTRadio: exports.FASTRadio,
    		FASTButton,
    		PickField,
    		createEventDispatcher,
    		intro,
    		beforeAfter,
    		okButton,
    		radio,
    		fields,
    		dispatch,
    		checkByDefault,
    		notify,
    		handleChange,
    		handleSelect,
    		isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ("intro" in $$props) $$invalidate(0, intro = $$props.intro);
    		if ("beforeAfter" in $$props) $$invalidate(7, beforeAfter = $$props.beforeAfter);
    		if ("okButton" in $$props) $$invalidate(1, okButton = $$props.okButton);
    		if ("radio" in $$props) $$invalidate(2, radio = $$props.radio);
    		if ("fields" in $$props) $$invalidate(8, fields = $$props.fields);
    		if ("isValid" in $$props) $$invalidate(3, isValid = $$props.isValid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fields, beforeAfter*/ 384) {
    			$$invalidate(3, isValid = fields && beforeAfter);
    		}
    	};

    	return [
    		intro,
    		okButton,
    		radio,
    		isValid,
    		notify,
    		handleChange,
    		handleSelect,
    		beforeAfter,
    		fields,
    		fast_radio_group_binding
    	];
    }

    class InsertField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { intro: 0, beforeAfter: 7, okButton: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InsertField",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*intro*/ ctx[0] === undefined && !("intro" in props)) {
    			console.warn("<InsertField> was created without expected prop 'intro'");
    		}
    	}

    	get intro() {
    		throw new Error("<InsertField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set intro(value) {
    		throw new Error("<InsertField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get beforeAfter() {
    		throw new Error("<InsertField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set beforeAfter(value) {
    		throw new Error("<InsertField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get okButton() {
    		throw new Error("<InsertField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set okButton(value) {
    		throw new Error("<InsertField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\InsertFieldDialog.svelte generated by Svelte v3.38.2 */

    function create_fragment$1(ctx) {
    	let winbox;
    	let current;

    	winbox = new Winbox_1({
    			props: {
    				component: InsertField,
    				props: { intro: /*intro*/ ctx[0], okButton: true },
    				events: {
    					change: /*change*/ ctx[4],
    					select: /*select*/ ctx[5]
    				},
    				x: /*x*/ ctx[1],
    				y: /*y*/ ctx[2],
    				title: /*title*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(winbox.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(winbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const winbox_changes = {};
    			if (dirty & /*intro*/ 1) winbox_changes.props = { intro: /*intro*/ ctx[0], okButton: true };
    			if (dirty & /*x*/ 2) winbox_changes.x = /*x*/ ctx[1];
    			if (dirty & /*y*/ 4) winbox_changes.y = /*y*/ ctx[2];
    			if (dirty & /*title*/ 8) winbox_changes.title = /*title*/ ctx[3];
    			winbox.$set(winbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(winbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(winbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(winbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InsertFieldDialog", slots, []);
    	let { intro } = $$props;
    	let { x = "center" } = $$props;
    	let { y = "center" } = $$props;
    	let { title = "Fields" } = $$props;
    	const dispatch = createEventDispatcher();

    	function change(e) {
    		const data = {
    			beforeAfter: e.detail.beforeAfter,
    			selectedFields: e.detail.fields
    		};

    		dispatch("change", data);
    	}

    	function select(e) {
    		const data = {
    			beforeAfter: e.detail.beforeAfter,
    			selectedFields: e.detail.fields
    		};

    		dispatch("select", data);
    	}

    	const writable_props = ["intro", "x", "y", "title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InsertFieldDialog> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("intro" in $$props) $$invalidate(0, intro = $$props.intro);
    		if ("x" in $$props) $$invalidate(1, x = $$props.x);
    		if ("y" in $$props) $$invalidate(2, y = $$props.y);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({
    		Winbox: Winbox_1,
    		InsertField,
    		createEventDispatcher,
    		onMount,
    		intro,
    		x,
    		y,
    		title,
    		dispatch,
    		change,
    		select
    	});

    	$$self.$inject_state = $$props => {
    		if ("intro" in $$props) $$invalidate(0, intro = $$props.intro);
    		if ("x" in $$props) $$invalidate(1, x = $$props.x);
    		if ("y" in $$props) $$invalidate(2, y = $$props.y);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [intro, x, y, title, change, select];
    }

    class InsertFieldDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { intro: 0, x: 1, y: 2, title: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InsertFieldDialog",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*intro*/ ctx[0] === undefined && !("intro" in props)) {
    			console.warn("<InsertFieldDialog> was created without expected prop 'intro'");
    		}
    	}

    	get intro() {
    		throw new Error("<InsertFieldDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set intro(value) {
    		throw new Error("<InsertFieldDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<InsertFieldDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<InsertFieldDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<InsertFieldDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<InsertFieldDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<InsertFieldDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<InsertFieldDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Wysiwyg.svelte generated by Svelte v3.38.2 */

    const { window: window_1 } = globals;

    // (104:0) {#if hoverElement || editingElement}
    function create_if_block(ctx) {
    	let widgetframe;
    	let updating_offset;
    	let updating_boundries;
    	let t;
    	let if_block_anchor;
    	let current;

    	function widgetframe_offset_binding(value) {
    		/*widgetframe_offset_binding*/ ctx[17](value);
    	}

    	function widgetframe_boundries_binding(value) {
    		/*widgetframe_boundries_binding*/ ctx[18](value);
    	}

    	let widgetframe_props = {
    		mode: /*wysiwygMode*/ ctx[6],
    		element: /*editingElement*/ ctx[5] && /*wysiwygMode*/ ctx[6] === "editing"
    		? /*editingElement*/ ctx[5]
    		: /*hoverElement*/ ctx[4]
    	};

    	if (/*frameOffset*/ ctx[0] !== void 0) {
    		widgetframe_props.offset = /*frameOffset*/ ctx[0];
    	}

    	if (/*frameBoundries*/ ctx[1] !== void 0) {
    		widgetframe_props.boundries = /*frameBoundries*/ ctx[1];
    	}

    	widgetframe = new WidgetFrame({ props: widgetframe_props, $$inline: true });
    	binding_callbacks.push(() => bind(widgetframe, "offset", widgetframe_offset_binding));
    	binding_callbacks.push(() => bind(widgetframe, "boundries", widgetframe_boundries_binding));
    	widgetframe.$on("clone", /*onClone*/ ctx[9]);
    	widgetframe.$on("hover", /*onMouseOver*/ ctx[10]);
    	widgetframe.$on("modechange", /*onModeChange*/ ctx[11]);
    	widgetframe.$on("showsource", /*onShowSource*/ ctx[12]);
    	widgetframe.$on("delete", /*onDelete*/ ctx[13]);
    	let if_block = /*editingElement*/ ctx[5] && /*wysiwygMode*/ ctx[6] === "editing" && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			create_component(widgetframe.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(widgetframe, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const widgetframe_changes = {};
    			if (dirty & /*wysiwygMode*/ 64) widgetframe_changes.mode = /*wysiwygMode*/ ctx[6];

    			if (dirty & /*editingElement, wysiwygMode, hoverElement*/ 112) widgetframe_changes.element = /*editingElement*/ ctx[5] && /*wysiwygMode*/ ctx[6] === "editing"
    			? /*editingElement*/ ctx[5]
    			: /*hoverElement*/ ctx[4];

    			if (!updating_offset && dirty & /*frameOffset*/ 1) {
    				updating_offset = true;
    				widgetframe_changes.offset = /*frameOffset*/ ctx[0];
    				add_flush_callback(() => updating_offset = false);
    			}

    			if (!updating_boundries && dirty & /*frameBoundries*/ 2) {
    				updating_boundries = true;
    				widgetframe_changes.boundries = /*frameBoundries*/ ctx[1];
    				add_flush_callback(() => updating_boundries = false);
    			}

    			widgetframe.$set(widgetframe_changes);

    			if (/*editingElement*/ ctx[5] && /*wysiwygMode*/ ctx[6] === "editing") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*editingElement, wysiwygMode*/ 96) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widgetframe.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widgetframe.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widgetframe, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(104:0) {#if hoverElement || editingElement}",
    		ctx
    	});

    	return block;
    }

    // (116:2) {#if editingElement && wysiwygMode === 'editing'}
    function create_if_block_1(ctx) {
    	let widgetelevation;
    	let t0;
    	let t1;
    	let if_block1_anchor;
    	let current;

    	widgetelevation = new WidgetElevation({
    			props: { element: /*editingElement*/ ctx[5] },
    			$$inline: true
    		});

    	widgetelevation.$on("click", /*click_handler*/ ctx[19]);
    	let if_block0 = /*displayInsertField*/ ctx[2] && create_if_block_3(ctx);
    	let if_block1 = /*displayWidgetFields*/ ctx[3] && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			create_component(widgetelevation.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(widgetelevation, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const widgetelevation_changes = {};
    			if (dirty & /*editingElement*/ 32) widgetelevation_changes.element = /*editingElement*/ ctx[5];
    			widgetelevation.$set(widgetelevation_changes);

    			if (/*displayInsertField*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*displayInsertField*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*displayWidgetFields*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*displayWidgetFields*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widgetelevation.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widgetelevation.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widgetelevation, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(116:2) {#if editingElement && wysiwygMode === 'editing'}",
    		ctx
    	});

    	return block;
    }

    // (118:4) {#if displayInsertField}
    function create_if_block_3(ctx) {
    	let insertfielddialog;
    	let current;

    	const insertfielddialog_spread_levels = [
    		{ x: /*winboxPosX*/ ctx[7] },
    		{ y: /*winboxPosY*/ ctx[8] },
    		{ title: "Insert Field" },
    		/*displayInsertField*/ ctx[2]
    	];

    	let insertfielddialog_props = {};

    	for (let i = 0; i < insertfielddialog_spread_levels.length; i += 1) {
    		insertfielddialog_props = assign(insertfielddialog_props, insertfielddialog_spread_levels[i]);
    	}

    	insertfielddialog = new InsertFieldDialog({
    			props: insertfielddialog_props,
    			$$inline: true
    		});

    	insertfielddialog.$on("select", /*select_handler*/ ctx[20]);

    	const block = {
    		c: function create() {
    			create_component(insertfielddialog.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(insertfielddialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const insertfielddialog_changes = (dirty & /*winboxPosX, winboxPosY, displayInsertField*/ 388)
    			? get_spread_update(insertfielddialog_spread_levels, [
    					dirty & /*winboxPosX*/ 128 && { x: /*winboxPosX*/ ctx[7] },
    					dirty & /*winboxPosY*/ 256 && { y: /*winboxPosY*/ ctx[8] },
    					insertfielddialog_spread_levels[2],
    					dirty & /*displayInsertField*/ 4 && get_spread_object(/*displayInsertField*/ ctx[2])
    				])
    			: {};

    			insertfielddialog.$set(insertfielddialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(insertfielddialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(insertfielddialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(insertfielddialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(118:4) {#if displayInsertField}",
    		ctx
    	});

    	return block;
    }

    // (127:4) {#if displayWidgetFields}
    function create_if_block_2(ctx) {
    	let widgetfieldsdialog;
    	let current;

    	const widgetfieldsdialog_spread_levels = [
    		{ x: /*winboxPosX*/ ctx[7] },
    		{ y: /*winboxPosY*/ ctx[8] },
    		{ title: "Fields" },
    		/*displayWidgetFields*/ ctx[3]
    	];

    	let widgetfieldsdialog_props = {};

    	for (let i = 0; i < widgetfieldsdialog_spread_levels.length; i += 1) {
    		widgetfieldsdialog_props = assign(widgetfieldsdialog_props, widgetfieldsdialog_spread_levels[i]);
    	}

    	widgetfieldsdialog = new WidgetFieldsDialog({
    			props: widgetfieldsdialog_props,
    			$$inline: true
    		});

    	widgetfieldsdialog.$on("change", /*change_handler*/ ctx[21]);

    	const block = {
    		c: function create() {
    			create_component(widgetfieldsdialog.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(widgetfieldsdialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const widgetfieldsdialog_changes = (dirty & /*winboxPosX, winboxPosY, displayWidgetFields*/ 392)
    			? get_spread_update(widgetfieldsdialog_spread_levels, [
    					dirty & /*winboxPosX*/ 128 && { x: /*winboxPosX*/ ctx[7] },
    					dirty & /*winboxPosY*/ 256 && { y: /*winboxPosY*/ ctx[8] },
    					widgetfieldsdialog_spread_levels[2],
    					dirty & /*displayWidgetFields*/ 8 && get_spread_object(/*displayWidgetFields*/ ctx[3])
    				])
    			: {};

    			widgetfieldsdialog.$set(widgetfieldsdialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widgetfieldsdialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widgetfieldsdialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widgetfieldsdialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(127:4) {#if displayWidgetFields}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = (/*hoverElement*/ ctx[4] || /*editingElement*/ ctx[5]) && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1, "keydown", /*keydown_handler*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*hoverElement*/ ctx[4] || /*editingElement*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hoverElement, editingElement*/ 48) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Wysiwyg", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { win = window } = $$props;
    	let displayInsertField;
    	let displayWidgetFields;
    	let hoverElement;
    	let editingElement;
    	let wysiwygMode = "inspecting";
    	const dispatch = createEventDispatcher();

    	onMount(() => {
    		win.addEventListener("pointermove", event => {
    			$$invalidate(4, hoverElement = event.target);
    		});
    	});

    	function onClone() {
    		// propagate callbacks for displaying extra modal dialogs
    		dispatch("clone", {
    			editingElement,
    			dialogInsertField: params => __awaiter(this, void 0, void 0, function* () {
    				$$invalidate(2, displayInsertField = params);
    			}), // TODO promise should contain selected field from dialog
    			
    		});

    		escape();
    	}

    	function dialogWidgetFields(params) {
    		$$invalidate(3, displayWidgetFields = params);
    	}

    	function onMouseOver(e) {
    		// propagate callback to alter behaviour of <WidgetFrame/>
    		dispatch("hover", {
    			hoverElement,
    			inspect: e.detail,
    			dialogWidgetFields
    		});
    	}

    	function onModeChange(e) {
    		if (wysiwygMode !== "editing") {
    			$$invalidate(2, displayInsertField = undefined);
    			$$invalidate(3, displayWidgetFields = undefined);
    			$$invalidate(5, editingElement = hoverElement);
    		}

    		$$invalidate(6, wysiwygMode = e.detail.mode);

    		dispatch("modechange", {
    			mode: e.detail.mode,
    			editingElement,
    			dialogWidgetFields
    		});

    		if (wysiwygMode === "editing") {
    			dispatch("editing", {
    				mode: e.detail.mode,
    				editingElement,
    				dialogWidgetFields
    			});
    		}
    	}

    	function onShowSource() {
    		dispatch("showsource", { editingElement });
    	}

    	function onDelete() {
    		dispatch("delete", { editingElement });
    		escape();
    	}

    	let frameOffset = { top: 0, left: 0 };
    	let frameBoundries = new DOMRect();
    	let winboxPosX = "center";
    	let winboxPosY = "center";

    	function escape() {
    		$$invalidate(5, editingElement = null);
    		$$invalidate(6, wysiwygMode = "inspecting");
    	}

    	const writable_props = ["win"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Wysiwyg> was created with unknown prop '${key}'`);
    	});

    	const keydown_handler = event => {
    		if (event.key === "Escape") {
    			escape();
    		}
    	};

    	function widgetframe_offset_binding(value) {
    		frameOffset = value;
    		$$invalidate(0, frameOffset);
    	}

    	function widgetframe_boundries_binding(value) {
    		frameBoundries = value;
    		$$invalidate(1, frameBoundries);
    	}

    	const click_handler = () => $$invalidate(6, wysiwygMode = "inspecting");
    	const select_handler = e => displayInsertField?.fieldSelected && displayInsertField?.fieldSelected(e.detail);
    	const change_handler = e => displayWidgetFields?.fieldsChanged && displayWidgetFields?.fieldsChanged(e.detail);

    	$$self.$$set = $$props => {
    		if ("win" in $$props) $$invalidate(15, win = $$props.win);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		WidgetElevation,
    		WidgetFrame,
    		WidgetFieldsDialog,
    		InsertFieldDialog,
    		createEventDispatcher,
    		onMount,
    		win,
    		displayInsertField,
    		displayWidgetFields,
    		hoverElement,
    		editingElement,
    		wysiwygMode,
    		dispatch,
    		onClone,
    		dialogWidgetFields,
    		onMouseOver,
    		onModeChange,
    		onShowSource,
    		onDelete,
    		frameOffset,
    		frameBoundries,
    		winboxPosX,
    		winboxPosY,
    		escape
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("win" in $$props) $$invalidate(15, win = $$props.win);
    		if ("displayInsertField" in $$props) $$invalidate(2, displayInsertField = $$props.displayInsertField);
    		if ("displayWidgetFields" in $$props) $$invalidate(3, displayWidgetFields = $$props.displayWidgetFields);
    		if ("hoverElement" in $$props) $$invalidate(4, hoverElement = $$props.hoverElement);
    		if ("editingElement" in $$props) $$invalidate(5, editingElement = $$props.editingElement);
    		if ("wysiwygMode" in $$props) $$invalidate(6, wysiwygMode = $$props.wysiwygMode);
    		if ("frameOffset" in $$props) $$invalidate(0, frameOffset = $$props.frameOffset);
    		if ("frameBoundries" in $$props) $$invalidate(1, frameBoundries = $$props.frameBoundries);
    		if ("winboxPosX" in $$props) $$invalidate(7, winboxPosX = $$props.winboxPosX);
    		if ("winboxPosY" in $$props) $$invalidate(8, winboxPosY = $$props.winboxPosY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*frameBoundries, frameOffset*/ 3) {
    			if (frameBoundries) {
    				let top = frameOffset.top + frameBoundries.top;
    				let left = frameOffset.left + frameBoundries.left;

    				$$invalidate(7, winboxPosX = left < (window.innerWidth - frameBoundries.width) / 2
    				? "right"
    				: "left");

    				$$invalidate(8, winboxPosY = top < (window.innerHeight - frameBoundries.height) / 2
    				? "bottom"
    				: "top");
    			}
    		}
    	};

    	return [
    		frameOffset,
    		frameBoundries,
    		displayInsertField,
    		displayWidgetFields,
    		hoverElement,
    		editingElement,
    		wysiwygMode,
    		winboxPosX,
    		winboxPosY,
    		onClone,
    		onMouseOver,
    		onModeChange,
    		onShowSource,
    		onDelete,
    		escape,
    		win,
    		keydown_handler,
    		widgetframe_offset_binding,
    		widgetframe_boundries_binding,
    		click_handler,
    		select_handler,
    		change_handler
    	];
    }

    class Wysiwyg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, { win: 15 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Wysiwyg",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get win() {
    		throw new Error("<Wysiwyg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set win(value) {
    		throw new Error("<Wysiwyg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class WysiwygHTMLElement extends HTMLElement {
        constructor() {
            super();
            this.contentWindow = window;
            this.component = undefined;
        }
        set win(win) {
            this.contentWindow = win;
        }
        get win() {
            return this.contentWindow;
        }
        connectedCallback() {
            this.style.width = "100%";
            this.style.height = "100%";
            this.component = new Wysiwyg({
                target: this,
                props: {
                    win: this.contentWindow
                }
            });
            this.component.$on('hover', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('hover', { detail: data }));
            });
            this.component.$on('showsource', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('showsource', { detail: data }));
            });
            this.component.$on('clone', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('clone', { detail: data }));
            });
            this.component.$on('delete', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('delete', { detail: data }));
            });
            this.component.$on('modechange', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('modechange', { detail: data }));
            });
            this.component.$on('editing', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('editing', { detail: data }));
            });
        }
        disconnectedCallback() {
            this.component.$destroy();
        }
    }
    try {
        customElements.define('iteria-wysiwyg', WysiwygHTMLElement);
    }
    catch (e) {
        console.error('define iteria-wysiwyg', e);
        // noop
    }

    class TranslationSheetHTMLElement extends HTMLElement {
        constructor() {
            super();
            this.translations = {};
            this.component = undefined;
        }
        set translation(tl) {
            this.translations = tl;
        }
        get translation() {
            return this.translations;
        }
        connectedCallback() {
            this.style.width = "100%";
            this.style.height = "100%";
            this.component = new TranslationSheet({
                target: this,
                props: {
                    translations: this.translations
                }
            });
            this.component.$on('change', (event) => {
                const data = event.detail;
                this.dispatchEvent(new CustomEvent('change', { detail: data }));
            });
        }
        disconnetedCallback() {
            this.component.$destroy();
        }
    }
    try {
        customElements.define('translation-sheet', TranslationSheetHTMLElement);
    }
    catch (e) {
        console.log('define translation-sheet', e);
    }

    exports.InsertField = InsertField;
    exports.InsertFieldDialog = InsertFieldDialog;
    exports.PickField = PickField;
    exports.TranslationSheet = TranslationSheet;
    exports.TranslationSheetHTMLElement = TranslationSheetHTMLElement;
    exports.WidgetElevation = WidgetElevation;
    exports.WidgetFields = WidgetFields;
    exports.WidgetFieldsDialog = WidgetFieldsDialog;
    exports.WidgetFrame = WidgetFrame;
    exports.WidgetTippy = WidgetTippy;
    exports.Winbox = Winbox_1;
    exports.Wysiwyg = Wysiwyg;
    exports.WysiwygHTMLElement = WysiwygHTMLElement;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
