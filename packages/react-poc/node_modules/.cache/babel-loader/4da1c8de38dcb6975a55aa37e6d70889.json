{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/michalzaduban/Desktop/Iteria/lowCode - new/lowcode/packages/react-poc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nmodule.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = \"./src/backend.js\");\n  /******/\n}(\n/************************************************************************/\n\n/******/\n{\n  /***/\n  \"../../node_modules/clipboard-js/clipboard.js\":\n  /*!*********************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/clipboard-js/clipboard.js ***!\n    \\*********************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    /* WEBPACK VAR INJECTION */\n    (function (setImmediate) {\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      } //  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd\n\n\n      (function (name, definition) {\n        if (true) {\n          module.exports = definition();\n        } else {}\n      })(\"clipboard\", function () {\n        if (typeof document === 'undefined' || !document.addEventListener) {\n          return null;\n        }\n\n        var clipboard = {};\n\n        clipboard.copy = function () {\n          var _intercept = false;\n          var _data = null; // Map from data type (e.g. \"text/html\") to value.\n\n          var _bogusSelection = false;\n\n          function cleanup() {\n            _intercept = false;\n            _data = null;\n\n            if (_bogusSelection) {\n              window.getSelection().removeAllRanges();\n            }\n\n            _bogusSelection = false;\n          }\n\n          document.addEventListener(\"copy\", function (e) {\n            if (_intercept) {\n              for (var key in _data) {\n                e.clipboardData.setData(key, _data[key]);\n              }\n\n              e.preventDefault();\n            }\n          }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529\n\n          function bogusSelect() {\n            var sel = document.getSelection(); // If \"nothing\" is selected...\n\n            if (!document.queryCommandEnabled(\"copy\") && sel.isCollapsed) {\n              // ... temporarily select the entire body.\n              //\n              // We select the entire body because:\n              // - it's guaranteed to exist,\n              // - it works (unlike, say, document.head, or phantom element that is\n              //   not inserted into the DOM),\n              // - it doesn't seem to flicker (due to the synchronous copy event), and\n              // - it avoids modifying the DOM (can trigger mutation observers).\n              //\n              // Because we can't do proper feature detection (we already checked\n              // document.queryCommandEnabled(\"copy\") , which actually gives a false\n              // negative for Blink when nothing is selected) and UA sniffing is not\n              // reliable (a lot of UA strings contain \"Safari\"), this will also\n              // happen for some browsers other than Safari. :-()\n              var range = document.createRange();\n              range.selectNodeContents(document.body);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              _bogusSelection = true;\n            }\n          }\n\n          ;\n          return function (data) {\n            return new Promise(function (resolve, reject) {\n              _intercept = true;\n\n              if (typeof data === \"string\") {\n                _data = {\n                  \"text/plain\": data\n                };\n              } else if (data instanceof Node) {\n                _data = {\n                  \"text/html\": new XMLSerializer().serializeToString(data)\n                };\n              } else if (data instanceof Object) {\n                _data = data;\n              } else {\n                reject(\"Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.\");\n              }\n\n              function triggerCopy(tryBogusSelect) {\n                try {\n                  if (document.execCommand(\"copy\")) {\n                    // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis\n                    // So we can call resolve() back here.\n                    cleanup();\n                    resolve();\n                  } else {\n                    if (!tryBogusSelect) {\n                      bogusSelect();\n                      triggerCopy(true);\n                    } else {\n                      cleanup();\n                      throw new Error(\"Unable to copy. Perhaps it's not available in your browser?\");\n                    }\n                  }\n                } catch (e) {\n                  cleanup();\n                  reject(e);\n                }\n              }\n\n              triggerCopy(false);\n            });\n          };\n        }();\n\n        clipboard.paste = function () {\n          var _intercept = false;\n\n          var _resolve;\n\n          var _dataType;\n\n          document.addEventListener(\"paste\", function (e) {\n            if (_intercept) {\n              _intercept = false;\n              e.preventDefault();\n              var resolve = _resolve;\n              _resolve = null;\n              resolve(e.clipboardData.getData(_dataType));\n            }\n          });\n          return function (dataType) {\n            return new Promise(function (resolve, reject) {\n              _intercept = true;\n              _resolve = resolve;\n              _dataType = dataType || \"text/plain\";\n\n              try {\n                if (!document.execCommand(\"paste\")) {\n                  _intercept = false;\n                  reject(new Error(\"Unable to paste. Pasting only works in Internet Explorer at the moment.\"));\n                }\n              } catch (e) {\n                _intercept = false;\n                reject(new Error(e));\n              }\n            });\n          };\n        }(); // Handle IE behaviour.\n\n\n        if (typeof ClipboardEvent === \"undefined\" && typeof window.clipboardData !== \"undefined\" && typeof window.clipboardData.setData !== \"undefined\") {\n          /*! promise-polyfill 2.0.1 */\n          (function (a) {\n            function b(a, b) {\n              return function () {\n                a.apply(b, arguments);\n              };\n            }\n\n            function c(a) {\n              if (\"object\" != _typeof(this)) throw new TypeError(\"Promises must be constructed via new\");\n              if (\"function\" != typeof a) throw new TypeError(\"not a function\");\n              this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));\n            }\n\n            function d(a) {\n              var b = this;\n              return null === this._state ? void this._deferreds.push(a) : void j(function () {\n                var c = b._state ? a.onFulfilled : a.onRejected;\n                if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);\n                var d;\n\n                try {\n                  d = c(b._value);\n                } catch (e) {\n                  return void a.reject(e);\n                }\n\n                a.resolve(d);\n              });\n            }\n\n            function e(a) {\n              try {\n                if (a === this) throw new TypeError(\"A promise cannot be resolved with itself.\");\n\n                if (a && (\"object\" == _typeof(a) || \"function\" == typeof a)) {\n                  var c = a.then;\n                  if (\"function\" == typeof c) return void i(b(c, a), b(e, this), b(f, this));\n                }\n\n                this._state = !0, this._value = a, g.call(this);\n              } catch (d) {\n                f.call(this, d);\n              }\n            }\n\n            function f(a) {\n              this._state = !1, this._value = a, g.call(this);\n            }\n\n            function g() {\n              for (var a = 0, b = this._deferreds.length; b > a; a++) {\n                d.call(this, this._deferreds[a]);\n              }\n\n              this._deferreds = null;\n            }\n\n            function h(a, b, c, d) {\n              this.onFulfilled = \"function\" == typeof a ? a : null, this.onRejected = \"function\" == typeof b ? b : null, this.resolve = c, this.reject = d;\n            }\n\n            function i(a, b, c) {\n              var d = !1;\n\n              try {\n                a(function (a) {\n                  d || (d = !0, b(a));\n                }, function (a) {\n                  d || (d = !0, c(a));\n                });\n              } catch (e) {\n                if (d) return;\n                d = !0, c(e);\n              }\n            }\n\n            var j = c.immediateFn || \"function\" == typeof setImmediate && setImmediate || function (a) {\n              setTimeout(a, 1);\n            },\n                k = Array.isArray || function (a) {\n              return \"[object Array]\" === Object.prototype.toString.call(a);\n            };\n\n            c.prototype[\"catch\"] = function (a) {\n              return this.then(null, a);\n            }, c.prototype.then = function (a, b) {\n              var e = this;\n              return new c(function (c, f) {\n                d.call(e, new h(a, b, c, f));\n              });\n            }, c.all = function () {\n              var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);\n              return new c(function (b, c) {\n                function d(f, g) {\n                  try {\n                    if (g && (\"object\" == _typeof(g) || \"function\" == typeof g)) {\n                      var h = g.then;\n                      if (\"function\" == typeof h) return void h.call(g, function (a) {\n                        d(f, a);\n                      }, c);\n                    }\n\n                    a[f] = g, 0 === --e && b(a);\n                  } catch (i) {\n                    c(i);\n                  }\n                }\n\n                if (0 === a.length) return b([]);\n\n                for (var e = a.length, f = 0; f < a.length; f++) {\n                  d(f, a[f]);\n                }\n              });\n            }, c.resolve = function (a) {\n              return a && \"object\" == _typeof(a) && a.constructor === c ? a : new c(function (b) {\n                b(a);\n              });\n            }, c.reject = function (a) {\n              return new c(function (b, c) {\n                c(a);\n              });\n            }, c.race = function (a) {\n              return new c(function (b, c) {\n                for (var d = 0, e = a.length; e > d; d++) {\n                  a[d].then(b, c);\n                }\n              });\n            }, true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);\n          })(this);\n\n          clipboard.copy = function (data) {\n            return new Promise(function (resolve, reject) {\n              // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n              // We only support the string type for now.\n              if (typeof data !== \"string\" && !(\"text/plain\" in data)) {\n                throw new Error(\"You must provide a text/plain type.\");\n              }\n\n              var strData = typeof data === \"string\" ? data : data[\"text/plain\"];\n              var copySucceeded = window.clipboardData.setData(\"Text\", strData);\n\n              if (copySucceeded) {\n                resolve();\n              } else {\n                reject(new Error(\"Copying was rejected.\"));\n              }\n            });\n          };\n\n          clipboard.paste = function () {\n            return new Promise(function (resolve, reject) {\n              var strData = window.clipboardData.getData(\"Text\");\n\n              if (strData) {\n                resolve(strData);\n              } else {\n                // The user rejected the paste request.\n                reject(new Error(\"Pasting was rejected.\"));\n              }\n            });\n          };\n        }\n\n        return clipboard;\n      });\n      /* WEBPACK VAR INJECTION */\n\n    }).call(this, __webpack_require__(\n    /*! ./../webpack/node_modules/timers-browserify/main.js */\n    \"../../node_modules/webpack/node_modules/timers-browserify/main.js\").setImmediate);\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/error-stack-parser/error-stack-parser.js\":\n  /*!************************************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/error-stack-parser/error-stack-parser.js ***!\n    \\************************************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    (function (root, factory) {\n      'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n      /* istanbul ignore next */\n\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\n        /*! stackframe */\n        \"../../node_modules/stackframe/stackframe.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n    })(this, function ErrorStackParser(StackFrame) {\n      'use strict';\n\n      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n      var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n      return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n          if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n            return this.parseOpera(error);\n          } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n            return this.parseV8OrIE(error);\n          } else if (error.stack) {\n            return this.parseFFOrSafari(error);\n          } else {\n            throw new Error('Cannot parse given Error object');\n          }\n        },\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n          // Fail-fast but return locations like \"(native)\"\n          if (urlLike.indexOf(':') === -1) {\n            return [urlLike];\n          }\n\n          var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n          var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n          return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n          var filtered = error.stack.split('\\n').filter(function (line) {\n            return !!line.match(CHROME_IE_STACK_REGEXP);\n          }, this);\n          return filtered.map(function (line) {\n            if (line.indexOf('(eval ') > -1) {\n              // Throw away eval information until we implement stacktrace.js/stackframe#8\n              line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n            }\n\n            var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n            // case it has spaces in it, as the string is split on \\s+ later on\n\n            var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n            sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n            var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n            var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n            var functionName = tokens.join(' ') || undefined;\n            var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n            return new StackFrame({\n              functionName: functionName,\n              fileName: fileName,\n              lineNumber: locationParts[1],\n              columnNumber: locationParts[2],\n              source: line\n            });\n          }, this);\n        },\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n          var filtered = error.stack.split('\\n').filter(function (line) {\n            return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n          }, this);\n          return filtered.map(function (line) {\n            // Throw away eval information until we implement stacktrace.js/stackframe#8\n            if (line.indexOf(' > eval') > -1) {\n              line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n            }\n\n            if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n              // Safari eval frames only have function names and nothing else\n              return new StackFrame({\n                functionName: line\n              });\n            } else {\n              var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n              var matches = line.match(functionNameRegex);\n              var functionName = matches && matches[1] ? matches[1] : undefined;\n              var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n              return new StackFrame({\n                functionName: functionName,\n                fileName: locationParts[0],\n                lineNumber: locationParts[1],\n                columnNumber: locationParts[2],\n                source: line\n              });\n            }\n          }, this);\n        },\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n          if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n            return this.parseOpera9(e);\n          } else if (!e.stack) {\n            return this.parseOpera10(e);\n          } else {\n            return this.parseOpera11(e);\n          }\n        },\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n          var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n          var lines = e.message.split('\\n');\n          var result = [];\n\n          for (var i = 2, len = lines.length; i < len; i += 2) {\n            var match = lineRE.exec(lines[i]);\n\n            if (match) {\n              result.push(new StackFrame({\n                fileName: match[2],\n                lineNumber: match[1],\n                source: lines[i]\n              }));\n            }\n          }\n\n          return result;\n        },\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n          var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n          var lines = e.stacktrace.split('\\n');\n          var result = [];\n\n          for (var i = 0, len = lines.length; i < len; i += 2) {\n            var match = lineRE.exec(lines[i]);\n\n            if (match) {\n              result.push(new StackFrame({\n                functionName: match[3] || undefined,\n                fileName: match[2],\n                lineNumber: match[1],\n                source: lines[i]\n              }));\n            }\n          }\n\n          return result;\n        },\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n          var filtered = error.stack.split('\\n').filter(function (line) {\n            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n          }, this);\n          return filtered.map(function (line) {\n            var tokens = line.split('@');\n            var locationParts = this.extractLocation(tokens.pop());\n            var functionCall = tokens.shift() || '';\n            var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n            var argsRaw;\n\n            if (functionCall.match(/\\(([^)]*)\\)/)) {\n              argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n            }\n\n            var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n            return new StackFrame({\n              functionName: functionName,\n              args: args,\n              fileName: locationParts[0],\n              lineNumber: locationParts[1],\n              columnNumber: locationParts[2],\n              source: line\n            });\n          }, this);\n        }\n      };\n    });\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/lodash.throttle/index.js\":\n  /*!********************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/lodash.throttle/index.js ***!\n    \\********************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    /* WEBPACK VAR INJECTION */\n    (function (global) {\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n      /**\n       * lodash (Custom Build) <https://lodash.com/>\n       * Build: `lodash modularize exports=\"npm\" -o ./`\n       * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n       * Released under MIT license <https://lodash.com/license>\n       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n       */\n\n      /** Used as the `TypeError` message for \"Functions\" methods. */\n\n\n      var FUNC_ERROR_TEXT = 'Expected a function';\n      /** Used as references for various `Number` constants. */\n\n      var NAN = 0 / 0;\n      /** `Object#toString` result references. */\n\n      var symbolTag = '[object Symbol]';\n      /** Used to match leading and trailing whitespace. */\n\n      var reTrim = /^\\s+|\\s+$/g;\n      /** Used to detect bad signed hexadecimal string values. */\n\n      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n      /** Used to detect binary string values. */\n\n      var reIsBinary = /^0b[01]+$/i;\n      /** Used to detect octal string values. */\n\n      var reIsOctal = /^0o[0-7]+$/i;\n      /** Built-in method references without a dependency on `root`. */\n\n      var freeParseInt = parseInt;\n      /** Detect free variable `global` from Node.js. */\n\n      var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n      /** Detect free variable `self`. */\n\n      var freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n      /** Used as a reference to the global object. */\n\n      var root = freeGlobal || freeSelf || Function('return this')();\n      /** Used for built-in method references. */\n\n      var objectProto = Object.prototype;\n      /**\n       * Used to resolve the\n       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n       * of values.\n       */\n\n      var objectToString = objectProto.toString;\n      /* Built-in method references for those with the same name as other `lodash` methods. */\n\n      var nativeMax = Math.max,\n          nativeMin = Math.min;\n      /**\n       * Gets the timestamp of the number of milliseconds that have elapsed since\n       * the Unix epoch (1 January 1970 00:00:00 UTC).\n       *\n       * @static\n       * @memberOf _\n       * @since 2.4.0\n       * @category Date\n       * @returns {number} Returns the timestamp.\n       * @example\n       *\n       * _.defer(function(stamp) {\n       *   console.log(_.now() - stamp);\n       * }, _.now());\n       * // => Logs the number of milliseconds it took for the deferred invocation.\n       */\n\n      var now = function now() {\n        return root.Date.now();\n      };\n      /**\n       * Creates a debounced function that delays invoking `func` until after `wait`\n       * milliseconds have elapsed since the last time the debounced function was\n       * invoked. The debounced function comes with a `cancel` method to cancel\n       * delayed `func` invocations and a `flush` method to immediately invoke them.\n       * Provide `options` to indicate whether `func` should be invoked on the\n       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n       * with the last arguments provided to the debounced function. Subsequent\n       * calls to the debounced function return the result of the last `func`\n       * invocation.\n       *\n       * **Note:** If `leading` and `trailing` options are `true`, `func` is\n       * invoked on the trailing edge of the timeout only if the debounced function\n       * is invoked more than once during the `wait` timeout.\n       *\n       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n       * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n       *\n       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n       * for details over the differences between `_.debounce` and `_.throttle`.\n       *\n       * @static\n       * @memberOf _\n       * @since 0.1.0\n       * @category Function\n       * @param {Function} func The function to debounce.\n       * @param {number} [wait=0] The number of milliseconds to delay.\n       * @param {Object} [options={}] The options object.\n       * @param {boolean} [options.leading=false]\n       *  Specify invoking on the leading edge of the timeout.\n       * @param {number} [options.maxWait]\n       *  The maximum time `func` is allowed to be delayed before it's invoked.\n       * @param {boolean} [options.trailing=true]\n       *  Specify invoking on the trailing edge of the timeout.\n       * @returns {Function} Returns the new debounced function.\n       * @example\n       *\n       * // Avoid costly calculations while the window size is in flux.\n       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n       *\n       * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n       * jQuery(element).on('click', _.debounce(sendMail, 300, {\n       *   'leading': true,\n       *   'trailing': false\n       * }));\n       *\n       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n       * var source = new EventSource('/stream');\n       * jQuery(source).on('message', debounced);\n       *\n       * // Cancel the trailing debounced invocation.\n       * jQuery(window).on('popstate', debounced.cancel);\n       */\n\n\n      function debounce(func, wait, options) {\n        var lastArgs,\n            lastThis,\n            maxWait,\n            result,\n            timerId,\n            lastCallTime,\n            lastInvokeTime = 0,\n            leading = false,\n            maxing = false,\n            trailing = true;\n\n        if (typeof func != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n\n        wait = toNumber(wait) || 0;\n\n        if (isObject(options)) {\n          leading = !!options.leading;\n          maxing = 'maxWait' in options;\n          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n          trailing = 'trailing' in options ? !!options.trailing : trailing;\n        }\n\n        function invokeFunc(time) {\n          var args = lastArgs,\n              thisArg = lastThis;\n          lastArgs = lastThis = undefined;\n          lastInvokeTime = time;\n          result = func.apply(thisArg, args);\n          return result;\n        }\n\n        function leadingEdge(time) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime = time; // Start the timer for the trailing edge.\n\n          timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n          return leading ? invokeFunc(time) : result;\n        }\n\n        function remainingWait(time) {\n          var timeSinceLastCall = time - lastCallTime,\n              timeSinceLastInvoke = time - lastInvokeTime,\n              result = wait - timeSinceLastCall;\n          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n        }\n\n        function shouldInvoke(time) {\n          var timeSinceLastCall = time - lastCallTime,\n              timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n          // trailing edge, the system time has gone backwards and we're treating\n          // it as the trailing edge, or we've hit the `maxWait` limit.\n\n          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n\n        function timerExpired() {\n          var time = now();\n\n          if (shouldInvoke(time)) {\n            return trailingEdge(time);\n          } // Restart the timer.\n\n\n          timerId = setTimeout(timerExpired, remainingWait(time));\n        }\n\n        function trailingEdge(time) {\n          timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n          // debounced at least once.\n\n          if (trailing && lastArgs) {\n            return invokeFunc(time);\n          }\n\n          lastArgs = lastThis = undefined;\n          return result;\n        }\n\n        function cancel() {\n          if (timerId !== undefined) {\n            clearTimeout(timerId);\n          }\n\n          lastInvokeTime = 0;\n          lastArgs = lastCallTime = lastThis = timerId = undefined;\n        }\n\n        function flush() {\n          return timerId === undefined ? result : trailingEdge(now());\n        }\n\n        function debounced() {\n          var time = now(),\n              isInvoking = shouldInvoke(time);\n          lastArgs = arguments;\n          lastThis = this;\n          lastCallTime = time;\n\n          if (isInvoking) {\n            if (timerId === undefined) {\n              return leadingEdge(lastCallTime);\n            }\n\n            if (maxing) {\n              // Handle invocations in a tight loop.\n              timerId = setTimeout(timerExpired, wait);\n              return invokeFunc(lastCallTime);\n            }\n          }\n\n          if (timerId === undefined) {\n            timerId = setTimeout(timerExpired, wait);\n          }\n\n          return result;\n        }\n\n        debounced.cancel = cancel;\n        debounced.flush = flush;\n        return debounced;\n      }\n      /**\n       * Creates a throttled function that only invokes `func` at most once per\n       * every `wait` milliseconds. The throttled function comes with a `cancel`\n       * method to cancel delayed `func` invocations and a `flush` method to\n       * immediately invoke them. Provide `options` to indicate whether `func`\n       * should be invoked on the leading and/or trailing edge of the `wait`\n       * timeout. The `func` is invoked with the last arguments provided to the\n       * throttled function. Subsequent calls to the throttled function return the\n       * result of the last `func` invocation.\n       *\n       * **Note:** If `leading` and `trailing` options are `true`, `func` is\n       * invoked on the trailing edge of the timeout only if the throttled function\n       * is invoked more than once during the `wait` timeout.\n       *\n       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n       * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n       *\n       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n       * for details over the differences between `_.throttle` and `_.debounce`.\n       *\n       * @static\n       * @memberOf _\n       * @since 0.1.0\n       * @category Function\n       * @param {Function} func The function to throttle.\n       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n       * @param {Object} [options={}] The options object.\n       * @param {boolean} [options.leading=true]\n       *  Specify invoking on the leading edge of the timeout.\n       * @param {boolean} [options.trailing=true]\n       *  Specify invoking on the trailing edge of the timeout.\n       * @returns {Function} Returns the new throttled function.\n       * @example\n       *\n       * // Avoid excessively updating the position while scrolling.\n       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n       *\n       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n       * jQuery(element).on('click', throttled);\n       *\n       * // Cancel the trailing throttled invocation.\n       * jQuery(window).on('popstate', throttled.cancel);\n       */\n\n\n      function throttle(func, wait, options) {\n        var leading = true,\n            trailing = true;\n\n        if (typeof func != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n\n        if (isObject(options)) {\n          leading = 'leading' in options ? !!options.leading : leading;\n          trailing = 'trailing' in options ? !!options.trailing : trailing;\n        }\n\n        return debounce(func, wait, {\n          'leading': leading,\n          'maxWait': wait,\n          'trailing': trailing\n        });\n      }\n      /**\n       * Checks if `value` is the\n       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n       *\n       * @static\n       * @memberOf _\n       * @since 0.1.0\n       * @category Lang\n       * @param {*} value The value to check.\n       * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n       * @example\n       *\n       * _.isObject({});\n       * // => true\n       *\n       * _.isObject([1, 2, 3]);\n       * // => true\n       *\n       * _.isObject(_.noop);\n       * // => true\n       *\n       * _.isObject(null);\n       * // => false\n       */\n\n\n      function isObject(value) {\n        var type = _typeof(value);\n\n        return !!value && (type == 'object' || type == 'function');\n      }\n      /**\n       * Checks if `value` is object-like. A value is object-like if it's not `null`\n       * and has a `typeof` result of \"object\".\n       *\n       * @static\n       * @memberOf _\n       * @since 4.0.0\n       * @category Lang\n       * @param {*} value The value to check.\n       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n       * @example\n       *\n       * _.isObjectLike({});\n       * // => true\n       *\n       * _.isObjectLike([1, 2, 3]);\n       * // => true\n       *\n       * _.isObjectLike(_.noop);\n       * // => false\n       *\n       * _.isObjectLike(null);\n       * // => false\n       */\n\n\n      function isObjectLike(value) {\n        return !!value && _typeof(value) == 'object';\n      }\n      /**\n       * Checks if `value` is classified as a `Symbol` primitive or object.\n       *\n       * @static\n       * @memberOf _\n       * @since 4.0.0\n       * @category Lang\n       * @param {*} value The value to check.\n       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n       * @example\n       *\n       * _.isSymbol(Symbol.iterator);\n       * // => true\n       *\n       * _.isSymbol('abc');\n       * // => false\n       */\n\n\n      function isSymbol(value) {\n        return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n      }\n      /**\n       * Converts `value` to a number.\n       *\n       * @static\n       * @memberOf _\n       * @since 4.0.0\n       * @category Lang\n       * @param {*} value The value to process.\n       * @returns {number} Returns the number.\n       * @example\n       *\n       * _.toNumber(3.2);\n       * // => 3.2\n       *\n       * _.toNumber(Number.MIN_VALUE);\n       * // => 5e-324\n       *\n       * _.toNumber(Infinity);\n       * // => Infinity\n       *\n       * _.toNumber('3.2');\n       * // => 3.2\n       */\n\n\n      function toNumber(value) {\n        if (typeof value == 'number') {\n          return value;\n        }\n\n        if (isSymbol(value)) {\n          return NAN;\n        }\n\n        if (isObject(value)) {\n          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n          value = isObject(other) ? other + '' : other;\n        }\n\n        if (typeof value != 'string') {\n          return value === 0 ? value : +value;\n        }\n\n        value = value.replace(reTrim, '');\n        var isBinary = reIsBinary.test(value);\n        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n      }\n\n      module.exports = throttle;\n      /* WEBPACK VAR INJECTION */\n    }).call(this, __webpack_require__(\n    /*! ./../webpack/buildin/global.js */\n    \"../../node_modules/webpack/buildin/global.js\"));\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/lru-cache/index.js\":\n  /*!**************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/lru-cache/index.js ***!\n    \\**************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\"; // A linked list to keep track of recently-used-ness\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    var Yallist = __webpack_require__(\n    /*! yallist */\n    \"../../node_modules/lru-cache/node_modules/yallist/yallist.js\");\n\n    var MAX = Symbol('max');\n    var LENGTH = Symbol('length');\n    var LENGTH_CALCULATOR = Symbol('lengthCalculator');\n    var ALLOW_STALE = Symbol('allowStale');\n    var MAX_AGE = Symbol('maxAge');\n    var DISPOSE = Symbol('dispose');\n    var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');\n    var LRU_LIST = Symbol('lruList');\n    var CACHE = Symbol('cache');\n    var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');\n\n    var naiveLength = function naiveLength() {\n      return 1;\n    }; // lruList is a yallist where the head is the youngest\n    // item, and the tail is the oldest.  the list contains the Hit\n    // objects as the entries.\n    // Each Hit object has a reference to its Yallist.Node.  This\n    // never changes.\n    //\n    // cache is a Map (or PseudoMap) that matches the keys to\n    // the Yallist.Node object.\n\n\n    var LRUCache = /*#__PURE__*/function () {\n      function LRUCache(options) {\n        _classCallCheck(this, LRUCache);\n\n        if (typeof options === 'number') options = {\n          max: options\n        };\n        if (!options) options = {};\n        if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.\n\n        var max = this[MAX] = options.max || Infinity;\n        var lc = options.length || naiveLength;\n        this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;\n        this[ALLOW_STALE] = options.stale || false;\n        if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');\n        this[MAX_AGE] = options.maxAge || 0;\n        this[DISPOSE] = options.dispose;\n        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n        this.reset();\n      } // resize the cache when the max changes.\n\n\n      _createClass(LRUCache, [{\n        key: \"rforEach\",\n        value: function rforEach(fn, thisp) {\n          thisp = thisp || this;\n\n          for (var walker = this[LRU_LIST].tail; walker !== null;) {\n            var prev = walker.prev;\n            forEachStep(this, fn, walker, thisp);\n            walker = prev;\n          }\n        }\n      }, {\n        key: \"forEach\",\n        value: function forEach(fn, thisp) {\n          thisp = thisp || this;\n\n          for (var walker = this[LRU_LIST].head; walker !== null;) {\n            var next = walker.next;\n            forEachStep(this, fn, walker, thisp);\n            walker = next;\n          }\n        }\n      }, {\n        key: \"keys\",\n        value: function keys() {\n          return this[LRU_LIST].toArray().map(function (k) {\n            return k.key;\n          });\n        }\n      }, {\n        key: \"values\",\n        value: function values() {\n          return this[LRU_LIST].toArray().map(function (k) {\n            return k.value;\n          });\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          var _this = this;\n\n          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n            this[LRU_LIST].forEach(function (hit) {\n              return _this[DISPOSE](hit.key, hit.value);\n            });\n          }\n\n          this[CACHE] = new Map(); // hash of items by key\n\n          this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n          this[LENGTH] = 0; // length of items in the list\n        }\n      }, {\n        key: \"dump\",\n        value: function dump() {\n          var _this2 = this;\n\n          return this[LRU_LIST].map(function (hit) {\n            return isStale(_this2, hit) ? false : {\n              k: hit.key,\n              v: hit.value,\n              e: hit.now + (hit.maxAge || 0)\n            };\n          }).toArray().filter(function (h) {\n            return h;\n          });\n        }\n      }, {\n        key: \"dumpLru\",\n        value: function dumpLru() {\n          return this[LRU_LIST];\n        }\n      }, {\n        key: \"set\",\n        value: function set(key, value, maxAge) {\n          maxAge = maxAge || this[MAX_AGE];\n          if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');\n          var now = maxAge ? Date.now() : 0;\n          var len = this[LENGTH_CALCULATOR](value, key);\n\n          if (this[CACHE].has(key)) {\n            if (len > this[MAX]) {\n              _del(this, this[CACHE].get(key));\n\n              return false;\n            }\n\n            var node = this[CACHE].get(key);\n            var item = node.value; // dispose of the old one before overwriting\n            // split out into 2 ifs for better coverage tracking\n\n            if (this[DISPOSE]) {\n              if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);\n            }\n\n            item.now = now;\n            item.maxAge = maxAge;\n            item.value = value;\n            this[LENGTH] += len - item.length;\n            item.length = len;\n            this.get(key);\n            trim(this);\n            return true;\n          }\n\n          var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n          if (hit.length > this[MAX]) {\n            if (this[DISPOSE]) this[DISPOSE](key, value);\n            return false;\n          }\n\n          this[LENGTH] += hit.length;\n          this[LRU_LIST].unshift(hit);\n          this[CACHE].set(key, this[LRU_LIST].head);\n          trim(this);\n          return true;\n        }\n      }, {\n        key: \"has\",\n        value: function has(key) {\n          if (!this[CACHE].has(key)) return false;\n          var hit = this[CACHE].get(key).value;\n          return !isStale(this, hit);\n        }\n      }, {\n        key: \"get\",\n        value: function get(key) {\n          return _get(this, key, true);\n        }\n      }, {\n        key: \"peek\",\n        value: function peek(key) {\n          return _get(this, key, false);\n        }\n      }, {\n        key: \"pop\",\n        value: function pop() {\n          var node = this[LRU_LIST].tail;\n          if (!node) return null;\n\n          _del(this, node);\n\n          return node.value;\n        }\n      }, {\n        key: \"del\",\n        value: function del(key) {\n          _del(this, this[CACHE].get(key));\n        }\n      }, {\n        key: \"load\",\n        value: function load(arr) {\n          // reset the cache\n          this.reset();\n          var now = Date.now(); // A previous serialized cache has the most recent items first\n\n          for (var l = arr.length - 1; l >= 0; l--) {\n            var hit = arr[l];\n            var expiresAt = hit.e || 0;\n            if (expiresAt === 0) // the item was created without expiration in a non aged cache\n              this.set(hit.k, hit.v);else {\n              var maxAge = expiresAt - now; // dont add already expired items\n\n              if (maxAge > 0) {\n                this.set(hit.k, hit.v, maxAge);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"prune\",\n        value: function prune() {\n          var _this3 = this;\n\n          this[CACHE].forEach(function (value, key) {\n            return _get(_this3, key, false);\n          });\n        }\n      }, {\n        key: \"max\",\n        set: function set(mL) {\n          if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');\n          this[MAX] = mL || Infinity;\n          trim(this);\n        },\n        get: function get() {\n          return this[MAX];\n        }\n      }, {\n        key: \"allowStale\",\n        set: function set(allowStale) {\n          this[ALLOW_STALE] = !!allowStale;\n        },\n        get: function get() {\n          return this[ALLOW_STALE];\n        }\n      }, {\n        key: \"maxAge\",\n        set: function set(mA) {\n          if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');\n          this[MAX_AGE] = mA;\n          trim(this);\n        },\n        get: function get() {\n          return this[MAX_AGE];\n        } // resize the cache when the lengthCalculator changes.\n\n      }, {\n        key: \"lengthCalculator\",\n        set: function set(lC) {\n          var _this4 = this;\n\n          if (typeof lC !== 'function') lC = naiveLength;\n\n          if (lC !== this[LENGTH_CALCULATOR]) {\n            this[LENGTH_CALCULATOR] = lC;\n            this[LENGTH] = 0;\n            this[LRU_LIST].forEach(function (hit) {\n              hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);\n              _this4[LENGTH] += hit.length;\n            });\n          }\n\n          trim(this);\n        },\n        get: function get() {\n          return this[LENGTH_CALCULATOR];\n        }\n      }, {\n        key: \"length\",\n        get: function get() {\n          return this[LENGTH];\n        }\n      }, {\n        key: \"itemCount\",\n        get: function get() {\n          return this[LRU_LIST].length;\n        }\n      }]);\n\n      return LRUCache;\n    }();\n\n    var _get = function _get(self, key, doUse) {\n      var node = self[CACHE].get(key);\n\n      if (node) {\n        var hit = node.value;\n\n        if (isStale(self, hit)) {\n          _del(self, node);\n\n          if (!self[ALLOW_STALE]) return undefined;\n        } else {\n          if (doUse) {\n            if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();\n            self[LRU_LIST].unshiftNode(node);\n          }\n        }\n\n        return hit.value;\n      }\n    };\n\n    var isStale = function isStale(self, hit) {\n      if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;\n      var diff = Date.now() - hit.now;\n      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];\n    };\n\n    var trim = function trim(self) {\n      if (self[LENGTH] > self[MAX]) {\n        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n          // We know that we're about to delete this one, and also\n          // what the next least recently used key will be, so just\n          // go ahead and set it now.\n          var prev = walker.prev;\n\n          _del(self, walker);\n\n          walker = prev;\n        }\n      }\n    };\n\n    var _del = function _del(self, node) {\n      if (node) {\n        var hit = node.value;\n        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);\n        self[LENGTH] -= hit.length;\n        self[CACHE].delete(hit.key);\n        self[LRU_LIST].removeNode(node);\n      }\n    };\n\n    var Entry = function Entry(key, value, length, now, maxAge) {\n      _classCallCheck(this, Entry);\n\n      this.key = key;\n      this.value = value;\n      this.length = length;\n      this.now = now;\n      this.maxAge = maxAge || 0;\n    };\n\n    var forEachStep = function forEachStep(self, fn, node, thisp) {\n      var hit = node.value;\n\n      if (isStale(self, hit)) {\n        _del(self, node);\n\n        if (!self[ALLOW_STALE]) hit = undefined;\n      }\n\n      if (hit) fn.call(thisp, hit.value, hit.key, self);\n    };\n\n    module.exports = LRUCache;\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/lru-cache/node_modules/yallist/iterator.js\":\n  /*!**************************************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/lru-cache/node_modules/yallist/iterator.js ***!\n    \\**************************************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    module.exports = function (Yallist) {\n      Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var walker;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                walker = this.head;\n\n              case 1:\n                if (!walker) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 4;\n                return walker.value;\n\n              case 4:\n                walker = walker.next;\n                _context.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      });\n    };\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/lru-cache/node_modules/yallist/yallist.js\":\n  /*!*************************************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/lru-cache/node_modules/yallist/yallist.js ***!\n    \\*************************************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    module.exports = Yallist;\n    Yallist.Node = Node;\n    Yallist.create = Yallist;\n\n    function Yallist(list) {\n      var self = this;\n\n      if (!(self instanceof Yallist)) {\n        self = new Yallist();\n      }\n\n      self.tail = null;\n      self.head = null;\n      self.length = 0;\n\n      if (list && typeof list.forEach === 'function') {\n        list.forEach(function (item) {\n          self.push(item);\n        });\n      } else if (arguments.length > 0) {\n        for (var i = 0, l = arguments.length; i < l; i++) {\n          self.push(arguments[i]);\n        }\n      }\n\n      return self;\n    }\n\n    Yallist.prototype.removeNode = function (node) {\n      if (node.list !== this) {\n        throw new Error('removing node which does not belong to this list');\n      }\n\n      var next = node.next;\n      var prev = node.prev;\n\n      if (next) {\n        next.prev = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      }\n\n      if (node === this.head) {\n        this.head = next;\n      }\n\n      if (node === this.tail) {\n        this.tail = prev;\n      }\n\n      node.list.length--;\n      node.next = null;\n      node.prev = null;\n      node.list = null;\n      return next;\n    };\n\n    Yallist.prototype.unshiftNode = function (node) {\n      if (node === this.head) {\n        return;\n      }\n\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n\n      var head = this.head;\n      node.list = this;\n      node.next = head;\n\n      if (head) {\n        head.prev = node;\n      }\n\n      this.head = node;\n\n      if (!this.tail) {\n        this.tail = node;\n      }\n\n      this.length++;\n    };\n\n    Yallist.prototype.pushNode = function (node) {\n      if (node === this.tail) {\n        return;\n      }\n\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n\n      var tail = this.tail;\n      node.list = this;\n      node.prev = tail;\n\n      if (tail) {\n        tail.next = node;\n      }\n\n      this.tail = node;\n\n      if (!this.head) {\n        this.head = node;\n      }\n\n      this.length++;\n    };\n\n    Yallist.prototype.push = function () {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        push(this, arguments[i]);\n      }\n\n      return this.length;\n    };\n\n    Yallist.prototype.unshift = function () {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        unshift(this, arguments[i]);\n      }\n\n      return this.length;\n    };\n\n    Yallist.prototype.pop = function () {\n      if (!this.tail) {\n        return undefined;\n      }\n\n      var res = this.tail.value;\n      this.tail = this.tail.prev;\n\n      if (this.tail) {\n        this.tail.next = null;\n      } else {\n        this.head = null;\n      }\n\n      this.length--;\n      return res;\n    };\n\n    Yallist.prototype.shift = function () {\n      if (!this.head) {\n        return undefined;\n      }\n\n      var res = this.head.value;\n      this.head = this.head.next;\n\n      if (this.head) {\n        this.head.prev = null;\n      } else {\n        this.tail = null;\n      }\n\n      this.length--;\n      return res;\n    };\n\n    Yallist.prototype.forEach = function (fn, thisp) {\n      thisp = thisp || this;\n\n      for (var walker = this.head, i = 0; walker !== null; i++) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.next;\n      }\n    };\n\n    Yallist.prototype.forEachReverse = function (fn, thisp) {\n      thisp = thisp || this;\n\n      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.prev;\n      }\n    };\n\n    Yallist.prototype.get = function (n) {\n      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n        // abort out of the list early if we hit a cycle\n        walker = walker.next;\n      }\n\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n\n    Yallist.prototype.getReverse = function (n) {\n      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n        // abort out of the list early if we hit a cycle\n        walker = walker.prev;\n      }\n\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n\n    Yallist.prototype.map = function (fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n\n      for (var walker = this.head; walker !== null;) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.next;\n      }\n\n      return res;\n    };\n\n    Yallist.prototype.mapReverse = function (fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n\n      for (var walker = this.tail; walker !== null;) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.prev;\n      }\n\n      return res;\n    };\n\n    Yallist.prototype.reduce = function (fn, initial) {\n      var acc;\n      var walker = this.head;\n\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.head) {\n        walker = this.head.next;\n        acc = this.head.value;\n      } else {\n        throw new TypeError('Reduce of empty list with no initial value');\n      }\n\n      for (var i = 0; walker !== null; i++) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.next;\n      }\n\n      return acc;\n    };\n\n    Yallist.prototype.reduceReverse = function (fn, initial) {\n      var acc;\n      var walker = this.tail;\n\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.tail) {\n        walker = this.tail.prev;\n        acc = this.tail.value;\n      } else {\n        throw new TypeError('Reduce of empty list with no initial value');\n      }\n\n      for (var i = this.length - 1; walker !== null; i--) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.prev;\n      }\n\n      return acc;\n    };\n\n    Yallist.prototype.toArray = function () {\n      var arr = new Array(this.length);\n\n      for (var i = 0, walker = this.head; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.next;\n      }\n\n      return arr;\n    };\n\n    Yallist.prototype.toArrayReverse = function () {\n      var arr = new Array(this.length);\n\n      for (var i = 0, walker = this.tail; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.prev;\n      }\n\n      return arr;\n    };\n\n    Yallist.prototype.slice = function (from, to) {\n      to = to || this.length;\n\n      if (to < 0) {\n        to += this.length;\n      }\n\n      from = from || 0;\n\n      if (from < 0) {\n        from += this.length;\n      }\n\n      var ret = new Yallist();\n\n      if (to < from || to < 0) {\n        return ret;\n      }\n\n      if (from < 0) {\n        from = 0;\n      }\n\n      if (to > this.length) {\n        to = this.length;\n      }\n\n      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n        walker = walker.next;\n      }\n\n      for (; walker !== null && i < to; i++, walker = walker.next) {\n        ret.push(walker.value);\n      }\n\n      return ret;\n    };\n\n    Yallist.prototype.sliceReverse = function (from, to) {\n      to = to || this.length;\n\n      if (to < 0) {\n        to += this.length;\n      }\n\n      from = from || 0;\n\n      if (from < 0) {\n        from += this.length;\n      }\n\n      var ret = new Yallist();\n\n      if (to < from || to < 0) {\n        return ret;\n      }\n\n      if (from < 0) {\n        from = 0;\n      }\n\n      if (to > this.length) {\n        to = this.length;\n      }\n\n      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n        walker = walker.prev;\n      }\n\n      for (; walker !== null && i > from; i--, walker = walker.prev) {\n        ret.push(walker.value);\n      }\n\n      return ret;\n    };\n\n    Yallist.prototype.splice = function (start, deleteCount\n    /*, ...nodes */\n    ) {\n      if (start > this.length) {\n        start = this.length - 1;\n      }\n\n      if (start < 0) {\n        start = this.length + start;\n      }\n\n      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n        walker = walker.next;\n      }\n\n      var ret = [];\n\n      for (var i = 0; walker && i < deleteCount; i++) {\n        ret.push(walker.value);\n        walker = this.removeNode(walker);\n      }\n\n      if (walker === null) {\n        walker = this.tail;\n      }\n\n      if (walker !== this.head && walker !== this.tail) {\n        walker = walker.prev;\n      }\n\n      for (var i = 2; i < arguments.length; i++) {\n        walker = insert(this, walker, arguments[i]);\n      }\n\n      return ret;\n    };\n\n    Yallist.prototype.reverse = function () {\n      var head = this.head;\n      var tail = this.tail;\n\n      for (var walker = head; walker !== null; walker = walker.prev) {\n        var p = walker.prev;\n        walker.prev = walker.next;\n        walker.next = p;\n      }\n\n      this.head = tail;\n      this.tail = head;\n      return this;\n    };\n\n    function insert(self, node, value) {\n      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);\n\n      if (inserted.next === null) {\n        self.tail = inserted;\n      }\n\n      if (inserted.prev === null) {\n        self.head = inserted;\n      }\n\n      self.length++;\n      return inserted;\n    }\n\n    function push(self, item) {\n      self.tail = new Node(item, self.tail, null, self);\n\n      if (!self.head) {\n        self.head = self.tail;\n      }\n\n      self.length++;\n    }\n\n    function unshift(self, item) {\n      self.head = new Node(item, null, self.head, self);\n\n      if (!self.tail) {\n        self.tail = self.head;\n      }\n\n      self.length++;\n    }\n\n    function Node(value, prev, next, list) {\n      if (!(this instanceof Node)) {\n        return new Node(value, prev, next, list);\n      }\n\n      this.list = list;\n      this.value = value;\n\n      if (prev) {\n        prev.next = this;\n        this.prev = prev;\n      } else {\n        this.prev = null;\n      }\n\n      if (next) {\n        next.prev = this;\n        this.next = next;\n      } else {\n        this.next = null;\n      }\n    }\n\n    try {\n      // add if support for Symbol.iterator is present\n      __webpack_require__(\n      /*! ./iterator.js */\n      \"../../node_modules/lru-cache/node_modules/yallist/iterator.js\")(Yallist);\n    } catch (er) {}\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/memoize-one/esm/index.js\":\n  /*!********************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/memoize-one/esm/index.js ***!\n    \\********************************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n\n    var simpleIsEqual = function simpleIsEqual(a, b) {\n      return a === b;\n    };\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = function (resultFn) {\n      var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n      var lastThis = void 0;\n      var lastArgs = [];\n      var lastResult = void 0;\n      var calledOnce = false;\n\n      var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n        return isEqual(newArg, lastArgs[index]);\n      };\n\n      var result = function result() {\n        for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {\n          newArgs[_key] = arguments[_key];\n        }\n\n        if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n          return lastResult;\n        }\n\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        lastResult = resultFn.apply(this, newArgs);\n        return lastResult;\n      };\n\n      return result;\n    };\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/object-assign/index.js\":\n  /*!******************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/object-assign/index.js ***!\n    \\******************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n    /*\n    object-assign\n    (c) Sindre Sorhus\n    @license MIT\n    */\n\n    /* eslint-disable no-unused-vars */\n\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n    function toObject(val) {\n      if (val === null || val === undefined) {\n        throw new TypeError('Object.assign cannot be called with null or undefined');\n      }\n\n      return Object(val);\n    }\n\n    function shouldUseNative() {\n      try {\n        if (!Object.assign) {\n          return false;\n        } // Detect buggy property enumeration order in older V8 versions.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n        test1[5] = 'de';\n\n        if (Object.getOwnPropertyNames(test1)[0] === '5') {\n          return false;\n        } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n        var test2 = {};\n\n        for (var i = 0; i < 10; i++) {\n          test2['_' + String.fromCharCode(i)] = i;\n        }\n\n        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n          return test2[n];\n        });\n\n        if (order2.join('') !== '0123456789') {\n          return false;\n        } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n        var test3 = {};\n        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n          test3[letter] = letter;\n        });\n\n        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n          return false;\n        }\n\n        return true;\n      } catch (err) {\n        // We don't expect any of the above to throw, but better to be safe.\n        return false;\n      }\n    }\n\n    module.exports = shouldUseNative() ? Object.assign : function (target, source) {\n      var from;\n      var to = toObject(target);\n      var symbols;\n\n      for (var s = 1; s < arguments.length; s++) {\n        from = Object(arguments[s]);\n\n        for (var key in from) {\n          if (hasOwnProperty.call(from, key)) {\n            to[key] = from[key];\n          }\n        }\n\n        if (getOwnPropertySymbols) {\n          symbols = getOwnPropertySymbols(from);\n\n          for (var i = 0; i < symbols.length; i++) {\n            if (propIsEnumerable.call(from, symbols[i])) {\n              to[symbols[i]] = from[symbols[i]];\n            }\n          }\n        }\n      }\n\n      return to;\n    };\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/process/browser.js\":\n  /*!**************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/process/browser.js ***!\n    \\**************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    // shim for using process in browser\n    var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n    // don't break things.  But we need to wrap it in a try catch in case it is\n    // wrapped in strict mode code which doesn't define any globals.  It's inside a\n    // function because try/catches deoptimize in certain engines.\n\n    var cachedSetTimeout;\n    var cachedClearTimeout;\n\n    function defaultSetTimout() {\n      throw new Error('setTimeout has not been defined');\n    }\n\n    function defaultClearTimeout() {\n      throw new Error('clearTimeout has not been defined');\n    }\n\n    (function () {\n      try {\n        if (typeof setTimeout === 'function') {\n          cachedSetTimeout = setTimeout;\n        } else {\n          cachedSetTimeout = defaultSetTimout;\n        }\n      } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n      }\n\n      try {\n        if (typeof clearTimeout === 'function') {\n          cachedClearTimeout = clearTimeout;\n        } else {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n      }\n    })();\n\n    function runTimeout(fun) {\n      if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n      } // if setTimeout wasn't available but was latter defined\n\n\n      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n          return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n          return cachedSetTimeout.call(this, fun, 0);\n        }\n      }\n    }\n\n    function runClearTimeout(marker) {\n      if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n      } // if clearTimeout wasn't available but was latter defined\n\n\n      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n          return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n          // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n          return cachedClearTimeout.call(this, marker);\n        }\n      }\n    }\n\n    var queue = [];\n    var draining = false;\n    var currentQueue;\n    var queueIndex = -1;\n\n    function cleanUpNextTick() {\n      if (!draining || !currentQueue) {\n        return;\n      }\n\n      draining = false;\n\n      if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n      } else {\n        queueIndex = -1;\n      }\n\n      if (queue.length) {\n        drainQueue();\n      }\n    }\n\n    function drainQueue() {\n      if (draining) {\n        return;\n      }\n\n      var timeout = runTimeout(cleanUpNextTick);\n      draining = true;\n      var len = queue.length;\n\n      while (len) {\n        currentQueue = queue;\n        queue = [];\n\n        while (++queueIndex < len) {\n          if (currentQueue) {\n            currentQueue[queueIndex].run();\n          }\n        }\n\n        queueIndex = -1;\n        len = queue.length;\n      }\n\n      currentQueue = null;\n      draining = false;\n      runClearTimeout(timeout);\n    }\n\n    process.nextTick = function (fun) {\n      var args = new Array(arguments.length - 1);\n\n      if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n          args[i - 1] = arguments[i];\n        }\n      }\n\n      queue.push(new Item(fun, args));\n\n      if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n      }\n    }; // v8 likes predictible objects\n\n\n    function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n    }\n\n    Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    };\n\n    process.title = 'browser';\n    process.browser = true;\n    process.env = {};\n    process.argv = [];\n    process.version = ''; // empty string to avoid regexp issues\n\n    process.versions = {};\n\n    function noop() {}\n\n    process.on = noop;\n    process.addListener = noop;\n    process.once = noop;\n    process.off = noop;\n    process.removeListener = noop;\n    process.removeAllListeners = noop;\n    process.emit = noop;\n    process.prependListener = noop;\n    process.prependOnceListener = noop;\n\n    process.listeners = function (name) {\n      return [];\n    };\n\n    process.binding = function (name) {\n      throw new Error('process.binding is not supported');\n    };\n\n    process.cwd = function () {\n      return '/';\n    };\n\n    process.chdir = function (dir) {\n      throw new Error('process.chdir is not supported');\n    };\n\n    process.umask = function () {\n      return 0;\n    };\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/raw-loader/dist/cjs.js!../react-devtools-shared/src/devtools/views/root.css\":\n  /*!***********************************************************************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/raw-loader/dist/cjs.js!../react-devtools-shared/src/devtools/views/root.css ***!\n    \\***********************************************************************************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \":root {\\n  /**\\n   * IMPORTANT: When new theme variables are added below also add them to SettingsContext updateThemeVariables()\\n   */\\n\\n  /* Light theme */\\n  --light-color-attribute-name: #ef6632;\\n  --light-color-attribute-name-not-editable: #23272f;\\n  --light-color-attribute-name-inverted: rgba(255, 255, 255, 0.7);\\n  --light-color-attribute-value: #1a1aa6;\\n  --light-color-attribute-value-inverted: #ffffff;\\n  --light-color-attribute-editable-value: #1a1aa6;\\n  --light-color-background: #ffffff;\\n  --light-color-background-hover: rgba(0, 136, 250, 0.1);\\n  --light-color-background-inactive: #e5e5e5;\\n  --light-color-background-invalid: #fff0f0;\\n  --light-color-background-selected: #0088fa;\\n  --light-color-button-background: #ffffff;\\n  --light-color-button-background-focus: #ededed;\\n  --light-color-button: #5f6673;\\n  --light-color-button-disabled: #cfd1d5;\\n  --light-color-button-active: #0088fa;\\n  --light-color-button-focus: #23272f;\\n  --light-color-button-hover: #23272f;\\n  --light-color-border: #eeeeee;\\n  --light-color-commit-did-not-render-fill: #cfd1d5;\\n  --light-color-commit-did-not-render-fill-text: #000000;\\n  --light-color-commit-did-not-render-pattern: #cfd1d5;\\n  --light-color-commit-did-not-render-pattern-text: #333333;\\n  --light-color-commit-gradient-0: #37afa9;\\n  --light-color-commit-gradient-1: #63b19e;\\n  --light-color-commit-gradient-2: #80b393;\\n  --light-color-commit-gradient-3: #97b488;\\n  --light-color-commit-gradient-4: #abb67d;\\n  --light-color-commit-gradient-5: #beb771;\\n  --light-color-commit-gradient-6: #cfb965;\\n  --light-color-commit-gradient-7: #dfba57;\\n  --light-color-commit-gradient-8: #efbb49;\\n  --light-color-commit-gradient-9: #febc38;\\n  --light-color-commit-gradient-text: #000000;\\n  --light-color-component-name: #6a51b2;\\n  --light-color-component-name-inverted: #ffffff;\\n  --light-color-component-badge-background: rgba(0, 0, 0, 0.1);\\n  --light-color-component-badge-background-inverted: rgba(255, 255, 255, 0.25);\\n  --light-color-component-badge-count: #777d88;\\n  --light-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\\n  --light-color-context-background: rgba(0,0,0,.9);\\n  --light-color-context-background-hover: rgba(255, 255, 255, 0.1);\\n  --light-color-context-background-selected: #178fb9;\\n  --light-color-context-border: #3d424a;\\n  --light-color-context-text: #ffffff;\\n  --light-color-context-text-selected: #ffffff;\\n  --light-color-dim: #777d88;\\n  --light-color-dimmer: #cfd1d5;\\n  --light-color-dimmest: #eff0f1;\\n  --light-color-error-background: hsl(0, 100%, 97%);\\n  --light-color-error-border: hsl(0, 100%, 92%);\\n  --light-color-error-text: #ff0000;\\n  --light-color-expand-collapse-toggle: #777d88;\\n  --light-color-link: #0000ff;\\n  --light-color-modal-background: rgba(255, 255, 255, 0.75);\\n  --light-color-record-active: #fc3a4b;\\n  --light-color-record-hover: #3578e5;\\n  --light-color-record-inactive: #0088fa;\\n  --light-color-scroll-thumb: #c2c2c2;\\n  --light-color-scroll-track: #fafafa;\\n  --light-color-search-match: yellow;\\n  --light-color-search-match-current: #f7923b;\\n  --light-color-selected-tree-highlight-active: rgba(0, 136, 250, 0.1);\\n  --light-color-selected-tree-highlight-inactive: rgba(0, 0, 0, 0.05);\\n  --light-color-shadow: rgba(0, 0, 0, 0.25);\\n  --light-color-tab-selected-border: #0088fa;\\n  --light-color-text: #000000;\\n  --light-color-text-invalid: #ff0000;\\n  --light-color-text-selected: #ffffff;\\n  --light-color-toggle-background-invalid: #fc3a4b;\\n  --light-color-toggle-background-on: #0088fa;\\n  --light-color-toggle-background-off: #cfd1d5;\\n  --light-color-toggle-text: #ffffff;\\n  --light-color-tooltip-background: rgba(0, 0, 0, 0.9);\\n  --light-color-tooltip-text: #ffffff;\\n\\n  /* Dark theme */\\n  --dark-color-attribute-name: #9d87d2;\\n  --dark-color-attribute-name-not-editable: #ededed;\\n  --dark-color-attribute-name-inverted: #282828;\\n  --dark-color-attribute-value: #cedae0;\\n  --dark-color-attribute-value-inverted: #ffffff;\\n  --dark-color-attribute-editable-value: yellow;\\n  --dark-color-background: #282c34;\\n  --dark-color-background-hover: rgba(255, 255, 255, 0.1);\\n  --dark-color-background-inactive: #3d424a;\\n  --dark-color-background-invalid: #5c0000;\\n  --dark-color-background-selected: #178fb9;\\n  --dark-color-button-background: #282c34;\\n  --dark-color-button-background-focus: #3d424a;\\n  --dark-color-button: #afb3b9;\\n  --dark-color-button-active: #61dafb;\\n  --dark-color-button-disabled: #4f5766;\\n  --dark-color-button-focus: #a2e9fc;\\n  --dark-color-button-hover: #ededed;\\n  --dark-color-border: #3d424a;\\n  --dark-color-commit-did-not-render-fill: #777d88;\\n  --dark-color-commit-did-not-render-fill-text: #000000;\\n  --dark-color-commit-did-not-render-pattern: #666c77;\\n  --dark-color-commit-did-not-render-pattern-text: #ffffff;\\n  --dark-color-commit-gradient-0: #37afa9;\\n  --dark-color-commit-gradient-1: #63b19e;\\n  --dark-color-commit-gradient-2: #80b393;\\n  --dark-color-commit-gradient-3: #97b488;\\n  --dark-color-commit-gradient-4: #abb67d;\\n  --dark-color-commit-gradient-5: #beb771;\\n  --dark-color-commit-gradient-6: #cfb965;\\n  --dark-color-commit-gradient-7: #dfba57;\\n  --dark-color-commit-gradient-8: #efbb49;\\n  --dark-color-commit-gradient-9: #febc38;\\n  --dark-color-commit-gradient-text: #000000;\\n  --dark-color-component-name: #61dafb;\\n  --dark-color-component-name-inverted: #282828;\\n  --dark-color-component-badge-background: rgba(255, 255, 255, 0.25);\\n  --dark-color-component-badge-background-inverted: rgba(0, 0, 0, 0.25);\\n  --dark-color-component-badge-count: #8f949d;\\n  --dark-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\\n  --dark-color-context-background: rgba(255,255,255,.9);\\n  --dark-color-context-background-hover: rgba(0, 136, 250, 0.1);\\n  --dark-color-context-background-selected: #0088fa;\\n  --dark-color-context-border: #eeeeee;\\n  --dark-color-context-text: #000000;\\n  --dark-color-context-text-selected: #ffffff;\\n  --dark-color-dim: #8f949d;\\n  --dark-color-dimmer: #777d88;\\n  --dark-color-dimmest: #4f5766;\\n  --dark-color-error-background: #200;\\n  --dark-color-error-border: #900;\\n  --dark-color-error-text: #f55;\\n  --dark-color-expand-collapse-toggle: #8f949d;\\n  --dark-color-link: #61dafb;\\n  --dark-color-modal-background: rgba(0, 0, 0, 0.75);\\n  --dark-color-record-active: #fc3a4b;\\n  --dark-color-record-hover: #a2e9fc;\\n  --dark-color-record-inactive: #61dafb;\\n  --dark-color-scroll-thumb: #afb3b9;\\n  --dark-color-scroll-track: #313640;\\n  --dark-color-search-match: yellow;\\n  --dark-color-search-match-current: #f7923b;\\n  --dark-color-selected-tree-highlight-active: rgba(23, 143, 185, 0.15);\\n  --dark-color-selected-tree-highlight-inactive: rgba(255, 255, 255, 0.05);\\n  --dark-color-shadow: rgba(0, 0, 0, 0.5);\\n  --dark-color-tab-selected-border: #178fb9;\\n  --dark-color-text: #ffffff;\\n  --dark-color-text-invalid: #ff8080;\\n  --dark-color-text-selected: #ffffff;\\n  --dark-color-toggle-background-invalid: #fc3a4b;\\n  --dark-color-toggle-background-on: #178fb9;\\n  --dark-color-toggle-background-off: #777d88;\\n  --dark-color-toggle-text: #ffffff;\\n  --dark-color-tooltip-background: rgba(255, 255, 255, 0.9);\\n  --dark-color-tooltip-text: #000000;\\n\\n  /* Font smoothing */\\n  --light-font-smoothing: auto;\\n  --dark-font-smoothing: antialiased;\\n  --font-smoothing: auto;\\n\\n  /* Compact density */\\n  --compact-font-size-monospace-small: 9px;\\n  --compact-font-size-monospace-normal: 11px;\\n  --compact-font-size-monospace-large: 15px;\\n  --compact-font-size-sans-small: 10px;\\n  --compact-font-size-sans-normal: 12px;\\n  --compact-font-size-sans-large: 14px;\\n  --compact-line-height-data: 18px;\\n  --compact-root-font-size: 16px;\\n\\n  /* Comfortable density */\\n  --comfortable-font-size-monospace-small: 10px;\\n  --comfortable-font-size-monospace-normal: 13px;\\n  --comfortable-font-size-monospace-large: 17px;\\n  --comfortable-font-size-sans-small: 12px;\\n  --comfortable-font-size-sans-normal: 14px;\\n  --comfortable-font-size-sans-large: 16px;\\n  --comfortable-line-height-data: 22px;\\n  --comfortable-root-font-size: 20px;\\n\\n  /* GitHub.com system fonts */\\n  --font-family-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo,\\n    Courier, monospace;\\n  --font-family-sans: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica,\\n    Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;\\n\\n  /* Constant values shared between JS and CSS */\\n  --interaction-commit-size: 10px;\\n  --interaction-label-width: 200px;\\n}\\n\";\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/setimmediate/setImmediate.js\":\n  /*!************************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/setimmediate/setImmediate.js ***!\n    \\************************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    /* WEBPACK VAR INJECTION */\n    (function (global, process) {\n      (function (global, undefined) {\n        \"use strict\";\n\n        if (global.setImmediate) {\n          return;\n        }\n\n        var nextHandle = 1; // Spec says greater than zero\n\n        var tasksByHandle = {};\n        var currentlyRunningATask = false;\n        var doc = global.document;\n        var registerImmediate;\n\n        function setImmediate(callback) {\n          // Callback can either be a function or a string\n          if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n          } // Copy function arguments\n\n\n          var args = new Array(arguments.length - 1);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n          } // Store and register the task\n\n\n          var task = {\n            callback: callback,\n            args: args\n          };\n          tasksByHandle[nextHandle] = task;\n          registerImmediate(nextHandle);\n          return nextHandle++;\n        }\n\n        function clearImmediate(handle) {\n          delete tasksByHandle[handle];\n        }\n\n        function run(task) {\n          var callback = task.callback;\n          var args = task.args;\n\n          switch (args.length) {\n            case 0:\n              callback();\n              break;\n\n            case 1:\n              callback(args[0]);\n              break;\n\n            case 2:\n              callback(args[0], args[1]);\n              break;\n\n            case 3:\n              callback(args[0], args[1], args[2]);\n              break;\n\n            default:\n              callback.apply(undefined, args);\n              break;\n          }\n        }\n\n        function runIfPresent(handle) {\n          // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n          // So if we're currently running a task, we'll need to delay this invocation.\n          if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n          } else {\n            var task = tasksByHandle[handle];\n\n            if (task) {\n              currentlyRunningATask = true;\n\n              try {\n                run(task);\n              } finally {\n                clearImmediate(handle);\n                currentlyRunningATask = false;\n              }\n            }\n          }\n        }\n\n        function installNextTickImplementation() {\n          registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n              runIfPresent(handle);\n            });\n          };\n        }\n\n        function canUsePostMessage() {\n          // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n          // where `global.postMessage` means something completely different and can't be used for this purpose.\n          if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n\n            global.onmessage = function () {\n              postMessageIsAsynchronous = false;\n            };\n\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n          }\n        }\n\n        function installPostMessageImplementation() {\n          // Installs an event handler on `global` for the `message` event: see\n          // * https://developer.mozilla.org/en/DOM/window.postMessage\n          // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n          var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n          var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n              runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n          };\n\n          if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n          } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n          }\n\n          registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n          };\n        }\n\n        function installMessageChannelImplementation() {\n          var channel = new MessageChannel();\n\n          channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n          };\n\n          registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n          };\n        }\n\n        function installReadyStateChangeImplementation() {\n          var html = doc.documentElement;\n\n          registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n\n            script.onreadystatechange = function () {\n              runIfPresent(handle);\n              script.onreadystatechange = null;\n              html.removeChild(script);\n              script = null;\n            };\n\n            html.appendChild(script);\n          };\n        }\n\n        function installSetTimeoutImplementation() {\n          registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n          };\n        } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n        attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n        if ({}.toString.call(global.process) === \"[object process]\") {\n          // For Node.js before 0.9\n          installNextTickImplementation();\n        } else if (canUsePostMessage()) {\n          // For non-IE10 modern browsers\n          installPostMessageImplementation();\n        } else if (global.MessageChannel) {\n          // For web workers, where supported\n          installMessageChannelImplementation();\n        } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n          // For IE 68\n          installReadyStateChangeImplementation();\n        } else {\n          // For older browsers\n          installSetTimeoutImplementation();\n        }\n\n        attachTo.setImmediate = setImmediate;\n        attachTo.clearImmediate = clearImmediate;\n      })(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n      /* WEBPACK VAR INJECTION */\n\n    }).call(this, __webpack_require__(\n    /*! ./../webpack/buildin/global.js */\n    \"../../node_modules/webpack/buildin/global.js\"), __webpack_require__(\n    /*! ./../process/browser.js */\n    \"../../node_modules/process/browser.js\"));\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/stackframe/stackframe.js\":\n  /*!********************************************************************************!*\\\n    !*** /Users/bvaughn/Documents/git/react/node_modules/stackframe/stackframe.js ***!\n    \\********************************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    (function (root, factory) {\n      'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n      /* istanbul ignore next */\n\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n    })(this, function () {\n      'use strict';\n\n      function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n      }\n\n      function _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.substring(1);\n      }\n\n      function _getter(p) {\n        return function () {\n          return this[p];\n        };\n      }\n\n      var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n      var numericProps = ['columnNumber', 'lineNumber'];\n      var stringProps = ['fileName', 'functionName', 'source'];\n      var arrayProps = ['args'];\n      var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n      function StackFrame(obj) {\n        if (!obj) return;\n\n        for (var i = 0; i < props.length; i++) {\n          if (obj[props[i]] !== undefined) {\n            this['set' + _capitalize(props[i])](obj[props[i]]);\n          }\n        }\n      }\n\n      StackFrame.prototype = {\n        getArgs: function getArgs() {\n          return this.args;\n        },\n        setArgs: function setArgs(v) {\n          if (Object.prototype.toString.call(v) !== '[object Array]') {\n            throw new TypeError('Args must be an Array');\n          }\n\n          this.args = v;\n        },\n        getEvalOrigin: function getEvalOrigin() {\n          return this.evalOrigin;\n        },\n        setEvalOrigin: function setEvalOrigin(v) {\n          if (v instanceof StackFrame) {\n            this.evalOrigin = v;\n          } else if (v instanceof Object) {\n            this.evalOrigin = new StackFrame(v);\n          } else {\n            throw new TypeError('Eval Origin must be an Object or StackFrame');\n          }\n        },\n        toString: function toString() {\n          var fileName = this.getFileName() || '';\n          var lineNumber = this.getLineNumber() || '';\n          var columnNumber = this.getColumnNumber() || '';\n          var functionName = this.getFunctionName() || '';\n\n          if (this.getIsEval()) {\n            if (fileName) {\n              return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n            }\n\n            return '[eval]:' + lineNumber + ':' + columnNumber;\n          }\n\n          if (functionName) {\n            return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n          }\n\n          return fileName + ':' + lineNumber + ':' + columnNumber;\n        }\n      };\n\n      StackFrame.fromString = function StackFrame$$fromString(str) {\n        var argsStartIndex = str.indexOf('(');\n        var argsEndIndex = str.lastIndexOf(')');\n        var functionName = str.substring(0, argsStartIndex);\n        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n        var locationString = str.substring(argsEndIndex + 1);\n\n        if (locationString.indexOf('@') === 0) {\n          var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n          var fileName = parts[1];\n          var lineNumber = parts[2];\n          var columnNumber = parts[3];\n        }\n\n        return new StackFrame({\n          functionName: functionName,\n          args: args || undefined,\n          fileName: fileName,\n          lineNumber: lineNumber || undefined,\n          columnNumber: columnNumber || undefined\n        });\n      };\n\n      for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n          return function (v) {\n            this[p] = Boolean(v);\n          };\n        }(booleanProps[i]);\n      }\n\n      for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n          return function (v) {\n            if (!_isNumber(v)) {\n              throw new TypeError(p + ' must be a Number');\n            }\n\n            this[p] = Number(v);\n          };\n        }(numericProps[j]);\n      }\n\n      for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n          return function (v) {\n            this[p] = String(v);\n          };\n        }(stringProps[k]);\n      }\n\n      return StackFrame;\n    });\n    /***/\n\n  },\n\n  /***/\n  \"../../node_modules/webpack/buildin/global.js\":\n  /*!***********************************!*\\\n    !*** (webpack)/buildin/global.js ***!\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    var g; // This works in non-strict mode\n\n    g = function () {\n      return this;\n    }();\n\n    try {\n      // This works if eval is allowed (see CSP)\n      g = g || new Function(\"return this\")();\n    } catch (e) {\n      // This works if the window reference is available\n      if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n    } // g can still be undefined, but nothing to do about it...\n    // We return undefined, instead of nothing here, so it's\n    // easier to handle this case. if(!global) { ...}\n\n\n    module.exports = g;\n    /***/\n  },\n\n  /***/\n  \"../../node_modules/webpack/node_modules/timers-browserify/main.js\":\n  /*!********************************************************!*\\\n    !*** (webpack)/node_modules/timers-browserify/main.js ***!\n    \\********************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    /* WEBPACK VAR INJECTION */\n    (function (global) {\n      var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\n      var apply = Function.prototype.apply; // DOM APIs, for completeness\n\n      exports.setTimeout = function () {\n        return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n      };\n\n      exports.setInterval = function () {\n        return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n      };\n\n      exports.clearTimeout = exports.clearInterval = function (timeout) {\n        if (timeout) {\n          timeout.close();\n        }\n      };\n\n      function Timeout(id, clearFn) {\n        this._id = id;\n        this._clearFn = clearFn;\n      }\n\n      Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n      Timeout.prototype.close = function () {\n        this._clearFn.call(scope, this._id);\n      }; // Does not start the time, just sets up the members needed.\n\n\n      exports.enroll = function (item, msecs) {\n        clearTimeout(item._idleTimeoutId);\n        item._idleTimeout = msecs;\n      };\n\n      exports.unenroll = function (item) {\n        clearTimeout(item._idleTimeoutId);\n        item._idleTimeout = -1;\n      };\n\n      exports._unrefActive = exports.active = function (item) {\n        clearTimeout(item._idleTimeoutId);\n        var msecs = item._idleTimeout;\n\n        if (msecs >= 0) {\n          item._idleTimeoutId = setTimeout(function onTimeout() {\n            if (item._onTimeout) item._onTimeout();\n          }, msecs);\n        }\n      }; // setimmediate attaches itself to the global object\n\n\n      __webpack_require__(\n      /*! setimmediate */\n      \"../../node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n      // able to install onto.  Search each possibility in the same order as the\n      // `setimmediate` library.\n\n\n      exports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\n      exports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n      /* WEBPACK VAR INJECTION */\n    }).call(this, __webpack_require__(\n    /*! ./../../buildin/global.js */\n    \"../../node_modules/webpack/buildin/global.js\"));\n    /***/\n  },\n\n  /***/\n  \"../react-debug-tools/index.js\":\n  /*!*************************************!*\\\n    !*** ../react-debug-tools/index.js ***!\n    \\*************************************/\n\n  /*! exports provided: inspectHooks, inspectHooksOfFiber */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */\n\n\n    var _src_ReactDebugTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./src/ReactDebugTools */\n    \"../react-debug-tools/src/ReactDebugTools.js\");\n    /* harmony reexport (safe) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooks\", function () {\n      return _src_ReactDebugTools__WEBPACK_IMPORTED_MODULE_0__[\"inspectHooks\"];\n    });\n    /* harmony reexport (safe) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooksOfFiber\", function () {\n      return _src_ReactDebugTools__WEBPACK_IMPORTED_MODULE_0__[\"inspectHooksOfFiber\"];\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n    /***/\n\n  },\n\n  /***/\n  \"../react-debug-tools/src/ReactDebugHooks.js\":\n  /*!***************************************************!*\\\n    !*** ../react-debug-tools/src/ReactDebugHooks.js ***!\n    \\***************************************************/\n\n  /*! exports provided: inspectHooks, inspectHooksOfFiber */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooks\", function () {\n      return inspectHooks;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooksOfFiber\", function () {\n      return inspectHooksOfFiber;\n    });\n    /* harmony import */\n\n\n    var react_reconciler_src_ReactTypeOfMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react-reconciler/src/ReactTypeOfMode */\n    \"../react-reconciler/src/ReactTypeOfMode.js\");\n    /* harmony import */\n\n\n    var error_stack_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! error-stack-parser */\n    \"../../node_modules/error-stack-parser/error-stack-parser.js\");\n    /* harmony import */\n\n\n    var error_stack_parser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(error_stack_parser__WEBPACK_IMPORTED_MODULE_1__);\n    /* harmony import */\n\n\n    var shared_ReactSharedInternals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! shared/ReactSharedInternals */\n    \"../shared/ReactSharedInternals.js\");\n    /* harmony import */\n\n\n    var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! shared/ReactSymbols */\n    \"../shared/ReactSymbols.js\");\n    /* harmony import */\n\n\n    var react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! react-reconciler/src/ReactWorkTags */\n    \"../react-reconciler/src/ReactWorkTags.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var hookLog = []; // Primitives\n\n    var primitiveStackCache = null;\n    var currentFiber = null;\n\n    function getPrimitiveStackCache() {\n      // This initializes a cache of all primitive hooks so that the top\n      // most stack frames added by calling the primitive hook can be removed.\n      if (primitiveStackCache === null) {\n        var cache = new Map();\n        var readHookLog;\n\n        try {\n          // Use all hooks here to add them to the hook log.\n          Dispatcher.useContext({\n            _currentValue: null\n          });\n          Dispatcher.useState(null);\n          Dispatcher.useReducer(function (s, a) {\n            return s;\n          }, null);\n          Dispatcher.useRef(null);\n          Dispatcher.useLayoutEffect(function () {});\n          Dispatcher.useEffect(function () {});\n          Dispatcher.useImperativeHandle(undefined, function () {\n            return null;\n          });\n          Dispatcher.useDebugValue(null);\n          Dispatcher.useCallback(function () {});\n          Dispatcher.useMemo(function () {\n            return null;\n          });\n          Dispatcher.useMutableSource({\n            _source: {},\n            _getVersion: function _getVersion() {\n              return 1;\n            },\n            _workInProgressVersionPrimary: null,\n            _workInProgressVersionSecondary: null\n          }, function () {\n            return null;\n          }, function () {\n            return function () {};\n          });\n        } finally {\n          readHookLog = hookLog;\n          hookLog = [];\n        }\n\n        for (var i = 0; i < readHookLog.length; i++) {\n          var hook = readHookLog[i];\n          cache.set(hook.primitive, error_stack_parser__WEBPACK_IMPORTED_MODULE_1___default.a.parse(hook.stackError));\n        }\n\n        primitiveStackCache = cache;\n      }\n\n      return primitiveStackCache;\n    }\n\n    var currentHook = null;\n\n    function nextHook() {\n      var hook = currentHook;\n\n      if (hook !== null) {\n        currentHook = hook.next;\n      }\n\n      return hook;\n    }\n\n    function readContext(context, observedBits) {\n      // For now we don't expose readContext usage in the hooks debugging info.\n      return context._currentValue;\n    }\n\n    function useContext(context, observedBits) {\n      hookLog.push({\n        primitive: 'Context',\n        stackError: new Error(),\n        value: context._currentValue\n      });\n      return context._currentValue;\n    }\n\n    function useState(initialState) {\n      var hook = nextHook();\n      var state = hook !== null ? hook.memoizedState : typeof initialState === 'function' ? // $FlowFixMe: Flow doesn't like mixed types\n      initialState() : initialState;\n      hookLog.push({\n        primitive: 'State',\n        stackError: new Error(),\n        value: state\n      });\n      return [state, function (action) {}];\n    }\n\n    function useReducer(reducer, initialArg, init) {\n      var hook = nextHook();\n      var state;\n\n      if (hook !== null) {\n        state = hook.memoizedState;\n      } else {\n        state = init !== undefined ? init(initialArg) : initialArg;\n      }\n\n      hookLog.push({\n        primitive: 'Reducer',\n        stackError: new Error(),\n        value: state\n      });\n      return [state, function (action) {}];\n    }\n\n    function useRef(initialValue) {\n      var hook = nextHook();\n      var ref = hook !== null ? hook.memoizedState : {\n        current: initialValue\n      };\n      hookLog.push({\n        primitive: 'Ref',\n        stackError: new Error(),\n        value: ref.current\n      });\n      return ref;\n    }\n\n    function useLayoutEffect(create, inputs) {\n      nextHook();\n      hookLog.push({\n        primitive: 'LayoutEffect',\n        stackError: new Error(),\n        value: create\n      });\n    }\n\n    function useEffect(create, inputs) {\n      nextHook();\n      hookLog.push({\n        primitive: 'Effect',\n        stackError: new Error(),\n        value: create\n      });\n    }\n\n    function useImperativeHandle(ref, create, inputs) {\n      nextHook(); // We don't actually store the instance anywhere if there is no ref callback\n      // and if there is a ref callback it might not store it but if it does we\n      // have no way of knowing where. So let's only enable introspection of the\n      // ref itself if it is using the object form.\n\n      var instance = undefined;\n\n      if (ref !== null && _typeof(ref) === 'object') {\n        instance = ref.current;\n      }\n\n      hookLog.push({\n        primitive: 'ImperativeHandle',\n        stackError: new Error(),\n        value: instance\n      });\n    }\n\n    function useDebugValue(value, formatterFn) {\n      hookLog.push({\n        primitive: 'DebugValue',\n        stackError: new Error(),\n        value: typeof formatterFn === 'function' ? formatterFn(value) : value\n      });\n    }\n\n    function useCallback(callback, inputs) {\n      var hook = nextHook();\n      hookLog.push({\n        primitive: 'Callback',\n        stackError: new Error(),\n        value: hook !== null ? hook.memoizedState[0] : callback\n      });\n      return callback;\n    }\n\n    function useMemo(nextCreate, inputs) {\n      var hook = nextHook();\n      var value = hook !== null ? hook.memoizedState[0] : nextCreate();\n      hookLog.push({\n        primitive: 'Memo',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useMutableSource(source, getSnapshot, subscribe) {\n      // useMutableSource() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // MutableSource\n\n      nextHook(); // State\n\n      nextHook(); // Effect\n\n      nextHook(); // Effect\n\n      var value = getSnapshot(source._source);\n      hookLog.push({\n        primitive: 'MutableSource',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useResponder(responder, listenerProps) {\n      // Don't put the actual event responder object in, just its displayName\n      var value = {\n        responder: responder.displayName || 'EventResponder',\n        props: listenerProps\n      };\n      hookLog.push({\n        primitive: 'Responder',\n        stackError: new Error(),\n        value: value\n      });\n      return {\n        responder: responder,\n        props: listenerProps\n      };\n    }\n\n    function useTransition(config) {\n      // useTransition() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // State\n\n      nextHook(); // Callback\n\n      hookLog.push({\n        primitive: 'Transition',\n        stackError: new Error(),\n        value: config\n      });\n      return [function (callback) {}, false];\n    }\n\n    function useDeferredValue(value, config) {\n      // useDeferredValue() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // State\n\n      nextHook(); // Effect\n\n      hookLog.push({\n        primitive: 'DeferredValue',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useOpaqueIdentifier() {\n      var hook = nextHook(); // State\n\n      if (currentFiber && currentFiber.mode === react_reconciler_src_ReactTypeOfMode__WEBPACK_IMPORTED_MODULE_0__[\"NoMode\"]) {\n        nextHook(); // Effect\n      }\n\n      var value = hook === null ? undefined : hook.memoizedState;\n\n      if (value && value.$$typeof === shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_3__[\"REACT_OPAQUE_ID_TYPE\"]) {\n        value = undefined;\n      }\n\n      hookLog.push({\n        primitive: 'OpaqueIdentifier',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    var Dispatcher = {\n      readContext: readContext,\n      useCallback: useCallback,\n      useContext: useContext,\n      useEffect: useEffect,\n      useImperativeHandle: useImperativeHandle,\n      useDebugValue: useDebugValue,\n      useLayoutEffect: useLayoutEffect,\n      useMemo: useMemo,\n      useReducer: useReducer,\n      useRef: useRef,\n      useState: useState,\n      useResponder: useResponder,\n      useTransition: useTransition,\n      useMutableSource: useMutableSource,\n      useDeferredValue: useDeferredValue,\n      useOpaqueIdentifier: useOpaqueIdentifier\n    }; // Inspect\n    // Don't assume\n    //\n    // We can't assume that stack frames are nth steps away from anything.\n    // E.g. we can't assume that the root call shares all frames with the stack\n    // of a hook call. A simple way to demonstrate this is wrapping `new Error()`\n    // in a wrapper constructor like a polyfill. That'll add an extra frame.\n    // Similar things can happen with the call to the dispatcher. The top frame\n    // may not be the primitive. Likewise the primitive can have fewer stack frames\n    // such as when a call to useState got inlined to use dispatcher.useState.\n    //\n    // We also can't assume that the last frame of the root call is the same\n    // frame as the last frame of the hook call because long stack traces can be\n    // truncated to a stack trace limit.\n\n    var mostLikelyAncestorIndex = 0;\n\n    function findSharedIndex(hookStack, rootStack, rootIndex) {\n      var source = rootStack[rootIndex].source;\n\n      hookSearch: for (var i = 0; i < hookStack.length; i++) {\n        if (hookStack[i].source === source) {\n          // This looks like a match. Validate that the rest of both stack match up.\n          for (var a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {\n            if (hookStack[b].source !== rootStack[a].source) {\n              // If not, give up and try a different match.\n              continue hookSearch;\n            }\n          }\n\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function findCommonAncestorIndex(rootStack, hookStack) {\n      var rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);\n\n      if (rootIndex !== -1) {\n        return rootIndex;\n      } // If the most likely one wasn't a hit, try any other frame to see if it is shared.\n      // If that takes more than 5 frames, something probably went wrong.\n\n\n      for (var i = 0; i < rootStack.length && i < 5; i++) {\n        rootIndex = findSharedIndex(hookStack, rootStack, i);\n\n        if (rootIndex !== -1) {\n          mostLikelyAncestorIndex = i;\n          return rootIndex;\n        }\n      }\n\n      return -1;\n    }\n\n    function isReactWrapper(functionName, primitiveName) {\n      if (!functionName) {\n        return false;\n      }\n\n      var expectedPrimitiveName = 'use' + primitiveName;\n\n      if (functionName.length < expectedPrimitiveName.length) {\n        return false;\n      }\n\n      return functionName.lastIndexOf(expectedPrimitiveName) === functionName.length - expectedPrimitiveName.length;\n    }\n\n    function findPrimitiveIndex(hookStack, hook) {\n      var stackCache = getPrimitiveStackCache();\n      var primitiveStack = stackCache.get(hook.primitive);\n\n      if (primitiveStack === undefined) {\n        return -1;\n      }\n\n      for (var i = 0; i < primitiveStack.length && i < hookStack.length; i++) {\n        if (primitiveStack[i].source !== hookStack[i].source) {\n          // If the next two frames are functions called `useX` then we assume that they're part of the\n          // wrappers that the React packager or other packages adds around the dispatcher.\n          if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n            i++;\n          }\n\n          if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n            i++;\n          }\n\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function parseTrimmedStack(rootStack, hook) {\n      // Get the stack trace between the primitive hook function and\n      // the root function call. I.e. the stack frames of custom hooks.\n      var hookStack = error_stack_parser__WEBPACK_IMPORTED_MODULE_1___default.a.parse(hook.stackError);\n      var rootIndex = findCommonAncestorIndex(rootStack, hookStack);\n      var primitiveIndex = findPrimitiveIndex(hookStack, hook);\n\n      if (rootIndex === -1 || primitiveIndex === -1 || rootIndex - primitiveIndex < 2) {\n        // Something went wrong. Give up.\n        return null;\n      }\n\n      return hookStack.slice(primitiveIndex, rootIndex - 1);\n    }\n\n    function parseCustomHookName(functionName) {\n      if (!functionName) {\n        return '';\n      }\n\n      var startIndex = functionName.lastIndexOf('.');\n\n      if (startIndex === -1) {\n        startIndex = 0;\n      }\n\n      if (functionName.substr(startIndex, 3) === 'use') {\n        startIndex += 3;\n      }\n\n      return functionName.substr(startIndex);\n    }\n\n    function buildTree(rootStack, readHookLog) {\n      var rootChildren = [];\n      var prevStack = null;\n      var levelChildren = rootChildren;\n      var nativeHookID = 0;\n      var stackOfChildren = [];\n\n      for (var i = 0; i < readHookLog.length; i++) {\n        var hook = readHookLog[i];\n        var stack = parseTrimmedStack(rootStack, hook);\n\n        if (stack !== null) {\n          // Note: The indices 0 <= n < length-1 will contain the names.\n          // The indices 1 <= n < length will contain the source locations.\n          // That's why we get the name from n - 1 and don't check the source\n          // of index 0.\n          var commonSteps = 0;\n\n          if (prevStack !== null) {\n            // Compare the current level's stack to the new stack.\n            while (commonSteps < stack.length && commonSteps < prevStack.length) {\n              var stackSource = stack[stack.length - commonSteps - 1].source;\n              var prevSource = prevStack[prevStack.length - commonSteps - 1].source;\n\n              if (stackSource !== prevSource) {\n                break;\n              }\n\n              commonSteps++;\n            } // Pop back the stack as many steps as were not common.\n\n\n            for (var j = prevStack.length - 1; j > commonSteps; j--) {\n              levelChildren = stackOfChildren.pop();\n            }\n          } // The remaining part of the new stack are custom hooks. Push them\n          // to the tree.\n\n\n          for (var _j = stack.length - commonSteps - 1; _j >= 1; _j--) {\n            var children = [];\n            levelChildren.push({\n              id: null,\n              isStateEditable: false,\n              name: parseCustomHookName(stack[_j - 1].functionName),\n              value: undefined,\n              subHooks: children\n            });\n            stackOfChildren.push(levelChildren);\n            levelChildren = children;\n          }\n\n          prevStack = stack;\n        }\n\n        var primitive = hook.primitive; // For now, the \"id\" of stateful hooks is just the stateful hook index.\n        // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).\n\n        var id = primitive === 'Context' || primitive === 'DebugValue' ? null : nativeHookID++; // For the time being, only State and Reducer hooks support runtime overrides.\n\n        var isStateEditable = primitive === 'Reducer' || primitive === 'State';\n        levelChildren.push({\n          id: id,\n          isStateEditable: isStateEditable,\n          name: primitive,\n          value: hook.value,\n          subHooks: []\n        });\n      } // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.\n\n\n      processDebugValues(rootChildren, null);\n      return rootChildren;\n    } // Custom hooks support user-configurable labels (via the special useDebugValue() hook).\n    // That hook adds user-provided values to the hooks tree,\n    // but these values aren't intended to appear alongside of the other hooks.\n    // Instead they should be attributed to their parent custom hook.\n    // This method walks the tree and assigns debug values to their custom hook owners.\n\n\n    function processDebugValues(hooksTree, parentHooksNode) {\n      var debugValueHooksNodes = [];\n\n      for (var i = 0; i < hooksTree.length; i++) {\n        var hooksNode = hooksTree[i];\n\n        if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {\n          hooksTree.splice(i, 1);\n          i--;\n          debugValueHooksNodes.push(hooksNode);\n        } else {\n          processDebugValues(hooksNode.subHooks, hooksNode);\n        }\n      } // Bubble debug value labels to their custom hook owner.\n      // If there is no parent hook, just ignore them for now.\n      // (We may warn about this in the future.)\n\n\n      if (parentHooksNode !== null) {\n        if (debugValueHooksNodes.length === 1) {\n          parentHooksNode.value = debugValueHooksNodes[0].value;\n        } else if (debugValueHooksNodes.length > 1) {\n          parentHooksNode.value = debugValueHooksNodes.map(function (_ref) {\n            var value = _ref.value;\n            return value;\n          });\n        }\n      }\n    }\n\n    function inspectHooks(renderFunction, props, currentDispatcher) {\n      // DevTools will pass the current renderer's injected dispatcher.\n      // Other apps might compile debug hooks as part of their app though.\n      if (currentDispatcher == null) {\n        currentDispatcher = shared_ReactSharedInternals__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ReactCurrentDispatcher;\n      }\n\n      var previousDispatcher = currentDispatcher.current;\n      var readHookLog;\n      currentDispatcher.current = Dispatcher;\n      var ancestorStackError;\n\n      try {\n        ancestorStackError = new Error();\n        renderFunction(props);\n      } finally {\n        readHookLog = hookLog;\n        hookLog = [];\n        currentDispatcher.current = previousDispatcher;\n      }\n\n      var rootStack = error_stack_parser__WEBPACK_IMPORTED_MODULE_1___default.a.parse(ancestorStackError);\n      return buildTree(rootStack, readHookLog);\n    }\n\n    function setupContexts(contextMap, fiber) {\n      var current = fiber;\n\n      while (current) {\n        if (current.tag === react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"ContextProvider\"]) {\n          var providerType = current.type;\n          var context = providerType._context;\n\n          if (!contextMap.has(context)) {\n            // Store the current value that we're going to restore later.\n            contextMap.set(context, context._currentValue); // Set the inner most provider value on the context.\n\n            context._currentValue = current.memoizedProps.value;\n          }\n        }\n\n        current = current.return;\n      }\n    }\n\n    function restoreContexts(contextMap) {\n      contextMap.forEach(function (value, context) {\n        return context._currentValue = value;\n      });\n    }\n\n    function inspectHooksOfForwardRef(renderFunction, props, ref, currentDispatcher) {\n      var previousDispatcher = currentDispatcher.current;\n      var readHookLog;\n      currentDispatcher.current = Dispatcher;\n      var ancestorStackError;\n\n      try {\n        ancestorStackError = new Error();\n        renderFunction(props, ref);\n      } finally {\n        readHookLog = hookLog;\n        hookLog = [];\n        currentDispatcher.current = previousDispatcher;\n      }\n\n      var rootStack = error_stack_parser__WEBPACK_IMPORTED_MODULE_1___default.a.parse(ancestorStackError);\n      return buildTree(rootStack, readHookLog);\n    }\n\n    function resolveDefaultProps(Component, baseProps) {\n      if (Component && Component.defaultProps) {\n        // Resolve default props. Taken from ReactElement\n        var props = Object.assign({}, baseProps);\n        var defaultProps = Component.defaultProps;\n\n        for (var propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n\n        return props;\n      }\n\n      return baseProps;\n    }\n\n    function inspectHooksOfFiber(fiber, currentDispatcher) {\n      // DevTools will pass the current renderer's injected dispatcher.\n      // Other apps might compile debug hooks as part of their app though.\n      if (currentDispatcher == null) {\n        currentDispatcher = shared_ReactSharedInternals__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ReactCurrentDispatcher;\n      }\n\n      currentFiber = fiber;\n\n      if (fiber.tag !== react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"FunctionComponent\"] && fiber.tag !== react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"SimpleMemoComponent\"] && fiber.tag !== react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"ForwardRef\"] && fiber.tag !== react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"Block\"]) {\n        throw new Error('Unknown Fiber. Needs to be a function component to inspect hooks.');\n      } // Warm up the cache so that it doesn't consume the currentHook.\n\n\n      getPrimitiveStackCache();\n      var type = fiber.type;\n      var props = fiber.memoizedProps;\n\n      if (type !== fiber.elementType) {\n        props = resolveDefaultProps(type, props);\n      } // Set up the current hook so that we can step through and read the\n      // current state from them.\n\n\n      currentHook = fiber.memoizedState;\n      var contextMap = new Map();\n\n      try {\n        setupContexts(contextMap, fiber);\n\n        if (fiber.tag === react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_4__[\"ForwardRef\"]) {\n          return inspectHooksOfForwardRef(type.render, props, fiber.ref, currentDispatcher);\n        }\n\n        return inspectHooks(type, props, currentDispatcher);\n      } finally {\n        currentHook = null;\n        restoreContexts(contextMap);\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-debug-tools/src/ReactDebugTools.js\":\n  /*!***************************************************!*\\\n    !*** ../react-debug-tools/src/ReactDebugTools.js ***!\n    \\***************************************************/\n\n  /*! exports provided: inspectHooks, inspectHooksOfFiber */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */\n\n\n    var _ReactDebugHooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./ReactDebugHooks */\n    \"../react-debug-tools/src/ReactDebugHooks.js\");\n    /* harmony reexport (safe) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooks\", function () {\n      return _ReactDebugHooks__WEBPACK_IMPORTED_MODULE_0__[\"inspectHooks\"];\n    });\n    /* harmony reexport (safe) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"inspectHooksOfFiber\", function () {\n      return _ReactDebugHooks__WEBPACK_IMPORTED_MODULE_0__[\"inspectHooksOfFiber\"];\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/node_modules/semver/semver.js\":\n  /*!**************************************************************!*\\\n    !*** ../react-devtools-shared/node_modules/semver/semver.js ***!\n    \\**************************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    /* WEBPACK VAR INJECTION */\n    (function (process) {\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports = module.exports = SemVer;\n      var debug;\n      /* istanbul ignore next */\n\n      if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n        debug = function debug() {\n          var args = Array.prototype.slice.call(arguments, 0);\n          args.unshift('SEMVER');\n          console.log.apply(console, args);\n        };\n      } else {\n        debug = function debug() {};\n      } // Note: this is the semver.org version of the spec that it implements\n      // Not necessarily the package version of this code.\n\n\n      exports.SEMVER_SPEC_VERSION = '2.0.0';\n      var MAX_LENGTH = 256;\n      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n      /* istanbul ignore next */\n      9007199254740991; // Max safe segment length for coercion.\n\n      var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re\n\n      var re = exports.re = [];\n      var src = exports.src = [];\n      var t = exports.tokens = {};\n      var R = 0;\n\n      function tok(n) {\n        t[n] = R++;\n      } // The following Regular Expressions can be used for tokenizing,\n      // validating, and parsing SemVer version strings.\n      // ## Numeric Identifier\n      // A single `0`, or a non-zero digit followed by zero or more digits.\n\n\n      tok('NUMERICIDENTIFIER');\n      src[t.NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\n      tok('NUMERICIDENTIFIERLOOSE');\n      src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier\n      // Zero or more digits, followed by a letter or hyphen, and then zero or\n      // more letters, digits, or hyphens.\n\n      tok('NONNUMERICIDENTIFIER');\n      src[t.NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version\n      // Three dot-separated numeric identifiers.\n\n      tok('MAINVERSION');\n      src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';\n      tok('MAINVERSIONLOOSE');\n      src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier\n      // A numeric identifier, or a non-numeric identifier.\n\n      tok('PRERELEASEIDENTIFIER');\n      src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';\n      tok('PRERELEASEIDENTIFIERLOOSE');\n      src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version\n      // Hyphen, followed by one or more dot-separated pre-release version\n      // identifiers.\n\n      tok('PRERELEASE');\n      src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';\n      tok('PRERELEASELOOSE');\n      src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier\n      // Any combination of digits, letters, or hyphens.\n\n      tok('BUILDIDENTIFIER');\n      src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata\n      // Plus sign, followed by one or more period-separated build metadata\n      // identifiers.\n\n      tok('BUILD');\n      src[t.BUILD] = '(?:\\\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String\n      // A main version, followed optionally by a pre-release version and\n      // build metadata.\n      // Note that the only major, minor, patch, and pre-release sections of\n      // the version string are capturing groups.  The build metadata is not a\n      // capturing group, because it should not ever be used in version\n      // comparison.\n\n      tok('FULL');\n      tok('FULLPLAIN');\n      src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';\n      src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n      // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n      // common in the npm registry.\n\n      tok('LOOSEPLAIN');\n      src[t.LOOSEPLAIN] = '[v=\\\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';\n      tok('LOOSE');\n      src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';\n      tok('GTLT');\n      src[t.GTLT] = '((?:<|>)?=?)'; // Something like \"2.*\" or \"1.2.x\".\n      // Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n      // Only the first item is strictly required.\n\n      tok('XRANGEIDENTIFIERLOOSE');\n      src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\n      tok('XRANGEIDENTIFIER');\n      src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\\\*';\n      tok('XRANGEPLAIN');\n      src[t.XRANGEPLAIN] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';\n      tok('XRANGEPLAINLOOSE');\n      src[t.XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';\n      tok('XRANGE');\n      src[t.XRANGE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAIN] + '$';\n      tok('XRANGELOOSE');\n      src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.\n      // Extract anything that could conceivably be a part of a valid semver\n\n      tok('COERCE');\n      src[t.COERCE] = '(^|[^\\\\d])' + '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\\\d])';\n      tok('COERCERTL');\n      re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.\n      // Meaning is \"reasonably at or greater than\"\n\n      tok('LONETILDE');\n      src[t.LONETILDE] = '(?:~>?)';\n      tok('TILDETRIM');\n      src[t.TILDETRIM] = '(\\\\s*)' + src[t.LONETILDE] + '\\\\s+';\n      re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');\n      var tildeTrimReplace = '$1~';\n      tok('TILDE');\n      src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';\n      tok('TILDELOOSE');\n      src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.\n      // Meaning is \"at least and backwards compatible with\"\n\n      tok('LONECARET');\n      src[t.LONECARET] = '(?:\\\\^)';\n      tok('CARETTRIM');\n      src[t.CARETTRIM] = '(\\\\s*)' + src[t.LONECARET] + '\\\\s+';\n      re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');\n      var caretTrimReplace = '$1^';\n      tok('CARET');\n      src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';\n      tok('CARETLOOSE');\n      src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\n      tok('COMPARATORLOOSE');\n      src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';\n      tok('COMPARATOR');\n      src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing\n      // it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\n      tok('COMPARATORTRIM');\n      src[t.COMPARATORTRIM] = '(\\\\s*)' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag\n\n      re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');\n      var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`\n      // Note that these all use the loose form, because they'll be\n      // checked against either the strict or loose comparator form\n      // later.\n\n      tok('HYPHENRANGE');\n      src[t.HYPHENRANGE] = '^\\\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\\\s*$';\n      tok('HYPHENRANGELOOSE');\n      src[t.HYPHENRANGELOOSE] = '^\\\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s*$'; // Star ranges basically just allow anything at all.\n\n      tok('STAR');\n      src[t.STAR] = '(<|>)?=?\\\\s*\\\\*'; // Compile to actual regexp objects.\n      // All are flag-free, unless they were created above with a flag.\n\n      for (var i = 0; i < R; i++) {\n        debug(i, src[i]);\n\n        if (!re[i]) {\n          re[i] = new RegExp(src[i]);\n        }\n      }\n\n      exports.parse = parse;\n\n      function parse(version, options) {\n        if (!options || _typeof(options) !== 'object') {\n          options = {\n            loose: !!options,\n            includePrerelease: false\n          };\n        }\n\n        if (version instanceof SemVer) {\n          return version;\n        }\n\n        if (typeof version !== 'string') {\n          return null;\n        }\n\n        if (version.length > MAX_LENGTH) {\n          return null;\n        }\n\n        var r = options.loose ? re[t.LOOSE] : re[t.FULL];\n\n        if (!r.test(version)) {\n          return null;\n        }\n\n        try {\n          return new SemVer(version, options);\n        } catch (er) {\n          return null;\n        }\n      }\n\n      exports.valid = valid;\n\n      function valid(version, options) {\n        var v = parse(version, options);\n        return v ? v.version : null;\n      }\n\n      exports.clean = clean;\n\n      function clean(version, options) {\n        var s = parse(version.trim().replace(/^[=v]+/, ''), options);\n        return s ? s.version : null;\n      }\n\n      exports.SemVer = SemVer;\n\n      function SemVer(version, options) {\n        if (!options || _typeof(options) !== 'object') {\n          options = {\n            loose: !!options,\n            includePrerelease: false\n          };\n        }\n\n        if (version instanceof SemVer) {\n          if (version.loose === options.loose) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== 'string') {\n          throw new TypeError('Invalid Version: ' + version);\n        }\n\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');\n        }\n\n        if (!(this instanceof SemVer)) {\n          return new SemVer(version, options);\n        }\n\n        debug('SemVer', version, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n\n        if (!m) {\n          throw new TypeError('Invalid Version: ' + version);\n        }\n\n        this.raw = version; // these are actually numbers\n\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError('Invalid major version');\n        }\n\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError('Invalid minor version');\n        }\n\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError('Invalid patch version');\n        } // numberify any prerelease numeric ids\n\n\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split('.').map(function (id) {\n            if (/^[0-9]+$/.test(id)) {\n              var num = +id;\n\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n\n            return id;\n          });\n        }\n\n        this.build = m[5] ? m[5].split('.') : [];\n        this.format();\n      }\n\n      SemVer.prototype.format = function () {\n        this.version = this.major + '.' + this.minor + '.' + this.patch;\n\n        if (this.prerelease.length) {\n          this.version += '-' + this.prerelease.join('.');\n        }\n\n        return this.version;\n      };\n\n      SemVer.prototype.toString = function () {\n        return this.version;\n      };\n\n      SemVer.prototype.compare = function (other) {\n        debug('SemVer.compare', this.version, this.options, other);\n\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n\n        return this.compareMain(other) || this.comparePre(other);\n      };\n\n      SemVer.prototype.compareMain = function (other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n\n        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n      };\n\n      SemVer.prototype.comparePre = function (other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        } // NOT having a prerelease is > having one\n\n\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n\n        var i = 0;\n\n        do {\n          var a = this.prerelease[i];\n          var b = other.prerelease[i];\n          debug('prerelease compare', i, a, b);\n\n          if (a === undefined && b === undefined) {\n            return 0;\n          } else if (b === undefined) {\n            return 1;\n          } else if (a === undefined) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      };\n\n      SemVer.prototype.compareBuild = function (other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n\n        var i = 0;\n\n        do {\n          var a = this.build[i];\n          var b = other.build[i];\n          debug('prerelease compare', i, a, b);\n\n          if (a === undefined && b === undefined) {\n            return 0;\n          } else if (b === undefined) {\n            return 1;\n          } else if (a === undefined) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }; // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n\n\n      SemVer.prototype.inc = function (release, identifier) {\n        switch (release) {\n          case 'premajor':\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc('pre', identifier);\n            break;\n\n          case 'preminor':\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc('pre', identifier);\n            break;\n\n          case 'prepatch':\n            // If this is already a prerelease, it will bump to the next version\n            // drop any prereleases that might already exist, since they are not\n            // relevant at this point.\n            this.prerelease.length = 0;\n            this.inc('patch', identifier);\n            this.inc('pre', identifier);\n            break;\n          // If the input is a non-prerelease version, this acts the same as\n          // prepatch.\n\n          case 'prerelease':\n            if (this.prerelease.length === 0) {\n              this.inc('patch', identifier);\n            }\n\n            this.inc('pre', identifier);\n            break;\n\n          case 'major':\n            // If this is a pre-major version, bump up to the same major version.\n            // Otherwise increment major.\n            // 1.0.0-5 bumps to 1.0.0\n            // 1.1.0 bumps to 2.0.0\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n\n          case 'minor':\n            // If this is a pre-minor version, bump up to the same minor version.\n            // Otherwise increment minor.\n            // 1.2.0-5 bumps to 1.2.0\n            // 1.2.1 bumps to 1.3.0\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n\n          case 'patch':\n            // If this is not a pre-release version, it will increment the patch.\n            // If it is a pre-release it will bump up to the same patch version.\n            // 1.2.0-5 patches to 1.2.0\n            // 1.2.0 patches to 1.2.1\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n\n            this.prerelease = [];\n            break;\n          // This probably shouldn't be used publicly.\n          // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n\n          case 'pre':\n            if (this.prerelease.length === 0) {\n              this.prerelease = [0];\n            } else {\n              var i = this.prerelease.length;\n\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === 'number') {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n\n              if (i === -1) {\n                // didn't increment anything\n                this.prerelease.push(0);\n              }\n            }\n\n            if (identifier) {\n              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n              if (this.prerelease[0] === identifier) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = [identifier, 0];\n                }\n              } else {\n                this.prerelease = [identifier, 0];\n              }\n            }\n\n            break;\n\n          default:\n            throw new Error('invalid increment argument: ' + release);\n        }\n\n        this.format();\n        this.raw = this.version;\n        return this;\n      };\n\n      exports.inc = inc;\n\n      function inc(version, release, loose, identifier) {\n        if (typeof loose === 'string') {\n          identifier = loose;\n          loose = undefined;\n        }\n\n        try {\n          return new SemVer(version, loose).inc(release, identifier).version;\n        } catch (er) {\n          return null;\n        }\n      }\n\n      exports.diff = diff;\n\n      function diff(version1, version2) {\n        if (eq(version1, version2)) {\n          return null;\n        } else {\n          var v1 = parse(version1);\n          var v2 = parse(version2);\n          var prefix = '';\n\n          if (v1.prerelease.length || v2.prerelease.length) {\n            prefix = 'pre';\n            var defaultResult = 'prerelease';\n          }\n\n          for (var key in v1) {\n            if (key === 'major' || key === 'minor' || key === 'patch') {\n              if (v1[key] !== v2[key]) {\n                return prefix + key;\n              }\n            }\n          }\n\n          return defaultResult; // may be undefined\n        }\n      }\n\n      exports.compareIdentifiers = compareIdentifiers;\n      var numeric = /^[0-9]+$/;\n\n      function compareIdentifiers(a, b) {\n        var anum = numeric.test(a);\n        var bnum = numeric.test(b);\n\n        if (anum && bnum) {\n          a = +a;\n          b = +b;\n        }\n\n        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n      }\n\n      exports.rcompareIdentifiers = rcompareIdentifiers;\n\n      function rcompareIdentifiers(a, b) {\n        return compareIdentifiers(b, a);\n      }\n\n      exports.major = major;\n\n      function major(a, loose) {\n        return new SemVer(a, loose).major;\n      }\n\n      exports.minor = minor;\n\n      function minor(a, loose) {\n        return new SemVer(a, loose).minor;\n      }\n\n      exports.patch = patch;\n\n      function patch(a, loose) {\n        return new SemVer(a, loose).patch;\n      }\n\n      exports.compare = compare;\n\n      function compare(a, b, loose) {\n        return new SemVer(a, loose).compare(new SemVer(b, loose));\n      }\n\n      exports.compareLoose = compareLoose;\n\n      function compareLoose(a, b) {\n        return compare(a, b, true);\n      }\n\n      exports.compareBuild = compareBuild;\n\n      function compareBuild(a, b, loose) {\n        var versionA = new SemVer(a, loose);\n        var versionB = new SemVer(b, loose);\n        return versionA.compare(versionB) || versionA.compareBuild(versionB);\n      }\n\n      exports.rcompare = rcompare;\n\n      function rcompare(a, b, loose) {\n        return compare(b, a, loose);\n      }\n\n      exports.sort = sort;\n\n      function sort(list, loose) {\n        return list.sort(function (a, b) {\n          return exports.compareBuild(a, b, loose);\n        });\n      }\n\n      exports.rsort = rsort;\n\n      function rsort(list, loose) {\n        return list.sort(function (a, b) {\n          return exports.compareBuild(b, a, loose);\n        });\n      }\n\n      exports.gt = gt;\n\n      function gt(a, b, loose) {\n        return compare(a, b, loose) > 0;\n      }\n\n      exports.lt = lt;\n\n      function lt(a, b, loose) {\n        return compare(a, b, loose) < 0;\n      }\n\n      exports.eq = eq;\n\n      function eq(a, b, loose) {\n        return compare(a, b, loose) === 0;\n      }\n\n      exports.neq = neq;\n\n      function neq(a, b, loose) {\n        return compare(a, b, loose) !== 0;\n      }\n\n      exports.gte = gte;\n\n      function gte(a, b, loose) {\n        return compare(a, b, loose) >= 0;\n      }\n\n      exports.lte = lte;\n\n      function lte(a, b, loose) {\n        return compare(a, b, loose) <= 0;\n      }\n\n      exports.cmp = cmp;\n\n      function cmp(a, op, b, loose) {\n        switch (op) {\n          case '===':\n            if (_typeof(a) === 'object') a = a.version;\n            if (_typeof(b) === 'object') b = b.version;\n            return a === b;\n\n          case '!==':\n            if (_typeof(a) === 'object') a = a.version;\n            if (_typeof(b) === 'object') b = b.version;\n            return a !== b;\n\n          case '':\n          case '=':\n          case '==':\n            return eq(a, b, loose);\n\n          case '!=':\n            return neq(a, b, loose);\n\n          case '>':\n            return gt(a, b, loose);\n\n          case '>=':\n            return gte(a, b, loose);\n\n          case '<':\n            return lt(a, b, loose);\n\n          case '<=':\n            return lte(a, b, loose);\n\n          default:\n            throw new TypeError('Invalid operator: ' + op);\n        }\n      }\n\n      exports.Comparator = Comparator;\n\n      function Comparator(comp, options) {\n        if (!options || _typeof(options) !== 'object') {\n          options = {\n            loose: !!options,\n            includePrerelease: false\n          };\n        }\n\n        if (comp instanceof Comparator) {\n          if (comp.loose === !!options.loose) {\n            return comp;\n          } else {\n            comp = comp.value;\n          }\n        }\n\n        if (!(this instanceof Comparator)) {\n          return new Comparator(comp, options);\n        }\n\n        debug('comparator', comp, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.parse(comp);\n\n        if (this.semver === ANY) {\n          this.value = '';\n        } else {\n          this.value = this.operator + this.semver.version;\n        }\n\n        debug('comp', this);\n      }\n\n      var ANY = {};\n\n      Comparator.prototype.parse = function (comp) {\n        var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n        var m = comp.match(r);\n\n        if (!m) {\n          throw new TypeError('Invalid comparator: ' + comp);\n        }\n\n        this.operator = m[1] !== undefined ? m[1] : '';\n\n        if (this.operator === '=') {\n          this.operator = '';\n        } // if it literally is just '>' or '' then allow anything.\n\n\n        if (!m[2]) {\n          this.semver = ANY;\n        } else {\n          this.semver = new SemVer(m[2], this.options.loose);\n        }\n      };\n\n      Comparator.prototype.toString = function () {\n        return this.value;\n      };\n\n      Comparator.prototype.test = function (version) {\n        debug('Comparator.test', version, this.options.loose);\n\n        if (this.semver === ANY || version === ANY) {\n          return true;\n        }\n\n        if (typeof version === 'string') {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n\n        return cmp(version, this.operator, this.semver, this.options);\n      };\n\n      Comparator.prototype.intersects = function (comp, options) {\n        if (!(comp instanceof Comparator)) {\n          throw new TypeError('a Comparator is required');\n        }\n\n        if (!options || _typeof(options) !== 'object') {\n          options = {\n            loose: !!options,\n            includePrerelease: false\n          };\n        }\n\n        var rangeTmp;\n\n        if (this.operator === '') {\n          if (this.value === '') {\n            return true;\n          }\n\n          rangeTmp = new Range(comp.value, options);\n          return satisfies(this.value, rangeTmp, options);\n        } else if (comp.operator === '') {\n          if (comp.value === '') {\n            return true;\n          }\n\n          rangeTmp = new Range(this.value, options);\n          return satisfies(comp.semver, rangeTmp, options);\n        }\n\n        var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n        var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n        var sameSemVer = this.semver.version === comp.semver.version;\n        var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n        var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n        var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n      };\n\n      exports.Range = Range;\n\n      function Range(range, options) {\n        if (!options || _typeof(options) !== 'object') {\n          options = {\n            loose: !!options,\n            includePrerelease: false\n          };\n        }\n\n        if (range instanceof Range) {\n          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n            return range;\n          } else {\n            return new Range(range.raw, options);\n          }\n        }\n\n        if (range instanceof Comparator) {\n          return new Range(range.value, options);\n        }\n\n        if (!(this instanceof Range)) {\n          return new Range(range, options);\n        }\n\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||\n\n        this.raw = range;\n        this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n          return this.parseRange(range.trim());\n        }, this).filter(function (c) {\n          // throw out any that are not relevant for whatever reason\n          return c.length;\n        });\n\n        if (!this.set.length) {\n          throw new TypeError('Invalid SemVer Range: ' + range);\n        }\n\n        this.format();\n      }\n\n      Range.prototype.format = function () {\n        this.range = this.set.map(function (comps) {\n          return comps.join(' ').trim();\n        }).join('||').trim();\n        return this.range;\n      };\n\n      Range.prototype.toString = function () {\n        return this.range;\n      };\n\n      Range.prototype.parseRange = function (range) {\n        var loose = this.options.loose;\n        range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\n        var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n        range = range.replace(hr, hyphenReplace);\n        debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\n        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n        debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`\n\n        range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`\n\n        range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces\n\n        range = range.split(/\\s+/).join(' '); // At this point, the range is completely trimmed and\n        // ready to be split into comparators.\n\n        var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n        var set = range.split(' ').map(function (comp) {\n          return parseComparator(comp, this.options);\n        }, this).join(' ').split(/\\s+/);\n\n        if (this.options.loose) {\n          // in loose mode, throw out any that are not valid comparators\n          set = set.filter(function (comp) {\n            return !!comp.match(compRe);\n          });\n        }\n\n        set = set.map(function (comp) {\n          return new Comparator(comp, this.options);\n        }, this);\n        return set;\n      };\n\n      Range.prototype.intersects = function (range, options) {\n        if (!(range instanceof Range)) {\n          throw new TypeError('a Range is required');\n        }\n\n        return this.set.some(function (thisComparators) {\n          return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {\n            return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {\n              return rangeComparators.every(function (rangeComparator) {\n                return thisComparator.intersects(rangeComparator, options);\n              });\n            });\n          });\n        });\n      }; // take a set of comparators and determine whether there\n      // exists a version which can satisfy it\n\n\n      function isSatisfiable(comparators, options) {\n        var result = true;\n        var remainingComparators = comparators.slice();\n        var testComparator = remainingComparators.pop();\n\n        while (result && remainingComparators.length) {\n          result = remainingComparators.every(function (otherComparator) {\n            return testComparator.intersects(otherComparator, options);\n          });\n          testComparator = remainingComparators.pop();\n        }\n\n        return result;\n      } // Mostly just for testing and legacy API reasons\n\n\n      exports.toComparators = toComparators;\n\n      function toComparators(range, options) {\n        return new Range(range, options).set.map(function (comp) {\n          return comp.map(function (c) {\n            return c.value;\n          }).join(' ').trim().split(' ');\n        });\n      } // comprised of xranges, tildes, stars, and gtlt's at this point.\n      // already replaced the hyphen ranges\n      // turn into a set of JUST comparators.\n\n\n      function parseComparator(comp, options) {\n        debug('comp', comp, options);\n        comp = replaceCarets(comp, options);\n        debug('caret', comp);\n        comp = replaceTildes(comp, options);\n        debug('tildes', comp);\n        comp = replaceXRanges(comp, options);\n        debug('xrange', comp);\n        comp = replaceStars(comp, options);\n        debug('stars', comp);\n        return comp;\n      }\n\n      function isX(id) {\n        return !id || id.toLowerCase() === 'x' || id === '*';\n      } // ~, ~> --> * (any, kinda silly)\n      // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n      // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n      // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n      // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n      // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\n\n\n      function replaceTildes(comp, options) {\n        return comp.trim().split(/\\s+/).map(function (comp) {\n          return replaceTilde(comp, options);\n        }).join(' ');\n      }\n\n      function replaceTilde(comp, options) {\n        var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n        return comp.replace(r, function (_, M, m, p, pr) {\n          debug('tilde', comp, _, M, m, p, pr);\n          var ret;\n\n          if (isX(M)) {\n            ret = '';\n          } else if (isX(m)) {\n            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n          } else if (isX(p)) {\n            // ~1.2 == >=1.2.0 <1.3.0\n            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n          } else if (pr) {\n            debug('replaceTilde pr', pr);\n            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n          } else {\n            // ~1.2.3 == >=1.2.3 <1.3.0\n            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n          }\n\n          debug('tilde return', ret);\n          return ret;\n        });\n      } // ^ --> * (any, kinda silly)\n      // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n      // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n      // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n      // ^1.2.3 --> >=1.2.3 <2.0.0\n      // ^1.2.0 --> >=1.2.0 <2.0.0\n\n\n      function replaceCarets(comp, options) {\n        return comp.trim().split(/\\s+/).map(function (comp) {\n          return replaceCaret(comp, options);\n        }).join(' ');\n      }\n\n      function replaceCaret(comp, options) {\n        debug('caret', comp, options);\n        var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n        return comp.replace(r, function (_, M, m, p, pr) {\n          debug('caret', comp, _, M, m, p, pr);\n          var ret;\n\n          if (isX(M)) {\n            ret = '';\n          } else if (isX(m)) {\n            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n          } else if (isX(p)) {\n            if (M === '0') {\n              ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n            } else {\n              ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n            }\n          } else if (pr) {\n            debug('replaceCaret pr', pr);\n\n            if (M === '0') {\n              if (m === '0') {\n                ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);\n              } else {\n                ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n              }\n            } else {\n              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';\n            }\n          } else {\n            debug('no pr');\n\n            if (M === '0') {\n              if (m === '0') {\n                ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);\n              } else {\n                ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n              }\n            } else {\n              ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';\n            }\n          }\n\n          debug('caret return', ret);\n          return ret;\n        });\n      }\n\n      function replaceXRanges(comp, options) {\n        debug('replaceXRanges', comp, options);\n        return comp.split(/\\s+/).map(function (comp) {\n          return replaceXRange(comp, options);\n        }).join(' ');\n      }\n\n      function replaceXRange(comp, options) {\n        comp = comp.trim();\n        var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n        return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n          debug('xRange', comp, ret, gtlt, M, m, p, pr);\n          var xM = isX(M);\n          var xm = xM || isX(m);\n          var xp = xm || isX(p);\n          var anyX = xp;\n\n          if (gtlt === '=' && anyX) {\n            gtlt = '';\n          } // if we're including prereleases in the match, then we need\n          // to fix this to -0, the lowest possible prerelease value\n\n\n          pr = options.includePrerelease ? '-0' : '';\n\n          if (xM) {\n            if (gtlt === '>' || gtlt === '<') {\n              // nothing is allowed\n              ret = '<0.0.0-0';\n            } else {\n              // nothing is forbidden\n              ret = '*';\n            }\n          } else if (gtlt && anyX) {\n            // we know patch is an x, because we have any x at all.\n            // replace X with 0\n            if (xm) {\n              m = 0;\n            }\n\n            p = 0;\n\n            if (gtlt === '>') {\n              // >1 => >=2.0.0\n              // >1.2 => >=1.3.0\n              // >1.2.3 => >= 1.2.4\n              gtlt = '>=';\n\n              if (xm) {\n                M = +M + 1;\n                m = 0;\n                p = 0;\n              } else {\n                m = +m + 1;\n                p = 0;\n              }\n            } else if (gtlt === '<=') {\n              // <=0.7.x is actually <0.8.0, since any 0.7.x should\n              // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n              gtlt = '<';\n\n              if (xm) {\n                M = +M + 1;\n              } else {\n                m = +m + 1;\n              }\n            }\n\n            ret = gtlt + M + '.' + m + '.' + p + pr;\n          } else if (xm) {\n            ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;\n          } else if (xp) {\n            ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;\n          }\n\n          debug('xRange return', ret);\n          return ret;\n        });\n      } // Because * is AND-ed with everything else in the comparator,\n      // and '' means \"any version\", just remove the *s entirely.\n\n\n      function replaceStars(comp, options) {\n        debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!\n\n        return comp.trim().replace(re[t.STAR], '');\n      } // This function is passed to string.replace(re[t.HYPHENRANGE])\n      // M, m, patch, prerelease, build\n      // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n      // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n      // 1.2 - 3.4 => >=1.2.0 <3.5.0\n\n\n      function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {\n        if (isX(fM)) {\n          from = '';\n        } else if (isX(fm)) {\n          from = '>=' + fM + '.0.0';\n        } else if (isX(fp)) {\n          from = '>=' + fM + '.' + fm + '.0';\n        } else {\n          from = '>=' + from;\n        }\n\n        if (isX(tM)) {\n          to = '';\n        } else if (isX(tm)) {\n          to = '<' + (+tM + 1) + '.0.0';\n        } else if (isX(tp)) {\n          to = '<' + tM + '.' + (+tm + 1) + '.0';\n        } else if (tpr) {\n          to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n        } else {\n          to = '<=' + to;\n        }\n\n        return (from + ' ' + to).trim();\n      } // if ANY of the sets match ALL of its comparators, then pass\n\n\n      Range.prototype.test = function (version) {\n        if (!version) {\n          return false;\n        }\n\n        if (typeof version === 'string') {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n\n        for (var i = 0; i < this.set.length; i++) {\n          if (testSet(this.set[i], version, this.options)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      function testSet(set, version, options) {\n        for (var i = 0; i < set.length; i++) {\n          if (!set[i].test(version)) {\n            return false;\n          }\n        }\n\n        if (version.prerelease.length && !options.includePrerelease) {\n          // Find the set of versions that are allowed to have prereleases\n          // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n          // That should allow `1.2.3-pr.2` to pass.\n          // However, `1.2.4-alpha.notready` should NOT be allowed,\n          // even though it's within the range set by the comparators.\n          for (i = 0; i < set.length; i++) {\n            debug(set[i].semver);\n\n            if (set[i].semver === ANY) {\n              continue;\n            }\n\n            if (set[i].semver.prerelease.length > 0) {\n              var allowed = set[i].semver;\n\n              if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n                return true;\n              }\n            }\n          } // Version has a -pre, but it's not one of the ones we like.\n\n\n          return false;\n        }\n\n        return true;\n      }\n\n      exports.satisfies = satisfies;\n\n      function satisfies(version, range, options) {\n        try {\n          range = new Range(range, options);\n        } catch (er) {\n          return false;\n        }\n\n        return range.test(version);\n      }\n\n      exports.maxSatisfying = maxSatisfying;\n\n      function maxSatisfying(versions, range, options) {\n        var max = null;\n        var maxSV = null;\n\n        try {\n          var rangeObj = new Range(range, options);\n        } catch (er) {\n          return null;\n        }\n\n        versions.forEach(function (v) {\n          if (rangeObj.test(v)) {\n            // satisfies(v, range, options)\n            if (!max || maxSV.compare(v) === -1) {\n              // compare(max, v, true)\n              max = v;\n              maxSV = new SemVer(max, options);\n            }\n          }\n        });\n        return max;\n      }\n\n      exports.minSatisfying = minSatisfying;\n\n      function minSatisfying(versions, range, options) {\n        var min = null;\n        var minSV = null;\n\n        try {\n          var rangeObj = new Range(range, options);\n        } catch (er) {\n          return null;\n        }\n\n        versions.forEach(function (v) {\n          if (rangeObj.test(v)) {\n            // satisfies(v, range, options)\n            if (!min || minSV.compare(v) === 1) {\n              // compare(min, v, true)\n              min = v;\n              minSV = new SemVer(min, options);\n            }\n          }\n        });\n        return min;\n      }\n\n      exports.minVersion = minVersion;\n\n      function minVersion(range, loose) {\n        range = new Range(range, loose);\n        var minver = new SemVer('0.0.0');\n\n        if (range.test(minver)) {\n          return minver;\n        }\n\n        minver = new SemVer('0.0.0-0');\n\n        if (range.test(minver)) {\n          return minver;\n        }\n\n        minver = null;\n\n        for (var i = 0; i < range.set.length; ++i) {\n          var comparators = range.set[i];\n          comparators.forEach(function (comparator) {\n            // Clone to avoid manipulating the comparator's semver object.\n            var compver = new SemVer(comparator.semver.version);\n\n            switch (comparator.operator) {\n              case '>':\n                if (compver.prerelease.length === 0) {\n                  compver.patch++;\n                } else {\n                  compver.prerelease.push(0);\n                }\n\n                compver.raw = compver.format();\n\n              /* fallthrough */\n\n              case '':\n              case '>=':\n                if (!minver || gt(minver, compver)) {\n                  minver = compver;\n                }\n\n                break;\n\n              case '<':\n              case '<=':\n                /* Ignore maximum versions */\n                break;\n\n              /* istanbul ignore next */\n\n              default:\n                throw new Error('Unexpected operation: ' + comparator.operator);\n            }\n          });\n        }\n\n        if (minver && range.test(minver)) {\n          return minver;\n        }\n\n        return null;\n      }\n\n      exports.validRange = validRange;\n\n      function validRange(range, options) {\n        try {\n          // Return '*' instead of '' so that truthiness works.\n          // This will throw if it's invalid anyway\n          return new Range(range, options).range || '*';\n        } catch (er) {\n          return null;\n        }\n      } // Determine if version is less than all the versions possible in the range\n\n\n      exports.ltr = ltr;\n\n      function ltr(version, range, options) {\n        return outside(version, range, '<', options);\n      } // Determine if version is greater than all the versions possible in the range.\n\n\n      exports.gtr = gtr;\n\n      function gtr(version, range, options) {\n        return outside(version, range, '>', options);\n      }\n\n      exports.outside = outside;\n\n      function outside(version, range, hilo, options) {\n        version = new SemVer(version, options);\n        range = new Range(range, options);\n        var gtfn, ltefn, ltfn, comp, ecomp;\n\n        switch (hilo) {\n          case '>':\n            gtfn = gt;\n            ltefn = lte;\n            ltfn = lt;\n            comp = '>';\n            ecomp = '>=';\n            break;\n\n          case '<':\n            gtfn = lt;\n            ltefn = gte;\n            ltfn = gt;\n            comp = '<';\n            ecomp = '<=';\n            break;\n\n          default:\n            throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n        } // If it satisifes the range it is not outside\n\n\n        if (satisfies(version, range, options)) {\n          return false;\n        } // From now on, variable terms are as if we're in \"gtr\" mode.\n        // but note that everything is flipped for the \"ltr\" function.\n\n\n        for (var i = 0; i < range.set.length; ++i) {\n          var comparators = range.set[i];\n          var high = null;\n          var low = null;\n          comparators.forEach(function (comparator) {\n            if (comparator.semver === ANY) {\n              comparator = new Comparator('>=0.0.0');\n            }\n\n            high = high || comparator;\n            low = low || comparator;\n\n            if (gtfn(comparator.semver, high.semver, options)) {\n              high = comparator;\n            } else if (ltfn(comparator.semver, low.semver, options)) {\n              low = comparator;\n            }\n          }); // If the edge version comparator has a operator then our version\n          // isn't outside it\n\n          if (high.operator === comp || high.operator === ecomp) {\n            return false;\n          } // If the lowest version comparator has an operator and our version\n          // is less than it then it isn't higher than the range\n\n\n          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n            return false;\n          } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      exports.prerelease = prerelease;\n\n      function prerelease(version, options) {\n        var parsed = parse(version, options);\n        return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n      }\n\n      exports.intersects = intersects;\n\n      function intersects(r1, r2, options) {\n        r1 = new Range(r1, options);\n        r2 = new Range(r2, options);\n        return r1.intersects(r2);\n      }\n\n      exports.coerce = coerce;\n\n      function coerce(version, options) {\n        if (version instanceof SemVer) {\n          return version;\n        }\n\n        if (typeof version === 'number') {\n          version = String(version);\n        }\n\n        if (typeof version !== 'string') {\n          return null;\n        }\n\n        options = options || {};\n        var match = null;\n\n        if (!options.rtl) {\n          match = version.match(re[t.COERCE]);\n        } else {\n          // Find the right-most coercible string that does not share\n          // a terminus with a more left-ward coercible string.\n          // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n          //\n          // Walk through the string checking with a /g regexp\n          // Manually set the index so as to pick up overlapping matches.\n          // Stop when we get a match that ends at the string end, since no\n          // coercible string can be more right-ward without the same terminus.\n          var next;\n\n          while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n            if (!match || next.index + next[0].length !== match.index + match[0].length) {\n              match = next;\n            }\n\n            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n          } // leave it in a clean state\n\n\n          re[t.COERCERTL].lastIndex = -1;\n        }\n\n        if (match === null) {\n          return null;\n        }\n\n        return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);\n      }\n      /* WEBPACK VAR INJECTION */\n\n    }).call(this, __webpack_require__(\n    /*! ./../../../../node_modules/process/browser.js */\n    \"../../node_modules/process/browser.js\"));\n    /***/\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\":\n  /*!***************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js ***!\n    \\***************************************************************************/\n\n  /*! exports provided: describeBuiltInComponentFrame, describeNativeComponentFrame, describeClassComponentFrame, describeFunctionComponentFrame, describeUnknownElementTypeFrameInDEV */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"describeBuiltInComponentFrame\", function () {\n      return describeBuiltInComponentFrame;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"describeNativeComponentFrame\", function () {\n      return describeNativeComponentFrame;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"describeClassComponentFrame\", function () {\n      return describeClassComponentFrame;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"describeFunctionComponentFrame\", function () {\n      return describeFunctionComponentFrame;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"describeUnknownElementTypeFrameInDEV\", function () {\n      return describeUnknownElementTypeFrameInDEV;\n    });\n    /* harmony import */\n\n\n    var _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./ReactSymbols */\n    \"../react-devtools-shared/src/backend/ReactSymbols.js\");\n    /* harmony import */\n\n\n    var shared_ConsolePatchingDev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! shared/ConsolePatchingDev */\n    \"../shared/ConsolePatchingDev.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // This is a DevTools fork of ReactComponentStackFrame.\n    // This fork enables DevTools to use the same \"native\" component stack format,\n    // while still maintaining support for multiple renderer versions\n    // (which use different values for ReactTypeOfWork).\n    // These methods are safe to import from shared;\n    // there is no React-specific logic here.\n\n\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      if (prefix === undefined) {\n        // Extract the VM specific prefix used by each line.\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = match && match[1] || '';\n        }\n      } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n      return '\\n' + prefix + name;\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n\n    if (true) {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      if (true) {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n\n      var control;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      reentry = true;\n      var previousDispatcher;\n\n      if (true) {\n        previousDispatcher = currentDispatcherRef.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        currentDispatcherRef.current = null;\n        Object(shared_ConsolePatchingDev__WEBPACK_IMPORTED_MODULE_1__[\"disableLogs\"])();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    if (true) {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        Error.prepareStackTrace = previousPrepareStackTrace;\n\n        if (true) {\n          currentDispatcherRef.current = previousDispatcher;\n          Object(shared_ConsolePatchingDev__WEBPACK_IMPORTED_MODULE_1__[\"reenableLogs\"])();\n        }\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n      if (true) {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n\n      return syntheticFrame;\n    }\n\n    function describeClassComponentFrame(ctor, source, ownerFn, currentDispatcherRef) {\n      return describeNativeComponentFrame(ctor, true, currentDispatcherRef);\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn, currentDispatcherRef) {\n      return describeNativeComponentFrame(fn, false, currentDispatcherRef);\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn, currentDispatcherRef) {\n      if (false) {}\n\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type, source, ownerFn);\n      }\n\n      switch (type) {\n        case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_NUMBER\"]:\n        case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_SYMBOL_STRING\"]:\n          return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n\n        case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_LIST_NUMBER\"]:\n        case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_LIST_SYMBOL_STRING\"]:\n          return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n      }\n\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"FORWARD_REF_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"FORWARD_REF_SYMBOL_STRING\"]:\n            return describeFunctionComponentFrame(type.render, source, ownerFn, currentDispatcherRef);\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"MEMO_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"MEMO_SYMBOL_STRING\"]:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn, currentDispatcherRef);\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"BLOCK_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"BLOCK_SYMBOL_STRING\"]:\n            return describeFunctionComponentFrame(type._render, source, ownerFn, currentDispatcherRef);\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"LAZY_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"LAZY_SYMBOL_STRING\"]:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn, currentDispatcherRef);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\":\n  /*!***************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js ***!\n    \\***************************************************************************/\n\n  /*! exports provided: getStackByFiberInDevAndProd */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getStackByFiberInDevAndProd\", function () {\n      return getStackByFiberInDevAndProd;\n    });\n    /* harmony import */\n\n\n    var _DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./DevToolsComponentStackFrame */\n    \"../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\");\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // This is a DevTools fork of ReactFiberComponentStack.\n    // This fork enables DevTools to use the same \"native\" component stack format,\n    // while still maintaining support for multiple renderer versions\n    // (which use different values for ReactTypeOfWork).\n\n\n    function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {\n      var HostComponent = workTagMap.HostComponent,\n          LazyComponent = workTagMap.LazyComponent,\n          SuspenseComponent = workTagMap.SuspenseComponent,\n          SuspenseListComponent = workTagMap.SuspenseListComponent,\n          FunctionComponent = workTagMap.FunctionComponent,\n          IndeterminateComponent = workTagMap.IndeterminateComponent,\n          SimpleMemoComponent = workTagMap.SimpleMemoComponent,\n          ForwardRef = workTagMap.ForwardRef,\n          Block = workTagMap.Block,\n          ClassComponent = workTagMap.ClassComponent;\n      var owner = true ? workInProgress._debugOwner ? workInProgress._debugOwner.type : null : undefined;\n      var source = true ? workInProgress._debugSource : undefined;\n\n      switch (workInProgress.tag) {\n        case HostComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])(workInProgress.type, source, owner);\n\n        case LazyComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('Lazy', source, owner);\n\n        case SuspenseComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('Suspense', source, owner);\n\n        case SuspenseListComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('SuspenseList', source, owner);\n\n        case FunctionComponent:\n        case IndeterminateComponent:\n        case SimpleMemoComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeFunctionComponentFrame\"])(workInProgress.type, source, owner, currentDispatcherRef);\n\n        case ForwardRef:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeFunctionComponentFrame\"])(workInProgress.type.render, source, owner, currentDispatcherRef);\n\n        case Block:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeFunctionComponentFrame\"])(workInProgress.type._render, source, owner, currentDispatcherRef);\n\n        case ClassComponent:\n          return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeClassComponentFrame\"])(workInProgress.type, source, owner, currentDispatcherRef);\n\n        default:\n          return '';\n      }\n    }\n\n    function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {\n      try {\n        var info = '';\n        var node = workInProgress;\n\n        do {\n          info += describeFiber(workTagMap, node, currentDispatcherRef);\n          node = node.return;\n        } while (node);\n\n        return info;\n      } catch (x) {\n        return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\":\n  /*!*********************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js ***!\n    \\*********************************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return resolveBoxStyle;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    /**\n     * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).\n     *\n     * Resolve a style property into it's component parts, e.g.\n     *\n     * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})\n     * -> {top: 5, left: 5, right: 5, bottom: 10}\n     */\n\n\n    function resolveBoxStyle(prefix, style) {\n      var hasParts = false;\n      var result = {\n        bottom: 0,\n        left: 0,\n        right: 0,\n        top: 0\n      };\n      var styleForAll = style[prefix];\n\n      if (styleForAll != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          result[key] = styleForAll;\n        }\n\n        hasParts = true;\n      }\n\n      var styleForHorizontal = style[prefix + 'Horizontal'];\n\n      if (styleForHorizontal != null) {\n        result.left = styleForHorizontal;\n        result.right = styleForHorizontal;\n        hasParts = true;\n      } else {\n        var styleForLeft = style[prefix + 'Left'];\n\n        if (styleForLeft != null) {\n          result.left = styleForLeft;\n          hasParts = true;\n        }\n\n        var styleForRight = style[prefix + 'Right'];\n\n        if (styleForRight != null) {\n          result.right = styleForRight;\n          hasParts = true;\n        }\n\n        var styleForEnd = style[prefix + 'End'];\n\n        if (styleForEnd != null) {\n          // TODO RTL support\n          result.right = styleForEnd;\n          hasParts = true;\n        }\n\n        var styleForStart = style[prefix + 'Start'];\n\n        if (styleForStart != null) {\n          // TODO RTL support\n          result.left = styleForStart;\n          hasParts = true;\n        }\n      }\n\n      var styleForVertical = style[prefix + 'Vertical'];\n\n      if (styleForVertical != null) {\n        result.bottom = styleForVertical;\n        result.top = styleForVertical;\n        hasParts = true;\n      } else {\n        var styleForBottom = style[prefix + 'Bottom'];\n\n        if (styleForBottom != null) {\n          result.bottom = styleForBottom;\n          hasParts = true;\n        }\n\n        var styleForTop = style[prefix + 'Top'];\n\n        if (styleForTop != null) {\n          result.top = styleForTop;\n          hasParts = true;\n        }\n      }\n\n      return hasParts ? result : null;\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\":\n  /*!****************************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js ***!\n    \\****************************************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return setupNativeStyleEditor;\n    });\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend/agent */\n    \"../react-devtools-shared/src/backend/agent.js\");\n    /* harmony import */\n\n\n    var _resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ./resolveBoxStyle */\n    \"../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {\n      bridge.addListener('NativeStyleEditor_measure', function (_ref) {\n        var id = _ref.id,\n            rendererID = _ref.rendererID;\n        measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n      });\n      bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {\n        var id = _ref2.id,\n            rendererID = _ref2.rendererID,\n            oldName = _ref2.oldName,\n            newName = _ref2.newName,\n            value = _ref2.value;\n        renameStyle(agent, id, rendererID, oldName, newName, value);\n        setTimeout(function () {\n          return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n        });\n      });\n      bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {\n        var id = _ref3.id,\n            rendererID = _ref3.rendererID,\n            name = _ref3.name,\n            value = _ref3.value;\n        setStyle(agent, id, rendererID, name, value);\n        setTimeout(function () {\n          return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n        });\n      });\n      bridge.send('isNativeStyleEditorSupported', {\n        isSupported: true,\n        validAttributes: validAttributes\n      });\n    }\n\n    var EMPTY_BOX_STYLE = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n    var componentIDToStyleOverrides = new Map();\n\n    function measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {\n      var data = agent.getInstanceAndStyle({\n        id: id,\n        rendererID: rendererID\n      });\n\n      if (!data || !data.style) {\n        bridge.send('NativeStyleEditor_styleAndLayout', {\n          id: id,\n          layout: null,\n          style: null\n        });\n        return;\n      }\n\n      var instance = data.instance,\n          style = data.style;\n      var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.\n\n      var styleOverrides = componentIDToStyleOverrides.get(id);\n\n      if (styleOverrides != null) {\n        resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);\n      }\n\n      if (!instance || typeof instance.measure !== 'function') {\n        bridge.send('NativeStyleEditor_styleAndLayout', {\n          id: id,\n          layout: null,\n          style: resolvedStyle || null\n        });\n        return;\n      } // $FlowFixMe the parameter types of an unknown function are unknown\n\n\n      instance.measure(function (x, y, width, height, left, top) {\n        // RN Android sometimes returns undefined here. Don't send measurements in this case.\n        // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817\n        if (typeof x !== 'number') {\n          bridge.send('NativeStyleEditor_styleAndLayout', {\n            id: id,\n            layout: null,\n            style: resolvedStyle || null\n          });\n          return;\n        }\n\n        var margin = resolvedStyle != null && Object(_resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('margin', resolvedStyle) || EMPTY_BOX_STYLE;\n        var padding = resolvedStyle != null && Object(_resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('padding', resolvedStyle) || EMPTY_BOX_STYLE;\n        bridge.send('NativeStyleEditor_styleAndLayout', {\n          id: id,\n          layout: {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            left: left,\n            top: top,\n            margin: margin,\n            padding: padding\n          },\n          style: resolvedStyle || null\n        });\n      });\n    }\n\n    function shallowClone(object) {\n      var cloned = {};\n\n      for (var n in object) {\n        cloned[n] = object[n];\n      }\n\n      return cloned;\n    }\n\n    function renameStyle(agent, id, rendererID, oldName, newName, value) {\n      var _ref4;\n\n      var data = agent.getInstanceAndStyle({\n        id: id,\n        rendererID: rendererID\n      });\n\n      if (!data || !data.style) {\n        return;\n      }\n\n      var instance = data.instance,\n          style = data.style;\n      var newStyle = newName ? (_ref4 = {}, _defineProperty(_ref4, oldName, undefined), _defineProperty(_ref4, newName, value), _ref4) : _defineProperty({}, oldName, undefined);\n      var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n      if (instance !== null && typeof instance.setNativeProps === 'function') {\n        // In the case of a host component, we need to use setNativeProps().\n        // Remember to \"correct\" resolved styles when we read them next time.\n        var styleOverrides = componentIDToStyleOverrides.get(id);\n\n        if (!styleOverrides) {\n          componentIDToStyleOverrides.set(id, newStyle);\n        } else {\n          Object.assign(styleOverrides, newStyle);\n        } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n        instance.setNativeProps({\n          style: newStyle\n        });\n      } else if (Array.isArray(style)) {\n        var lastIndex = style.length - 1;\n\n        if (_typeof(style[lastIndex]) === 'object' && !Array.isArray(style[lastIndex])) {\n          customStyle = shallowClone(style[lastIndex]);\n          delete customStyle[oldName];\n\n          if (newName) {\n            customStyle[newName] = value;\n          } else {\n            customStyle[oldName] = undefined;\n          }\n\n          agent.overrideProps({\n            id: id,\n            rendererID: rendererID,\n            path: ['style', lastIndex],\n            value: customStyle\n          });\n        } else {\n          agent.overrideProps({\n            id: id,\n            rendererID: rendererID,\n            path: ['style'],\n            value: style.concat([newStyle])\n          });\n        }\n      } else if (_typeof(style) === 'object') {\n        customStyle = shallowClone(style);\n        delete customStyle[oldName];\n\n        if (newName) {\n          customStyle[newName] = value;\n        } else {\n          customStyle[oldName] = undefined;\n        }\n\n        agent.overrideProps({\n          id: id,\n          rendererID: rendererID,\n          path: ['style'],\n          value: customStyle\n        });\n      } else {\n        agent.overrideProps({\n          id: id,\n          rendererID: rendererID,\n          path: ['style'],\n          value: [style, newStyle]\n        });\n      }\n\n      agent.emit('hideNativeHighlight');\n    }\n\n    function setStyle(agent, id, rendererID, name, value) {\n      var data = agent.getInstanceAndStyle({\n        id: id,\n        rendererID: rendererID\n      });\n\n      if (!data || !data.style) {\n        return;\n      }\n\n      var instance = data.instance,\n          style = data.style;\n\n      var newStyle = _defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n\n      if (instance !== null && typeof instance.setNativeProps === 'function') {\n        // In the case of a host component, we need to use setNativeProps().\n        // Remember to \"correct\" resolved styles when we read them next time.\n        var styleOverrides = componentIDToStyleOverrides.get(id);\n\n        if (!styleOverrides) {\n          componentIDToStyleOverrides.set(id, newStyle);\n        } else {\n          Object.assign(styleOverrides, newStyle);\n        } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n        instance.setNativeProps({\n          style: newStyle\n        });\n      } else if (Array.isArray(style)) {\n        var lastLength = style.length - 1;\n\n        if (_typeof(style[lastLength]) === 'object' && !Array.isArray(style[lastLength])) {\n          agent.overrideProps({\n            id: id,\n            rendererID: rendererID,\n            path: ['style', lastLength, name],\n            value: value\n          });\n        } else {\n          agent.overrideProps({\n            id: id,\n            rendererID: rendererID,\n            path: ['style'],\n            value: style.concat([newStyle])\n          });\n        }\n      } else {\n        agent.overrideProps({\n          id: id,\n          rendererID: rendererID,\n          path: ['style'],\n          value: [style, newStyle]\n        });\n      }\n\n      agent.emit('hideNativeHighlight');\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/ReactSymbols.js\":\n  /*!************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/ReactSymbols.js ***!\n    \\************************************************************/\n\n  /*! exports provided: BLOCK_NUMBER, BLOCK_SYMBOL_STRING, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, CONTEXT_NUMBER, CONTEXT_SYMBOL_STRING, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, ELEMENT_NUMBER, ELEMENT_SYMBOL_STRING, DEBUG_TRACING_MODE_NUMBER, DEBUG_TRACING_MODE_SYMBOL_STRING, FORWARD_REF_NUMBER, FORWARD_REF_SYMBOL_STRING, FRAGMENT_NUMBER, FRAGMENT_SYMBOL_STRING, FUNDAMENTAL_NUMBER, FUNDAMENTAL_SYMBOL_STRING, LAZY_NUMBER, LAZY_SYMBOL_STRING, MEMO_NUMBER, MEMO_SYMBOL_STRING, OPAQUE_ID_NUMBER, OPAQUE_ID_SYMBOL_STRING, PORTAL_NUMBER, PORTAL_SYMBOL_STRING, PROFILER_NUMBER, PROFILER_SYMBOL_STRING, PROVIDER_NUMBER, PROVIDER_SYMBOL_STRING, RESPONDER_NUMBER, RESPONDER_SYMBOL_STRING, SCOPE_NUMBER, SCOPE_SYMBOL_STRING, SERVER_BLOCK_NUMBER, SERVER_BLOCK_SYMBOL_STRING, STRICT_MODE_NUMBER, STRICT_MODE_SYMBOL_STRING, SUSPENSE_NUMBER, SUSPENSE_SYMBOL_STRING, SUSPENSE_LIST_NUMBER, SUSPENSE_LIST_SYMBOL_STRING */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"BLOCK_NUMBER\", function () {\n      return BLOCK_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"BLOCK_SYMBOL_STRING\", function () {\n      return BLOCK_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"CONCURRENT_MODE_NUMBER\", function () {\n      return CONCURRENT_MODE_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"CONCURRENT_MODE_SYMBOL_STRING\", function () {\n      return CONCURRENT_MODE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"CONTEXT_NUMBER\", function () {\n      return CONTEXT_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"CONTEXT_SYMBOL_STRING\", function () {\n      return CONTEXT_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\", function () {\n      return DEPRECATED_ASYNC_MODE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ELEMENT_NUMBER\", function () {\n      return ELEMENT_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ELEMENT_SYMBOL_STRING\", function () {\n      return ELEMENT_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"DEBUG_TRACING_MODE_NUMBER\", function () {\n      return DEBUG_TRACING_MODE_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"DEBUG_TRACING_MODE_SYMBOL_STRING\", function () {\n      return DEBUG_TRACING_MODE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FORWARD_REF_NUMBER\", function () {\n      return FORWARD_REF_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FORWARD_REF_SYMBOL_STRING\", function () {\n      return FORWARD_REF_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FRAGMENT_NUMBER\", function () {\n      return FRAGMENT_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FRAGMENT_SYMBOL_STRING\", function () {\n      return FRAGMENT_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FUNDAMENTAL_NUMBER\", function () {\n      return FUNDAMENTAL_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FUNDAMENTAL_SYMBOL_STRING\", function () {\n      return FUNDAMENTAL_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LAZY_NUMBER\", function () {\n      return LAZY_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LAZY_SYMBOL_STRING\", function () {\n      return LAZY_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"MEMO_NUMBER\", function () {\n      return MEMO_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"MEMO_SYMBOL_STRING\", function () {\n      return MEMO_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"OPAQUE_ID_NUMBER\", function () {\n      return OPAQUE_ID_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"OPAQUE_ID_SYMBOL_STRING\", function () {\n      return OPAQUE_ID_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PORTAL_NUMBER\", function () {\n      return PORTAL_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PORTAL_SYMBOL_STRING\", function () {\n      return PORTAL_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PROFILER_NUMBER\", function () {\n      return PROFILER_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PROFILER_SYMBOL_STRING\", function () {\n      return PROFILER_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PROVIDER_NUMBER\", function () {\n      return PROVIDER_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PROVIDER_SYMBOL_STRING\", function () {\n      return PROVIDER_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"RESPONDER_NUMBER\", function () {\n      return RESPONDER_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"RESPONDER_SYMBOL_STRING\", function () {\n      return RESPONDER_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SCOPE_NUMBER\", function () {\n      return SCOPE_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SCOPE_SYMBOL_STRING\", function () {\n      return SCOPE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SERVER_BLOCK_NUMBER\", function () {\n      return SERVER_BLOCK_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SERVER_BLOCK_SYMBOL_STRING\", function () {\n      return SERVER_BLOCK_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"STRICT_MODE_NUMBER\", function () {\n      return STRICT_MODE_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"STRICT_MODE_SYMBOL_STRING\", function () {\n      return STRICT_MODE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SUSPENSE_NUMBER\", function () {\n      return SUSPENSE_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SUSPENSE_SYMBOL_STRING\", function () {\n      return SUSPENSE_SYMBOL_STRING;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SUSPENSE_LIST_NUMBER\", function () {\n      return SUSPENSE_LIST_NUMBER;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SUSPENSE_LIST_SYMBOL_STRING\", function () {\n      return SUSPENSE_LIST_SYMBOL_STRING;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // This list should be kept updated to reflect additions to 'shared/ReactSymbols'.\n    // DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:\n    // 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)\n    // 2. DevTools must support both Symbol and numeric forms of each symbol;\n    //    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.\n\n\n    var BLOCK_NUMBER = 0xead9;\n    var BLOCK_SYMBOL_STRING = 'Symbol(react.block)';\n    var CONCURRENT_MODE_NUMBER = 0xeacf;\n    var CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';\n    var CONTEXT_NUMBER = 0xeace;\n    var CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';\n    var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';\n    var ELEMENT_NUMBER = 0xeac7;\n    var ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';\n    var DEBUG_TRACING_MODE_NUMBER = 0xeae1;\n    var DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';\n    var FORWARD_REF_NUMBER = 0xead0;\n    var FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';\n    var FRAGMENT_NUMBER = 0xeacb;\n    var FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';\n    var FUNDAMENTAL_NUMBER = 0xead5;\n    var FUNDAMENTAL_SYMBOL_STRING = 'Symbol(react.fundamental)';\n    var LAZY_NUMBER = 0xead4;\n    var LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';\n    var MEMO_NUMBER = 0xead3;\n    var MEMO_SYMBOL_STRING = 'Symbol(react.memo)';\n    var OPAQUE_ID_NUMBER = 0xeae0;\n    var OPAQUE_ID_SYMBOL_STRING = 'Symbol(react.opaque.id)';\n    var PORTAL_NUMBER = 0xeaca;\n    var PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';\n    var PROFILER_NUMBER = 0xead2;\n    var PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';\n    var PROVIDER_NUMBER = 0xeacd;\n    var PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';\n    var RESPONDER_NUMBER = 0xead6;\n    var RESPONDER_SYMBOL_STRING = 'Symbol(react.responder)';\n    var SCOPE_NUMBER = 0xead7;\n    var SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';\n    var SERVER_BLOCK_NUMBER = 0xeada;\n    var SERVER_BLOCK_SYMBOL_STRING = 'Symbol(react.server.block)';\n    var STRICT_MODE_NUMBER = 0xeacc;\n    var STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';\n    var SUSPENSE_NUMBER = 0xead1;\n    var SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';\n    var SUSPENSE_LIST_NUMBER = 0xead8;\n    var SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';\n    /***/\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/agent.js\":\n  /*!*****************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/agent.js ***!\n    \\*****************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return Agent;\n    });\n    /* harmony import */\n\n\n    var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ../events */\n    \"../react-devtools-shared/src/events.js\");\n    /* harmony import */\n\n\n    var lodash_throttle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! lodash.throttle */\n    \"../../node_modules/lodash.throttle/index.js\");\n    /* harmony import */\n\n\n    var lodash_throttle__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_1__);\n    /* harmony import */\n\n\n    var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! ../constants */\n    \"../react-devtools-shared/src/constants.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! react-devtools-shared/src/storage */\n    \"../react-devtools-shared/src/storage.js\");\n    /* harmony import */\n\n\n    var _views_Highlighter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! ./views/Highlighter */\n    \"../react-devtools-shared/src/backend/views/Highlighter/index.js\");\n    /* harmony import */\n\n\n    var _views_TraceUpdates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\n    /*! ./views/TraceUpdates */\n    \"../react-devtools-shared/src/backend/views/TraceUpdates/index.js\");\n    /* harmony import */\n\n\n    var _console__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\n    /*! ./console */\n    \"../react-devtools-shared/src/backend/console.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      }\n\n      return _assertThisInitialized(self);\n    }\n\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n\n    function _assertThisInitialized(self) {\n      if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return self;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n      return _setPrototypeOf(o, p);\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var debug = function debug(methodName) {\n      if (_constants__WEBPACK_IMPORTED_MODULE_2__[\"__DEBUG__\"]) {\n        var _console;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        (_console = console).log.apply(_console, [\"%cAgent %c\".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));\n      }\n    };\n\n    var Agent = /*#__PURE__*/function (_EventEmitter) {\n      _inherits(Agent, _EventEmitter);\n\n      function Agent(bridge) {\n        var _this;\n\n        _classCallCheck(this, Agent);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Agent).call(this));\n\n        _defineProperty(_assertThisInitialized(_this), \"_isProfiling\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"_recordChangeDescriptions\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"_rendererInterfaces\", {});\n\n        _defineProperty(_assertThisInitialized(_this), \"_persistedSelection\", null);\n\n        _defineProperty(_assertThisInitialized(_this), \"_persistedSelectionMatch\", null);\n\n        _defineProperty(_assertThisInitialized(_this), \"_traceUpdatesEnabled\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"copyElementPath\", function (_ref) {\n          var id = _ref.id,\n              path = _ref.path,\n              rendererID = _ref.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.copyElementPath(id, path);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"getProfilingData\", function (_ref2) {\n          var rendererID = _ref2.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n          }\n\n          _this._bridge.send('profilingData', renderer.getProfilingData());\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"getProfilingStatus\", function () {\n          _this._bridge.send('profilingStatus', _this._isProfiling);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"getOwnersList\", function (_ref3) {\n          var id = _ref3.id,\n              rendererID = _ref3.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            var owners = renderer.getOwnersList(id);\n\n            _this._bridge.send('ownersList', {\n              id: id,\n              owners: owners\n            });\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"inspectElement\", function (_ref4) {\n          var id = _ref4.id,\n              path = _ref4.path,\n              rendererID = _ref4.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            _this._bridge.send('inspectedElement', renderer.inspectElement(id, path)); // When user selects an element, stop trying to restore the selection,\n            // and instead remember the current selection for the next reload.\n\n\n            if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {\n              _this._persistedSelection = null;\n              _this._persistedSelectionMatch = null;\n              renderer.setTrackedPath(null);\n\n              _this._throttledPersistSelection(rendererID, id);\n            } // TODO: If there was a way to change the selected DOM element\n            // in native Elements tab without forcing a switch to it, we'd do it here.\n            // For now, it doesn't seem like there is a way to do that:\n            // https://github.com/bvaughn/react-devtools-experimental/issues/102\n            // (Setting $0 doesn't work, and calling inspect() switches the tab.)\n\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"logElementToConsole\", function (_ref5) {\n          var id = _ref5.id,\n              rendererID = _ref5.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.logElementToConsole(id);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"reloadAndProfile\", function (recordChangeDescriptions) {\n          Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\"], 'true');\n          Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\"], recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.\n          // In that case, the shell must also listen for this specific message to know when it needs to reload the app.\n          // The agent can't do this in a way that is renderer agnostic.\n\n          _this._bridge.send('reloadAppForProfiling');\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"overrideContext\", function (_ref6) {\n          var id = _ref6.id,\n              path = _ref6.path,\n              rendererID = _ref6.rendererID,\n              value = _ref6.value;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.setInContext(id, path, value);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"overrideHookState\", function (_ref7) {\n          var id = _ref7.id,\n              hookID = _ref7.hookID,\n              path = _ref7.path,\n              rendererID = _ref7.rendererID,\n              value = _ref7.value;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.setInHook(id, hookID, path, value);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"overrideProps\", function (_ref8) {\n          var id = _ref8.id,\n              path = _ref8.path,\n              rendererID = _ref8.rendererID,\n              value = _ref8.value;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.setInProps(id, path, value);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"overrideState\", function (_ref9) {\n          var id = _ref9.id,\n              path = _ref9.path,\n              rendererID = _ref9.rendererID,\n              value = _ref9.value;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.setInState(id, path, value);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"overrideSuspense\", function (_ref10) {\n          var id = _ref10.id,\n              rendererID = _ref10.rendererID,\n              forceFallback = _ref10.forceFallback;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.overrideSuspense(id, forceFallback);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"setTraceUpdatesEnabled\", function (traceUpdatesEnabled) {\n          _this._traceUpdatesEnabled = traceUpdatesEnabled;\n          Object(_views_TraceUpdates__WEBPACK_IMPORTED_MODULE_5__[\"toggleEnabled\"])(traceUpdatesEnabled);\n\n          for (var rendererID in _this._rendererInterfaces) {\n            var renderer = _this._rendererInterfaces[rendererID];\n            renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"syncSelectionFromNativeElementsPanel\", function () {\n          var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;\n\n          if (target == null) {\n            return;\n          }\n\n          _this.selectNode(target);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"shutdown\", function () {\n          // Clean up the overlay if visible, and associated events.\n          _this.emit('shutdown');\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"startProfiling\", function (recordChangeDescriptions) {\n          _this._recordChangeDescriptions = recordChangeDescriptions;\n          _this._isProfiling = true;\n\n          for (var rendererID in _this._rendererInterfaces) {\n            var renderer = _this._rendererInterfaces[rendererID];\n            renderer.startProfiling(recordChangeDescriptions);\n          }\n\n          _this._bridge.send('profilingStatus', _this._isProfiling);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"stopProfiling\", function () {\n          _this._isProfiling = false;\n          _this._recordChangeDescriptions = false;\n\n          for (var rendererID in _this._rendererInterfaces) {\n            var renderer = _this._rendererInterfaces[rendererID];\n            renderer.stopProfiling();\n          }\n\n          _this._bridge.send('profilingStatus', _this._isProfiling);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"storeAsGlobal\", function (_ref11) {\n          var count = _ref11.count,\n              id = _ref11.id,\n              path = _ref11.path,\n              rendererID = _ref11.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.storeAsGlobal(id, path, count);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"updateConsolePatchSettings\", function (_ref12) {\n          var appendComponentStack = _ref12.appendComponentStack,\n              breakOnConsoleErrors = _ref12.breakOnConsoleErrors; // If the frontend preference has change,\n          // or in the case of React Native- if the backend is just finding out the preference-\n          // then install or uninstall the console overrides.\n          // It's safe to call these methods multiple times, so we don't need to worry about that.\n\n          if (appendComponentStack || breakOnConsoleErrors) {\n            Object(_console__WEBPACK_IMPORTED_MODULE_6__[\"patch\"])({\n              appendComponentStack: appendComponentStack,\n              breakOnConsoleErrors: breakOnConsoleErrors\n            });\n          } else {\n            Object(_console__WEBPACK_IMPORTED_MODULE_6__[\"unpatch\"])();\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"updateComponentFilters\", function (componentFilters) {\n          for (var rendererID in _this._rendererInterfaces) {\n            var renderer = _this._rendererInterfaces[rendererID];\n            renderer.updateComponentFilters(componentFilters);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"viewAttributeSource\", function (_ref13) {\n          var id = _ref13.id,\n              path = _ref13.path,\n              rendererID = _ref13.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.prepareViewAttributeSource(id, path);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"viewElementSource\", function (_ref14) {\n          var id = _ref14.id,\n              rendererID = _ref14.rendererID;\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n          } else {\n            renderer.prepareViewElementSource(id);\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"onTraceUpdates\", function (nodes) {\n          _this.emit('traceUpdates', nodes);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"onHookOperations\", function (operations) {\n          if (_constants__WEBPACK_IMPORTED_MODULE_2__[\"__DEBUG__\"]) {\n            debug('onHookOperations', operations);\n          } // TODO:\n          // The chrome.runtime does not currently support transferables; it forces JSON serialization.\n          // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134\n          //\n          // Regarding transferables, the postMessage doc states:\n          // If the ownership of an object is transferred, it becomes unusable (neutered)\n          // in the context it was sent from and becomes available only to the worker it was sent to.\n          //\n          // Even though Chrome is eventually JSON serializing the array buffer,\n          // using the transferable approach also sometimes causes it to throw:\n          //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.\n          //\n          // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25\n          //\n          // The Store has a fallback in place that parses the message as JSON if the type isn't an array.\n          // For now the simplest fix seems to be to not transfer the array.\n          // This will negatively impact performance on Firefox so it's unfortunate,\n          // but until we're able to fix the Chrome error mentioned above, it seems necessary.\n          //\n          // this._bridge.send('operations', operations, [operations.buffer]);\n\n\n          _this._bridge.send('operations', operations);\n\n          if (_this._persistedSelection !== null) {\n            var rendererID = operations[0];\n\n            if (_this._persistedSelection.rendererID === rendererID) {\n              // Check if we can select a deeper match for the persisted selection.\n              var renderer = _this._rendererInterfaces[rendererID];\n\n              if (renderer == null) {\n                console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n              } else {\n                var prevMatch = _this._persistedSelectionMatch;\n                var nextMatch = renderer.getBestMatchForTrackedPath();\n                _this._persistedSelectionMatch = nextMatch;\n                var prevMatchID = prevMatch !== null ? prevMatch.id : null;\n                var nextMatchID = nextMatch !== null ? nextMatch.id : null;\n\n                if (prevMatchID !== nextMatchID) {\n                  if (nextMatchID !== null) {\n                    // We moved forward, unlocking a deeper node.\n                    _this._bridge.send('selectFiber', nextMatchID);\n                  }\n                }\n\n                if (nextMatch !== null && nextMatch.isFullMatch) {\n                  // We've just unlocked the innermost selected node.\n                  // There's no point tracking it further.\n                  _this._persistedSelection = null;\n                  _this._persistedSelectionMatch = null;\n                  renderer.setTrackedPath(null);\n                }\n              }\n            }\n          }\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"_throttledPersistSelection\", lodash_throttle__WEBPACK_IMPORTED_MODULE_1___default()(function (rendererID, id) {\n          // This is throttled, so both renderer and selected ID\n          // might not be available by the time we read them.\n          // This is why we need the defensive checks here.\n          var renderer = _this._rendererInterfaces[rendererID];\n          var path = renderer != null ? renderer.getPathForElement(id) : null;\n\n          if (path !== null) {\n            Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_LAST_SELECTION_KEY\"], JSON.stringify({\n              rendererID: rendererID,\n              path: path\n            }));\n          } else {\n            Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageRemoveItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_LAST_SELECTION_KEY\"]);\n          }\n        }, 1000));\n\n        if (Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\"]) === 'true') {\n          _this._recordChangeDescriptions = Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\"]) === 'true';\n          _this._isProfiling = true;\n          Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageRemoveItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\"]);\n          Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageRemoveItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\"]);\n        }\n\n        var persistedSelectionString = Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"SESSION_STORAGE_LAST_SELECTION_KEY\"]);\n\n        if (persistedSelectionString != null) {\n          _this._persistedSelection = JSON.parse(persistedSelectionString);\n        }\n\n        _this._bridge = bridge;\n        bridge.addListener('copyElementPath', _this.copyElementPath);\n        bridge.addListener('getProfilingData', _this.getProfilingData);\n        bridge.addListener('getProfilingStatus', _this.getProfilingStatus);\n        bridge.addListener('getOwnersList', _this.getOwnersList);\n        bridge.addListener('inspectElement', _this.inspectElement);\n        bridge.addListener('logElementToConsole', _this.logElementToConsole);\n        bridge.addListener('overrideContext', _this.overrideContext);\n        bridge.addListener('overrideHookState', _this.overrideHookState);\n        bridge.addListener('overrideProps', _this.overrideProps);\n        bridge.addListener('overrideState', _this.overrideState);\n        bridge.addListener('overrideSuspense', _this.overrideSuspense);\n        bridge.addListener('reloadAndProfile', _this.reloadAndProfile);\n        bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);\n        bridge.addListener('startProfiling', _this.startProfiling);\n        bridge.addListener('stopProfiling', _this.stopProfiling);\n        bridge.addListener('storeAsGlobal', _this.storeAsGlobal);\n        bridge.addListener('syncSelectionFromNativeElementsPanel', _this.syncSelectionFromNativeElementsPanel);\n        bridge.addListener('shutdown', _this.shutdown);\n        bridge.addListener('updateConsolePatchSettings', _this.updateConsolePatchSettings);\n        bridge.addListener('updateComponentFilters', _this.updateComponentFilters);\n        bridge.addListener('viewAttributeSource', _this.viewAttributeSource);\n        bridge.addListener('viewElementSource', _this.viewElementSource);\n\n        if (_this._isProfiling) {\n          bridge.send('profilingStatus', true);\n        } // Notify the frontend if the backend supports the Storage API (e.g. localStorage).\n        // If not, features like reload-and-profile will not work correctly and must be disabled.\n\n\n        var isBackendStorageAPISupported = false;\n\n        try {\n          localStorage.getItem('test');\n          isBackendStorageAPISupported = true;\n        } catch (error) {}\n\n        bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);\n        Object(_views_Highlighter__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(bridge, _assertThisInitialized(_this));\n        Object(_views_TraceUpdates__WEBPACK_IMPORTED_MODULE_5__[\"initialize\"])(_assertThisInitialized(_this));\n        return _this;\n      }\n\n      _createClass(Agent, [{\n        key: \"getInstanceAndStyle\",\n        value: function getInstanceAndStyle(_ref15) {\n          var id = _ref15.id,\n              rendererID = _ref15.rendererID;\n          var renderer = this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n            return null;\n          }\n\n          return renderer.getInstanceAndStyle(id);\n        }\n      }, {\n        key: \"getIDForNode\",\n        value: function getIDForNode(node) {\n          for (var rendererID in this._rendererInterfaces) {\n            var renderer = this._rendererInterfaces[rendererID];\n\n            try {\n              var id = renderer.getFiberIDForNative(node, true);\n\n              if (id !== null) {\n                return id;\n              }\n            } catch (error) {// Some old React versions might throw if they can't find a match.\n              // If so we should ignore it...\n            }\n          }\n\n          return null;\n        }\n      }, {\n        key: \"selectNode\",\n        value: function selectNode(target) {\n          var id = this.getIDForNode(target);\n\n          if (id !== null) {\n            this._bridge.send('selectFiber', id);\n          }\n        }\n      }, {\n        key: \"setRendererInterface\",\n        value: function setRendererInterface(rendererID, rendererInterface) {\n          this._rendererInterfaces[rendererID] = rendererInterface;\n\n          if (this._isProfiling) {\n            rendererInterface.startProfiling(this._recordChangeDescriptions);\n          }\n\n          rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether\n          // we remember the previous selection that we'd like to restore.\n          // It'll start tracking mounts for matches to the last selection path.\n\n          var selection = this._persistedSelection;\n\n          if (selection !== null && selection.rendererID === rendererID) {\n            rendererInterface.setTrackedPath(selection.path);\n          }\n        }\n      }, {\n        key: \"onUnsupportedRenderer\",\n        value: function onUnsupportedRenderer(rendererID) {\n          this._bridge.send('unsupportedRendererVersion', rendererID);\n        }\n      }, {\n        key: \"rendererInterfaces\",\n        get: function get() {\n          return this._rendererInterfaces;\n        }\n      }]);\n\n      return Agent;\n    }(_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/console.js\":\n  /*!*******************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/console.js ***!\n    \\*******************************************************/\n\n  /*! exports provided: dangerous_setTargetConsoleForTesting, registerRenderer, patch, unpatch */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"dangerous_setTargetConsoleForTesting\", function () {\n      return dangerous_setTargetConsoleForTesting;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"registerRenderer\", function () {\n      return registerRenderer;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"patch\", function () {\n      return patch;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"unpatch\", function () {\n      return unpatch;\n    });\n    /* harmony import */\n\n\n    var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./renderer */\n    \"../react-devtools-shared/src/backend/renderer.js\");\n    /* harmony import */\n\n\n    var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ./DevToolsFiberComponentStack */\n    \"../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\");\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var APPEND_STACK_TO_METHODS = ['error', 'trace', 'warn']; // React's custom built component stack strings match \"\\s{4}in\"\n    // Chrome's prefix matches \"\\s{4}at\"\n\n    var PREFIX_REGEX = /\\s{4}(in|at)\\s{1}/; // Firefox and Safari have no prefix (\"\")\n    // but we can fallback to looking for location info (e.g. \"foo.js:12:345\")\n\n    var ROW_COLUMN_NUMBER_REGEX = /:\\d+:\\d+(\\n|$)/;\n    var injectedRenderers = new Map();\n    var targetConsole = console;\n    var targetConsoleMethods = {};\n\n    for (var method in console) {\n      targetConsoleMethods[method] = console[method];\n    }\n\n    var unpatchFn = null; // Enables e.g. Jest tests to inject a mock console object.\n\n    function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n      targetConsole = targetConsoleForTesting;\n      targetConsoleMethods = {};\n\n      for (var _method in targetConsole) {\n        targetConsoleMethods[_method] = console[_method];\n      }\n    } // v16 renderers should use this method to inject internals necessary to generate a component stack.\n    // These internals will be used if the console is patched.\n    // Injecting them separately allows the console to easily be patched or un-patched later (at runtime).\n\n\n    function registerRenderer(renderer) {\n      var currentDispatcherRef = renderer.currentDispatcherRef,\n          getCurrentFiber = renderer.getCurrentFiber,\n          findFiberByHostInstance = renderer.findFiberByHostInstance,\n          version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.\n\n      if (typeof findFiberByHostInstance !== 'function') {\n        return;\n      } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.\n      // getCurrentFiber gets injected for v16.9+.\n\n\n      if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {\n        var _getInternalReactCons = Object(_renderer__WEBPACK_IMPORTED_MODULE_0__[\"getInternalReactConstants\"])(version),\n            ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;\n\n        injectedRenderers.set(renderer, {\n          currentDispatcherRef: currentDispatcherRef,\n          getCurrentFiber: getCurrentFiber,\n          workTagMap: ReactTypeOfWork\n        });\n      }\n    }\n\n    var consoleSettingsRef = {\n      appendComponentStack: false,\n      breakOnConsoleErrors: false\n    }; // Patches console methods to append component stack for the current fiber.\n    // Call unpatch() to remove the injected behavior.\n\n    function patch(_ref) {\n      var appendComponentStack = _ref.appendComponentStack,\n          breakOnConsoleErrors = _ref.breakOnConsoleErrors; // Settings may change after we've patched the console.\n      // Using a shared ref allows the patch function to read the latest values.\n\n      consoleSettingsRef.appendComponentStack = appendComponentStack;\n      consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;\n\n      if (unpatchFn !== null) {\n        // Don't patch twice.\n        return;\n      }\n\n      var originalConsoleMethods = {};\n\n      unpatchFn = function unpatchFn() {\n        for (var _method2 in originalConsoleMethods) {\n          try {\n            // $FlowFixMe property error|warn is not writable.\n            targetConsole[_method2] = originalConsoleMethods[_method2];\n          } catch (error) {}\n        }\n      };\n\n      APPEND_STACK_TO_METHODS.forEach(function (method) {\n        try {\n          var originalMethod = originalConsoleMethods[method] = targetConsole[method];\n\n          var overrideMethod = function overrideMethod() {\n            var latestAppendComponentStack = consoleSettingsRef.appendComponentStack;\n            var latestBreakOnConsoleErrors = consoleSettingsRef.breakOnConsoleErrors;\n\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            if (latestAppendComponentStack) {\n              try {\n                // If we are ever called with a string that already has a component stack, e.g. a React error/warning,\n                // don't append a second stack.\n                var lastArg = args.length > 0 ? args[args.length - 1] : null;\n                var alreadyHasComponentStack = lastArg !== null && (PREFIX_REGEX.test(lastArg) || ROW_COLUMN_NUMBER_REGEX.test(lastArg));\n\n                if (!alreadyHasComponentStack) {\n                  // If there's a component stack for at least one of the injected renderers, append it.\n                  // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)\n                  // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n                  var _iteratorNormalCompletion = true;\n                  var _didIteratorError = false;\n                  var _iteratorError = undefined;\n\n                  try {\n                    for (var _iterator = injectedRenderers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var _step$value = _step.value,\n                          currentDispatcherRef = _step$value.currentDispatcherRef,\n                          getCurrentFiber = _step$value.getCurrentFiber,\n                          workTagMap = _step$value.workTagMap;\n                      var current = getCurrentFiber();\n\n                      if (current != null) {\n                        var componentStack = Object(_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_1__[\"getStackByFiberInDevAndProd\"])(workTagMap, current, currentDispatcherRef);\n\n                        if (componentStack !== '') {\n                          args.push(componentStack);\n                        }\n\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                      }\n                    } finally {\n                      if (_didIteratorError) {\n                        throw _iteratorError;\n                      }\n                    }\n                  }\n                }\n              } catch (error) {// Don't let a DevTools or React internal error interfere with logging.\n              }\n            }\n\n            if (latestBreakOnConsoleErrors) {\n              // --- Welcome to debugging with React DevTools ---\n              // This debugger statement means that you've enabled the \"break on warnings\" feature.\n              // Use the browser's Call Stack panel to step out of this override function-\n              // to where the original warning or error was logged.\n              // eslint-disable-next-line no-debugger\n              debugger;\n            }\n\n            originalMethod.apply(void 0, args);\n          };\n\n          overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod; // $FlowFixMe property error|warn is not writable.\n\n          targetConsole[method] = overrideMethod;\n        } catch (error) {}\n      });\n    } // Removed component stack patch from console methods.\n\n\n    function unpatch() {\n      if (unpatchFn !== null) {\n        unpatchFn();\n        unpatchFn = null;\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/index.js\":\n  /*!*****************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/index.js ***!\n    \\*****************************************************/\n\n  /*! exports provided: initBackend */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"initBackend\", function () {\n      return initBackend;\n    });\n    /* harmony import */\n\n\n    var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./agent */\n    \"../react-devtools-shared/src/backend/agent.js\");\n    /* harmony import */\n\n\n    var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ./renderer */\n    \"../react-devtools-shared/src/backend/renderer.js\");\n    /* harmony import */\n\n\n    var _legacy_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! ./legacy/renderer */\n    \"../react-devtools-shared/src/backend/legacy/renderer.js\");\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function initBackend(hook, agent, global) {\n      if (hook == null) {\n        // DevTools didn't get injected into this page (maybe b'c of the contentType).\n        return function () {};\n      }\n\n      var subs = [hook.sub('renderer-attached', function (_ref) {\n        var id = _ref.id,\n            renderer = _ref.renderer,\n            rendererInterface = _ref.rendererInterface;\n        agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,\n        // it's time to flush the pending operation codes to the frontend.\n\n        rendererInterface.flushInitialOperations();\n      }), hook.sub('unsupported-renderer-version', function (id) {\n        agent.onUnsupportedRenderer(id);\n      }), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode\n      ];\n\n      var attachRenderer = function attachRenderer(id, renderer) {\n        var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)\n\n        if (rendererInterface == null) {\n          if (typeof renderer.findFiberByHostInstance === 'function') {\n            // react-reconciler v16+\n            rendererInterface = Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[\"attach\"])(hook, id, renderer, global);\n          } else if (renderer.ComponentTree) {\n            // react-dom v15\n            rendererInterface = Object(_legacy_renderer__WEBPACK_IMPORTED_MODULE_2__[\"attach\"])(hook, id, renderer, global);\n          } else {// Older react-dom or other unsupported renderer version\n          }\n\n          if (rendererInterface != null) {\n            hook.rendererInterfaces.set(id, rendererInterface);\n          }\n        } // Notify the DevTools frontend about new renderers.\n        // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).\n\n\n        if (rendererInterface != null) {\n          hook.emit('renderer-attached', {\n            id: id,\n            renderer: renderer,\n            rendererInterface: rendererInterface\n          });\n        } else {\n          hook.emit('unsupported-renderer-version', id);\n        }\n      }; // Connect renderers that have already injected themselves.\n\n\n      hook.renderers.forEach(function (renderer, id) {\n        attachRenderer(id, renderer);\n      }); // Connect any new renderers that injected themselves.\n\n      subs.push(hook.sub('renderer', function (_ref2) {\n        var id = _ref2.id,\n            renderer = _ref2.renderer;\n        attachRenderer(id, renderer);\n      }));\n      hook.emit('react-devtools', agent);\n      hook.reactDevtoolsAgent = agent;\n\n      var onAgentShutdown = function onAgentShutdown() {\n        subs.forEach(function (fn) {\n          return fn();\n        });\n        hook.rendererInterfaces.forEach(function (rendererInterface) {\n          rendererInterface.cleanup();\n        });\n        hook.reactDevtoolsAgent = null;\n      };\n\n      agent.addListener('shutdown', onAgentShutdown);\n      subs.push(function () {\n        agent.removeListener('shutdown', onAgentShutdown);\n      });\n      return function () {\n        subs.forEach(function (fn) {\n          return fn();\n        });\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/legacy/renderer.js\":\n  /*!***************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/legacy/renderer.js ***!\n    \\***************************************************************/\n\n  /*! exports provided: attach */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"attach\", function () {\n      return attach;\n    });\n    /* harmony import */\n\n\n    var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react-devtools-shared/src/types */\n    \"../react-devtools-shared/src/types.js\");\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ../../utils */\n    \"../react-devtools-shared/src/utils.js\");\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! ../utils */\n    \"../react-devtools-shared/src/backend/utils.js\");\n    /* harmony import */\n\n\n    var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! ../../constants */\n    \"../react-devtools-shared/src/constants.js\");\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! ./utils */\n    \"../react-devtools-shared/src/backend/legacy/utils.js\");\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n      }\n\n      return keys;\n    }\n\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function (key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n\n      return target;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function getData(internalInstance) {\n      var displayName = null;\n      var key = null; // != used deliberately here to catch undefined and null\n\n      if (internalInstance._currentElement != null) {\n        if (internalInstance._currentElement.key) {\n          key = '' + internalInstance._currentElement.key;\n        }\n\n        var elementType = internalInstance._currentElement.type;\n\n        if (typeof elementType === 'string') {\n          displayName = elementType;\n        } else if (typeof elementType === 'function') {\n          displayName = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getDisplayName\"])(elementType);\n        }\n      }\n\n      return {\n        displayName: displayName,\n        key: key\n      };\n    }\n\n    function getElementType(internalInstance) {\n      // != used deliberately here to catch undefined and null\n      if (internalInstance._currentElement != null) {\n        var elementType = internalInstance._currentElement.type;\n\n        if (typeof elementType === 'function') {\n          var publicInstance = internalInstance.getPublicInstance();\n\n          if (publicInstance !== null) {\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeClass\"];\n          } else {\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeFunction\"];\n          }\n        } else if (typeof elementType === 'string') {\n          return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeHostComponent\"];\n        }\n      }\n\n      return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"];\n    }\n\n    function getChildren(internalInstance) {\n      var children = []; // If the parent is a native node without rendered children, but with\n      // multiple string children, then the `element` that gets passed in here is\n      // a plain value -- a string or number.\n\n      if (_typeof(internalInstance) !== 'object') {// No children\n      } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children\n      } else if (internalInstance._renderedComponent) {\n        var child = internalInstance._renderedComponent;\n\n        if (getElementType(child) !== react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n          children.push(child);\n        }\n      } else if (internalInstance._renderedChildren) {\n        var renderedChildren = internalInstance._renderedChildren;\n\n        for (var name in renderedChildren) {\n          var _child = renderedChildren[name];\n\n          if (getElementType(_child) !== react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n            children.push(_child);\n          }\n        }\n      } // Note: we skip the case where children are just strings or numbers\n      // because the new DevTools skips over host text nodes anyway.\n\n\n      return children;\n    }\n\n    function attach(hook, rendererID, renderer, global) {\n      var idToInternalInstanceMap = new Map();\n      var internalInstanceToIDMap = new WeakMap();\n      var internalInstanceToRootIDMap = new WeakMap();\n      var getInternalIDForNative = null;\n      var findNativeNodeForInternalID;\n\n      if (renderer.ComponentTree) {\n        getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {\n          var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);\n          return internalInstanceToIDMap.get(internalInstance) || null;\n        };\n\n        findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {\n          var internalInstance = idToInternalInstanceMap.get(id);\n          return renderer.ComponentTree.getNodeFromInstance(internalInstance);\n        };\n      } else if (renderer.Mount.getID && renderer.Mount.getNode) {\n        getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {\n          // Not implemented.\n          return null;\n        };\n\n        findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {\n          // Not implemented.\n          return null;\n        };\n      }\n\n      function getDisplayNameForFiberID(id) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n        return internalInstance ? getData(internalInstance).displayName : null;\n      }\n\n      function getID(internalInstance) {\n        if (_typeof(internalInstance) !== 'object' || internalInstance === null) {\n          throw new Error('Invalid internal instance: ' + internalInstance);\n        }\n\n        if (!internalInstanceToIDMap.has(internalInstance)) {\n          var _id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getUID\"])();\n\n          internalInstanceToIDMap.set(internalInstance, _id);\n          idToInternalInstanceMap.set(_id, internalInstance);\n        }\n\n        return internalInstanceToIDMap.get(internalInstance);\n      }\n\n      function areEqualArrays(a, b) {\n        if (a.length !== b.length) {\n          return false;\n        }\n\n        for (var i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) {\n            return false;\n          }\n        }\n\n        return true;\n      } // This is shared mutable state that lets us keep track of where we are.\n\n\n      var parentIDStack = [];\n      var oldReconcilerMethods = null;\n\n      if (renderer.Reconciler) {\n        // React 15\n        oldReconcilerMethods = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"decorateMany\"])(renderer.Reconciler, {\n          mountComponent: function mountComponent(fn, args) {\n            var internalInstance = args[0];\n            var hostContainerInfo = args[3];\n\n            if (getElementType(internalInstance) === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n              return fn.apply(this, args);\n            }\n\n            if (hostContainerInfo._topLevelWrapper === undefined) {\n              // SSR\n              return fn.apply(this, args);\n            }\n\n            var id = getID(internalInstance); // Push the operation.\n\n            var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;\n            recordMount(internalInstance, id, parentID);\n            parentIDStack.push(id); // Remember the root.\n\n            internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));\n\n            try {\n              var result = fn.apply(this, args);\n              parentIDStack.pop();\n              return result;\n            } catch (err) {\n              parentIDStack = [];\n              throw err;\n            } finally {\n              if (parentIDStack.length === 0) {\n                var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n                if (rootID === undefined) {\n                  throw new Error('Expected to find root ID.');\n                }\n\n                flushPendingEvents(rootID);\n              }\n            }\n          },\n          performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {\n            var internalInstance = args[0];\n\n            if (getElementType(internalInstance) === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n              return fn.apply(this, args);\n            }\n\n            var id = getID(internalInstance);\n            parentIDStack.push(id);\n            var prevChildren = getChildren(internalInstance);\n\n            try {\n              var result = fn.apply(this, args);\n              var nextChildren = getChildren(internalInstance);\n\n              if (!areEqualArrays(prevChildren, nextChildren)) {\n                // Push the operation\n                recordReorder(internalInstance, id, nextChildren);\n              }\n\n              parentIDStack.pop();\n              return result;\n            } catch (err) {\n              parentIDStack = [];\n              throw err;\n            } finally {\n              if (parentIDStack.length === 0) {\n                var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n                if (rootID === undefined) {\n                  throw new Error('Expected to find root ID.');\n                }\n\n                flushPendingEvents(rootID);\n              }\n            }\n          },\n          receiveComponent: function receiveComponent(fn, args) {\n            var internalInstance = args[0];\n\n            if (getElementType(internalInstance) === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n              return fn.apply(this, args);\n            }\n\n            var id = getID(internalInstance);\n            parentIDStack.push(id);\n            var prevChildren = getChildren(internalInstance);\n\n            try {\n              var result = fn.apply(this, args);\n              var nextChildren = getChildren(internalInstance);\n\n              if (!areEqualArrays(prevChildren, nextChildren)) {\n                // Push the operation\n                recordReorder(internalInstance, id, nextChildren);\n              }\n\n              parentIDStack.pop();\n              return result;\n            } catch (err) {\n              parentIDStack = [];\n              throw err;\n            } finally {\n              if (parentIDStack.length === 0) {\n                var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n                if (rootID === undefined) {\n                  throw new Error('Expected to find root ID.');\n                }\n\n                flushPendingEvents(rootID);\n              }\n            }\n          },\n          unmountComponent: function unmountComponent(fn, args) {\n            var internalInstance = args[0];\n\n            if (getElementType(internalInstance) === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeOtherOrUnknown\"]) {\n              return fn.apply(this, args);\n            }\n\n            var id = getID(internalInstance);\n            parentIDStack.push(id);\n\n            try {\n              var result = fn.apply(this, args);\n              parentIDStack.pop(); // Push the operation.\n\n              recordUnmount(internalInstance, id);\n              return result;\n            } catch (err) {\n              parentIDStack = [];\n              throw err;\n            } finally {\n              if (parentIDStack.length === 0) {\n                var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n                if (rootID === undefined) {\n                  throw new Error('Expected to find root ID.');\n                }\n\n                flushPendingEvents(rootID);\n              }\n            }\n          }\n        });\n      }\n\n      function cleanup() {\n        if (oldReconcilerMethods !== null) {\n          if (renderer.Component) {\n            Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"restoreMany\"])(renderer.Component.Mixin, oldReconcilerMethods);\n          } else {\n            Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"restoreMany\"])(renderer.Reconciler, oldReconcilerMethods);\n          }\n        }\n\n        oldReconcilerMethods = null;\n      }\n\n      function recordMount(internalInstance, id, parentID) {\n        var isRoot = parentID === 0;\n\n        if (_constants__WEBPACK_IMPORTED_MODULE_3__[\"__DEBUG__\"]) {\n          console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);\n        }\n\n        if (isRoot) {\n          // TODO Is this right? For all versions?\n          var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;\n          pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_ADD\"]);\n          pushOperation(id);\n          pushOperation(react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeRoot\"]);\n          pushOperation(0); // isProfilingSupported?\n\n          pushOperation(hasOwnerMetadata ? 1 : 0);\n        } else {\n          var type = getElementType(internalInstance);\n\n          var _getData = getData(internalInstance),\n              displayName = _getData.displayName,\n              key = _getData.key;\n\n          var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;\n          var displayNameStringID = getStringID(displayName);\n          var keyStringID = getStringID(key);\n          pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_ADD\"]);\n          pushOperation(id);\n          pushOperation(type);\n          pushOperation(parentID);\n          pushOperation(ownerID);\n          pushOperation(displayNameStringID);\n          pushOperation(keyStringID);\n        }\n      }\n\n      function recordReorder(internalInstance, id, nextChildren) {\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_REORDER_CHILDREN\"]);\n        pushOperation(id);\n        var nextChildIDs = nextChildren.map(getID);\n        pushOperation(nextChildIDs.length);\n\n        for (var i = 0; i < nextChildIDs.length; i++) {\n          pushOperation(nextChildIDs[i]);\n        }\n      }\n\n      function recordUnmount(internalInstance, id) {\n        pendingUnmountedIDs.push(id);\n        idToInternalInstanceMap.delete(id);\n      }\n\n      function crawlAndRecordInitialMounts(id, parentID, rootID) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_3__[\"__DEBUG__\"]) {\n          console.group('crawlAndRecordInitialMounts() id:', id);\n        }\n\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance != null) {\n          internalInstanceToRootIDMap.set(internalInstance, rootID);\n          recordMount(internalInstance, id, parentID);\n          getChildren(internalInstance).forEach(function (child) {\n            return crawlAndRecordInitialMounts(getID(child), id, rootID);\n          });\n        }\n\n        if (_constants__WEBPACK_IMPORTED_MODULE_3__[\"__DEBUG__\"]) {\n          console.groupEnd();\n        }\n      }\n\n      function flushInitialOperations() {\n        // Crawl roots though and register any nodes that mounted before we were injected.\n        var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;\n\n        for (var key in roots) {\n          var internalInstance = roots[key];\n\n          var _id2 = getID(internalInstance);\n\n          crawlAndRecordInitialMounts(_id2, 0, _id2);\n          flushPendingEvents(_id2);\n        }\n      }\n\n      var pendingOperations = [];\n      var pendingStringTable = new Map();\n      var pendingUnmountedIDs = [];\n      var pendingStringTableLength = 0;\n      var pendingUnmountedRootID = null;\n\n      function flushPendingEvents(rootID) {\n        if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n          return;\n        }\n\n        var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n        var operations = new Array( // Identify which renderer this update is coming from.\n        2 + // [rendererID, rootFiberID]\n        // How big is the string table?\n        1 + // [stringTableLength]\n        // Then goes the actual string table.\n        pendingStringTableLength + ( // All unmounts are batched in a single message.\n        // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n        numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations\n        pendingOperations.length); // Identify which renderer this update is coming from.\n        // This enables roots to be mapped to renderers,\n        // Which in turn enables fiber properations, states, and hooks to be inspected.\n\n        var i = 0;\n        operations[i++] = rendererID;\n        operations[i++] = rootID; // Now fill in the string table.\n        // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n        operations[i++] = pendingStringTableLength;\n        pendingStringTable.forEach(function (value, key) {\n          operations[i++] = key.length;\n          var encodedKey = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"utfEncodeString\"])(key);\n\n          for (var j = 0; j < encodedKey.length; j++) {\n            operations[i + j] = encodedKey[j];\n          }\n\n          i += key.length;\n        });\n\n        if (numUnmountIDs > 0) {\n          // All unmounts except roots are batched in a single message.\n          operations[i++] = _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_REMOVE\"]; // The first number is how many unmounted IDs we're gonna send.\n\n          operations[i++] = numUnmountIDs; // Fill in the unmounts\n\n          for (var j = 0; j < pendingUnmountedIDs.length; j++) {\n            operations[i++] = pendingUnmountedIDs[j];\n          } // The root ID should always be unmounted last.\n\n\n          if (pendingUnmountedRootID !== null) {\n            operations[i] = pendingUnmountedRootID;\n            i++;\n          }\n        } // Fill in the rest of the operations.\n\n\n        for (var _j = 0; _j < pendingOperations.length; _j++) {\n          operations[i + _j] = pendingOperations[_j];\n        }\n\n        i += pendingOperations.length;\n\n        if (_constants__WEBPACK_IMPORTED_MODULE_3__[\"__DEBUG__\"]) {\n          Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"printOperationsArray\"])(operations);\n        } // If we've already connected to the frontend, just pass the operations through.\n\n\n        hook.emit('operations', operations);\n        pendingOperations.length = 0;\n        pendingUnmountedIDs = [];\n        pendingUnmountedRootID = null;\n        pendingStringTable.clear();\n        pendingStringTableLength = 0;\n      }\n\n      function pushOperation(op) {\n        if (true) {\n          if (!Number.isInteger(op)) {\n            console.error('pushOperation() was called but the value is not an integer.', op);\n          }\n        }\n\n        pendingOperations.push(op);\n      }\n\n      function getStringID(str) {\n        if (str === null) {\n          return 0;\n        }\n\n        var existingID = pendingStringTable.get(str);\n\n        if (existingID !== undefined) {\n          return existingID;\n        }\n\n        var stringID = pendingStringTable.size + 1;\n        pendingStringTable.set(str, stringID); // The string table total length needs to account\n        // both for the string length, and for the array item\n        // that contains the length itself. Hence + 1.\n\n        pendingStringTableLength += str.length + 1;\n        return stringID;\n      }\n\n      var currentlyInspectedElementID = null;\n      var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,\n      // so that we can send their data along if the element is re-rendered.\n\n      function mergeInspectedPaths(path) {\n        var current = currentlyInspectedPaths;\n        path.forEach(function (key) {\n          if (!current[key]) {\n            current[key] = {};\n          }\n\n          current = current[key];\n        });\n      }\n\n      function createIsPathAllowed(key) {\n        // This function helps prevent previously-inspected paths from being dehydrated in updates.\n        // This is important to avoid a bad user experience where expanded toggles collapse on update.\n        return function isPathAllowed(path) {\n          var current = currentlyInspectedPaths[key];\n\n          if (!current) {\n            return false;\n          }\n\n          for (var i = 0; i < path.length; i++) {\n            current = current[path[i]];\n\n            if (!current) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n      } // Fast path props lookup for React Native style editor.\n\n\n      function getInstanceAndStyle(id) {\n        var instance = null;\n        var style = null;\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance != null) {\n          instance = internalInstance._instance || null;\n          var element = internalInstance._currentElement;\n\n          if (element != null && element.props != null) {\n            style = element.props.style || null;\n          }\n        }\n\n        return {\n          instance: instance,\n          style: style\n        };\n      }\n\n      function updateSelectedElement(id) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance == null) {\n          console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        switch (getElementType(internalInstance)) {\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeClass\"]:\n            global.$r = internalInstance._instance;\n            break;\n\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeFunction\"]:\n            var element = internalInstance._currentElement;\n\n            if (element == null) {\n              console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n              return;\n            }\n\n            global.$r = {\n              props: element.props,\n              type: element.type\n            };\n            break;\n\n          default:\n            global.$r = null;\n            break;\n        }\n      }\n\n      function storeAsGlobal(id, path, count) {\n        var inspectedElement = inspectElementRaw(id);\n\n        if (inspectedElement !== null) {\n          var value = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getInObject\"])(inspectedElement, path);\n          var key = \"$reactTemp\".concat(count);\n          window[key] = value;\n          console.log(key);\n          console.log(value);\n        }\n      }\n\n      function copyElementPath(id, path) {\n        var inspectedElement = inspectElementRaw(id);\n\n        if (inspectedElement !== null) {\n          Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"copyToClipboard\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getInObject\"])(inspectedElement, path));\n        }\n      }\n\n      function inspectElement(id, path) {\n        if (currentlyInspectedElementID !== id) {\n          currentlyInspectedElementID = id;\n          currentlyInspectedPaths = {};\n        }\n\n        var inspectedElement = inspectElementRaw(id);\n\n        if (inspectedElement === null) {\n          return {\n            id: id,\n            type: 'not-found'\n          };\n        }\n\n        if (path != null) {\n          mergeInspectedPaths(path);\n        } // Any time an inspected element has an update,\n        // we should update the selected $r value as wel.\n        // Do this before dehyration (cleanForBridge).\n\n\n        updateSelectedElement(id);\n        inspectedElement.context = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"cleanForBridge\"])(inspectedElement.context, createIsPathAllowed('context'));\n        inspectedElement.props = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"cleanForBridge\"])(inspectedElement.props, createIsPathAllowed('props'));\n        inspectedElement.state = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"cleanForBridge\"])(inspectedElement.state, createIsPathAllowed('state'));\n        return {\n          id: id,\n          type: 'full-data',\n          value: inspectedElement\n        };\n      }\n\n      function inspectElementRaw(id) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance == null) {\n          return null;\n        }\n\n        var _getData2 = getData(internalInstance),\n            displayName = _getData2.displayName,\n            key = _getData2.key;\n\n        var type = getElementType(internalInstance);\n        var context = null;\n        var owners = null;\n        var props = null;\n        var state = null;\n        var source = null;\n        var element = internalInstance._currentElement;\n\n        if (element !== null) {\n          props = element.props;\n          source = element._source != null ? element._source : null;\n          var owner = element._owner;\n\n          if (owner) {\n            owners = [];\n\n            while (owner != null) {\n              owners.push({\n                displayName: getData(owner).displayName || 'Unknown',\n                id: getID(owner),\n                type: getElementType(owner)\n              });\n\n              if (owner._currentElement) {\n                owner = owner._currentElement._owner;\n              }\n            }\n          }\n        }\n\n        var publicInstance = internalInstance._instance;\n\n        if (publicInstance != null) {\n          context = publicInstance.context || null;\n          state = publicInstance.state || null;\n        }\n\n        return {\n          id: id,\n          // Hooks did not exist in legacy versions\n          canEditHooks: false,\n          // Does the current renderer support editable function props?\n          canEditFunctionProps: true,\n          // Suspense did not exist in legacy versions\n          canToggleSuspense: false,\n          // Can view component source location.\n          canViewSource: type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeClass\"] || type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_0__[\"ElementTypeFunction\"],\n          // Only legacy context exists in legacy versions.\n          hasLegacyContext: true,\n          displayName: displayName,\n          type: type,\n          key: key != null ? key : null,\n          // Inspectable properties.\n          context: context,\n          hooks: null,\n          props: props,\n          state: state,\n          // List of owners\n          owners: owners,\n          // Location of component in source code.\n          source: source,\n          rootType: null,\n          rendererPackageName: null,\n          rendererVersion: null\n        };\n      }\n\n      function logElementToConsole(id) {\n        var result = inspectElementRaw(id);\n\n        if (result === null) {\n          console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        var supportsGroup = typeof console.groupCollapsed === 'function';\n\n        if (supportsGroup) {\n          console.groupCollapsed(\"[Click to expand] %c<\".concat(result.displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n          'color: var(--dom-tag-name-color); font-weight: normal;');\n        }\n\n        if (result.props !== null) {\n          console.log('Props:', result.props);\n        }\n\n        if (result.state !== null) {\n          console.log('State:', result.state);\n        }\n\n        if (result.context !== null) {\n          console.log('Context:', result.context);\n        }\n\n        var nativeNode = findNativeNodeForInternalID(id);\n\n        if (nativeNode !== null) {\n          console.log('Node:', nativeNode);\n        }\n\n        if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n          console.log('Right-click any value to save it as a global variable for further inspection.');\n        }\n\n        if (supportsGroup) {\n          console.groupEnd();\n        }\n      }\n\n      function prepareViewAttributeSource(id, path) {\n        var inspectedElement = inspectElementRaw(id);\n\n        if (inspectedElement !== null) {\n          window.$attribute = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getInObject\"])(inspectedElement, path);\n        }\n      }\n\n      function prepareViewElementSource(id) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance == null) {\n          console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        var element = internalInstance._currentElement;\n\n        if (element == null) {\n          console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        global.$type = element.type;\n      }\n\n      function setInProps(id, path, value) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance != null) {\n          var element = internalInstance._currentElement;\n          internalInstance._currentElement = _objectSpread({}, element, {\n            props: Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"copyWithSet\"])(element.props, path, value)\n          });\n          Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"forceUpdate\"])(internalInstance._instance);\n        }\n      }\n\n      function setInState(id, path, value) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance != null) {\n          var publicInstance = internalInstance._instance;\n\n          if (publicInstance != null) {\n            setIn(publicInstance.state, path, value);\n            Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"forceUpdate\"])(publicInstance);\n          }\n        }\n      }\n\n      function setInContext(id, path, value) {\n        var internalInstance = idToInternalInstanceMap.get(id);\n\n        if (internalInstance != null) {\n          var publicInstance = internalInstance._instance;\n\n          if (publicInstance != null) {\n            setIn(publicInstance.context, path, value);\n            Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"forceUpdate\"])(publicInstance);\n          }\n        }\n      }\n\n      function setIn(obj, path, value) {\n        var last = path.pop();\n        var parent = path.reduce( // $FlowFixMe\n        function (reduced, attr) {\n          return reduced ? reduced[attr] : null;\n        }, obj);\n\n        if (parent) {\n          // $FlowFixMe\n          parent[last] = value;\n        }\n      } // v16+ only features\n\n\n      var getProfilingData = function getProfilingData() {\n        throw new Error('getProfilingData not supported by this renderer');\n      };\n\n      var handleCommitFiberRoot = function handleCommitFiberRoot() {\n        throw new Error('handleCommitFiberRoot not supported by this renderer');\n      };\n\n      var handleCommitFiberUnmount = function handleCommitFiberUnmount() {\n        throw new Error('handleCommitFiberUnmount not supported by this renderer');\n      };\n\n      var overrideSuspense = function overrideSuspense() {\n        throw new Error('overrideSuspense not supported by this renderer');\n      };\n\n      var setInHook = function setInHook() {\n        throw new Error('setInHook not supported by this renderer');\n      };\n\n      var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n      };\n\n      var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n      };\n\n      function getBestMatchForTrackedPath() {\n        // Not implemented.\n        return null;\n      }\n\n      function getPathForElement(id) {\n        // Not implemented.\n        return null;\n      }\n\n      function updateComponentFilters(componentFilters) {// Not implemented.\n      }\n\n      function setTraceUpdatesEnabled(enabled) {// Not implemented.\n      }\n\n      function setTrackedPath(path) {// Not implemented.\n      }\n\n      function getOwnersList(id) {\n        // Not implemented.\n        return null;\n      }\n\n      return {\n        cleanup: cleanup,\n        copyElementPath: copyElementPath,\n        flushInitialOperations: flushInitialOperations,\n        getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n        getDisplayNameForFiberID: getDisplayNameForFiberID,\n        getFiberIDForNative: getInternalIDForNative,\n        getInstanceAndStyle: getInstanceAndStyle,\n        findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {\n          var nativeNode = findNativeNodeForInternalID(id);\n          return nativeNode == null ? null : [nativeNode];\n        },\n        getOwnersList: getOwnersList,\n        getPathForElement: getPathForElement,\n        getProfilingData: getProfilingData,\n        handleCommitFiberRoot: handleCommitFiberRoot,\n        handleCommitFiberUnmount: handleCommitFiberUnmount,\n        inspectElement: inspectElement,\n        logElementToConsole: logElementToConsole,\n        overrideSuspense: overrideSuspense,\n        prepareViewAttributeSource: prepareViewAttributeSource,\n        prepareViewElementSource: prepareViewElementSource,\n        renderer: renderer,\n        setInContext: setInContext,\n        setInHook: setInHook,\n        setInProps: setInProps,\n        setInState: setInState,\n        setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n        setTrackedPath: setTrackedPath,\n        startProfiling: startProfiling,\n        stopProfiling: stopProfiling,\n        storeAsGlobal: storeAsGlobal,\n        updateComponentFilters: updateComponentFilters\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/legacy/utils.js\":\n  /*!************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/legacy/utils.js ***!\n    \\************************************************************/\n\n  /*! exports provided: decorate, decorateMany, restoreMany, forceUpdate */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"decorate\", function () {\n      return decorate;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"decorateMany\", function () {\n      return decorateMany;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"restoreMany\", function () {\n      return restoreMany;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"forceUpdate\", function () {\n      return forceUpdate;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function decorate(object, attr, fn) {\n      var old = object[attr];\n\n      object[attr] = function (instance) {\n        return fn.call(this, old, arguments);\n      };\n\n      return old;\n    }\n\n    function decorateMany(source, fns) {\n      var olds = {};\n\n      for (var name in fns) {\n        olds[name] = decorate(source, name, fns[name]);\n      }\n\n      return olds;\n    }\n\n    function restoreMany(source, olds) {\n      for (var name in olds) {\n        source[name] = olds[name];\n      }\n    }\n\n    function forceUpdate(instance) {\n      if (typeof instance.forceUpdate === 'function') {\n        instance.forceUpdate();\n      } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {\n        instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/renderer.js\":\n  /*!********************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/renderer.js ***!\n    \\********************************************************/\n\n  /*! exports provided: getInternalReactConstants, attach */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getInternalReactConstants\", function () {\n      return getInternalReactConstants;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"attach\", function () {\n      return attach;\n    });\n    /* harmony import */\n\n\n    var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! semver */\n    \"../react-devtools-shared/node_modules/semver/semver.js\");\n    /* harmony import */\n\n\n    var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */\n\n\n    var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! react-devtools-shared/src/types */\n    \"../react-devtools-shared/src/types.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! react-devtools-shared/src/utils */\n    \"../react-devtools-shared/src/utils.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! react-devtools-shared/src/storage */\n    \"../react-devtools-shared/src/storage.js\");\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! ./utils */\n    \"../react-devtools-shared/src/backend/utils.js\");\n    /* harmony import */\n\n\n    var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\n    /*! ../constants */\n    \"../react-devtools-shared/src/constants.js\");\n    /* harmony import */\n\n\n    var react_debug_tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\n    /*! react-debug-tools */\n    \"../react-debug-tools/index.js\");\n    /* harmony import */\n\n\n    var _console__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\n    /*! ./console */\n    \"../react-devtools-shared/src/backend/console.js\");\n    /* harmony import */\n\n\n    var _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\n    /*! ./ReactSymbols */\n    \"../react-devtools-shared/src/backend/ReactSymbols.js\");\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n      }\n\n      return keys;\n    }\n\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function (key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n\n      return target;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n    }\n\n    function _iterableToArray(iter) {\n      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n    }\n\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n\n        return arr2;\n      }\n    }\n\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n    }\n\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n\n    function _iterableToArrayLimit(arr, i) {\n      if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n        return;\n      }\n\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr)) return arr;\n    }\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\n    var getCurrentTime = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n      return performance.now();\n    } : function () {\n      return Date.now();\n    };\n\n    function getInternalReactConstants(version) {\n      var ReactTypeOfSideEffect = {\n        NoEffect: 0,\n        PerformedWork: 1,\n        Placement: 2\n      }; // **********************************************************\n      // The section below is copied from files in React repo.\n      // Keep it in sync, and add version guards if it changes.\n      //\n      // Technically these priority levels are invalid for versions before 16.9,\n      // but 16.9 is the first version to report priority level to DevTools,\n      // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.\n\n      var ReactPriorityLevels = {\n        ImmediatePriority: 99,\n        UserBlockingPriority: 98,\n        NormalPriority: 97,\n        LowPriority: 96,\n        IdlePriority: 95,\n        NoPriority: 90\n      };\n      var ReactTypeOfWork = null; // **********************************************************\n      // The section below is copied from files in React repo.\n      // Keep it in sync, and add version guards if it changes.\n\n      if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '17.0.0-alpha')) {\n        // TODO (Offscreen) Update the version number above to reflect the first Offscreen alpha/beta release.\n        ReactTypeOfWork = {\n          Block: 22,\n          ClassComponent: 1,\n          ContextConsumer: 9,\n          ContextProvider: 10,\n          CoroutineComponent: -1,\n          // Removed\n          CoroutineHandlerPhase: -1,\n          // Removed\n          DehydratedSuspenseComponent: 18,\n          // Behind a flag\n          ForwardRef: 11,\n          Fragment: 7,\n          FunctionComponent: 0,\n          HostComponent: 5,\n          HostPortal: 4,\n          HostRoot: 3,\n          HostText: 6,\n          IncompleteClassComponent: 17,\n          IndeterminateComponent: 2,\n          LazyComponent: 16,\n          MemoComponent: 14,\n          Mode: 8,\n          OffscreenComponent: 23,\n          // Experimental\n          Profiler: 12,\n          SimpleMemoComponent: 15,\n          SuspenseComponent: 13,\n          SuspenseListComponent: 19,\n          // Experimental\n          YieldComponent: -1 // Removed\n\n        };\n      } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.6.0-beta.0')) {\n        ReactTypeOfWork = {\n          Block: 22,\n          ClassComponent: 1,\n          ContextConsumer: 9,\n          ContextProvider: 10,\n          CoroutineComponent: -1,\n          // Removed\n          CoroutineHandlerPhase: -1,\n          // Removed\n          DehydratedSuspenseComponent: 18,\n          // Behind a flag\n          ForwardRef: 11,\n          Fragment: 7,\n          FunctionComponent: 0,\n          HostComponent: 5,\n          HostPortal: 4,\n          HostRoot: 3,\n          HostText: 6,\n          IncompleteClassComponent: 17,\n          IndeterminateComponent: 2,\n          LazyComponent: 16,\n          MemoComponent: 14,\n          Mode: 8,\n          OffscreenComponent: -1,\n          // Experimental\n          Profiler: 12,\n          SimpleMemoComponent: 15,\n          SuspenseComponent: 13,\n          SuspenseListComponent: 19,\n          // Experimental\n          YieldComponent: -1 // Removed\n\n        };\n      } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.4.3-alpha')) {\n        ReactTypeOfWork = {\n          Block: -1,\n          // Doesn't exist yet\n          ClassComponent: 2,\n          ContextConsumer: 11,\n          ContextProvider: 12,\n          CoroutineComponent: -1,\n          // Removed\n          CoroutineHandlerPhase: -1,\n          // Removed\n          DehydratedSuspenseComponent: -1,\n          // Doesn't exist yet\n          ForwardRef: 13,\n          Fragment: 9,\n          FunctionComponent: 0,\n          HostComponent: 7,\n          HostPortal: 6,\n          HostRoot: 5,\n          HostText: 8,\n          IncompleteClassComponent: -1,\n          // Doesn't exist yet\n          IndeterminateComponent: 4,\n          LazyComponent: -1,\n          // Doesn't exist yet\n          MemoComponent: -1,\n          // Doesn't exist yet\n          Mode: 10,\n          OffscreenComponent: -1,\n          // Experimental\n          Profiler: 15,\n          SimpleMemoComponent: -1,\n          // Doesn't exist yet\n          SuspenseComponent: 16,\n          SuspenseListComponent: -1,\n          // Doesn't exist yet\n          YieldComponent: -1 // Removed\n\n        };\n      } else {\n        ReactTypeOfWork = {\n          Block: -1,\n          // Doesn't exist yet\n          ClassComponent: 2,\n          ContextConsumer: 12,\n          ContextProvider: 13,\n          CoroutineComponent: 7,\n          CoroutineHandlerPhase: 8,\n          DehydratedSuspenseComponent: -1,\n          // Doesn't exist yet\n          ForwardRef: 14,\n          Fragment: 10,\n          FunctionComponent: 1,\n          HostComponent: 5,\n          HostPortal: 4,\n          HostRoot: 3,\n          HostText: 6,\n          IncompleteClassComponent: -1,\n          // Doesn't exist yet\n          IndeterminateComponent: 0,\n          LazyComponent: -1,\n          // Doesn't exist yet\n          MemoComponent: -1,\n          // Doesn't exist yet\n          Mode: 11,\n          OffscreenComponent: -1,\n          // Experimental\n          Profiler: 15,\n          SimpleMemoComponent: -1,\n          // Doesn't exist yet\n          SuspenseComponent: 16,\n          SuspenseListComponent: -1,\n          // Doesn't exist yet\n          YieldComponent: 9\n        };\n      } // **********************************************************\n      // End of copied code.\n      // **********************************************************\n\n\n      function getTypeSymbol(type) {\n        var symbolOrNumber = _typeof(type) === 'object' && type !== null ? type.$$typeof : type; // $FlowFixMe Flow doesn't know about typeof \"symbol\"\n\n        return _typeof(symbolOrNumber) === 'symbol' ? symbolOrNumber.toString() : symbolOrNumber;\n      }\n\n      var _ReactTypeOfWork = ReactTypeOfWork,\n          ClassComponent = _ReactTypeOfWork.ClassComponent,\n          IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,\n          FunctionComponent = _ReactTypeOfWork.FunctionComponent,\n          IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,\n          ForwardRef = _ReactTypeOfWork.ForwardRef,\n          HostRoot = _ReactTypeOfWork.HostRoot,\n          HostComponent = _ReactTypeOfWork.HostComponent,\n          HostPortal = _ReactTypeOfWork.HostPortal,\n          HostText = _ReactTypeOfWork.HostText,\n          Fragment = _ReactTypeOfWork.Fragment,\n          MemoComponent = _ReactTypeOfWork.MemoComponent,\n          SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,\n          SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,\n          SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent;\n\n      function resolveFiberType(type) {\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"MEMO_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"MEMO_SYMBOL_STRING\"]:\n            // recursively resolving memo type in case of memo(forwardRef(Component))\n            return resolveFiberType(type.type);\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"FORWARD_REF_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"FORWARD_REF_SYMBOL_STRING\"]:\n            return type.render;\n\n          default:\n            return type;\n        }\n      } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n      function getDisplayNameForFiber(fiber) {\n        var type = fiber.type,\n            tag = fiber.tag;\n        var resolvedType = type;\n\n        if (_typeof(type) === 'object' && type !== null) {\n          resolvedType = resolveFiberType(type);\n        }\n\n        var resolvedContext = null;\n\n        switch (tag) {\n          case ClassComponent:\n          case IncompleteClassComponent:\n            return Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType);\n\n          case FunctionComponent:\n          case IndeterminateComponent:\n            return Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType);\n\n          case ForwardRef:\n            // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n            return type && type.displayName || Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType, 'Anonymous');\n\n          case HostRoot:\n            return null;\n\n          case HostComponent:\n            return type;\n\n          case HostPortal:\n          case HostText:\n          case Fragment:\n            return null;\n\n          case MemoComponent:\n          case SimpleMemoComponent:\n            return Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType, 'Anonymous');\n\n          case SuspenseComponent:\n            return 'Suspense';\n\n          case SuspenseListComponent:\n            return 'SuspenseList';\n\n          default:\n            var typeSymbol = getTypeSymbol(type);\n\n            switch (typeSymbol) {\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n                return null;\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]:\n                // 16.3.0 exposed the context object as \"context\"\n                // PR #12501 changed it to \"_context\" for 16.3.1+\n                // NOTE Keep in sync with inspectElementRaw()\n                resolvedContext = fiber.type._context || fiber.type.context;\n                return \"\".concat(resolvedContext.displayName || 'Context', \".Provider\");\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]:\n                // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n                // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n                // NOTE Keep in sync with inspectElementRaw()\n                resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'\n                // If you change the name, figure out a more resilient way to detect it.\n\n                return \"\".concat(resolvedContext.displayName || 'Context', \".Consumer\");\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n                return null;\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_SYMBOL_STRING\"]:\n                return \"Profiler(\".concat(fiber.memoizedProps.id, \")\");\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"SCOPE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"SCOPE_SYMBOL_STRING\"]:\n                return 'Scope';\n\n              default:\n                // Unknown element type.\n                // This may mean a new element type that has not yet been added to DevTools.\n                return null;\n            }\n\n        }\n      }\n\n      return {\n        getDisplayNameForFiber: getDisplayNameForFiber,\n        getTypeSymbol: getTypeSymbol,\n        ReactPriorityLevels: ReactPriorityLevels,\n        ReactTypeOfWork: ReactTypeOfWork,\n        ReactTypeOfSideEffect: ReactTypeOfSideEffect\n      };\n    }\n\n    function attach(hook, rendererID, renderer, global) {\n      var _getInternalReactCons = getInternalReactConstants(renderer.version),\n          getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,\n          getTypeSymbol = _getInternalReactCons.getTypeSymbol,\n          ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,\n          ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,\n          ReactTypeOfSideEffect = _getInternalReactCons.ReactTypeOfSideEffect;\n\n      var NoEffect = ReactTypeOfSideEffect.NoEffect,\n          PerformedWork = ReactTypeOfSideEffect.PerformedWork,\n          Placement = ReactTypeOfSideEffect.Placement;\n      var FunctionComponent = ReactTypeOfWork.FunctionComponent,\n          ClassComponent = ReactTypeOfWork.ClassComponent,\n          ContextConsumer = ReactTypeOfWork.ContextConsumer,\n          DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,\n          Fragment = ReactTypeOfWork.Fragment,\n          ForwardRef = ReactTypeOfWork.ForwardRef,\n          HostRoot = ReactTypeOfWork.HostRoot,\n          HostPortal = ReactTypeOfWork.HostPortal,\n          HostComponent = ReactTypeOfWork.HostComponent,\n          HostText = ReactTypeOfWork.HostText,\n          IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,\n          IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,\n          MemoComponent = ReactTypeOfWork.MemoComponent,\n          OffscreenComponent = ReactTypeOfWork.OffscreenComponent,\n          SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,\n          SuspenseComponent = ReactTypeOfWork.SuspenseComponent,\n          SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent;\n      var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,\n          UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,\n          NormalPriority = ReactPriorityLevels.NormalPriority,\n          LowPriority = ReactPriorityLevels.LowPriority,\n          IdlePriority = ReactPriorityLevels.IdlePriority,\n          NoPriority = ReactPriorityLevels.NoPriority;\n      var overrideHookState = renderer.overrideHookState,\n          overrideProps = renderer.overrideProps,\n          setSuspenseHandler = renderer.setSuspenseHandler,\n          scheduleUpdate = renderer.scheduleUpdate;\n      var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function'; // Patching the console enables DevTools to do a few useful things:\n      // * Append component stacks to warnings and error messages\n      // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n      //\n      // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.\n\n      if (true) {\n        Object(_console__WEBPACK_IMPORTED_MODULE_7__[\"registerRenderer\"])(renderer); // The renderer interface can't read these preferences directly,\n        // because it is stored in localStorage within the context of the extension.\n        // It relies on the extension to pass the preference through via the global.\n\n        var appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;\n        var breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true;\n\n        if (appendComponentStack || breakOnConsoleErrors) {\n          Object(_console__WEBPACK_IMPORTED_MODULE_7__[\"patch\"])({\n            appendComponentStack: appendComponentStack,\n            breakOnConsoleErrors: breakOnConsoleErrors\n          });\n        }\n      }\n\n      var debug = function debug(name, fiber, parentFiber) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          var displayName = getDisplayNameForFiber(fiber) || 'null';\n          var id = getFiberID(fiber);\n          var parentDisplayName = parentFiber != null && getDisplayNameForFiber(parentFiber) || 'null';\n          var parentID = parentFiber ? getFiberID(parentFiber) : ''; // NOTE: calling getFiberID or getPrimaryFiber is unsafe here\n          // because it will put them in the map. For now, we'll omit them.\n          // TODO: better debugging story for this.\n\n          console.log(\"[renderer] %c\".concat(name, \" %c\").concat(displayName, \" (\").concat(id, \") %c\").concat(parentFiber ? \"\".concat(parentDisplayName, \" (\").concat(parentID, \")\") : ''), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;');\n        }\n      }; // Configurable Components tree filters.\n\n\n      var hideElementsWithDisplayNames = new Set();\n      var hideElementsWithPaths = new Set();\n      var hideElementsWithTypes = new Set(); // Highlight updates\n\n      var traceUpdatesEnabled = false;\n      var traceUpdatesForNodes = new Set();\n\n      function applyComponentFilters(componentFilters) {\n        hideElementsWithTypes.clear();\n        hideElementsWithDisplayNames.clear();\n        hideElementsWithPaths.clear();\n        componentFilters.forEach(function (componentFilter) {\n          if (!componentFilter.isEnabled) {\n            return;\n          }\n\n          switch (componentFilter.type) {\n            case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterDisplayName\"]:\n              if (componentFilter.isValid && componentFilter.value !== '') {\n                hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));\n              }\n\n              break;\n\n            case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterElementType\"]:\n              hideElementsWithTypes.add(componentFilter.value);\n              break;\n\n            case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterLocation\"]:\n              if (componentFilter.isValid && componentFilter.value !== '') {\n                hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));\n              }\n\n              break;\n\n            case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterHOC\"]:\n              hideElementsWithDisplayNames.add(new RegExp('\\\\('));\n              break;\n\n            default:\n              console.warn(\"Invalid component filter type \\\"\".concat(componentFilter.type, \"\\\"\"));\n              break;\n          }\n        });\n      } // The renderer interface can't read saved component filters directly,\n      // because they are stored in localStorage within the context of the extension.\n      // Instead it relies on the extension to pass filters through.\n\n\n      if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {\n        applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);\n      } else {\n        // Unfortunately this feature is not expected to work for React Native for now.\n        // It would be annoying for us to spam YellowBox warnings with unactionable stuff,\n        // so for now just skip this message...\n        //console.warn(' DevTools: Could not locate saved component filters');\n        // Fallback to assuming the default filters in this case.\n        applyComponentFilters(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDefaultComponentFilters\"])());\n      } // If necessary, we can revisit optimizing this operation.\n      // For example, we could add a new recursive unmount tree operation.\n      // The unmount operations are already significantly smaller than mount operations though.\n      // This is something to keep in mind for later.\n\n\n      function updateComponentFilters(componentFilters) {\n        if (isProfiling) {\n          // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n          // If necessary, we could support this- but it doesn't seem like a necessary use case.\n          throw Error('Cannot modify filter preferences while profiling');\n        } // Recursively unmount all roots.\n\n\n        hook.getFiberRoots(rendererID).forEach(function (root) {\n          currentRootID = getFiberID(getPrimaryFiber(root.current));\n          unmountFiberChildrenRecursively(root.current);\n          recordUnmount(root.current, false);\n          currentRootID = -1;\n        });\n        applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.\n\n        rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.\n\n        hook.getFiberRoots(rendererID).forEach(function (root) {\n          currentRootID = getFiberID(getPrimaryFiber(root.current));\n          setRootPseudoKey(currentRootID, root.current);\n          mountFiberRecursively(root.current, null, false, false);\n          flushPendingEvents(root);\n          currentRootID = -1;\n        });\n      } // NOTICE Keep in sync with get*ForFiber methods\n\n\n      function shouldFilterFiber(fiber) {\n        var _debugSource = fiber._debugSource,\n            tag = fiber.tag,\n            type = fiber.type;\n\n        switch (tag) {\n          case DehydratedSuspenseComponent:\n            // TODO: ideally we would show dehydrated Suspense immediately.\n            // However, it has some special behavior (like disconnecting\n            // an alternate and turning into real Suspense) which breaks DevTools.\n            // For now, ignore it, and only show it once it gets hydrated.\n            // https://github.com/bvaughn/react-devtools-experimental/issues/197\n            return true;\n\n          case HostPortal:\n          case HostText:\n          case Fragment:\n          case OffscreenComponent:\n            return true;\n\n          case HostRoot:\n            // It is never valid to filter the root element.\n            return false;\n\n          default:\n            var typeSymbol = getTypeSymbol(type);\n\n            switch (typeSymbol) {\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n                return true;\n\n              default:\n                break;\n            }\n\n        }\n\n        var elementType = getElementTypeForFiber(fiber);\n\n        if (hideElementsWithTypes.has(elementType)) {\n          return true;\n        }\n\n        if (hideElementsWithDisplayNames.size > 0) {\n          var displayName = getDisplayNameForFiber(fiber);\n\n          if (displayName != null) {\n            // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = hideElementsWithDisplayNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var displayNameRegExp = _step.value;\n\n                if (displayNameRegExp.test(displayName)) {\n                  return true;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n        }\n\n        if (_debugSource != null && hideElementsWithPaths.size > 0) {\n          var fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = hideElementsWithPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var pathRegExp = _step2.value;\n\n              if (pathRegExp.test(fileName)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        return false;\n      } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n      function getElementTypeForFiber(fiber) {\n        var type = fiber.type,\n            tag = fiber.tag;\n\n        switch (tag) {\n          case ClassComponent:\n          case IncompleteClassComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"];\n\n          case FunctionComponent:\n          case IndeterminateComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"];\n\n          case ForwardRef:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"];\n\n          case HostRoot:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeRoot\"];\n\n          case HostComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"];\n\n          case HostPortal:\n          case HostText:\n          case Fragment:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n          case MemoComponent:\n          case SimpleMemoComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"];\n\n          case SuspenseComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeSuspense\"];\n\n          case SuspenseListComponent:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeSuspenseList\"];\n\n          default:\n            var typeSymbol = getTypeSymbol(type);\n\n            switch (typeSymbol) {\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"];\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"];\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_NUMBER\"]:\n              case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_SYMBOL_STRING\"]:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeProfiler\"];\n\n              default:\n                return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n            }\n\n        }\n      } // This is a slightly annoying indirection.\n      // It is currently necessary because DevTools wants to use unique objects as keys for instances.\n      // However fibers have two versions.\n      // We use this set to remember first encountered fiber for each conceptual instance.\n\n\n      function getPrimaryFiber(fiber) {\n        if (primaryFibers.has(fiber)) {\n          return fiber;\n        }\n\n        var alternate = fiber.alternate;\n\n        if (alternate != null && primaryFibers.has(alternate)) {\n          return alternate;\n        }\n\n        primaryFibers.add(fiber);\n        return fiber;\n      }\n\n      var fiberToIDMap = new Map();\n      var idToFiberMap = new Map();\n      var primaryFibers = new Set(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n      // This is so that we can quickly capture a snapshot of those values if profiling starts.\n      // If we didn't store these values, we'd have to crawl the tree when profiling started,\n      // and use a slow path to find each of the current Fibers.\n\n      var idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n      // This map enables us to filter these times by root when sending them to the frontend.\n\n      var idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.\n\n      var currentRootID = -1;\n\n      function getFiberID(primaryFiber) {\n        if (!fiberToIDMap.has(primaryFiber)) {\n          var id = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getUID\"])();\n          fiberToIDMap.set(primaryFiber, id);\n          idToFiberMap.set(id, primaryFiber);\n        }\n\n        return fiberToIDMap.get(primaryFiber);\n      }\n\n      function getChangeDescription(prevFiber, nextFiber) {\n        switch (getElementTypeForFiber(nextFiber)) {\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"]:\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"]:\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]:\n            if (prevFiber === null) {\n              return {\n                context: null,\n                didHooksChange: false,\n                isFirstMount: true,\n                props: null,\n                state: null\n              };\n            } else {\n              return {\n                context: getContextChangedKeys(nextFiber),\n                didHooksChange: didHooksChange(prevFiber.memoizedState, nextFiber.memoizedState),\n                isFirstMount: false,\n                props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n                state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)\n              };\n            }\n\n          default:\n            return null;\n        }\n      }\n\n      function updateContextsForFiber(fiber) {\n        switch (getElementTypeForFiber(fiber)) {\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n            if (idToContextsMap !== null) {\n              var id = getFiberID(getPrimaryFiber(fiber));\n              var contexts = getContextsForFiber(fiber);\n\n              if (contexts !== null) {\n                idToContextsMap.set(id, contexts);\n              }\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      } // Differentiates between a null context value and no context.\n\n\n      var NO_CONTEXT = {};\n\n      function getContextsForFiber(fiber) {\n        switch (getElementTypeForFiber(fiber)) {\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n            var instance = fiber.stateNode;\n            var legacyContext = NO_CONTEXT;\n            var modernContext = NO_CONTEXT;\n\n            if (instance != null) {\n              if (instance.constructor && instance.constructor.contextType != null) {\n                modernContext = instance.context;\n              } else {\n                legacyContext = instance.context;\n\n                if (legacyContext && Object.keys(legacyContext).length === 0) {\n                  legacyContext = NO_CONTEXT;\n                }\n              }\n            }\n\n            return [legacyContext, modernContext];\n\n          default:\n            return null;\n        }\n      } // Record all contexts at the time profiling is started.\n      // Fibers only store the current context value,\n      // so we need to track them separately in order to determine changed keys.\n\n\n      function crawlToInitializeContextsMap(fiber) {\n        updateContextsForFiber(fiber);\n        var current = fiber.child;\n\n        while (current !== null) {\n          crawlToInitializeContextsMap(current);\n          current = current.sibling;\n        }\n      }\n\n      function getContextChangedKeys(fiber) {\n        switch (getElementTypeForFiber(fiber)) {\n          case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n            if (idToContextsMap !== null) {\n              var id = getFiberID(getPrimaryFiber(fiber));\n              var prevContexts = idToContextsMap.has(id) ? idToContextsMap.get(id) : null;\n              var nextContexts = getContextsForFiber(fiber);\n\n              if (prevContexts == null || nextContexts == null) {\n                return null;\n              }\n\n              var _prevContexts = _slicedToArray(prevContexts, 2),\n                  prevLegacyContext = _prevContexts[0],\n                  prevModernContext = _prevContexts[1];\n\n              var _nextContexts = _slicedToArray(nextContexts, 2),\n                  nextLegacyContext = _nextContexts[0],\n                  nextModernContext = _nextContexts[1];\n\n              if (nextLegacyContext !== NO_CONTEXT) {\n                return getChangedKeys(prevLegacyContext, nextLegacyContext);\n              } else if (nextModernContext !== NO_CONTEXT) {\n                return prevModernContext !== nextModernContext;\n              }\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        return null;\n      }\n\n      function didHooksChange(prev, next) {\n        if (prev == null || next == null) {\n          return false;\n        } // We can't report anything meaningful for hooks changes.\n\n\n        if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n          while (next !== null) {\n            if (next.memoizedState !== prev.memoizedState) {\n              return true;\n            } else {\n              next = next.next;\n              prev = prev.next;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      function getChangedKeys(prev, next) {\n        if (prev == null || next == null) {\n          return null;\n        } // We can't report anything meaningful for hooks changes.\n\n\n        if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n          return null;\n        }\n\n        var keys = new Set([].concat(_toConsumableArray(Object.keys(prev)), _toConsumableArray(Object.keys(next))));\n        var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var key = _step3.value;\n\n            if (prev[key] !== next[key]) {\n              changedKeys.push(key);\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return changedKeys;\n      } // eslint-disable-next-line no-unused-vars\n\n\n      function didFiberRender(prevFiber, nextFiber) {\n        switch (nextFiber.tag) {\n          case ClassComponent:\n          case FunctionComponent:\n          case ContextConsumer:\n          case MemoComponent:\n          case SimpleMemoComponent:\n            // For types that execute user code, we check PerformedWork effect.\n            // We don't reflect bailouts (either referential or sCU) in DevTools.\n            // eslint-disable-next-line no-bitwise\n            return (nextFiber.effectTag & PerformedWork) === PerformedWork;\n          // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+\n          // so it won't get highlighted with React 16.3.0 to 16.3.2.\n\n          default:\n            // For host components and other types, we compare inputs\n            // to determine whether something is an update.\n            return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;\n        }\n      }\n\n      var pendingOperations = [];\n      var pendingRealUnmountedIDs = [];\n      var pendingSimulatedUnmountedIDs = [];\n      var pendingOperationsQueue = [];\n      var pendingStringTable = new Map();\n      var pendingStringTableLength = 0;\n      var pendingUnmountedRootID = null;\n\n      function pushOperation(op) {\n        if (true) {\n          if (!Number.isInteger(op)) {\n            console.error('pushOperation() was called but the value is not an integer.', op);\n          }\n        }\n\n        pendingOperations.push(op);\n      }\n\n      function flushPendingEvents(root) {\n        if (pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n          // If we aren't profiling, we can just bail out here.\n          // No use sending an empty update over the bridge.\n          //\n          // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:\n          // (1) an initial tree snapshot and\n          // (2) the operations array for each commit\n          // Because of this, it's important that the operations and metadata arrays align,\n          // So it's important not to omit even empty operations while profiling is active.\n          if (!isProfiling) {\n            return;\n          }\n        }\n\n        var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n        var operations = new Array( // Identify which renderer this update is coming from.\n        2 + // [rendererID, rootFiberID]\n        // How big is the string table?\n        1 + // [stringTableLength]\n        // Then goes the actual string table.\n        pendingStringTableLength + ( // All unmounts are batched in a single message.\n        // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n        numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations\n        pendingOperations.length); // Identify which renderer this update is coming from.\n        // This enables roots to be mapped to renderers,\n        // Which in turn enables fiber props, states, and hooks to be inspected.\n\n        var i = 0;\n        operations[i++] = rendererID;\n        operations[i++] = currentRootID; // Use this ID in case the root was unmounted!\n        // Now fill in the string table.\n        // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n        operations[i++] = pendingStringTableLength;\n        pendingStringTable.forEach(function (value, key) {\n          operations[i++] = key.length;\n          var encodedKey = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"utfEncodeString\"])(key);\n\n          for (var j = 0; j < encodedKey.length; j++) {\n            operations[i + j] = encodedKey[j];\n          }\n\n          i += key.length;\n        });\n\n        if (numUnmountIDs > 0) {\n          // All unmounts except roots are batched in a single message.\n          operations[i++] = _constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_REMOVE\"]; // The first number is how many unmounted IDs we're gonna send.\n\n          operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.\n          // They were inserted parents-first by React, but we want children-first.\n          // So we traverse our array backwards.\n\n          for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {\n            operations[i++] = pendingRealUnmountedIDs[j];\n          } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.\n          // (We want children to go before parents.)\n          // They go *after* the real unmounts because we know for sure they won't be\n          // children of already pushed \"real\" IDs. If they were, we wouldn't be able\n          // to discover them during the traversal, as they would have been deleted.\n\n\n          for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {\n            operations[i + _j] = pendingSimulatedUnmountedIDs[_j];\n          }\n\n          i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.\n\n          if (pendingUnmountedRootID !== null) {\n            operations[i] = pendingUnmountedRootID;\n            i++;\n          }\n        } // Fill in the rest of the operations.\n\n\n        for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {\n          operations[i + _j2] = pendingOperations[_j2];\n        }\n\n        i += pendingOperations.length; // Let the frontend know about tree operations.\n        // The first value in this array will identify which root it corresponds to,\n        // so we do no longer need to dispatch a separate root-committed event.\n\n        if (pendingOperationsQueue !== null) {\n          // Until the frontend has been connected, store the tree operations.\n          // This will let us avoid walking the tree later when the frontend connects,\n          // and it enables the Profiler's reload-and-profile functionality to work as well.\n          pendingOperationsQueue.push(operations);\n        } else {\n          // If we've already connected to the frontend, just pass the operations through.\n          hook.emit('operations', operations);\n        }\n\n        pendingOperations.length = 0;\n        pendingRealUnmountedIDs.length = 0;\n        pendingSimulatedUnmountedIDs.length = 0;\n        pendingUnmountedRootID = null;\n        pendingStringTable.clear();\n        pendingStringTableLength = 0;\n      }\n\n      function getStringID(str) {\n        if (str === null) {\n          return 0;\n        }\n\n        var existingID = pendingStringTable.get(str);\n\n        if (existingID !== undefined) {\n          return existingID;\n        }\n\n        var stringID = pendingStringTable.size + 1;\n        pendingStringTable.set(str, stringID); // The string table total length needs to account\n        // both for the string length, and for the array item\n        // that contains the length itself. Hence + 1.\n\n        pendingStringTableLength += str.length + 1;\n        return stringID;\n      }\n\n      function recordMount(fiber, parentFiber) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          debug('recordMount()', fiber, parentFiber);\n        }\n\n        var isRoot = fiber.tag === HostRoot;\n        var id = getFiberID(getPrimaryFiber(fiber));\n        var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');\n        var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n        if (isRoot) {\n          pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_ADD\"]);\n          pushOperation(id);\n          pushOperation(react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeRoot\"]);\n          pushOperation(isProfilingSupported ? 1 : 0);\n          pushOperation(hasOwnerMetadata ? 1 : 0);\n\n          if (isProfiling) {\n            if (displayNamesByRootID !== null) {\n              displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));\n            }\n          }\n        } else {\n          var key = fiber.key;\n          var displayName = getDisplayNameForFiber(fiber);\n          var elementType = getElementTypeForFiber(fiber);\n          var _debugOwner = fiber._debugOwner;\n          var ownerID = _debugOwner != null ? getFiberID(getPrimaryFiber(_debugOwner)) : 0;\n          var parentID = parentFiber ? getFiberID(getPrimaryFiber(parentFiber)) : 0;\n          var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n          // in such a way as to bypass the default stringification of the \"key\" property.\n\n          var keyString = key === null ? null : '' + key;\n          var keyStringID = getStringID(keyString);\n          pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_ADD\"]);\n          pushOperation(id);\n          pushOperation(elementType);\n          pushOperation(parentID);\n          pushOperation(ownerID);\n          pushOperation(displayNameStringID);\n          pushOperation(keyStringID);\n        }\n\n        if (isProfilingSupported) {\n          idToRootMap.set(id, currentRootID);\n          recordProfilingDurations(fiber);\n        }\n      }\n\n      function recordUnmount(fiber, isSimulated) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          debug('recordUnmount()', fiber);\n        }\n\n        if (trackedPathMatchFiber !== null) {\n          // We're in the process of trying to restore previous selection.\n          // If this fiber matched but is being unmounted, there's no use trying.\n          // Reset the state so we don't keep holding onto it.\n          if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {\n            setTrackedPath(null);\n          }\n        }\n\n        var isRoot = fiber.tag === HostRoot;\n        var primaryFiber = getPrimaryFiber(fiber);\n\n        if (!fiberToIDMap.has(primaryFiber)) {\n          // If we've never seen this Fiber, it might be because\n          // it is inside a non-current Suspense fragment tree,\n          // and so the store is not even aware of it.\n          // In that case we can just ignore it, or otherwise\n          // there will be errors later on.\n          primaryFibers.delete(primaryFiber); // TODO: this is fragile and can obscure actual bugs.\n\n          return;\n        }\n\n        var id = getFiberID(primaryFiber);\n\n        if (isRoot) {\n          // Roots must be removed only after all children (pending and simulated) have been removed.\n          // So we track it separately.\n          pendingUnmountedRootID = id;\n        } else if (!shouldFilterFiber(fiber)) {\n          // To maintain child-first ordering,\n          // we'll push it into one of these queues,\n          // and later arrange them in the correct order.\n          if (isSimulated) {\n            pendingSimulatedUnmountedIDs.push(id);\n          } else {\n            pendingRealUnmountedIDs.push(id);\n          }\n        }\n\n        fiberToIDMap.delete(primaryFiber);\n        idToFiberMap.delete(id);\n        primaryFibers.delete(primaryFiber);\n        var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n        if (isProfilingSupported) {\n          idToRootMap.delete(id);\n          idToTreeBaseDurationMap.delete(id);\n        }\n      }\n\n      function mountFiberRecursively(fiber, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          debug('mountFiberRecursively()', fiber, parentFiber);\n        } // If we have the tree selection from previous reload, try to match this Fiber.\n        // Also remember whether to do the same for siblings.\n\n\n        var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);\n        var shouldIncludeInTree = !shouldFilterFiber(fiber);\n\n        if (shouldIncludeInTree) {\n          recordMount(fiber, parentFiber);\n        }\n\n        if (traceUpdatesEnabled) {\n          if (traceNearestHostComponentUpdate) {\n            var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n\n            if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"]) {\n              traceUpdatesForNodes.add(fiber.stateNode);\n              traceNearestHostComponentUpdate = false;\n            }\n          } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,\n          // because we don't want to highlight every host node inside of a newly mounted subtree.\n\n        }\n\n        var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;\n\n        if (isSuspense) {\n          var isTimedOut = fiber.memoizedState !== null;\n\n          if (isTimedOut) {\n            // Special case: if Suspense mounts in a timed-out state,\n            // get the fallback child from the inner fragment and mount\n            // it as if it was our own child. Updates handle this too.\n            var primaryChildFragment = fiber.child;\n            var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n            var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n            if (fallbackChild !== null) {\n              mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n            }\n          } else {\n            var primaryChild = null;\n            var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;\n\n            if (areSuspenseChildrenConditionallyWrapped) {\n              primaryChild = fiber.child;\n            } else if (fiber.child !== null) {\n              primaryChild = fiber.child.child;\n            }\n\n            if (primaryChild !== null) {\n              mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n            }\n          }\n        } else {\n          if (fiber.child !== null) {\n            mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        } // We're exiting this Fiber now, and entering its siblings.\n        // If we have selection to restore, we might need to re-activate tracking.\n\n\n        updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n\n        if (traverseSiblings && fiber.sibling !== null) {\n          mountFiberRecursively(fiber.sibling, parentFiber, true, traceNearestHostComponentUpdate);\n        }\n      } // We use this to simulate unmounting for Suspense trees\n      // when we switch from primary to fallback.\n\n\n      function unmountFiberChildrenRecursively(fiber) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          debug('unmountFiberChildrenRecursively()', fiber);\n        } // We might meet a nested Suspense on our way.\n\n\n        var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;\n        var child = fiber.child;\n\n        if (isTimedOutSuspense) {\n          // If it's showing fallback tree, let's traverse it instead.\n          var primaryChildFragment = fiber.child;\n          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.\n\n          child = fallbackChildFragment ? fallbackChildFragment.child : null;\n        }\n\n        while (child !== null) {\n          // Record simulated unmounts children-first.\n          // We skip nodes without return because those are real unmounts.\n          if (child.return !== null) {\n            unmountFiberChildrenRecursively(child);\n            recordUnmount(child, true);\n          }\n\n          child = child.sibling;\n        }\n      }\n\n      function recordProfilingDurations(fiber) {\n        var id = getFiberID(getPrimaryFiber(fiber));\n        var actualDuration = fiber.actualDuration,\n            treeBaseDuration = fiber.treeBaseDuration;\n        idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);\n\n        if (isProfiling) {\n          var alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,\n          // because it's possible that one of its descendants did.\n\n          if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {\n            // Tree base duration updates are included in the operations typed array.\n            // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n            var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n            pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\"]);\n            pushOperation(id);\n            pushOperation(convertedTreeBaseDuration);\n          }\n\n          if (alternate == null || didFiberRender(alternate, fiber)) {\n            if (actualDuration != null) {\n              // The actual duration reported by React includes time spent working on children.\n              // This is useful information, but it's also useful to be able to exclude child durations.\n              // The frontend can't compute this, since the immediate children may have been filtered out.\n              // So we need to do this on the backend.\n              // Note that this calculated self duration is not the same thing as the base duration.\n              // The two are calculated differently (tree duration does not accumulate).\n              var selfDuration = actualDuration;\n              var child = fiber.child;\n\n              while (child !== null) {\n                selfDuration -= child.actualDuration || 0;\n                child = child.sibling;\n              } // If profiling is active, store durations for elements that were rendered during the commit.\n              // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.\n              // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)\n              // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we \"bailed out\".\n\n\n              var metadata = currentCommitProfilingMetadata;\n              metadata.durations.push(id, actualDuration, selfDuration);\n              metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);\n\n              if (recordChangeDescriptions) {\n                var changeDescription = getChangeDescription(alternate, fiber);\n\n                if (changeDescription !== null) {\n                  if (metadata.changeDescriptions !== null) {\n                    metadata.changeDescriptions.set(id, changeDescription);\n                  }\n                }\n\n                updateContextsForFiber(fiber);\n              }\n            }\n          }\n        }\n      }\n\n      function recordResetChildren(fiber, childSet) {\n        // The frontend only really cares about the displayName, key, and children.\n        // The first two don't really change, so we are only concerned with the order of children here.\n        // This is trickier than a simple comparison though, since certain types of fibers are filtered.\n        var nextChildren = []; // This is a naive implementation that shallowly recourses children.\n        // We might want to revisit this if it proves to be too inefficient.\n\n        var child = childSet;\n\n        while (child !== null) {\n          findReorderedChildrenRecursively(child, nextChildren);\n          child = child.sibling;\n        }\n\n        var numChildren = nextChildren.length;\n\n        if (numChildren < 2) {\n          // No need to reorder.\n          return;\n        }\n\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_REORDER_CHILDREN\"]);\n        pushOperation(getFiberID(getPrimaryFiber(fiber)));\n        pushOperation(numChildren);\n\n        for (var i = 0; i < nextChildren.length; i++) {\n          pushOperation(nextChildren[i]);\n        }\n      }\n\n      function findReorderedChildrenRecursively(fiber, nextChildren) {\n        if (!shouldFilterFiber(fiber)) {\n          nextChildren.push(getFiberID(getPrimaryFiber(fiber)));\n        } else {\n          var child = fiber.child;\n\n          while (child !== null) {\n            findReorderedChildrenRecursively(child, nextChildren);\n            child = child.sibling;\n          }\n        }\n      } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n      function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {\n        if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n          debug('updateFiberRecursively()', nextFiber, parentFiber);\n        }\n\n        if (traceUpdatesEnabled) {\n          var elementType = getElementTypeForFiber(nextFiber);\n\n          if (traceNearestHostComponentUpdate) {\n            // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n            if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"]) {\n              traceUpdatesForNodes.add(nextFiber.stateNode);\n              traceNearestHostComponentUpdate = false;\n            }\n          } else {\n            if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"]) {\n              // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).\n              traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);\n            }\n          }\n        }\n\n        if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === getFiberID(getPrimaryFiber(nextFiber)) && didFiberRender(prevFiber, nextFiber)) {\n          // If this Fiber has updated, clear cached inspected data.\n          // If it is inspected again, it may need to be re-run to obtain updated hooks values.\n          hasElementUpdatedSinceLastInspected = true;\n        }\n\n        var shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n        var isSuspense = nextFiber.tag === SuspenseComponent;\n        var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.\n        // Rather than unmount the timed out content (and possibly lose important state),\n        // React re-parents this content within a hidden Fragment while the fallback is showing.\n        // This behavior doesn't need to be observable in the DevTools though.\n        // It might even result in a bad user experience for e.g. node selection in the Elements panel.\n        // The easiest fix is to strip out the intermediate Fragment fibers,\n        // so the Elements panel and Profiler don't need to special case them.\n        // Suspense components only have a non-null memoizedState if they're timed-out.\n\n        var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n        var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()\n        // inside ReactFiberBeginWork in the React source code.\n\n        if (prevDidTimeout && nextDidTimeOut) {\n          // Fallback -> Fallback:\n          // 1. Reconcile fallback set.\n          var nextFiberChild = nextFiber.child;\n          var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate\n          // because the set is special and alternate may not exist.\n\n          var prevFiberChild = prevFiber.child;\n          var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;\n\n          if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {\n            shouldResetChildren = true;\n          }\n        } else if (prevDidTimeout && !nextDidTimeOut) {\n          // Fallback -> Primary:\n          // 1. Unmount fallback set\n          // Note: don't emulate fallback unmount because React actually did it.\n          // 2. Mount primary set\n          var nextPrimaryChildSet = nextFiber.child;\n\n          if (nextPrimaryChildSet !== null) {\n            mountFiberRecursively(nextPrimaryChildSet, nextFiber, true, traceNearestHostComponentUpdate);\n          }\n\n          shouldResetChildren = true;\n        } else if (!prevDidTimeout && nextDidTimeOut) {\n          // Primary -> Fallback:\n          // 1. Hide primary set\n          // This is not a real unmount, so it won't get reported by React.\n          // We need to manually walk the previous tree and record unmounts.\n          unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set\n\n          var _nextFiberChild = nextFiber.child;\n\n          var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;\n\n          if (_nextFallbackChildSet != null) {\n            mountFiberRecursively(_nextFallbackChildSet, nextFiber, true, traceNearestHostComponentUpdate);\n            shouldResetChildren = true;\n          }\n        } else {\n          // Common case: Primary -> Primary.\n          // This is the same code path as for non-Suspense fibers.\n          if (nextFiber.child !== prevFiber.child) {\n            // If the first child is different, we need to traverse them.\n            // Each next child will be either a new child (mount) or an alternate (update).\n            var nextChild = nextFiber.child;\n            var prevChildAtSameIndex = prevFiber.child;\n\n            while (nextChild) {\n              // We already know children will be referentially different because\n              // they are either new mounts or alternates of previous children.\n              // Schedule updates and mounts depending on whether alternates exist.\n              // We don't track deletions here because they are reported separately.\n              if (nextChild.alternate) {\n                var prevChild = nextChild.alternate;\n\n                if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {\n                  // If a nested tree child order changed but it can't handle its own\n                  // child order invalidation (e.g. because it's filtered out like host nodes),\n                  // propagate the need to reset child order upwards to this Fiber.\n                  shouldResetChildren = true;\n                } // However we also keep track if the order of the children matches\n                // the previous order. They are always different referentially, but\n                // if the instances line up conceptually we'll want to know that.\n\n\n                if (prevChild !== prevChildAtSameIndex) {\n                  shouldResetChildren = true;\n                }\n              } else {\n                mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);\n                shouldResetChildren = true;\n              } // Try the next child.\n\n\n              nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can\n              // keep comparing if they line up.\n\n              if (!shouldResetChildren && prevChildAtSameIndex !== null) {\n                prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n              }\n            } // If we have no more children, but used to, they don't line up.\n\n\n            if (prevChildAtSameIndex !== null) {\n              shouldResetChildren = true;\n            }\n          } else {\n            if (traceUpdatesEnabled) {\n              // If we're tracing updates and we've bailed out before reaching a host node,\n              // we should fall back to recursively marking the nearest host descendants for highlight.\n              if (traceNearestHostComponentUpdate) {\n                var hostFibers = findAllCurrentHostFibers(getFiberID(getPrimaryFiber(nextFiber)));\n                hostFibers.forEach(function (hostFiber) {\n                  traceUpdatesForNodes.add(hostFiber.stateNode);\n                });\n              }\n            }\n          }\n        }\n\n        if (shouldIncludeInTree) {\n          var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');\n\n          if (isProfilingSupported) {\n            recordProfilingDurations(nextFiber);\n          }\n        }\n\n        if (shouldResetChildren) {\n          // We need to crawl the subtree for closest non-filtered Fibers\n          // so that we can display them in a flat children set.\n          if (shouldIncludeInTree) {\n            // Normally, search for children from the rendered child.\n            var nextChildSet = nextFiber.child;\n\n            if (nextDidTimeOut) {\n              // Special case: timed-out Suspense renders the fallback set.\n              var _nextFiberChild2 = nextFiber.child;\n              nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;\n            }\n\n            if (nextChildSet != null) {\n              recordResetChildren(nextFiber, nextChildSet);\n            } // We've handled the child order change for this Fiber.\n            // Since it's included, there's no need to invalidate parent child order.\n\n\n            return false;\n          } else {\n            // Let the closest unfiltered parent Fiber reset its child order instead.\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      function cleanup() {// We don't patch any methods so there is no cleanup.\n      }\n\n      function flushInitialOperations() {\n        var localPendingOperationsQueue = pendingOperationsQueue;\n        pendingOperationsQueue = null;\n\n        if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {\n          // We may have already queued up some operations before the frontend connected\n          // If so, let the frontend know about them.\n          localPendingOperationsQueue.forEach(function (operations) {\n            hook.emit('operations', operations);\n          });\n        } else {\n          // Before the traversals, remember to start tracking\n          // our path in case we have selection to restore.\n          if (trackedPath !== null) {\n            mightBeOnTrackedPath = true;\n          } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.\n\n\n          hook.getFiberRoots(rendererID).forEach(function (root) {\n            currentRootID = getFiberID(getPrimaryFiber(root.current));\n            setRootPseudoKey(currentRootID, root.current); // Checking root.memoizedInteractions handles multi-renderer edge-case-\n            // where some v16 renderers support profiling and others don't.\n\n            if (isProfiling && root.memoizedInteractions != null) {\n              // If profiling is active, store commit time and duration, and the current interactions.\n              // The frontend may request this information after profiling has stopped.\n              currentCommitProfilingMetadata = {\n                changeDescriptions: recordChangeDescriptions ? new Map() : null,\n                durations: [],\n                commitTime: getCurrentTime() - profilingStartTime,\n                interactions: Array.from(root.memoizedInteractions).map(function (interaction) {\n                  return _objectSpread({}, interaction, {\n                    timestamp: interaction.timestamp - profilingStartTime\n                  });\n                }),\n                maxActualDuration: 0,\n                priorityLevel: null\n              };\n            }\n\n            mountFiberRecursively(root.current, null, false, false);\n            flushPendingEvents(root);\n            currentRootID = -1;\n          });\n        }\n      }\n\n      function handleCommitFiberUnmount(fiber) {\n        // This is not recursive.\n        // We can't traverse fibers after unmounting so instead\n        // we rely on React telling us about each unmount.\n        recordUnmount(fiber, false);\n      }\n\n      function handleCommitFiberRoot(root, priorityLevel) {\n        var current = root.current;\n        var alternate = current.alternate;\n        currentRootID = getFiberID(getPrimaryFiber(current)); // Before the traversals, remember to start tracking\n        // our path in case we have selection to restore.\n\n        if (trackedPath !== null) {\n          mightBeOnTrackedPath = true;\n        }\n\n        if (traceUpdatesEnabled) {\n          traceUpdatesForNodes.clear();\n        } // Checking root.memoizedInteractions handles multi-renderer edge-case-\n        // where some v16 renderers support profiling and others don't.\n\n\n        var isProfilingSupported = root.memoizedInteractions != null;\n\n        if (isProfiling && isProfilingSupported) {\n          // If profiling is active, store commit time and duration, and the current interactions.\n          // The frontend may request this information after profiling has stopped.\n          currentCommitProfilingMetadata = {\n            changeDescriptions: recordChangeDescriptions ? new Map() : null,\n            durations: [],\n            commitTime: getCurrentTime() - profilingStartTime,\n            interactions: Array.from(root.memoizedInteractions).map(function (interaction) {\n              return _objectSpread({}, interaction, {\n                timestamp: interaction.timestamp - profilingStartTime\n              });\n            }),\n            maxActualDuration: 0,\n            priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel)\n          };\n        }\n\n        if (alternate) {\n          // TODO: relying on this seems a bit fishy.\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n          if (!wasMounted && isMounted) {\n            // Mount a new root.\n            setRootPseudoKey(currentRootID, current);\n            mountFiberRecursively(current, null, false, false);\n          } else if (wasMounted && isMounted) {\n            // Update an existing root.\n            updateFiberRecursively(current, alternate, null, false);\n          } else if (wasMounted && !isMounted) {\n            // Unmount an existing root.\n            removeRootPseudoKey(currentRootID);\n            recordUnmount(current, false);\n          }\n        } else {\n          // Mount a new root.\n          setRootPseudoKey(currentRootID, current);\n          mountFiberRecursively(current, null, false, false);\n        }\n\n        if (isProfiling && isProfilingSupported) {\n          var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);\n\n          if (commitProfilingMetadata != null) {\n            commitProfilingMetadata.push(currentCommitProfilingMetadata);\n          } else {\n            rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);\n          }\n        } // We're done here.\n\n\n        flushPendingEvents(root);\n\n        if (traceUpdatesEnabled) {\n          hook.emit('traceUpdates', traceUpdatesForNodes);\n        }\n\n        currentRootID = -1;\n      }\n\n      function findAllCurrentHostFibers(id) {\n        var fibers = [];\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (!fiber) {\n          return fibers;\n        } // Next we'll drill down this component to find all HostComponent/Text.\n\n\n        var node = fiber;\n\n        while (true) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            fibers.push(node);\n          } else if (node.child) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === fiber) {\n            return fibers;\n          }\n\n          while (!node.sibling) {\n            if (!node.return || node.return === fiber) {\n              return fibers;\n            }\n\n            node = node.return;\n          }\n\n          node.sibling.return = node.return;\n          node = node.sibling;\n        } // Flow needs the return here, but ESLint complains about it.\n        // eslint-disable-next-line no-unreachable\n\n\n        return fibers;\n      }\n\n      function findNativeNodesForFiberID(id) {\n        try {\n          var _fiber = findCurrentFiberUsingSlowPathById(id);\n\n          if (_fiber === null) {\n            return null;\n          } // Special case for a timed-out Suspense.\n\n\n          var isTimedOutSuspense = _fiber.tag === SuspenseComponent && _fiber.memoizedState !== null;\n\n          if (isTimedOutSuspense) {\n            // A timed-out Suspense's findDOMNode is useless.\n            // Try our best to find the fallback directly.\n            var maybeFallbackFiber = _fiber.child && _fiber.child.sibling;\n\n            if (maybeFallbackFiber != null) {\n              _fiber = maybeFallbackFiber;\n            }\n          }\n\n          var hostFibers = findAllCurrentHostFibers(id);\n          return hostFibers.map(function (hostFiber) {\n            return hostFiber.stateNode;\n          }).filter(Boolean);\n        } catch (err) {\n          // The fiber might have unmounted by now.\n          return null;\n        }\n      }\n\n      function getDisplayNameForFiberID(id) {\n        var fiber = idToFiberMap.get(id);\n        return fiber != null ? getDisplayNameForFiber(fiber) : null;\n      }\n\n      function getFiberIDForNative(hostInstance) {\n        var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var fiber = renderer.findFiberByHostInstance(hostInstance);\n\n        if (fiber != null) {\n          if (findNearestUnfilteredAncestor) {\n            while (fiber !== null && shouldFilterFiber(fiber)) {\n              fiber = fiber.return;\n            }\n          }\n\n          return getFiberID(getPrimaryFiber(fiber));\n        }\n\n        return null;\n      }\n\n      var MOUNTING = 1;\n      var MOUNTED = 2;\n      var UNMOUNTED = 3; // This function is copied from React and should be kept in sync:\n      // https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n      function isFiberMountedImpl(fiber) {\n        var node = fiber;\n\n        if (!fiber.alternate) {\n          // If there is no alternate, this might be a new tree that isn't inserted\n          // yet. If it is, then it will have a pending insertion effect on it.\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n\n          while (node.return) {\n            node = node.return;\n\n            if ((node.effectTag & Placement) !== NoEffect) {\n              return MOUNTING;\n            }\n          }\n        } else {\n          while (node.return) {\n            node = node.return;\n          }\n        }\n\n        if (node.tag === HostRoot) {\n          // TODO: Check if this was a nested HostRoot when used with\n          // renderContainerIntoSubtree.\n          return MOUNTED;\n        } // If we didn't hit the root, that means that we're in an disconnected tree\n        // that has been unmounted.\n\n\n        return UNMOUNTED;\n      } // This function is copied from React and should be kept in sync:\n      // https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberTreeReflection.js\n      // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).\n      // BEGIN copied code\n\n\n      function findCurrentFiberUsingSlowPathById(id) {\n        var fiber = idToFiberMap.get(id);\n\n        if (fiber == null) {\n          console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n          return null;\n        }\n\n        var alternate = fiber.alternate;\n\n        if (!alternate) {\n          // If there is no alternate, then we only need to check if it is mounted.\n          var state = isFiberMountedImpl(fiber);\n\n          if (state === UNMOUNTED) {\n            throw Error('Unable to find node on an unmounted component.');\n          }\n\n          if (state === MOUNTING) {\n            return null;\n          }\n\n          return fiber;\n        } // If we have two possible branches, we'll walk backwards up to the root\n        // to see what path the root points to. On the way we may hit one of the\n        // special cases and we'll deal with them.\n\n\n        var a = fiber;\n        var b = alternate;\n\n        while (true) {\n          var parentA = a.return;\n\n          if (parentA === null) {\n            // We're at the root.\n            break;\n          }\n\n          var parentB = parentA.alternate;\n\n          if (parentB === null) {\n            // There is no alternate. This is an unusual case. Currently, it only\n            // happens when a Suspense component is hidden. An extra fragment fiber\n            // is inserted in between the Suspense fiber and its children. Skip\n            // over this extra fragment fiber and proceed to the next parent.\n            var nextParent = parentA.return;\n\n            if (nextParent !== null) {\n              a = b = nextParent;\n              continue;\n            } // If there's no parent, we're at the root.\n\n\n            break;\n          } // If both copies of the parent fiber point to the same child, we can\n          // assume that the child is current. This happens when we bailout on low\n          // priority: the bailed out fiber's child reuses the current child.\n\n\n          if (parentA.child === parentB.child) {\n            var child = parentA.child;\n\n            while (child) {\n              if (child === a) {\n                // We've determined that A is the current branch.\n                if (isFiberMountedImpl(parentA) !== MOUNTED) {\n                  throw Error('Unable to find node on an unmounted component.');\n                }\n\n                return fiber;\n              }\n\n              if (child === b) {\n                // We've determined that B is the current branch.\n                if (isFiberMountedImpl(parentA) !== MOUNTED) {\n                  throw Error('Unable to find node on an unmounted component.');\n                }\n\n                return alternate;\n              }\n\n              child = child.sibling;\n            } // We should never have an alternate for any mounting node. So the only\n            // way this could possibly happen is if this was unmounted, if at all.\n\n\n            throw Error('Unable to find node on an unmounted component.');\n          }\n\n          if (a.return !== b.return) {\n            // The return pointer of A and the return pointer of B point to different\n            // fibers. We assume that return pointers never criss-cross, so A must\n            // belong to the child set of A.return, and B must belong to the child\n            // set of B.return.\n            a = parentA;\n            b = parentB;\n          } else {\n            // The return pointers point to the same fiber. We'll have to use the\n            // default, slow path: scan the child sets of each parent alternate to see\n            // which child belongs to which set.\n            //\n            // Search parent A's child set\n            var didFindChild = false;\n            var _child = parentA.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentA;\n                b = parentB;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentA;\n                a = parentB;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            if (!didFindChild) {\n              // Search parent B's child set\n              _child = parentB.child;\n\n              while (_child) {\n                if (_child === a) {\n                  didFindChild = true;\n                  a = parentB;\n                  b = parentA;\n                  break;\n                }\n\n                if (_child === b) {\n                  didFindChild = true;\n                  b = parentB;\n                  a = parentA;\n                  break;\n                }\n\n                _child = _child.sibling;\n              }\n\n              if (!didFindChild) {\n                throw Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n              }\n            }\n          }\n\n          if (a.alternate !== b) {\n            throw Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n          }\n        } // If the root is not a host container, we're in a disconnected tree. I.e.\n        // unmounted.\n\n\n        if (a.tag !== HostRoot) {\n          throw Error('Unable to find node on an unmounted component.');\n        }\n\n        if (a.stateNode.current === a) {\n          // We've determined that A is the current branch.\n          return fiber;\n        } // Otherwise B has to be current branch.\n\n\n        return alternate;\n      } // END copied code\n\n\n      function prepareViewAttributeSource(id, path) {\n        var isCurrent = isMostRecentlyInspectedElementCurrent(id);\n\n        if (isCurrent) {\n          window.$attribute = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path);\n        }\n      }\n\n      function prepareViewElementSource(id) {\n        var fiber = idToFiberMap.get(id);\n\n        if (fiber == null) {\n          console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        var elementType = fiber.elementType,\n            tag = fiber.tag,\n            type = fiber.type;\n\n        switch (tag) {\n          case ClassComponent:\n          case IncompleteClassComponent:\n          case IndeterminateComponent:\n          case FunctionComponent:\n            global.$type = type;\n            break;\n\n          case ForwardRef:\n            global.$type = type.render;\n            break;\n\n          case MemoComponent:\n          case SimpleMemoComponent:\n            global.$type = elementType != null && elementType.type != null ? elementType.type : type;\n            break;\n\n          default:\n            global.$type = null;\n            break;\n        }\n      }\n\n      function getOwnersList(id) {\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber == null) {\n          return null;\n        }\n\n        var _debugOwner = fiber._debugOwner;\n        var owners = [{\n          displayName: getDisplayNameForFiber(fiber) || 'Anonymous',\n          id: id,\n          type: getElementTypeForFiber(fiber)\n        }];\n\n        if (_debugOwner) {\n          var owner = _debugOwner;\n\n          while (owner !== null) {\n            owners.unshift({\n              displayName: getDisplayNameForFiber(owner) || 'Anonymous',\n              id: getFiberID(getPrimaryFiber(owner)),\n              type: getElementTypeForFiber(owner)\n            });\n            owner = owner._debugOwner || null;\n          }\n        }\n\n        return owners;\n      } // Fast path props lookup for React Native style editor.\n      // Could use inspectElementRaw() but that would require shallow rendering hooks components,\n      // and could also mess with memoization.\n\n\n      function getInstanceAndStyle(id) {\n        var instance = null;\n        var style = null;\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber !== null) {\n          instance = fiber.stateNode;\n\n          if (fiber.memoizedProps !== null) {\n            style = fiber.memoizedProps.style;\n          }\n        }\n\n        return {\n          instance: instance,\n          style: style\n        };\n      }\n\n      function inspectElementRaw(id) {\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber == null) {\n          return null;\n        }\n\n        var _debugOwner = fiber._debugOwner,\n            _debugSource = fiber._debugSource,\n            stateNode = fiber.stateNode,\n            key = fiber.key,\n            memoizedProps = fiber.memoizedProps,\n            memoizedState = fiber.memoizedState,\n            dependencies = fiber.dependencies,\n            tag = fiber.tag,\n            type = fiber.type;\n        var elementType = getElementTypeForFiber(fiber);\n        var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies);\n        var typeSymbol = getTypeSymbol(type);\n        var canViewSource = false;\n        var context = null;\n\n        if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {\n          canViewSource = true;\n\n          if (stateNode && stateNode.context != null) {\n            // Don't show an empty context object for class components that don't use the context API.\n            var shouldHideContext = elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"] && !(type.contextTypes || type.contextType);\n\n            if (!shouldHideContext) {\n              context = stateNode.context;\n            }\n          }\n        } else if (typeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"] || typeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]) {\n          // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n          // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n          // NOTE Keep in sync with getDisplayNameForFiber()\n          var consumerResolvedContext = type._context || type; // Global context value.\n\n          context = consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n          var _current = fiber.return;\n\n          while (_current !== null) {\n            var currentType = _current.type;\n            var currentTypeSymbol = getTypeSymbol(currentType);\n\n            if (currentTypeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"] || currentTypeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]) {\n              // 16.3.0 exposed the context object as \"context\"\n              // PR #12501 changed it to \"_context\" for 16.3.1+\n              // NOTE Keep in sync with getDisplayNameForFiber()\n              var providerResolvedContext = currentType._context || currentType.context;\n\n              if (providerResolvedContext === consumerResolvedContext) {\n                context = _current.memoizedProps.value;\n                break;\n              }\n            }\n\n            _current = _current.return;\n          }\n        }\n\n        var hasLegacyContext = false;\n\n        if (context !== null) {\n          hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.\n          // Otherwise simple values (e.g. strings, booleans) become harder to handle.\n\n          context = {\n            value: context\n          };\n        }\n\n        var owners = null;\n\n        if (_debugOwner) {\n          owners = [];\n          var owner = _debugOwner;\n\n          while (owner !== null) {\n            owners.push({\n              displayName: getDisplayNameForFiber(owner) || 'Anonymous',\n              id: getFiberID(getPrimaryFiber(owner)),\n              type: getElementTypeForFiber(owner)\n            });\n            owner = owner._debugOwner || null;\n          }\n        }\n\n        var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;\n        var hooks = null;\n\n        if (usesHooks) {\n          var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.\n\n          for (var method in console) {\n            try {\n              originalConsoleMethods[method] = console[method]; // $FlowFixMe property error|warn is not writable.\n\n              console[method] = function () {};\n            } catch (error) {}\n          }\n\n          try {\n            hooks = Object(react_debug_tools__WEBPACK_IMPORTED_MODULE_6__[\"inspectHooksOfFiber\"])(fiber, renderer.currentDispatcherRef);\n          } finally {\n            // Restore original console functionality.\n            for (var _method in originalConsoleMethods) {\n              try {\n                // $FlowFixMe property error|warn is not writable.\n                console[_method] = originalConsoleMethods[_method];\n              } catch (error) {}\n            }\n          }\n        }\n\n        var rootType = null;\n        var current = fiber;\n\n        while (current.return !== null) {\n          current = current.return;\n        }\n\n        var fiberRoot = current.stateNode;\n\n        if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n          rootType = fiberRoot._debugRootType;\n        }\n\n        return {\n          id: id,\n          // Does the current renderer support editable hooks?\n          canEditHooks: typeof overrideHookState === 'function',\n          // Does the current renderer support editable function props?\n          canEditFunctionProps: typeof overrideProps === 'function',\n          canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.\n          !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,\n          // allow toggling it back to remove the fallback override.\n          forceFallbackForSuspenseIDs.has(id)),\n          // Can view component source location.\n          canViewSource: canViewSource,\n          // Does the component have legacy context attached to it.\n          hasLegacyContext: hasLegacyContext,\n          key: key != null ? key : null,\n          displayName: getDisplayNameForFiber(fiber),\n          type: elementType,\n          // Inspectable properties.\n          // TODO Review sanitization approach for the below inspectable values.\n          context: context,\n          hooks: hooks,\n          props: memoizedProps,\n          state: usesHooks ? null : memoizedState,\n          // List of owners\n          owners: owners,\n          // Location of component in source code.\n          source: _debugSource || null,\n          rootType: rootType,\n          rendererPackageName: renderer.rendererPackageName,\n          rendererVersion: renderer.version\n        };\n      }\n\n      var mostRecentlyInspectedElement = null;\n      var hasElementUpdatedSinceLastInspected = false;\n      var currentlyInspectedPaths = {};\n\n      function isMostRecentlyInspectedElementCurrent(id) {\n        return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && !hasElementUpdatedSinceLastInspected;\n      } // Track the intersection of currently inspected paths,\n      // so that we can send their data along if the element is re-rendered.\n\n\n      function mergeInspectedPaths(path) {\n        var current = currentlyInspectedPaths;\n        path.forEach(function (key) {\n          if (!current[key]) {\n            current[key] = {};\n          }\n\n          current = current[key];\n        });\n      }\n\n      function createIsPathAllowed(key, secondaryCategory) {\n        // This function helps prevent previously-inspected paths from being dehydrated in updates.\n        // This is important to avoid a bad user experience where expanded toggles collapse on update.\n        return function isPathAllowed(path) {\n          switch (secondaryCategory) {\n            case 'hooks':\n              if (path.length === 1) {\n                // Never dehydrate the \"hooks\" object at the top levels.\n                return true;\n              }\n\n              if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {\n                // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,\n                // so it's easiest for now if we just don't break on this boundary.\n                // We can always dehydrate a level deeper (in the value object).\n                return true;\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];\n\n          if (!current) {\n            return false;\n          }\n\n          for (var i = 0; i < path.length; i++) {\n            current = current[path[i]];\n\n            if (!current) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n      }\n\n      function updateSelectedElement(inspectedElement) {\n        var hooks = inspectedElement.hooks,\n            id = inspectedElement.id,\n            props = inspectedElement.props;\n        var fiber = idToFiberMap.get(id);\n\n        if (fiber == null) {\n          console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        var elementType = fiber.elementType,\n            stateNode = fiber.stateNode,\n            tag = fiber.tag,\n            type = fiber.type;\n\n        switch (tag) {\n          case ClassComponent:\n          case IncompleteClassComponent:\n          case IndeterminateComponent:\n            global.$r = stateNode;\n            break;\n\n          case FunctionComponent:\n            global.$r = {\n              hooks: hooks,\n              props: props,\n              type: type\n            };\n            break;\n\n          case ForwardRef:\n            global.$r = {\n              props: props,\n              type: type.render\n            };\n            break;\n\n          case MemoComponent:\n          case SimpleMemoComponent:\n            global.$r = {\n              props: props,\n              type: elementType != null && elementType.type != null ? elementType.type : type\n            };\n            break;\n\n          default:\n            global.$r = null;\n            break;\n        }\n      }\n\n      function storeAsGlobal(id, path, count) {\n        var isCurrent = isMostRecentlyInspectedElementCurrent(id);\n\n        if (isCurrent) {\n          var value = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path);\n          var key = \"$reactTemp\".concat(count);\n          window[key] = value;\n          console.log(key);\n          console.log(value);\n        }\n      }\n\n      function copyElementPath(id, path) {\n        var isCurrent = isMostRecentlyInspectedElementCurrent(id);\n\n        if (isCurrent) {\n          Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyToClipboard\"])(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path));\n        }\n      }\n\n      function inspectElement(id, path) {\n        var isCurrent = isMostRecentlyInspectedElementCurrent(id);\n\n        if (isCurrent) {\n          if (path != null) {\n            mergeInspectedPaths(path);\n            var secondaryCategory = null;\n\n            if (path[0] === 'hooks') {\n              secondaryCategory = 'hooks';\n            } // If this element has not been updated since it was last inspected,\n            // we can just return the subset of data in the newly-inspected path.\n\n\n            return {\n              id: id,\n              type: 'hydrated-path',\n              path: path,\n              value: Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)\n            };\n          } else {\n            // If this element has not been updated since it was last inspected, we don't need to re-run it.\n            // Instead we can just return the ID to indicate that it has not changed.\n            return {\n              id: id,\n              type: 'no-change'\n            };\n          }\n        } else {\n          hasElementUpdatedSinceLastInspected = false;\n\n          if (mostRecentlyInspectedElement === null || mostRecentlyInspectedElement.id !== id) {\n            currentlyInspectedPaths = {};\n          }\n\n          mostRecentlyInspectedElement = inspectElementRaw(id);\n\n          if (mostRecentlyInspectedElement === null) {\n            return {\n              id: id,\n              type: 'not-found'\n            };\n          }\n\n          if (path != null) {\n            mergeInspectedPaths(path);\n          } // Any time an inspected element has an update,\n          // we should update the selected $r value as wel.\n          // Do this before dehydration (cleanForBridge).\n\n\n          updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.\n          // This will enable us to send patches without re-inspecting if hydrated paths are requested.\n          // (Reducing how often we shallow-render is a better DX for function components that use hooks.)\n\n          var cleanedInspectedElement = _objectSpread({}, mostRecentlyInspectedElement);\n\n          cleanedInspectedElement.context = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.context, createIsPathAllowed('context', null));\n          cleanedInspectedElement.hooks = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks'));\n          cleanedInspectedElement.props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.props, createIsPathAllowed('props', null));\n          cleanedInspectedElement.state = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.state, createIsPathAllowed('state', null));\n          return {\n            id: id,\n            type: 'full-data',\n            value: cleanedInspectedElement\n          };\n        }\n      }\n\n      function logElementToConsole(id) {\n        var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);\n\n        if (result === null) {\n          console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        var supportsGroup = typeof console.groupCollapsed === 'function';\n\n        if (supportsGroup) {\n          console.groupCollapsed(\"[Click to expand] %c<\".concat(result.displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n          'color: var(--dom-tag-name-color); font-weight: normal;');\n        }\n\n        if (result.props !== null) {\n          console.log('Props:', result.props);\n        }\n\n        if (result.state !== null) {\n          console.log('State:', result.state);\n        }\n\n        if (result.hooks !== null) {\n          console.log('Hooks:', result.hooks);\n        }\n\n        var nativeNodes = findNativeNodesForFiberID(id);\n\n        if (nativeNodes !== null) {\n          console.log('Nodes:', nativeNodes);\n        }\n\n        if (result.source !== null) {\n          console.log('Location:', result.source);\n        }\n\n        if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n          console.log('Right-click any value to save it as a global variable for further inspection.');\n        }\n\n        if (supportsGroup) {\n          console.groupEnd();\n        }\n      }\n\n      function setInHook(id, index, path, value) {\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber !== null) {\n          if (typeof overrideHookState === 'function') {\n            overrideHookState(fiber, index, path, value);\n          }\n        }\n      }\n\n      function setInProps(id, path, value) {\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber !== null) {\n          var instance = fiber.stateNode;\n\n          if (instance === null) {\n            if (typeof overrideProps === 'function') {\n              overrideProps(fiber, path, value);\n            }\n          } else {\n            fiber.pendingProps = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyWithSet\"])(instance.props, path, value);\n            instance.forceUpdate();\n          }\n        }\n      }\n\n      function setInState(id, path, value) {\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber !== null) {\n          var instance = fiber.stateNode;\n          Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"setInObject\"])(instance.state, path, value);\n          instance.forceUpdate();\n        }\n      }\n\n      function setInContext(id, path, value) {\n        // To simplify hydration and display of primitive context values (e.g. number, string)\n        // the inspectElement() method wraps context in a {value: ...} object.\n        // We need to remove the first part of the path (the \"value\") before continuing.\n        path = path.slice(1);\n        var fiber = findCurrentFiberUsingSlowPathById(id);\n\n        if (fiber !== null) {\n          var instance = fiber.stateNode;\n\n          if (path.length === 0) {\n            // Simple context value\n            instance.context = value;\n          } else {\n            Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"setInObject\"])(instance.context, path, value);\n          }\n\n          instance.forceUpdate();\n        }\n      }\n\n      var currentCommitProfilingMetadata = null;\n      var displayNamesByRootID = null;\n      var idToContextsMap = null;\n      var initialTreeBaseDurationsMap = null;\n      var initialIDToRootMap = null;\n      var isProfiling = false;\n      var profilingStartTime = 0;\n      var recordChangeDescriptions = false;\n      var rootToCommitProfilingMetadataMap = null;\n\n      function getProfilingData() {\n        var dataForRoots = [];\n\n        if (rootToCommitProfilingMetadataMap === null) {\n          throw Error('getProfilingData() called before any profiling data was recorded');\n        }\n\n        rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {\n          var commitData = [];\n          var initialTreeBaseDurations = [];\n          var allInteractions = new Map();\n          var interactionCommits = new Map();\n          var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';\n\n          if (initialTreeBaseDurationsMap != null) {\n            initialTreeBaseDurationsMap.forEach(function (treeBaseDuration, id) {\n              if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {\n                // We don't need to convert milliseconds to microseconds in this case,\n                // because the profiling summary is JSON serialized.\n                initialTreeBaseDurations.push([id, treeBaseDuration]);\n              }\n            });\n          }\n\n          commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {\n            var changeDescriptions = commitProfilingData.changeDescriptions,\n                durations = commitProfilingData.durations,\n                interactions = commitProfilingData.interactions,\n                maxActualDuration = commitProfilingData.maxActualDuration,\n                priorityLevel = commitProfilingData.priorityLevel,\n                commitTime = commitProfilingData.commitTime;\n            var interactionIDs = [];\n            interactions.forEach(function (interaction) {\n              if (!allInteractions.has(interaction.id)) {\n                allInteractions.set(interaction.id, interaction);\n              }\n\n              interactionIDs.push(interaction.id);\n              var commitIndices = interactionCommits.get(interaction.id);\n\n              if (commitIndices != null) {\n                commitIndices.push(commitIndex);\n              } else {\n                interactionCommits.set(interaction.id, [commitIndex]);\n              }\n            });\n            var fiberActualDurations = [];\n            var fiberSelfDurations = [];\n\n            for (var i = 0; i < durations.length; i += 3) {\n              var fiberID = durations[i];\n              fiberActualDurations.push([fiberID, durations[i + 1]]);\n              fiberSelfDurations.push([fiberID, durations[i + 2]]);\n            }\n\n            commitData.push({\n              changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,\n              duration: maxActualDuration,\n              fiberActualDurations: fiberActualDurations,\n              fiberSelfDurations: fiberSelfDurations,\n              interactionIDs: interactionIDs,\n              priorityLevel: priorityLevel,\n              timestamp: commitTime\n            });\n          });\n          dataForRoots.push({\n            commitData: commitData,\n            displayName: displayName,\n            initialTreeBaseDurations: initialTreeBaseDurations,\n            interactionCommits: Array.from(interactionCommits.entries()),\n            interactions: Array.from(allInteractions.entries()),\n            rootID: rootID\n          });\n        });\n        return {\n          dataForRoots: dataForRoots,\n          rendererID: rendererID\n        };\n      }\n\n      function startProfiling(shouldRecordChangeDescriptions) {\n        if (isProfiling) {\n          return;\n        }\n\n        recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.\n        // It's important we snapshot both the durations and the id-to-root map,\n        // since either of these may change during the profiling session\n        // (e.g. when a fiber is re-rendered or when a fiber gets removed).\n\n        displayNamesByRootID = new Map();\n        initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);\n        initialIDToRootMap = new Map(idToRootMap);\n        idToContextsMap = new Map();\n        hook.getFiberRoots(rendererID).forEach(function (root) {\n          var rootID = getFiberID(getPrimaryFiber(root.current));\n          displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));\n\n          if (shouldRecordChangeDescriptions) {\n            // Record all contexts at the time profiling is started.\n            // Fibers only store the current context value,\n            // so we need to track them separately in order to determine changed keys.\n            crawlToInitializeContextsMap(root.current);\n          }\n        });\n        isProfiling = true;\n        profilingStartTime = getCurrentTime();\n        rootToCommitProfilingMetadataMap = new Map();\n      }\n\n      function stopProfiling() {\n        isProfiling = false;\n        recordChangeDescriptions = false;\n      } // Automatically start profiling so that we don't miss timing info from initial \"mount\".\n\n\n      if (Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_5__[\"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\"]) === 'true') {\n        startProfiling(Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_5__[\"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\"]) === 'true');\n      } // React will switch between these implementations depending on whether\n      // we have any manually suspended Fibers or not.\n\n\n      function shouldSuspendFiberAlwaysFalse() {\n        return false;\n      }\n\n      var forceFallbackForSuspenseIDs = new Set();\n\n      function shouldSuspendFiberAccordingToSet(fiber) {\n        var id = getFiberID(getPrimaryFiber(fiber));\n        return forceFallbackForSuspenseIDs.has(id);\n      }\n\n      function overrideSuspense(id, forceFallback) {\n        if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n          throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');\n        }\n\n        if (forceFallback) {\n          forceFallbackForSuspenseIDs.add(id);\n\n          if (forceFallbackForSuspenseIDs.size === 1) {\n            // First override is added. Switch React to slower path.\n            setSuspenseHandler(shouldSuspendFiberAccordingToSet);\n          }\n        } else {\n          forceFallbackForSuspenseIDs.delete(id);\n\n          if (forceFallbackForSuspenseIDs.size === 0) {\n            // Last override is gone. Switch React back to fast path.\n            setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n          }\n        }\n\n        var fiber = idToFiberMap.get(id);\n\n        if (fiber != null) {\n          scheduleUpdate(fiber);\n        }\n      } // Remember if we're trying to restore the selection after reload.\n      // In that case, we'll do some extra checks for matching mounts.\n\n\n      var trackedPath = null;\n      var trackedPathMatchFiber = null;\n      var trackedPathMatchDepth = -1;\n      var mightBeOnTrackedPath = false;\n\n      function setTrackedPath(path) {\n        if (path === null) {\n          trackedPathMatchFiber = null;\n          trackedPathMatchDepth = -1;\n          mightBeOnTrackedPath = false;\n        }\n\n        trackedPath = path;\n      } // We call this before traversing a new mount.\n      // It remembers whether this Fiber is the next best match for tracked path.\n      // The return value signals whether we should keep matching siblings or not.\n\n\n      function updateTrackedPathStateBeforeMount(fiber) {\n        if (trackedPath === null || !mightBeOnTrackedPath) {\n          // Fast path: there's nothing to track so do nothing and ignore siblings.\n          return false;\n        }\n\n        var returnFiber = fiber.return;\n        var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.\n        // Is this newly mounted Fiber a direct child of the current best match?\n        // (This will also be true for new roots if we haven't matched anything yet.)\n\n        if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {\n          // Is this the next Fiber we should select? Let's compare the frames.\n          var actualFrame = getPathFrame(fiber);\n          var expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n          if (expectedFrame === undefined) {\n            throw new Error('Expected to see a frame at the next depth.');\n          }\n\n          if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n            // We have our next match.\n            trackedPathMatchFiber = fiber;\n            trackedPathMatchDepth++; // Are we out of frames to match?\n\n            if (trackedPathMatchDepth === trackedPath.length - 1) {\n              // There's nothing that can possibly match afterwards.\n              // Don't check the children.\n              mightBeOnTrackedPath = false;\n            } else {\n              // Check the children, as they might reveal the next match.\n              mightBeOnTrackedPath = true;\n            } // In either case, since we have a match, we don't need\n            // to check the siblings. They'll never match.\n\n\n            return false;\n          }\n        } // This Fiber's parent is on the path, but this Fiber itself isn't.\n        // There's no need to check its children--they won't be on the path either.\n\n\n        mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n        return true;\n      }\n\n      function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {\n        // updateTrackedPathStateBeforeMount() told us whether to match siblings.\n        // Now that we're entering siblings, let's use that information.\n        mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;\n      } // Roots don't have a real persistent identity.\n      // A root's \"pseudo key\" is \"childDisplayName:indexWithThatName\".\n      // For example, \"App:0\" or, in case of similar roots, \"Story:0\", \"Story:1\", etc.\n      // We will use this to try to disambiguate roots when restoring selection between reloads.\n\n\n      var rootPseudoKeys = new Map();\n      var rootDisplayNameCounter = new Map();\n\n      function setRootPseudoKey(id, fiber) {\n        var name = getDisplayNameForRoot(fiber);\n        var counter = rootDisplayNameCounter.get(name) || 0;\n        rootDisplayNameCounter.set(name, counter + 1);\n        var pseudoKey = \"\".concat(name, \":\").concat(counter);\n        rootPseudoKeys.set(id, pseudoKey);\n      }\n\n      function removeRootPseudoKey(id) {\n        var pseudoKey = rootPseudoKeys.get(id);\n\n        if (pseudoKey === undefined) {\n          throw new Error('Expected root pseudo key to be known.');\n        }\n\n        var name = pseudoKey.substring(0, pseudoKey.lastIndexOf(':'));\n        var counter = rootDisplayNameCounter.get(name);\n\n        if (counter === undefined) {\n          throw new Error('Expected counter to be known.');\n        }\n\n        if (counter > 1) {\n          rootDisplayNameCounter.set(name, counter - 1);\n        } else {\n          rootDisplayNameCounter.delete(name);\n        }\n\n        rootPseudoKeys.delete(id);\n      }\n\n      function getDisplayNameForRoot(fiber) {\n        var preferredDisplayName = null;\n        var fallbackDisplayName = null;\n        var child = fiber.child; // Go at most three levels deep into direct children\n        // while searching for a child that has a displayName.\n\n        for (var i = 0; i < 3; i++) {\n          if (child === null) {\n            break;\n          }\n\n          var displayName = getDisplayNameForFiber(child);\n\n          if (displayName !== null) {\n            // Prefer display names that we get from user-defined components.\n            // We want to avoid using e.g. 'Suspense' unless we find nothing else.\n            if (typeof child.type === 'function') {\n              // There's a few user-defined tags, but we'll prefer the ones\n              // that are usually explicitly named (function or class components).\n              preferredDisplayName = displayName;\n            } else if (fallbackDisplayName === null) {\n              fallbackDisplayName = displayName;\n            }\n          }\n\n          if (preferredDisplayName !== null) {\n            break;\n          }\n\n          child = child.child;\n        }\n\n        return preferredDisplayName || fallbackDisplayName || 'Anonymous';\n      }\n\n      function getPathFrame(fiber) {\n        var key = fiber.key;\n        var displayName = getDisplayNameForFiber(fiber);\n        var index = fiber.index;\n\n        switch (fiber.tag) {\n          case HostRoot:\n            // Roots don't have a real displayName, index, or key.\n            // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).\n            var id = getFiberID(getPrimaryFiber(fiber));\n            var pseudoKey = rootPseudoKeys.get(id);\n\n            if (pseudoKey === undefined) {\n              throw new Error('Expected mounted root to have known pseudo key.');\n            }\n\n            displayName = pseudoKey;\n            break;\n\n          case HostComponent:\n            displayName = fiber.type;\n            break;\n\n          default:\n            break;\n        }\n\n        return {\n          displayName: displayName,\n          key: key,\n          index: index\n        };\n      } // Produces a serializable representation that does a best effort\n      // of identifying a particular Fiber between page reloads.\n      // The return path will contain Fibers that are \"invisible\" to the store\n      // because their keys and indexes are important to restoring the selection.\n\n\n      function getPathForElement(id) {\n        var fiber = idToFiberMap.get(id);\n\n        if (fiber == null) {\n          return null;\n        }\n\n        var keyPath = [];\n\n        while (fiber !== null) {\n          keyPath.push(getPathFrame(fiber));\n          fiber = fiber.return;\n        }\n\n        keyPath.reverse();\n        return keyPath;\n      }\n\n      function getBestMatchForTrackedPath() {\n        if (trackedPath === null) {\n          // Nothing to match.\n          return null;\n        }\n\n        if (trackedPathMatchFiber === null) {\n          // We didn't find anything.\n          return null;\n        } // Find the closest Fiber store is aware of.\n\n\n        var fiber = trackedPathMatchFiber;\n\n        while (fiber !== null && shouldFilterFiber(fiber)) {\n          fiber = fiber.return;\n        }\n\n        if (fiber === null) {\n          return null;\n        }\n\n        return {\n          id: getFiberID(getPrimaryFiber(fiber)),\n          isFullMatch: trackedPathMatchDepth === trackedPath.length - 1\n        };\n      }\n\n      var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {\n        if (priorityLevel == null) {\n          return 'Unknown';\n        }\n\n        switch (priorityLevel) {\n          case ImmediatePriority:\n            return 'Immediate';\n\n          case UserBlockingPriority:\n            return 'User-Blocking';\n\n          case NormalPriority:\n            return 'Normal';\n\n          case LowPriority:\n            return 'Low';\n\n          case IdlePriority:\n            return 'Idle';\n\n          case NoPriority:\n          default:\n            return 'Unknown';\n        }\n      };\n\n      function setTraceUpdatesEnabled(isEnabled) {\n        traceUpdatesEnabled = isEnabled;\n      }\n\n      return {\n        cleanup: cleanup,\n        copyElementPath: copyElementPath,\n        findNativeNodesForFiberID: findNativeNodesForFiberID,\n        flushInitialOperations: flushInitialOperations,\n        getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n        getDisplayNameForFiberID: getDisplayNameForFiberID,\n        getFiberIDForNative: getFiberIDForNative,\n        getInstanceAndStyle: getInstanceAndStyle,\n        getOwnersList: getOwnersList,\n        getPathForElement: getPathForElement,\n        getProfilingData: getProfilingData,\n        handleCommitFiberRoot: handleCommitFiberRoot,\n        handleCommitFiberUnmount: handleCommitFiberUnmount,\n        inspectElement: inspectElement,\n        logElementToConsole: logElementToConsole,\n        prepareViewAttributeSource: prepareViewAttributeSource,\n        prepareViewElementSource: prepareViewElementSource,\n        overrideSuspense: overrideSuspense,\n        renderer: renderer,\n        setInContext: setInContext,\n        setInHook: setInHook,\n        setInProps: setInProps,\n        setInState: setInState,\n        setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n        setTrackedPath: setTrackedPath,\n        startProfiling: startProfiling,\n        stopProfiling: stopProfiling,\n        storeAsGlobal: storeAsGlobal,\n        updateComponentFilters: updateComponentFilters\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/utils.js\":\n  /*!*****************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/utils.js ***!\n    \\*****************************************************/\n\n  /*! exports provided: cleanForBridge, copyToClipboard, copyWithSet, serializeToString */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"cleanForBridge\", function () {\n      return cleanForBridge;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"copyToClipboard\", function () {\n      return copyToClipboard;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"copyWithSet\", function () {\n      return copyWithSet;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"serializeToString\", function () {\n      return serializeToString;\n    });\n    /* harmony import */\n\n\n    var clipboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! clipboard-js */\n    \"../../node_modules/clipboard-js/clipboard.js\");\n    /* harmony import */\n\n\n    var clipboard_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard_js__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */\n\n\n    var _hydration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ../hydration */\n    \"../react-devtools-shared/src/hydration.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n      }\n\n      return keys;\n    }\n\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function (key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n\n      return target;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function cleanForBridge(data, isPathAllowed) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (data !== null) {\n        var cleanedPaths = [];\n        var unserializablePaths = [];\n        var cleanedData = Object(_hydration__WEBPACK_IMPORTED_MODULE_1__[\"dehydrate\"])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n        return {\n          data: cleanedData,\n          cleaned: cleanedPaths,\n          unserializable: unserializablePaths\n        };\n      } else {\n        return null;\n      }\n    }\n\n    function copyToClipboard(value) {\n      var safeToCopy = serializeToString(value);\n      var text = safeToCopy === undefined ? 'undefined' : safeToCopy;\n      var clipboardCopyText = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.clipboardCopyText; // On Firefox navigator.clipboard.writeText has to be called from\n      // the content script js code (because it requires the clipboardWrite\n      // permission to be allowed out of a \"user handling\" callback),\n      // clipboardCopyText is an helper injected into the page from.\n      // injectGlobalHook.\n\n      if (typeof clipboardCopyText === 'function') {\n        clipboardCopyText(text).catch(function (err) {});\n      } else {\n        Object(clipboard_js__WEBPACK_IMPORTED_MODULE_0__[\"copy\"])(text);\n      }\n    }\n\n    function copyWithSet(obj, path, value) {\n      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      if (index >= path.length) {\n        return value;\n      }\n\n      var key = path[index];\n      var updated = Array.isArray(obj) ? obj.slice() : _objectSpread({}, obj); // $FlowFixMe number or string is fine here\n\n      updated[key] = copyWithSet(obj[key], path, value, index + 1);\n      return updated;\n    }\n\n    function serializeToString(data) {\n      var cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n      return JSON.stringify(data, function (key, value) {\n        if (_typeof(value) === 'object' && value !== null) {\n          if (cache.has(value)) {\n            return;\n          }\n\n          cache.add(value);\n        } // $FlowFixMe\n\n\n        if (typeof value === 'bigint') {\n          return value.toString() + 'n';\n        }\n\n        return value;\n      });\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\":\n  /*!*****************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js ***!\n    \\*****************************************************************************/\n\n  /*! exports provided: hideOverlay, showOverlay */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"hideOverlay\", function () {\n      return hideOverlay;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"showOverlay\", function () {\n      return showOverlay;\n    });\n    /* harmony import */\n\n\n    var _Overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./Overlay */\n    \"../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\");\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var SHOW_DURATION = 2000;\n    var timeoutID = null;\n    var overlay = null;\n\n    function hideOverlay() {\n      timeoutID = null;\n\n      if (overlay !== null) {\n        overlay.remove();\n        overlay = null;\n      }\n    }\n\n    function showOverlay(elements, componentName, hideAfterTimeout) {\n      // TODO (npm-packages) Detect RN and support it somehow\n      if (window.document == null) {\n        return;\n      }\n\n      if (timeoutID !== null) {\n        clearTimeout(timeoutID);\n      }\n\n      if (elements == null) {\n        return;\n      }\n\n      if (overlay === null) {\n        overlay = new _Overlay__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      }\n\n      overlay.inspect(elements, componentName);\n\n      if (hideAfterTimeout) {\n        timeoutID = setTimeout(hideOverlay, SHOW_DURATION);\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\":\n  /*!*************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js ***!\n    \\*************************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return Overlay;\n    });\n    /* harmony import */\n\n\n    var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! object-assign */\n    \"../../node_modules/object-assign/index.js\");\n    /* harmony import */\n\n\n    var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ../utils */\n    \"../react-devtools-shared/src/backend/views/utils.js\");\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // Note that the Overlay components are not affected by the active Theme,\n    // because they highlight elements in the main Chrome window (outside of devtools).\n    // The colors below were chosen to roughly match those used by Chrome devtools.\n\n\n    var OverlayRect = /*#__PURE__*/function () {\n      function OverlayRect(doc, container) {\n        _classCallCheck(this, OverlayRect);\n\n        this.node = doc.createElement('div');\n        this.border = doc.createElement('div');\n        this.padding = doc.createElement('div');\n        this.content = doc.createElement('div');\n        this.border.style.borderColor = overlayStyles.border;\n        this.padding.style.borderColor = overlayStyles.padding;\n        this.content.style.backgroundColor = overlayStyles.background;\n        object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.node.style, {\n          borderColor: overlayStyles.margin,\n          pointerEvents: 'none',\n          position: 'fixed'\n        });\n        this.node.style.zIndex = '10000000';\n        this.node.appendChild(this.border);\n        this.border.appendChild(this.padding);\n        this.padding.appendChild(this.content);\n        container.appendChild(this.node);\n      }\n\n      _createClass(OverlayRect, [{\n        key: \"remove\",\n        value: function remove() {\n          if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function update(box, dims) {\n          boxWrap(dims, 'margin', this.node);\n          boxWrap(dims, 'border', this.border);\n          boxWrap(dims, 'padding', this.padding);\n          object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.content.style, {\n            height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',\n            width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'\n          });\n          object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.node.style, {\n            top: box.top - dims.marginTop + 'px',\n            left: box.left - dims.marginLeft + 'px'\n          });\n        }\n      }]);\n\n      return OverlayRect;\n    }();\n\n    var OverlayTip = /*#__PURE__*/function () {\n      function OverlayTip(doc, container) {\n        _classCallCheck(this, OverlayTip);\n\n        this.tip = doc.createElement('div');\n        object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.tip.style, {\n          display: 'flex',\n          flexFlow: 'row nowrap',\n          backgroundColor: '#333740',\n          borderRadius: '2px',\n          fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\n          fontWeight: 'bold',\n          padding: '3px 5px',\n          pointerEvents: 'none',\n          position: 'fixed',\n          fontSize: '12px',\n          whiteSpace: 'nowrap'\n        });\n        this.nameSpan = doc.createElement('span');\n        this.tip.appendChild(this.nameSpan);\n        object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.nameSpan.style, {\n          color: '#ee78e6',\n          borderRight: '1px solid #aaaaaa',\n          paddingRight: '0.5rem',\n          marginRight: '0.5rem'\n        });\n        this.dimSpan = doc.createElement('span');\n        this.tip.appendChild(this.dimSpan);\n        object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.dimSpan.style, {\n          color: '#d7d7d7'\n        });\n        this.tip.style.zIndex = '10000000';\n        container.appendChild(this.tip);\n      }\n\n      _createClass(OverlayTip, [{\n        key: \"remove\",\n        value: function remove() {\n          if (this.tip.parentNode) {\n            this.tip.parentNode.removeChild(this.tip);\n          }\n        }\n      }, {\n        key: \"updateText\",\n        value: function updateText(name, width, height) {\n          this.nameSpan.textContent = name;\n          this.dimSpan.textContent = Math.round(width) + 'px  ' + Math.round(height) + 'px';\n        }\n      }, {\n        key: \"updatePosition\",\n        value: function updatePosition(dims, bounds) {\n          var tipRect = this.tip.getBoundingClientRect();\n          var tipPos = findTipPos(dims, bounds, {\n            width: tipRect.width,\n            height: tipRect.height\n          });\n          object_assign__WEBPACK_IMPORTED_MODULE_0___default()(this.tip.style, tipPos.style);\n        }\n      }]);\n\n      return OverlayTip;\n    }();\n\n    var Overlay = /*#__PURE__*/function () {\n      function Overlay() {\n        _classCallCheck(this, Overlay); // Find the root window, because overlays are positioned relative to it.\n\n\n        var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n        this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.\n\n        var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n        this.tipBoundsWindow = tipBoundsWindow;\n        var doc = currentWindow.document;\n        this.container = doc.createElement('div');\n        this.container.style.zIndex = '10000000';\n        this.tip = new OverlayTip(doc, this.container);\n        this.rects = [];\n        doc.body.appendChild(this.container);\n      }\n\n      _createClass(Overlay, [{\n        key: \"remove\",\n        value: function remove() {\n          this.tip.remove();\n          this.rects.forEach(function (rect) {\n            rect.remove();\n          });\n          this.rects.length = 0;\n\n          if (this.container.parentNode) {\n            this.container.parentNode.removeChild(this.container);\n          }\n        }\n      }, {\n        key: \"inspect\",\n        value: function inspect(nodes, name) {\n          var _this = this; // We can't get the size of text nodes or comment nodes. React as of v15\n          // heavily uses comment nodes to delimit text.\n\n\n          var elements = nodes.filter(function (node) {\n            return node.nodeType === Node.ELEMENT_NODE;\n          });\n\n          while (this.rects.length > elements.length) {\n            var rect = this.rects.pop();\n            rect.remove();\n          }\n\n          if (elements.length === 0) {\n            return;\n          }\n\n          while (this.rects.length < elements.length) {\n            this.rects.push(new OverlayRect(this.window.document, this.container));\n          }\n\n          var outerBox = {\n            top: Number.POSITIVE_INFINITY,\n            right: Number.NEGATIVE_INFINITY,\n            bottom: Number.NEGATIVE_INFINITY,\n            left: Number.POSITIVE_INFINITY\n          };\n          elements.forEach(function (element, index) {\n            var box = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getNestedBoundingClientRect\"])(element, _this.window);\n            var dims = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getElementDimensions\"])(element);\n            outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);\n            outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);\n            outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);\n            outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);\n            var rect = _this.rects[index];\n            rect.update(box, dims);\n          });\n\n          if (!name) {\n            name = elements[0].nodeName.toLowerCase();\n            var node = elements[0];\n            var hook = node.ownerDocument.defaultView.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n            if (hook != null && hook.rendererInterfaces != null) {\n              var ownerName = null; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = hook.rendererInterfaces.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var rendererInterface = _step.value;\n                  var id = rendererInterface.getFiberIDForNative(node, true);\n\n                  if (id !== null) {\n                    ownerName = rendererInterface.getDisplayNameForFiberID(id, true);\n                    break;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              if (ownerName) {\n                name += ' (in ' + ownerName + ')';\n              }\n            }\n          }\n\n          this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);\n          var tipBounds = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getNestedBoundingClientRect\"])(this.tipBoundsWindow.document.documentElement, this.window);\n          this.tip.updatePosition({\n            top: outerBox.top,\n            left: outerBox.left,\n            height: outerBox.bottom - outerBox.top,\n            width: outerBox.right - outerBox.left\n          }, {\n            top: tipBounds.top + this.tipBoundsWindow.scrollY,\n            left: tipBounds.left + this.tipBoundsWindow.scrollX,\n            height: this.tipBoundsWindow.innerHeight,\n            width: this.tipBoundsWindow.innerWidth\n          });\n        }\n      }]);\n\n      return Overlay;\n    }();\n\n    function findTipPos(dims, bounds, tipSize) {\n      var tipHeight = Math.max(tipSize.height, 20);\n      var tipWidth = Math.max(tipSize.width, 60);\n      var margin = 5;\n      var top;\n\n      if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {\n        if (dims.top + dims.height < bounds.top + 0) {\n          top = bounds.top + margin;\n        } else {\n          top = dims.top + dims.height + margin;\n        }\n      } else if (dims.top - tipHeight <= bounds.top + bounds.height) {\n        if (dims.top - tipHeight - margin < bounds.top + margin) {\n          top = bounds.top + margin;\n        } else {\n          top = dims.top - tipHeight - margin;\n        }\n      } else {\n        top = bounds.top + bounds.height - tipHeight - margin;\n      }\n\n      var left = dims.left + margin;\n\n      if (dims.left < bounds.left) {\n        left = bounds.left + margin;\n      }\n\n      if (dims.left + tipWidth > bounds.left + bounds.width) {\n        left = bounds.left + bounds.width - tipWidth - margin;\n      }\n\n      top += 'px';\n      left += 'px';\n      return {\n        style: {\n          top: top,\n          left: left\n        }\n      };\n    }\n\n    function boxWrap(dims, what, node) {\n      object_assign__WEBPACK_IMPORTED_MODULE_0___default()(node.style, {\n        borderTopWidth: dims[what + 'Top'] + 'px',\n        borderLeftWidth: dims[what + 'Left'] + 'px',\n        borderRightWidth: dims[what + 'Right'] + 'px',\n        borderBottomWidth: dims[what + 'Bottom'] + 'px',\n        borderStyle: 'solid'\n      });\n    }\n\n    var overlayStyles = {\n      background: 'rgba(120, 170, 210, 0.7)',\n      padding: 'rgba(77, 200, 0, 0.3)',\n      margin: 'rgba(255, 155, 0, 0.3)',\n      border: 'rgba(255, 200, 50, 0.3)'\n    };\n    /***/\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/Highlighter/index.js\":\n  /*!***********************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/Highlighter/index.js ***!\n    \\***********************************************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return setupHighlighter;\n    });\n    /* harmony import */\n\n\n    var memoize_one__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! memoize-one */\n    \"../../node_modules/memoize-one/esm/index.js\");\n    /* harmony import */\n\n\n    var lodash_throttle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! lodash.throttle */\n    \"../../node_modules/lodash.throttle/index.js\");\n    /* harmony import */\n\n\n    var lodash_throttle__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_1__);\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend/agent */\n    \"../react-devtools-shared/src/backend/agent.js\");\n    /* harmony import */\n\n\n    var _Highlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! ./Highlighter */\n    \"../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\");\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // This plug-in provides in-page highlighting of the selected element.\n    // It is used by the browser extension nad the standalone DevTools shell (when connected to a browser).\n    // It is not currently the mechanism used to highlight React Native views.\n    // That is done by the React Native Inspector component.\n\n\n    var iframesListeningTo = new Set();\n\n    function setupHighlighter(bridge, agent) {\n      bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);\n      bridge.addListener('highlightNativeElement', highlightNativeElement);\n      bridge.addListener('shutdown', stopInspectingNative);\n      bridge.addListener('startInspectingNative', startInspectingNative);\n      bridge.addListener('stopInspectingNative', stopInspectingNative);\n\n      function startInspectingNative() {\n        registerListenersOnWindow(window);\n      }\n\n      function registerListenersOnWindow(window) {\n        // This plug-in may run in non-DOM environments (e.g. React Native).\n        if (window && typeof window.addEventListener === 'function') {\n          window.addEventListener('click', onClick, true);\n          window.addEventListener('mousedown', onMouseEvent, true);\n          window.addEventListener('mouseover', onMouseEvent, true);\n          window.addEventListener('mouseup', onMouseEvent, true);\n          window.addEventListener('pointerdown', onPointerDown, true);\n          window.addEventListener('pointerover', onPointerOver, true);\n          window.addEventListener('pointerup', onPointerUp, true);\n        }\n      }\n\n      function stopInspectingNative() {\n        Object(_Highlighter__WEBPACK_IMPORTED_MODULE_3__[\"hideOverlay\"])();\n        removeListenersOnWindow(window);\n        iframesListeningTo.forEach(function (frame) {\n          try {\n            removeListenersOnWindow(frame.contentWindow);\n          } catch (error) {// This can error when the iframe is on a cross-origin.\n          }\n        });\n        iframesListeningTo = new Set();\n      }\n\n      function removeListenersOnWindow(window) {\n        // This plug-in may run in non-DOM environments (e.g. React Native).\n        if (window && typeof window.removeEventListener === 'function') {\n          window.removeEventListener('click', onClick, true);\n          window.removeEventListener('mousedown', onMouseEvent, true);\n          window.removeEventListener('mouseover', onMouseEvent, true);\n          window.removeEventListener('mouseup', onMouseEvent, true);\n          window.removeEventListener('pointerdown', onPointerDown, true);\n          window.removeEventListener('pointerover', onPointerOver, true);\n          window.removeEventListener('pointerup', onPointerUp, true);\n        }\n      }\n\n      function clearNativeElementHighlight() {\n        Object(_Highlighter__WEBPACK_IMPORTED_MODULE_3__[\"hideOverlay\"])();\n      }\n\n      function highlightNativeElement(_ref) {\n        var displayName = _ref.displayName,\n            hideAfterTimeout = _ref.hideAfterTimeout,\n            id = _ref.id,\n            openNativeElementsPanel = _ref.openNativeElementsPanel,\n            rendererID = _ref.rendererID,\n            scrollIntoView = _ref.scrollIntoView;\n        var renderer = agent.rendererInterfaces[rendererID];\n\n        if (renderer == null) {\n          console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n        }\n\n        var nodes = null;\n\n        if (renderer !== null) {\n          nodes = renderer.findNativeNodesForFiberID(id);\n        }\n\n        if (nodes != null && nodes[0] != null) {\n          var node = nodes[0];\n\n          if (scrollIntoView && typeof node.scrollIntoView === 'function') {\n            // If the node isn't visible show it before highlighting it.\n            // We may want to reconsider this; it might be a little disruptive.\n            // $FlowFixMe Flow only knows about 'start' | 'end'\n            node.scrollIntoView({\n              block: 'nearest',\n              inline: 'nearest'\n            });\n          }\n\n          Object(_Highlighter__WEBPACK_IMPORTED_MODULE_3__[\"showOverlay\"])(nodes, displayName, hideAfterTimeout);\n\n          if (openNativeElementsPanel) {\n            window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;\n            bridge.send('syncSelectionToNativeElementsPanel');\n          }\n        } else {\n          Object(_Highlighter__WEBPACK_IMPORTED_MODULE_3__[\"hideOverlay\"])();\n        }\n      }\n\n      function onClick(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        stopInspectingNative();\n        bridge.send('stopInspectingNative', true);\n      }\n\n      function onMouseEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      function onPointerDown(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        selectFiberForNode(event.target);\n      }\n\n      function onPointerOver(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        var target = event.target;\n\n        if (target.tagName === 'IFRAME') {\n          var iframe = target;\n\n          try {\n            if (!iframesListeningTo.has(iframe)) {\n              var _window = iframe.contentWindow;\n              registerListenersOnWindow(_window);\n              iframesListeningTo.add(iframe);\n            }\n          } catch (error) {// This can error when the iframe is on a cross-origin.\n          }\n        } // Don't pass the name explicitly.\n        // It will be inferred from DOM tag and Fiber owner.\n\n\n        Object(_Highlighter__WEBPACK_IMPORTED_MODULE_3__[\"showOverlay\"])([target], null, false);\n        selectFiberForNode(target);\n      }\n\n      function onPointerUp(event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      var selectFiberForNode = lodash_throttle__WEBPACK_IMPORTED_MODULE_1___default()(Object(memoize_one__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function (node) {\n        var id = agent.getIDForNode(node);\n\n        if (id !== null) {\n          bridge.send('selectFiber', id);\n        }\n      }), 200, // Don't change the selection in the very first 200ms\n      // because those are usually unintentional as you lift the cursor.\n      {\n        leading: false\n      });\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\":\n  /*!*************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js ***!\n    \\*************************************************************************/\n\n  /*! exports provided: draw, destroy */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"draw\", function () {\n      return draw;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"destroy\", function () {\n      return destroy;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.\n\n    var COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];\n    var canvas = null;\n\n    function draw(nodeToData) {\n      if (canvas === null) {\n        initialize();\n      }\n\n      var canvasFlow = canvas;\n      canvasFlow.width = window.innerWidth;\n      canvasFlow.height = window.innerHeight;\n      var context = canvasFlow.getContext('2d');\n      context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);\n      nodeToData.forEach(function (_ref) {\n        var count = _ref.count,\n            rect = _ref.rect;\n\n        if (rect !== null) {\n          var colorIndex = Math.min(COLORS.length - 1, count - 1);\n          var color = COLORS[colorIndex];\n          drawBorder(context, rect, color);\n        }\n      });\n    }\n\n    function drawBorder(context, rect, color) {\n      var height = rect.height,\n          left = rect.left,\n          top = rect.top,\n          width = rect.width; // outline\n\n      context.lineWidth = 1;\n      context.strokeStyle = OUTLINE_COLOR;\n      context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset\n\n      context.lineWidth = 1;\n      context.strokeStyle = OUTLINE_COLOR;\n      context.strokeRect(left + 1, top + 1, width - 1, height - 1);\n      context.strokeStyle = color;\n      context.setLineDash([0]); // border\n\n      context.lineWidth = 1;\n      context.strokeRect(left, top, width - 1, height - 1);\n      context.setLineDash([0]);\n    }\n\n    function destroy() {\n      if (canvas !== null) {\n        if (canvas.parentNode != null) {\n          canvas.parentNode.removeChild(canvas);\n        }\n\n        canvas = null;\n      }\n    }\n\n    function initialize() {\n      canvas = window.document.createElement('canvas');\n      canvas.style.cssText = \"\\n    xx-background-color: red;\\n    xx-opacity: 0.5;\\n    bottom: 0;\\n    left: 0;\\n    pointer-events: none;\\n    position: fixed;\\n    right: 0;\\n    top: 0;\\n    z-index: 1000000000;\\n  \";\n      var root = window.document.documentElement;\n      root.insertBefore(canvas, root.firstChild);\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/TraceUpdates/index.js\":\n  /*!************************************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/TraceUpdates/index.js ***!\n    \\************************************************************************/\n\n  /*! exports provided: initialize, toggleEnabled */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"initialize\", function () {\n      return initialize;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"toggleEnabled\", function () {\n      return toggleEnabled;\n    });\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend/agent */\n    \"../react-devtools-shared/src/backend/agent.js\");\n    /* harmony import */\n\n\n    var _canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! ./canvas */\n    \"../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\");\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! ../utils */\n    \"../react-devtools-shared/src/backend/views/utils.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // How long the rect should be shown for?\n\n\n    var DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?\n    // This can be important if we're getting a flurry of events (e.g. scroll update).\n\n    var MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?\n\n    var REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n    var getCurrentTime = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n      return performance.now();\n    } : function () {\n      return Date.now();\n    };\n    var nodeToData = new Map();\n    var agent = null;\n    var drawAnimationFrameID = null;\n    var isEnabled = false;\n    var redrawTimeoutID = null;\n\n    function initialize(injectedAgent) {\n      agent = injectedAgent;\n      agent.addListener('traceUpdates', traceUpdates);\n    }\n\n    function toggleEnabled(value) {\n      isEnabled = value;\n\n      if (!isEnabled) {\n        nodeToData.clear();\n\n        if (drawAnimationFrameID !== null) {\n          cancelAnimationFrame(drawAnimationFrameID);\n          drawAnimationFrameID = null;\n        }\n\n        if (redrawTimeoutID !== null) {\n          clearTimeout(redrawTimeoutID);\n          redrawTimeoutID = null;\n        }\n\n        Object(_canvas__WEBPACK_IMPORTED_MODULE_1__[\"destroy\"])();\n      }\n    }\n\n    function traceUpdates(nodes) {\n      if (!isEnabled) {\n        return;\n      }\n\n      nodes.forEach(function (node) {\n        var data = nodeToData.get(node);\n        var now = getCurrentTime();\n        var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;\n        var rect = data != null ? data.rect : null;\n\n        if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {\n          lastMeasuredAt = now;\n          rect = measureNode(node);\n        }\n\n        nodeToData.set(node, {\n          count: data != null ? data.count + 1 : 1,\n          expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,\n          lastMeasuredAt: lastMeasuredAt,\n          rect: rect\n        });\n      });\n\n      if (redrawTimeoutID !== null) {\n        clearTimeout(redrawTimeoutID);\n        redrawTimeoutID = null;\n      }\n\n      if (drawAnimationFrameID === null) {\n        drawAnimationFrameID = requestAnimationFrame(prepareToDraw);\n      }\n    }\n\n    function prepareToDraw() {\n      drawAnimationFrameID = null;\n      redrawTimeoutID = null;\n      var now = getCurrentTime();\n      var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.\n\n      nodeToData.forEach(function (data, node) {\n        if (data.expirationTime < now) {\n          nodeToData.delete(node);\n        } else {\n          earliestExpiration = Math.min(earliestExpiration, data.expirationTime);\n        }\n      });\n      Object(_canvas__WEBPACK_IMPORTED_MODULE_1__[\"draw\"])(nodeToData);\n\n      if (earliestExpiration !== Number.MAX_VALUE) {\n        redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);\n      }\n    }\n\n    function measureNode(node) {\n      if (!node || typeof node.getBoundingClientRect !== 'function') {\n        return null;\n      }\n\n      var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n      return Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getNestedBoundingClientRect\"])(node, currentWindow);\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/backend/views/utils.js\":\n  /*!***********************************************************!*\\\n    !*** ../react-devtools-shared/src/backend/views/utils.js ***!\n    \\***********************************************************/\n\n  /*! exports provided: getOwnerWindow, getOwnerIframe, getBoundingClientRectWithBorderOffset, mergeRectOffsets, getNestedBoundingClientRect, getElementDimensions */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getOwnerWindow\", function () {\n      return getOwnerWindow;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getOwnerIframe\", function () {\n      return getOwnerIframe;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getBoundingClientRectWithBorderOffset\", function () {\n      return getBoundingClientRectWithBorderOffset;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"mergeRectOffsets\", function () {\n      return mergeRectOffsets;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getNestedBoundingClientRect\", function () {\n      return getNestedBoundingClientRect;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getElementDimensions\", function () {\n      return getElementDimensions;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // Get the window object for the document that a node belongs to,\n    // or return null if it cannot be found (node not attached to DOM,\n    // etc).\n\n\n    function getOwnerWindow(node) {\n      if (!node.ownerDocument) {\n        return null;\n      }\n\n      return node.ownerDocument.defaultView;\n    } // Get the iframe containing a node, or return null if it cannot\n    // be found (node not within iframe, etc).\n\n\n    function getOwnerIframe(node) {\n      var nodeWindow = getOwnerWindow(node);\n\n      if (nodeWindow) {\n        return nodeWindow.frameElement;\n      }\n\n      return null;\n    } // Get a bounding client rect for a node, with an\n    // offset added to compensate for its border.\n\n\n    function getBoundingClientRectWithBorderOffset(node) {\n      var dimensions = getElementDimensions(node);\n      return mergeRectOffsets([node.getBoundingClientRect(), {\n        top: dimensions.borderTop,\n        left: dimensions.borderLeft,\n        bottom: dimensions.borderBottom,\n        right: dimensions.borderRight,\n        // This width and height won't get used by mergeRectOffsets (since this\n        // is not the first rect in the array), but we set them so that this\n        // object typechecks as a ClientRect.\n        width: 0,\n        height: 0\n      }]);\n    } // Add together the top, left, bottom, and right properties of\n    // each ClientRect, but keep the width and height of the first one.\n\n\n    function mergeRectOffsets(rects) {\n      return rects.reduce(function (previousRect, rect) {\n        if (previousRect == null) {\n          return rect;\n        }\n\n        return {\n          top: previousRect.top + rect.top,\n          left: previousRect.left + rect.left,\n          width: previousRect.width,\n          height: previousRect.height,\n          bottom: previousRect.bottom + rect.bottom,\n          right: previousRect.right + rect.right\n        };\n      });\n    } // Calculate a boundingClientRect for a node relative to boundaryWindow,\n    // taking into account any offsets caused by intermediate iframes.\n\n\n    function getNestedBoundingClientRect(node, boundaryWindow) {\n      var ownerIframe = getOwnerIframe(node);\n\n      if (ownerIframe && ownerIframe !== boundaryWindow) {\n        var rects = [node.getBoundingClientRect()];\n        var currentIframe = ownerIframe;\n        var onlyOneMore = false;\n\n        while (currentIframe) {\n          var rect = getBoundingClientRectWithBorderOffset(currentIframe);\n          rects.push(rect);\n          currentIframe = getOwnerIframe(currentIframe);\n\n          if (onlyOneMore) {\n            break;\n          } // We don't want to calculate iframe offsets upwards beyond\n          // the iframe containing the boundaryWindow, but we\n          // need to calculate the offset relative to the boundaryWindow.\n\n\n          if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {\n            onlyOneMore = true;\n          }\n        }\n\n        return mergeRectOffsets(rects);\n      } else {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    function getElementDimensions(domElement) {\n      var calculatedStyle = window.getComputedStyle(domElement);\n      return {\n        borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),\n        borderRight: parseInt(calculatedStyle.borderRightWidth, 10),\n        borderTop: parseInt(calculatedStyle.borderTopWidth, 10),\n        borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),\n        marginLeft: parseInt(calculatedStyle.marginLeft, 10),\n        marginRight: parseInt(calculatedStyle.marginRight, 10),\n        marginTop: parseInt(calculatedStyle.marginTop, 10),\n        marginBottom: parseInt(calculatedStyle.marginBottom, 10),\n        paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),\n        paddingRight: parseInt(calculatedStyle.paddingRight, 10),\n        paddingTop: parseInt(calculatedStyle.paddingTop, 10),\n        paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/bridge.js\":\n  /*!**********************************************!*\\\n    !*** ../react-devtools-shared/src/bridge.js ***!\n    \\**********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */\n\n\n    var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./events */\n    \"../react-devtools-shared/src/events.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n    }\n\n    function _iterableToArray(iter) {\n      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n    }\n\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n\n        return arr2;\n      }\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      }\n\n      return _assertThisInitialized(self);\n    }\n\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n\n    function _assertThisInitialized(self) {\n      if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return self;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n      return _setPrototypeOf(o, p);\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var BATCH_DURATION = 100;\n\n    var Bridge = /*#__PURE__*/function (_EventEmitter) {\n      _inherits(Bridge, _EventEmitter);\n\n      function Bridge(wall) {\n        var _this;\n\n        _classCallCheck(this, Bridge);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Bridge).call(this));\n\n        _defineProperty(_assertThisInitialized(_this), \"_isShutdown\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"_messageQueue\", []);\n\n        _defineProperty(_assertThisInitialized(_this), \"_timeoutID\", null);\n\n        _defineProperty(_assertThisInitialized(_this), \"_wallUnlisten\", null);\n\n        _defineProperty(_assertThisInitialized(_this), \"_flush\", function () {\n          // This method is used after the bridge is marked as destroyed in shutdown sequence,\n          // so we do not bail out if the bridge marked as destroyed.\n          // It is a private method that the bridge ensures is only called at the right times.\n          if (_this._timeoutID !== null) {\n            clearTimeout(_this._timeoutID);\n            _this._timeoutID = null;\n          }\n\n          if (_this._messageQueue.length) {\n            for (var i = 0; i < _this._messageQueue.length; i += 2) {\n              var _this$_wall;\n\n              (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(_toConsumableArray(_this._messageQueue[i + 1])));\n            }\n\n            _this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep\n            // flushing in a loop as long as messages continue to be added. Once no\n            // more are, the timer expires.\n\n            _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);\n          }\n        });\n\n        _this._wall = wall;\n        _this._wallUnlisten = wall.listen(function (message) {\n          _assertThisInitialized(_this).emit(message.event, message.payload);\n        }) || null;\n        return _this;\n      } // Listening directly to the wall isn't advised.\n      // It can be used to listen for legacy (v3) messages (since they use a different format).\n\n\n      _createClass(Bridge, [{\n        key: \"send\",\n        value: function send(event) {\n          if (this._isShutdown) {\n            console.warn(\"Cannot send message \\\"\".concat(event, \"\\\" through a Bridge that has been shutdown.\"));\n            return;\n          } // When we receive a message:\n          // - we add it to our queue of messages to be sent\n          // - if there hasn't been a message recently, we set a timer for 0 ms in\n          //   the future, allowing all messages created in the same tick to be sent\n          //   together\n          // - if there *has* been a message flushed in the last BATCH_DURATION ms\n          //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will\n          //   be set, and we'll simply add to the queue and wait for that\n\n\n          for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            payload[_key - 1] = arguments[_key];\n          }\n\n          this._messageQueue.push(event, payload);\n\n          if (!this._timeoutID) {\n            this._timeoutID = setTimeout(this._flush, 0);\n          }\n        }\n      }, {\n        key: \"shutdown\",\n        value: function shutdown() {\n          if (this._isShutdown) {\n            console.warn('Bridge was already shutdown.');\n            return;\n          } // Queue the shutdown outgoing message for subscribers.\n\n\n          this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.\n\n          this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.\n          // $FlowFixMe This property is not writable.\n\n          this.addListener = function () {}; // $FlowFixMe This property is not writable.\n\n\n          this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.\n          // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.\n\n\n          this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.\n\n          var wallUnlisten = this._wallUnlisten;\n\n          if (wallUnlisten) {\n            wallUnlisten();\n          } // Synchronously flush all queued outgoing messages.\n          // At this step the subscribers' code may run in this call stack.\n\n\n          do {\n            this._flush();\n          } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.\n\n\n          if (this._timeoutID !== null) {\n            clearTimeout(this._timeoutID);\n            this._timeoutID = null;\n          }\n        }\n      }, {\n        key: \"wall\",\n        get: function get() {\n          return this._wall;\n        }\n      }]);\n\n      return Bridge;\n    }(_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = Bridge;\n    /***/\n  },\n\n  /***/\n  \"../react-devtools-shared/src/constants.js\":\n  /*!*************************************************!*\\\n    !*** ../react-devtools-shared/src/constants.js ***!\n    \\*************************************************/\n\n  /*! exports provided: __DEBUG__, TREE_OPERATION_ADD, TREE_OPERATION_REMOVE, TREE_OPERATION_REORDER_CHILDREN, TREE_OPERATION_UPDATE_TREE_BASE_DURATION, LOCAL_STORAGE_FILTER_PREFERENCES_KEY, SESSION_STORAGE_LAST_SELECTION_KEY, SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS, LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY, LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY, PROFILER_EXPORT_VERSION, CHANGE_LOG_URL, UNSUPPORTED_VERSION_URL, COMFORTABLE_LINE_HEIGHT, COMPACT_LINE_HEIGHT */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"__DEBUG__\", function () {\n      return __DEBUG__;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_ADD\", function () {\n      return TREE_OPERATION_ADD;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_REMOVE\", function () {\n      return TREE_OPERATION_REMOVE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_REORDER_CHILDREN\", function () {\n      return TREE_OPERATION_REORDER_CHILDREN;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\", function () {\n      return TREE_OPERATION_UPDATE_TREE_BASE_DURATION;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\", function () {\n      return LOCAL_STORAGE_FILTER_PREFERENCES_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_LAST_SELECTION_KEY\", function () {\n      return SESSION_STORAGE_LAST_SELECTION_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\", function () {\n      return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\", function () {\n      return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\", function () {\n      return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\", function () {\n      return LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY\", function () {\n      return LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"PROFILER_EXPORT_VERSION\", function () {\n      return PROFILER_EXPORT_VERSION;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"CHANGE_LOG_URL\", function () {\n      return CHANGE_LOG_URL;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"UNSUPPORTED_VERSION_URL\", function () {\n      return UNSUPPORTED_VERSION_URL;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"COMFORTABLE_LINE_HEIGHT\", function () {\n      return COMFORTABLE_LINE_HEIGHT;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"COMPACT_LINE_HEIGHT\", function () {\n      return COMPACT_LINE_HEIGHT;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // Flip this flag to true to enable verbose console debug logging.\n\n\n    var __DEBUG__ = false;\n    var TREE_OPERATION_ADD = 1;\n    var TREE_OPERATION_REMOVE = 2;\n    var TREE_OPERATION_REORDER_CHILDREN = 3;\n    var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\n    var LOCAL_STORAGE_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\n    var SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\n    var SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\n    var SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\n    var LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';\n    var LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = 'React::DevTools::appendComponentStack';\n    var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\n    var PROFILER_EXPORT_VERSION = 4;\n    var CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/master/packages/react-devtools/CHANGELOG.md';\n    var UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back'; // HACK\n    //\n    // Extracting during build time avoids a temporarily invalid state for the inline target.\n    // Sometimes the inline target is rendered before root styles are applied,\n    // which would result in e.g. NaN itemSize being passed to react-window list.\n    //\n\n    var COMFORTABLE_LINE_HEIGHT;\n    var COMPACT_LINE_HEIGHT;\n\n    try {\n      // $FlowFixMe\n      var rawStyleString = __webpack_require__(\n      /*! !raw-loader!react-devtools-shared/src/devtools/views/root.css */\n      \"../../node_modules/raw-loader/dist/cjs.js!../react-devtools-shared/src/devtools/views/root.css\").default;\n\n      var extractVar = function extractVar(varName) {\n        var regExp = new RegExp(\"\".concat(varName, \": ([0-9]+)\"));\n        var match = rawStyleString.match(regExp);\n        return parseInt(match[1], 10);\n      };\n\n      COMFORTABLE_LINE_HEIGHT = extractVar('comfortable-line-height-data');\n      COMPACT_LINE_HEIGHT = extractVar('compact-line-height-data');\n    } catch (error) {\n      // We can't use the Webpack loader syntax in the context of Jest,\n      // so tests need some reasonably meaningful fallback value.\n      COMFORTABLE_LINE_HEIGHT = 15;\n      COMPACT_LINE_HEIGHT = 10;\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/events.js\":\n  /*!**********************************************!*\\\n    !*** ../react-devtools-shared/src/events.js ***!\n    \\**********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"default\", function () {\n      return EventEmitter;\n    });\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var EventEmitter = /*#__PURE__*/function () {\n      function EventEmitter() {\n        _classCallCheck(this, EventEmitter);\n\n        _defineProperty(this, \"listenersMap\", new Map());\n      }\n\n      _createClass(EventEmitter, [{\n        key: \"addListener\",\n        value: function addListener(event, listener) {\n          var listeners = this.listenersMap.get(event);\n\n          if (listeners === undefined) {\n            this.listenersMap.set(event, [listener]);\n          } else {\n            var index = listeners.indexOf(listener);\n\n            if (index < 0) {\n              listeners.push(listener);\n            }\n          }\n        }\n      }, {\n        key: \"emit\",\n        value: function emit(event) {\n          var listeners = this.listenersMap.get(event);\n\n          if (listeners !== undefined) {\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n\n            if (listeners.length === 1) {\n              // No need to clone or try/catch\n              var listener = listeners[0];\n              listener.apply(null, args);\n            } else {\n              var didThrow = false;\n              var caughtError = null;\n              var clonedListeners = Array.from(listeners);\n\n              for (var i = 0; i < clonedListeners.length; i++) {\n                var _listener = clonedListeners[i];\n\n                try {\n                  _listener.apply(null, args);\n                } catch (error) {\n                  if (caughtError === null) {\n                    didThrow = true;\n                    caughtError = error;\n                  }\n                }\n              }\n\n              if (didThrow) {\n                throw caughtError;\n              }\n            }\n          }\n        }\n      }, {\n        key: \"removeAllListeners\",\n        value: function removeAllListeners() {\n          this.listenersMap.clear();\n        }\n      }, {\n        key: \"removeListener\",\n        value: function removeListener(event, listener) {\n          var listeners = this.listenersMap.get(event);\n\n          if (listeners !== undefined) {\n            var index = listeners.indexOf(listener);\n\n            if (index >= 0) {\n              listeners.splice(index, 1);\n            }\n          }\n        }\n      }]);\n\n      return EventEmitter;\n    }();\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/hook.js\":\n  /*!********************************************!*\\\n    !*** ../react-devtools-shared/src/hook.js ***!\n    \\********************************************/\n\n  /*! exports provided: installHook */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"installHook\", function () {\n      return installHook;\n    });\n    /* harmony import */\n\n\n    var _backend_console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./backend/console */\n    \"../react-devtools-shared/src/backend/console.js\");\n    /**\n     * Install the hook on window, which is an event emitter.\n     * Note because Chrome content scripts cannot directly modify the window object,\n     * we are evaling this function by inserting a script tag.\n     * That's why we have to inline the whole event emitter implementation here.\n     *\n     * \n     */\n\n\n    function installHook(target) {\n      if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {\n        return null;\n      }\n\n      function detectReactBuildType(renderer) {\n        try {\n          if (typeof renderer.version === 'string') {\n            // React DOM Fiber (16+)\n            if (renderer.bundleType > 0) {\n              // This is not a production build.\n              // We are currently only using 0 (PROD) and 1 (DEV)\n              // but might add 2 (PROFILE) in the future.\n              return 'development';\n            } // React 16 uses flat bundles. If we report the bundle as production\n            // version, it means we also minified and envified it ourselves.\n\n\n            return 'production'; // Note: There is still a risk that the CommonJS entry point has not\n            // been envified or uglified. In this case the user would have *both*\n            // development and production bundle, but only the prod one would run.\n            // This would be really bad. We have a separate check for this because\n            // it happens *outside* of the renderer injection. See `checkDCE` below.\n          }\n\n          var _toString = Function.prototype.toString;\n\n          if (renderer.Mount && renderer.Mount._renderNewRootComponent) {\n            // React DOM Stack\n            var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):\n\n\n            if (renderRootCode.indexOf('function') !== 0) {\n              // Hope for the best if we're not sure.\n              return 'production';\n            } // Check for React DOM Stack < 15.1.0 in development.\n            // If it contains \"storedMeasure\" call, it's wrapped in ReactPerf (DEV only).\n            // This would be true even if it's minified, as method name still matches.\n\n\n            if (renderRootCode.indexOf('storedMeasure') !== -1) {\n              return 'development';\n            } // For other versions (and configurations) it's not so easy.\n            // Let's quickly exclude proper production builds.\n            // If it contains a warning message, it's either a DEV build,\n            // or an PROD build without proper dead code elimination.\n\n\n            if (renderRootCode.indexOf('should be a pure function') !== -1) {\n              // Now how do we tell a DEV build from a bad PROD build?\n              // If we see NODE_ENV, we're going to assume this is a dev build\n              // because most likely it is referring to an empty shim.\n              if (renderRootCode.indexOf('NODE_ENV') !== -1) {\n                return 'development';\n              } // If we see \"development\", we're dealing with an envified DEV build\n              // (such as the official React DEV UMD).\n\n\n              if (renderRootCode.indexOf('development') !== -1) {\n                return 'development';\n              } // I've seen process.env.NODE_ENV !== 'production' being smartly\n              // replaced by `true` in DEV by Webpack. I don't know how that\n              // works but we can safely guard against it because `true` was\n              // never used in the function source since it was written.\n\n\n              if (renderRootCode.indexOf('true') !== -1) {\n                return 'development';\n              } // By now either it is a production build that has not been minified,\n              // or (worse) this is a minified development build using non-standard\n              // environment (e.g. \"staging\"). We're going to look at whether\n              // the function argument name is mangled:\n\n\n              if ( // 0.13 to 15\n              renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n              renderRootCode.indexOf('nextComponent') !== -1) {\n                // We can't be certain whether this is a development build or not,\n                // but it is definitely unminified.\n                return 'unminified';\n              } else {\n                // This is likely a minified development build.\n                return 'development';\n              }\n            } // By now we know that it's envified and dead code elimination worked,\n            // but what if it's still not minified? (Is this even possible?)\n            // Let's check matches for the first argument name.\n\n\n            if ( // 0.13 to 15\n            renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n            renderRootCode.indexOf('nextComponent') !== -1) {\n              return 'unminified';\n            } // Seems like we're using the production version.\n            // However, the branch above is Stack-only so this is 15 or earlier.\n\n\n            return 'outdated';\n          }\n        } catch (err) {// Weird environments may exist.\n          // This code needs a higher fault tolerance\n          // because it runs even with closed DevTools.\n          // TODO: should we catch errors in all injected code, and not just this part?\n        }\n\n        return 'production';\n      }\n\n      function checkDCE(fn) {\n        // This runs for production versions of React.\n        // Needs to be super safe.\n        try {\n          var _toString2 = Function.prototype.toString;\n\n          var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only\n          // condition. However the function executes only in PROD. Therefore,\n          // if we see it, dead code elimination did not work.\n\n\n          if (code.indexOf('^_^') > -1) {\n            // Remember to report during next injection.\n            hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.\n            // Not synchronously so that it doesn't break the calling code.\n\n            setTimeout(function () {\n              throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://fb.me/react-perf-use-the-production-build');\n            });\n          }\n        } catch (err) {}\n      }\n\n      var uidCounter = 0;\n\n      function inject(renderer) {\n        var id = ++uidCounter;\n        renderers.set(id, renderer);\n        var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:\n        // * Append component stacks to warnings and error messages\n        // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n        //\n        // For React Native, we intentionally patch early (during injection).\n        // This provides React Native developers with components stacks even if they don't run DevTools.\n        // This won't work for DOM though, since this entire file is eval'ed and inserted as a script tag.\n        // In that case, we'll patch later (when the frontend attaches).\n        //\n        // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.\n\n        if (true) {\n          try {\n            var appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;\n            var breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true; // The installHook() function is injected by being stringified in the browser,\n            // so imports outside of this function do not get included.\n            //\n            // Normally we could check \"typeof patchConsole === 'function'\",\n            // but Webpack wraps imports with an object (e.g. _backend_console__WEBPACK_IMPORTED_MODULE_0__)\n            // and the object itself will be undefined as well for the reasons mentioned above,\n            // so we use try/catch instead.\n\n            if (appendComponentStack || breakOnConsoleErrors) {\n              Object(_backend_console__WEBPACK_IMPORTED_MODULE_0__[\"registerRenderer\"])(renderer);\n              Object(_backend_console__WEBPACK_IMPORTED_MODULE_0__[\"patch\"])({\n                appendComponentStack: appendComponentStack,\n                breakOnConsoleErrors: breakOnConsoleErrors\n              });\n            }\n          } catch (error) {}\n        } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.\n        // Otherwise the renderer won't yet exist and we can skip this step.\n\n\n        var attach = target.__REACT_DEVTOOLS_ATTACH__;\n\n        if (typeof attach === 'function') {\n          var rendererInterface = attach(hook, id, renderer, target);\n          hook.rendererInterfaces.set(id, rendererInterface);\n        }\n\n        hook.emit('renderer', {\n          id: id,\n          renderer: renderer,\n          reactBuildType: reactBuildType\n        });\n        return id;\n      }\n\n      var hasDetectedBadDCE = false;\n\n      function sub(event, fn) {\n        hook.on(event, fn);\n        return function () {\n          return hook.off(event, fn);\n        };\n      }\n\n      function on(event, fn) {\n        if (!listeners[event]) {\n          listeners[event] = [];\n        }\n\n        listeners[event].push(fn);\n      }\n\n      function off(event, fn) {\n        if (!listeners[event]) {\n          return;\n        }\n\n        var index = listeners[event].indexOf(fn);\n\n        if (index !== -1) {\n          listeners[event].splice(index, 1);\n        }\n\n        if (!listeners[event].length) {\n          delete listeners[event];\n        }\n      }\n\n      function emit(event, data) {\n        if (listeners[event]) {\n          listeners[event].map(function (fn) {\n            return fn(data);\n          });\n        }\n      }\n\n      function getFiberRoots(rendererID) {\n        var roots = fiberRoots;\n\n        if (!roots[rendererID]) {\n          roots[rendererID] = new Set();\n        }\n\n        return roots[rendererID];\n      }\n\n      function onCommitFiberUnmount(rendererID, fiber) {\n        var rendererInterface = rendererInterfaces.get(rendererID);\n\n        if (rendererInterface != null) {\n          rendererInterface.handleCommitFiberUnmount(fiber);\n        }\n      }\n\n      function onCommitFiberRoot(rendererID, root, priorityLevel) {\n        var mountedRoots = hook.getFiberRoots(rendererID);\n        var current = root.current;\n        var isKnownRoot = mountedRoots.has(root);\n        var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.\n\n        if (!isKnownRoot && !isUnmounting) {\n          mountedRoots.add(root);\n        } else if (isKnownRoot && isUnmounting) {\n          mountedRoots.delete(root);\n        }\n\n        var rendererInterface = rendererInterfaces.get(rendererID);\n\n        if (rendererInterface != null) {\n          rendererInterface.handleCommitFiberRoot(root, priorityLevel);\n        }\n      } // TODO: More meaningful names for \"rendererInterfaces\" and \"renderers\".\n\n\n      var fiberRoots = {};\n      var rendererInterfaces = new Map();\n      var listeners = {};\n      var renderers = new Map();\n      var hook = {\n        rendererInterfaces: rendererInterfaces,\n        listeners: listeners,\n        // Fast Refresh for web relies on this.\n        renderers: renderers,\n        emit: emit,\n        getFiberRoots: getFiberRoots,\n        inject: inject,\n        on: on,\n        off: off,\n        sub: sub,\n        // This is a legacy flag.\n        // React v16 checks the hook for this to ensure DevTools is new enough.\n        supportsFiber: true,\n        // React calls these methods.\n        checkDCE: checkDCE,\n        onCommitFiberUnmount: onCommitFiberUnmount,\n        onCommitFiberRoot: onCommitFiberRoot\n      };\n      Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {\n        // This property needs to be configurable for the test environment,\n        // else we won't be able to delete and recreate it beween tests.\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n          return hook;\n        }\n      });\n      return hook;\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/hydration.js\":\n  /*!*************************************************!*\\\n    !*** ../react-devtools-shared/src/hydration.js ***!\n    \\*************************************************/\n\n  /*! exports provided: meta, dehydrate, fillInPath, hydrate */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"meta\", function () {\n      return meta;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"dehydrate\", function () {\n      return dehydrate;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"fillInPath\", function () {\n      return fillInPath;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"hydrate\", function () {\n      return hydrate;\n    });\n    /* harmony import */\n\n\n    var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! ./utils */\n    \"../react-devtools-shared/src/utils.js\");\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n      }\n\n      return keys;\n    }\n\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function (key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n\n      return target;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var meta = {\n      inspectable: Symbol('inspectable'),\n      inspected: Symbol('inspected'),\n      name: Symbol('name'),\n      preview_long: Symbol('preview_long'),\n      preview_short: Symbol('preview_short'),\n      readonly: Symbol('readonly'),\n      size: Symbol('size'),\n      type: Symbol('type'),\n      unserializable: Symbol('unserializable')\n    }; // This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n    // Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n    // unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n    //\n    // Reducing this threshold will improve the speed of initial component inspection,\n    // but may decrease the responsiveness of expanding objects/arrays to inspect further.\n\n    var LEVEL_THRESHOLD = 2;\n    /**\n     * Generate the dehydrated metadata for complex object instances\n     */\n\n    function createDehydrated(type, inspectable, data, cleaned, path) {\n      cleaned.push(path);\n      var dehydrated = {\n        inspectable: inspectable,\n        type: type,\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n      };\n\n      if (type === 'array' || type === 'typed_array') {\n        dehydrated.size = data.length;\n      } else if (type === 'object') {\n        dehydrated.size = Object.keys(data).length;\n      }\n\n      if (type === 'iterator' || type === 'typed_array') {\n        dehydrated.readonly = true;\n      }\n\n      return dehydrated;\n    }\n    /**\n     * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n     * The paths of the stripped out objects are appended to the `cleaned` list.\n     * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n     * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n     *\n     * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n     * Output: {\n     *   \"some\": {\n     *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n     *   },\n     *   \"other\": {\n     *     \"name\": \"AnInstance\",\n     *     \"type\": \"object\",\n     *   },\n     * }\n     * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n     */\n\n\n    function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {\n      var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(data);\n      var isPathAllowedCheck;\n\n      switch (type) {\n        case 'html_element':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.tagName,\n            type: type\n          };\n\n        case 'function':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.name || 'function',\n            type: type\n          };\n\n        case 'string':\n          return data.length <= 500 ? data : data.slice(0, 500) + '...';\n\n        case 'bigint':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.toString(),\n            type: type\n          };\n\n        case 'symbol':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.toString(),\n            type: type\n          };\n        // React Elements aren't very inspector-friendly,\n        // and often contain private fields or circular references.\n\n        case 'react_element':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDisplayNameForReactElement\"])(data) || 'Unknown',\n            type: type\n          };\n        // ArrayBuffers error if you try to inspect them.\n\n        case 'array_buffer':\n        case 'data_view':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n            size: data.byteLength,\n            type: type\n          };\n\n        case 'array':\n          isPathAllowedCheck = isPathAllowed(path);\n\n          if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n            return createDehydrated(type, true, data, cleaned, path);\n          }\n\n          return data.map(function (item, i) {\n            return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n          });\n\n        case 'typed_array':\n        case 'iterator':\n          isPathAllowedCheck = isPathAllowed(path);\n\n          if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n            return createDehydrated(type, true, data, cleaned, path);\n          } else {\n            var unserializableValue = {\n              unserializable: true,\n              type: type,\n              readonly: true,\n              size: type === 'typed_array' ? data.length : undefined,\n              preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n              preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n              name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n            };\n\n            if (_typeof(data[Symbol.iterator])) {\n              // TRICKY\n              // Don't use [...spread] syntax for this purpose.\n              // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n              // Other types (e.g. typed arrays, Sets) will not spread correctly.\n              Array.from(data).forEach(function (item, i) {\n                return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n              });\n            }\n\n            unserializable.push(path);\n            return unserializableValue;\n          }\n\n        case 'date':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.toString(),\n            type: type\n          };\n\n        case 'regexp':\n          cleaned.push(path);\n          return {\n            inspectable: false,\n            preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n            preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n            name: data.toString(),\n            type: type\n          };\n\n        case 'object':\n          isPathAllowedCheck = isPathAllowed(path);\n\n          if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n            return createDehydrated(type, true, data, cleaned, path);\n          } else {\n            var object = {};\n\n            for (var name in data) {\n              object[name] = dehydrate(data[name], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n            }\n\n            return object;\n          }\n\n        case 'infinity':\n        case 'nan':\n        case 'undefined':\n          // Some values are lossy when sent through a WebSocket.\n          // We dehydrate+rehydrate them to preserve their type.\n          cleaned.push(path);\n          return {\n            type: type\n          };\n\n        default:\n          return data;\n      }\n    }\n\n    function fillInPath(object, data, path, value) {\n      var target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path);\n\n      if (target != null) {\n        if (!target[meta.unserializable]) {\n          delete target[meta.inspectable];\n          delete target[meta.inspected];\n          delete target[meta.name];\n          delete target[meta.preview_long];\n          delete target[meta.preview_short];\n          delete target[meta.readonly];\n          delete target[meta.size];\n          delete target[meta.type];\n        }\n      }\n\n      if (value !== null && data.unserializable.length > 0) {\n        var unserializablePath = data.unserializable[0];\n        var isMatch = unserializablePath.length === path.length;\n\n        for (var i = 0; i < path.length; i++) {\n          if (path[i] !== unserializablePath[i]) {\n            isMatch = false;\n            break;\n          }\n        }\n\n        if (isMatch) {\n          upgradeUnserializable(value, value);\n        }\n      }\n\n      Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"setInObject\"])(object, path, value);\n    }\n\n    function hydrate(object, cleaned, unserializable) {\n      cleaned.forEach(function (path) {\n        var length = path.length;\n        var last = path[length - 1];\n        var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path.slice(0, length - 1));\n\n        if (!parent || !parent.hasOwnProperty(last)) {\n          return;\n        }\n\n        var value = parent[last];\n\n        if (value.type === 'infinity') {\n          parent[last] = Infinity;\n        } else if (value.type === 'nan') {\n          parent[last] = NaN;\n        } else if (value.type === 'undefined') {\n          parent[last] = undefined;\n        } else {\n          // Replace the string keys with Symbols so they're non-enumerable.\n          var replaced = {};\n          replaced[meta.inspectable] = !!value.inspectable;\n          replaced[meta.inspected] = false;\n          replaced[meta.name] = value.name;\n          replaced[meta.preview_long] = value.preview_long;\n          replaced[meta.preview_short] = value.preview_short;\n          replaced[meta.size] = value.size;\n          replaced[meta.readonly] = !!value.readonly;\n          replaced[meta.type] = value.type;\n          parent[last] = replaced;\n        }\n      });\n      unserializable.forEach(function (path) {\n        var length = path.length;\n        var last = path[length - 1];\n        var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path.slice(0, length - 1));\n\n        if (!parent || !parent.hasOwnProperty(last)) {\n          return;\n        }\n\n        var node = parent[last];\n\n        var replacement = _objectSpread({}, node);\n\n        upgradeUnserializable(replacement, node);\n        parent[last] = replacement;\n      });\n      return object;\n    }\n\n    function upgradeUnserializable(destination, source) {\n      var _Object$definePropert;\n\n      Object.defineProperties(destination, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, meta.inspected, {\n        configurable: true,\n        enumerable: false,\n        value: !!source.inspected\n      }), _defineProperty(_Object$definePropert, meta.name, {\n        configurable: true,\n        enumerable: false,\n        value: source.name\n      }), _defineProperty(_Object$definePropert, meta.preview_long, {\n        configurable: true,\n        enumerable: false,\n        value: source.preview_long\n      }), _defineProperty(_Object$definePropert, meta.preview_short, {\n        configurable: true,\n        enumerable: false,\n        value: source.preview_short\n      }), _defineProperty(_Object$definePropert, meta.size, {\n        configurable: true,\n        enumerable: false,\n        value: source.size\n      }), _defineProperty(_Object$definePropert, meta.readonly, {\n        configurable: true,\n        enumerable: false,\n        value: !!source.readonly\n      }), _defineProperty(_Object$definePropert, meta.type, {\n        configurable: true,\n        enumerable: false,\n        value: source.type\n      }), _defineProperty(_Object$definePropert, meta.unserializable, {\n        configurable: true,\n        enumerable: false,\n        value: !!source.unserializable\n      }), _Object$definePropert));\n      delete destination.inspected;\n      delete destination.name;\n      delete destination.preview_long;\n      delete destination.preview_short;\n      delete destination.size;\n      delete destination.readonly;\n      delete destination.type;\n      delete destination.unserializable;\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/storage.js\":\n  /*!***********************************************!*\\\n    !*** ../react-devtools-shared/src/storage.js ***!\n    \\***********************************************/\n\n  /*! exports provided: localStorageGetItem, localStorageRemoveItem, localStorageSetItem, sessionStorageGetItem, sessionStorageRemoveItem, sessionStorageSetItem */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"localStorageGetItem\", function () {\n      return localStorageGetItem;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"localStorageRemoveItem\", function () {\n      return localStorageRemoveItem;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"localStorageSetItem\", function () {\n      return localStorageSetItem;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"sessionStorageGetItem\", function () {\n      return sessionStorageGetItem;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"sessionStorageRemoveItem\", function () {\n      return sessionStorageRemoveItem;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"sessionStorageSetItem\", function () {\n      return sessionStorageSetItem;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function localStorageGetItem(key) {\n      try {\n        return localStorage.getItem(key);\n      } catch (error) {\n        return null;\n      }\n    }\n\n    function localStorageRemoveItem(key) {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {}\n    }\n\n    function localStorageSetItem(key, value) {\n      try {\n        return localStorage.setItem(key, value);\n      } catch (error) {}\n    }\n\n    function sessionStorageGetItem(key) {\n      try {\n        return sessionStorage.getItem(key);\n      } catch (error) {\n        return null;\n      }\n    }\n\n    function sessionStorageRemoveItem(key) {\n      try {\n        sessionStorage.removeItem(key);\n      } catch (error) {}\n    }\n\n    function sessionStorageSetItem(key, value) {\n      try {\n        return sessionStorage.setItem(key, value);\n      } catch (error) {}\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-devtools-shared/src/types.js\":\n  /*!*********************************************!*\\\n    !*** ../react-devtools-shared/src/types.js ***!\n    \\*********************************************/\n\n  /*! exports provided: ElementTypeClass, ElementTypeContext, ElementTypeFunction, ElementTypeForwardRef, ElementTypeHostComponent, ElementTypeMemo, ElementTypeOtherOrUnknown, ElementTypeProfiler, ElementTypeRoot, ElementTypeSuspense, ElementTypeSuspenseList, ComponentFilterElementType, ComponentFilterDisplayName, ComponentFilterLocation, ComponentFilterHOC */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeClass\", function () {\n      return ElementTypeClass;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeContext\", function () {\n      return ElementTypeContext;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeFunction\", function () {\n      return ElementTypeFunction;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeForwardRef\", function () {\n      return ElementTypeForwardRef;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeHostComponent\", function () {\n      return ElementTypeHostComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeMemo\", function () {\n      return ElementTypeMemo;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeOtherOrUnknown\", function () {\n      return ElementTypeOtherOrUnknown;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeProfiler\", function () {\n      return ElementTypeProfiler;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeRoot\", function () {\n      return ElementTypeRoot;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeSuspense\", function () {\n      return ElementTypeSuspense;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ElementTypeSuspenseList\", function () {\n      return ElementTypeSuspenseList;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ComponentFilterElementType\", function () {\n      return ComponentFilterElementType;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ComponentFilterDisplayName\", function () {\n      return ComponentFilterDisplayName;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ComponentFilterLocation\", function () {\n      return ComponentFilterLocation;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ComponentFilterHOC\", function () {\n      return ComponentFilterHOC;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // WARNING\n    // The values below are referenced by ComponentFilters (which are saved via localStorage).\n    // Do not change them or it will break previously saved user customizations.\n    // If new element types are added, use new numbers rather than re-ordering existing ones.\n    //\n    // Changing these types is also a backwards breaking change for the standalone shell,\n    // since the frontend and backend must share the same values-\n    // and the backend is embedded in certain environments (like React Native).\n\n\n    var ElementTypeClass = 1;\n    var ElementTypeContext = 2;\n    var ElementTypeFunction = 5;\n    var ElementTypeForwardRef = 6;\n    var ElementTypeHostComponent = 7;\n    var ElementTypeMemo = 8;\n    var ElementTypeOtherOrUnknown = 9;\n    var ElementTypeProfiler = 10;\n    var ElementTypeRoot = 11;\n    var ElementTypeSuspense = 12;\n    var ElementTypeSuspenseList = 13; // Different types of elements displayed in the Elements tree.\n    // These types may be used to visually distinguish types,\n    // or to enable/disable certain functionality.\n    // WARNING\n    // The values below are referenced by ComponentFilters (which are saved via localStorage).\n    // Do not change them or it will break previously saved user customizations.\n    // If new filter types are added, use new numbers rather than re-ordering existing ones.\n\n    var ComponentFilterElementType = 1;\n    var ComponentFilterDisplayName = 2;\n    var ComponentFilterLocation = 3;\n    var ComponentFilterHOC = 4;\n    /***/\n  },\n\n  /***/\n  \"../react-devtools-shared/src/utils.js\":\n  /*!*********************************************!*\\\n    !*** ../react-devtools-shared/src/utils.js ***!\n    \\*********************************************/\n\n  /*! exports provided: alphaSortKeys, getDisplayName, getUID, utfDecodeString, utfEncodeString, printOperationsArray, getDefaultComponentFilters, getSavedComponentFilters, saveComponentFilters, getAppendComponentStack, setAppendComponentStack, getBreakOnConsoleErrors, setBreakOnConsoleErrors, separateDisplayNameAndHOCs, shallowDiffers, getInObject, setInObject, getDataType, getDisplayNameForReactElement, formatDataForPreview */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"alphaSortKeys\", function () {\n      return alphaSortKeys;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getDisplayName\", function () {\n      return getDisplayName;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getUID\", function () {\n      return getUID;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"utfDecodeString\", function () {\n      return utfDecodeString;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"utfEncodeString\", function () {\n      return utfEncodeString;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"printOperationsArray\", function () {\n      return printOperationsArray;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getDefaultComponentFilters\", function () {\n      return getDefaultComponentFilters;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getSavedComponentFilters\", function () {\n      return getSavedComponentFilters;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"saveComponentFilters\", function () {\n      return saveComponentFilters;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getAppendComponentStack\", function () {\n      return getAppendComponentStack;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"setAppendComponentStack\", function () {\n      return setAppendComponentStack;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getBreakOnConsoleErrors\", function () {\n      return getBreakOnConsoleErrors;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"setBreakOnConsoleErrors\", function () {\n      return setBreakOnConsoleErrors;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"separateDisplayNameAndHOCs\", function () {\n      return separateDisplayNameAndHOCs;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"shallowDiffers\", function () {\n      return shallowDiffers;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getInObject\", function () {\n      return getInObject;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"setInObject\", function () {\n      return setInObject;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getDataType\", function () {\n      return getDataType;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getDisplayNameForReactElement\", function () {\n      return getDisplayNameForReactElement;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"formatDataForPreview\", function () {\n      return formatDataForPreview;\n    });\n    /* harmony import */\n\n\n    var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! lru-cache */\n    \"../../node_modules/lru-cache/index.js\");\n    /* harmony import */\n\n\n    var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */\n\n\n    var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! react-is */\n    \"react-is\");\n    /* harmony import */\n\n\n    var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);\n    /* harmony import */\n\n\n    var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! ./constants */\n    \"../react-devtools-shared/src/constants.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! react-devtools-shared/src/types */\n    \"../react-devtools-shared/src/types.js\");\n    /* harmony import */\n\n\n    var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! ./storage */\n    \"../react-devtools-shared/src/storage.js\");\n    /* harmony import */\n\n\n    var _hydration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\n    /*! ./hydration */\n    \"../react-devtools-shared/src/hydration.js\");\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n    }\n\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n    }\n\n    function _iterableToArray(iter) {\n      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n    }\n\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n\n        return arr2;\n      }\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n    // Try to reuse the already encoded strings.\n\n    var encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({\n      max: 1000\n    });\n\n    function alphaSortKeys(a, b) {\n      if (a > b) {\n        return 1;\n      } else if (b > a) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n\n    function getDisplayName(type) {\n      var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';\n      var nameFromCache = cachedDisplayNames.get(type);\n\n      if (nameFromCache != null) {\n        return nameFromCache;\n      }\n\n      var displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n      // It's only safe to use for our purposes if it's a string.\n      // github.com/facebook/react-devtools/issues/803\n\n      if (typeof type.displayName === 'string') {\n        displayName = type.displayName;\n      } else if (typeof type.name === 'string' && type.name !== '') {\n        displayName = type.name;\n      }\n\n      cachedDisplayNames.set(type, displayName);\n      return displayName;\n    }\n\n    var uidCounter = 0;\n\n    function getUID() {\n      return ++uidCounter;\n    }\n\n    function utfDecodeString(array) {\n      return String.fromCodePoint.apply(String, _toConsumableArray(array));\n    }\n\n    function utfEncodeString(string) {\n      var cached = encodedStringCache.get(string);\n\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      var encoded = new Array(string.length);\n\n      for (var i = 0; i < string.length; i++) {\n        encoded[i] = string.codePointAt(i);\n      }\n\n      encodedStringCache.set(string, encoded);\n      return encoded;\n    }\n\n    function printOperationsArray(operations) {\n      // The first two values are always rendererID and rootID\n      var rendererID = operations[0];\n      var rootID = operations[1];\n      var logs = [\"operations for renderer:\".concat(rendererID, \" and root:\").concat(rootID)];\n      var i = 2; // Reassemble the string table.\n\n      var stringTable = [null // ID = 0 corresponds to the null string.\n      ];\n      var stringTableSize = operations[i++];\n      var stringTableEnd = i + stringTableSize;\n\n      while (i < stringTableEnd) {\n        var nextLength = operations[i++];\n        var nextString = utfDecodeString(operations.slice(i, i + nextLength));\n        stringTable.push(nextString);\n        i += nextLength;\n      }\n\n      while (i < operations.length) {\n        var operation = operations[i];\n\n        switch (operation) {\n          case _constants__WEBPACK_IMPORTED_MODULE_2__[\"TREE_OPERATION_ADD\"]:\n            {\n              var id = operations[i + 1];\n              var type = operations[i + 2];\n              i += 3;\n\n              if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeRoot\"]) {\n                logs.push(\"Add new root node \".concat(id));\n                i++; // supportsProfiling\n\n                i++; // hasOwnerMetadata\n              } else {\n                var parentID = operations[i];\n                i++;\n                i++; // ownerID\n\n                var displayNameStringID = operations[i];\n                var displayName = stringTable[displayNameStringID];\n                i++;\n                i++; // key\n\n                logs.push(\"Add node \".concat(id, \" (\").concat(displayName || 'null', \") as child of \").concat(parentID));\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_2__[\"TREE_OPERATION_REMOVE\"]:\n            {\n              var removeLength = operations[i + 1];\n              i += 2;\n\n              for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n                var _id = operations[i];\n                i += 1;\n                logs.push(\"Remove node \".concat(_id));\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_2__[\"TREE_OPERATION_REORDER_CHILDREN\"]:\n            {\n              var _id2 = operations[i + 1];\n              var numChildren = operations[i + 2];\n              i += 3;\n              var children = operations.slice(i, i + numChildren);\n              i += numChildren;\n              logs.push(\"Re-order node \".concat(_id2, \" children \").concat(children.join(',')));\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_2__[\"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\"]:\n            // Base duration updates are only sent while profiling is in progress.\n            // We can ignore them at this point.\n            // The profiler UI uses them lazily in order to generate the tree.\n            i += 3;\n            break;\n\n          default:\n            throw Error(\"Unsupported Bridge operation \".concat(operation));\n        }\n      }\n\n      console.log(logs.join('\\n  '));\n    }\n\n    function getDefaultComponentFilters() {\n      return [{\n        type: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ComponentFilterElementType\"],\n        value: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeHostComponent\"],\n        isEnabled: true\n      }];\n    }\n\n    function getSavedComponentFilters() {\n      try {\n        var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\"]);\n\n        if (raw != null) {\n          return JSON.parse(raw);\n        }\n      } catch (error) {}\n\n      return getDefaultComponentFilters();\n    }\n\n    function saveComponentFilters(componentFilters) {\n      Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\"], JSON.stringify(componentFilters));\n    }\n\n    function getAppendComponentStack() {\n      try {\n        var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\"]);\n\n        if (raw != null) {\n          return JSON.parse(raw);\n        }\n      } catch (error) {}\n\n      return true;\n    }\n\n    function setAppendComponentStack(value) {\n      Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\"], JSON.stringify(value));\n    }\n\n    function getBreakOnConsoleErrors() {\n      try {\n        var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\"]);\n\n        if (raw != null) {\n          return JSON.parse(raw);\n        }\n      } catch (error) {}\n\n      return false;\n    }\n\n    function setBreakOnConsoleErrors(value) {\n      Object(_storage__WEBPACK_IMPORTED_MODULE_4__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_2__[\"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\"], JSON.stringify(value));\n    }\n\n    function separateDisplayNameAndHOCs(displayName, type) {\n      if (displayName === null) {\n        return [null, null];\n      }\n\n      var hocDisplayNames = null;\n\n      switch (type) {\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeClass\"]:\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeForwardRef\"]:\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeFunction\"]:\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeMemo\"]:\n          if (displayName.indexOf('(') >= 0) {\n            var matches = displayName.match(/[^()]+/g);\n\n            if (matches != null) {\n              displayName = matches.pop();\n              hocDisplayNames = matches;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeMemo\"]) {\n        if (hocDisplayNames === null) {\n          hocDisplayNames = ['Memo'];\n        } else {\n          hocDisplayNames.unshift('Memo');\n        }\n      } else if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_3__[\"ElementTypeForwardRef\"]) {\n        if (hocDisplayNames === null) {\n          hocDisplayNames = ['ForwardRef'];\n        } else {\n          hocDisplayNames.unshift('ForwardRef');\n        }\n      }\n\n      return [displayName, hocDisplayNames];\n    } // Pulled from react-compat\n    // https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\n\n    function shallowDiffers(prev, next) {\n      for (var attribute in prev) {\n        if (!(attribute in next)) {\n          return true;\n        }\n      }\n\n      for (var _attribute in next) {\n        if (prev[_attribute] !== next[_attribute]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getInObject(object, path) {\n      return path.reduce(function (reduced, attr) {\n        if (reduced) {\n          if (hasOwnProperty.call(reduced, attr)) {\n            return reduced[attr];\n          }\n\n          if (typeof reduced[Symbol.iterator] === 'function') {\n            // Convert iterable to array and return array[index]\n            //\n            // TRICKY\n            // Don't use [...spread] syntax for this purpose.\n            // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n            // Other types (e.g. typed arrays, Sets) will not spread correctly.\n            return Array.from(reduced)[attr];\n          }\n        }\n\n        return null;\n      }, object);\n    }\n\n    function setInObject(object, path, value) {\n      var length = path.length;\n      var last = path[length - 1];\n\n      if (object != null) {\n        var parent = getInObject(object, path.slice(0, length - 1));\n\n        if (parent) {\n          parent[last] = value;\n        }\n      }\n    }\n    /**\n     * Get a enhanced/artificial type string based on the object instance\n     */\n\n\n    function getDataType(data) {\n      if (data === null) {\n        return 'null';\n      } else if (data === undefined) {\n        return 'undefined';\n      }\n\n      if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__[\"isElement\"])(data)) {\n        return 'react_element';\n      }\n\n      if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n        return 'html_element';\n      }\n\n      var type = _typeof(data);\n\n      switch (type) {\n        case 'bigint':\n          return 'bigint';\n\n        case 'boolean':\n          return 'boolean';\n\n        case 'function':\n          return 'function';\n\n        case 'number':\n          if (Number.isNaN(data)) {\n            return 'nan';\n          } else if (!Number.isFinite(data)) {\n            return 'infinity';\n          } else {\n            return 'number';\n          }\n\n        case 'object':\n          if (Array.isArray(data)) {\n            return 'array';\n          } else if (ArrayBuffer.isView(data)) {\n            return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n          } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n            // HACK This ArrayBuffer check is gross; is there a better way?\n            // We could try to create a new DataView with the value.\n            // If it doesn't error, we know it's an ArrayBuffer,\n            // but this seems kind of awkward and expensive.\n            return 'array_buffer';\n          } else if (typeof data[Symbol.iterator] === 'function') {\n            return 'iterator';\n          } else if (data.constructor && data.constructor.name === 'RegExp') {\n            return 'regexp';\n          } else if (Object.prototype.toString.call(data) === '[object Date]') {\n            return 'date';\n          }\n\n          return 'object';\n\n        case 'string':\n          return 'string';\n\n        case 'symbol':\n          return 'symbol';\n\n        default:\n          return 'unknown';\n      }\n    }\n\n    function getDisplayNameForReactElement(element) {\n      var elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__[\"typeOf\"])(element);\n\n      switch (elementType) {\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ContextConsumer\"]:\n          return 'ContextConsumer';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ContextProvider\"]:\n          return 'ContextProvider';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ForwardRef\"]:\n          return 'ForwardRef';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"]:\n          return 'Fragment';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Lazy\"]:\n          return 'Lazy';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Memo\"]:\n          return 'Memo';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Portal\"]:\n          return 'Portal';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Profiler\"]:\n          return 'Profiler';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"StrictMode\"]:\n          return 'StrictMode';\n\n        case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Suspense\"]:\n          return 'Suspense';\n\n        default:\n          var type = element.type;\n\n          if (typeof type === 'string') {\n            return type;\n          } else if (type != null) {\n            return getDisplayName(type, 'Anonymous');\n          } else {\n            return 'Element';\n          }\n\n      }\n    }\n\n    var MAX_PREVIEW_STRING_LENGTH = 50;\n\n    function truncateForDisplay(string) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;\n\n      if (string.length > length) {\n        return string.substr(0, length) + '';\n      } else {\n        return string;\n      }\n    } // Attempts to mimic Chrome's inline preview for values.\n    // For example, the following value...\n    //   {\n    //      foo: 123,\n    //      bar: \"abc\",\n    //      baz: [true, false],\n    //      qux: { ab: 1, cd: 2 }\n    //   };\n    //\n    // Would show a preview of...\n    //   {foo: 123, bar: \"abc\", baz: Array(2), qux: {}}\n    //\n    // And the following value...\n    //   [\n    //     123,\n    //     \"abc\",\n    //     [true, false],\n    //     { foo: 123, bar: \"abc\" }\n    //   ];\n    //\n    // Would show a preview of...\n    //   [123, \"abc\", Array(2), {}]\n\n\n    function formatDataForPreview(data, showFormattedValue) {\n      if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_5__[\"meta\"].type)) {\n        return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_5__[\"meta\"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_5__[\"meta\"].preview_short];\n      }\n\n      var type = getDataType(data);\n\n      switch (type) {\n        case 'html_element':\n          return \"<\".concat(truncateForDisplay(data.tagName.toLowerCase()), \" />\");\n\n        case 'function':\n          return truncateForDisplay(\"\\u0192 \".concat(data.name, \"() {}\"));\n\n        case 'string':\n          return \"\\\"\".concat(data, \"\\\"\");\n\n        case 'bigint':\n          return truncateForDisplay(data.toString() + 'n');\n\n        case 'regexp':\n          return truncateForDisplay(data.toString());\n\n        case 'symbol':\n          return truncateForDisplay(data.toString());\n\n        case 'react_element':\n          return \"<\".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), \" />\");\n\n        case 'array_buffer':\n          return \"ArrayBuffer(\".concat(data.byteLength, \")\");\n\n        case 'data_view':\n          return \"DataView(\".concat(data.buffer.byteLength, \")\");\n\n        case 'array':\n          if (showFormattedValue) {\n            var formatted = '';\n\n            for (var i = 0; i < data.length; i++) {\n              if (i > 0) {\n                formatted += ', ';\n              }\n\n              formatted += formatDataForPreview(data[i], false);\n\n              if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n                // Prevent doing a lot of unnecessary iteration...\n                break;\n              }\n            }\n\n            return \"[\".concat(truncateForDisplay(formatted), \"]\");\n          } else {\n            var length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_5__[\"meta\"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_5__[\"meta\"].size] : data.length;\n            return \"Array(\".concat(length, \")\");\n          }\n\n        case 'typed_array':\n          var shortName = \"\".concat(data.constructor.name, \"(\").concat(data.length, \")\");\n\n          if (showFormattedValue) {\n            var _formatted = '';\n\n            for (var _i = 0; _i < data.length; _i++) {\n              if (_i > 0) {\n                _formatted += ', ';\n              }\n\n              _formatted += data[_i];\n\n              if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n                // Prevent doing a lot of unnecessary iteration...\n                break;\n              }\n            }\n\n            return \"\".concat(shortName, \" [\").concat(truncateForDisplay(_formatted), \"]\");\n          } else {\n            return shortName;\n          }\n\n        case 'iterator':\n          var name = data.constructor.name;\n\n          if (showFormattedValue) {\n            // TRICKY\n            // Don't use [...spread] syntax for this purpose.\n            // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n            // Other types (e.g. typed arrays, Sets) will not spread correctly.\n            var array = Array.from(data);\n            var _formatted2 = '';\n\n            for (var _i2 = 0; _i2 < array.length; _i2++) {\n              var entryOrEntries = array[_i2];\n\n              if (_i2 > 0) {\n                _formatted2 += ', ';\n              } // TRICKY\n              // Browsers display Maps and Sets differently.\n              // To mimic their behavior, detect if we've been given an entries tuple.\n              //   Map(2) {\"abc\" => 123, \"def\" => 123}\n              //   Set(2) {\"abc\", 123}\n\n\n              if (Array.isArray(entryOrEntries)) {\n                var key = formatDataForPreview(entryOrEntries[0], true);\n                var value = formatDataForPreview(entryOrEntries[1], false);\n                _formatted2 += \"\".concat(key, \" => \").concat(value);\n              } else {\n                _formatted2 += formatDataForPreview(entryOrEntries, false);\n              }\n\n              if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {\n                // Prevent doing a lot of unnecessary iteration...\n                break;\n              }\n            }\n\n            return \"\".concat(name, \"(\").concat(data.size, \") {\").concat(truncateForDisplay(_formatted2), \"}\");\n          } else {\n            return \"\".concat(name, \"(\").concat(data.size, \")\");\n          }\n\n        case 'date':\n          return data.toString();\n\n        case 'object':\n          if (showFormattedValue) {\n            var keys = Object.keys(data).sort(alphaSortKeys);\n            var _formatted3 = '';\n\n            for (var _i3 = 0; _i3 < keys.length; _i3++) {\n              var _key = keys[_i3];\n\n              if (_i3 > 0) {\n                _formatted3 += ', ';\n              }\n\n              _formatted3 += \"\".concat(_key, \": \").concat(formatDataForPreview(data[_key], false));\n\n              if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {\n                // Prevent doing a lot of unnecessary iteration...\n                break;\n              }\n            }\n\n            return \"{\".concat(truncateForDisplay(_formatted3), \"}\");\n          } else {\n            return '{}';\n          }\n\n        case 'boolean':\n        case 'number':\n        case 'infinity':\n        case 'nan':\n        case 'null':\n        case 'undefined':\n          return data;\n\n        default:\n          try {\n            return truncateForDisplay('' + data);\n          } catch (error) {\n            return 'unserializable';\n          }\n\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../react-reconciler/src/ReactTypeOfMode.js\":\n  /*!**************************************************!*\\\n    !*** ../react-reconciler/src/ReactTypeOfMode.js ***!\n    \\**************************************************/\n\n  /*! exports provided: NoMode, StrictMode, BlockingMode, ConcurrentMode, ProfileMode, DebugTracingMode */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"NoMode\", function () {\n      return NoMode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"StrictMode\", function () {\n      return StrictMode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"BlockingMode\", function () {\n      return BlockingMode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ConcurrentMode\", function () {\n      return ConcurrentMode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ProfileMode\", function () {\n      return ProfileMode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"DebugTracingMode\", function () {\n      return DebugTracingMode;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var NoMode = 0;\n    var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root\n    // tag instead\n\n    var BlockingMode = 2;\n    var ConcurrentMode = 4;\n    var ProfileMode = 8;\n    var DebugTracingMode = 16;\n    /***/\n  },\n\n  /***/\n  \"../react-reconciler/src/ReactWorkTags.js\":\n  /*!************************************************!*\\\n    !*** ../react-reconciler/src/ReactWorkTags.js ***!\n    \\************************************************/\n\n  /*! exports provided: FunctionComponent, ClassComponent, IndeterminateComponent, HostRoot, HostPortal, HostComponent, HostText, Fragment, Mode, ContextConsumer, ContextProvider, ForwardRef, Profiler, SuspenseComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, DehydratedFragment, SuspenseListComponent, FundamentalComponent, ScopeComponent, Block, OffscreenComponent, LegacyHiddenComponent */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FunctionComponent\", function () {\n      return FunctionComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ClassComponent\", function () {\n      return ClassComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"IndeterminateComponent\", function () {\n      return IndeterminateComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"HostRoot\", function () {\n      return HostRoot;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"HostPortal\", function () {\n      return HostPortal;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"HostComponent\", function () {\n      return HostComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"HostText\", function () {\n      return HostText;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"Fragment\", function () {\n      return Fragment;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"Mode\", function () {\n      return Mode;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ContextConsumer\", function () {\n      return ContextConsumer;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ContextProvider\", function () {\n      return ContextProvider;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ForwardRef\", function () {\n      return ForwardRef;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"Profiler\", function () {\n      return Profiler;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SuspenseComponent\", function () {\n      return SuspenseComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"MemoComponent\", function () {\n      return MemoComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SimpleMemoComponent\", function () {\n      return SimpleMemoComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LazyComponent\", function () {\n      return LazyComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"IncompleteClassComponent\", function () {\n      return IncompleteClassComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"DehydratedFragment\", function () {\n      return DehydratedFragment;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"SuspenseListComponent\", function () {\n      return SuspenseListComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"FundamentalComponent\", function () {\n      return FundamentalComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"ScopeComponent\", function () {\n      return ScopeComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"Block\", function () {\n      return Block;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"OffscreenComponent\", function () {\n      return OffscreenComponent;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"LegacyHiddenComponent\", function () {\n      return LegacyHiddenComponent;\n    });\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var FunctionComponent = 0;\n    var ClassComponent = 1;\n    var IndeterminateComponent = 2; // Before we know whether it is function or class\n\n    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\n    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\n    var HostComponent = 5;\n    var HostText = 6;\n    var Fragment = 7;\n    var Mode = 8;\n    var ContextConsumer = 9;\n    var ContextProvider = 10;\n    var ForwardRef = 11;\n    var Profiler = 12;\n    var SuspenseComponent = 13;\n    var MemoComponent = 14;\n    var SimpleMemoComponent = 15;\n    var LazyComponent = 16;\n    var IncompleteClassComponent = 17;\n    var DehydratedFragment = 18;\n    var SuspenseListComponent = 19;\n    var FundamentalComponent = 20;\n    var ScopeComponent = 21;\n    var Block = 22;\n    var OffscreenComponent = 23;\n    var LegacyHiddenComponent = 24;\n    /***/\n  },\n\n  /***/\n  \"../shared/ConsolePatchingDev.js\":\n  /*!***************************************!*\\\n    !*** ../shared/ConsolePatchingDev.js ***!\n    \\***************************************/\n\n  /*! exports provided: disableLogs, reenableLogs */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"disableLogs\", function () {\n      return disableLogs;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"reenableLogs\", function () {\n      return reenableLogs;\n    });\n\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n      }\n\n      return keys;\n    }\n\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function (key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function (key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n\n      return target;\n    }\n\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n\n      return obj;\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      if (true) {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      if (true) {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _objectSpread({}, props, {\n              value: prevLog\n            }),\n            info: _objectSpread({}, props, {\n              value: prevInfo\n            }),\n            warn: _objectSpread({}, props, {\n              value: prevWarn\n            }),\n            error: _objectSpread({}, props, {\n              value: prevError\n            }),\n            group: _objectSpread({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _objectSpread({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _objectSpread({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    /***/\n\n  },\n\n  /***/\n  \"../shared/ReactSharedInternals.js\":\n  /*!*****************************************!*\\\n    !*** ../shared/ReactSharedInternals.js ***!\n    \\*****************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */\n\n\n    var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react */\n    \"react\");\n    /* harmony import */\n\n\n    var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var ReactSharedInternals = react__WEBPACK_IMPORTED_MODULE_0__[\"__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\"];\n    /* harmony default export */\n\n    __webpack_exports__[\"default\"] = ReactSharedInternals;\n    /***/\n  },\n\n  /***/\n  \"../shared/ReactSymbols.js\":\n  /*!*********************************!*\\\n    !*** ../shared/ReactSymbols.js ***!\n    \\*********************************/\n\n  /*! exports provided: REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE, REACT_FRAGMENT_TYPE, REACT_STRICT_MODE_TYPE, REACT_PROFILER_TYPE, REACT_PROVIDER_TYPE, REACT_CONTEXT_TYPE, REACT_FORWARD_REF_TYPE, REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE, REACT_BLOCK_TYPE, REACT_SERVER_BLOCK_TYPE, REACT_FUNDAMENTAL_TYPE, REACT_RESPONDER_TYPE, REACT_SCOPE_TYPE, REACT_OPAQUE_ID_TYPE, REACT_DEBUG_TRACING_MODE_TYPE, REACT_OFFSCREEN_TYPE, REACT_LEGACY_HIDDEN_TYPE, getIteratorFn */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_ELEMENT_TYPE\", function () {\n      return REACT_ELEMENT_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_PORTAL_TYPE\", function () {\n      return REACT_PORTAL_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_FRAGMENT_TYPE\", function () {\n      return REACT_FRAGMENT_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_STRICT_MODE_TYPE\", function () {\n      return REACT_STRICT_MODE_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_PROFILER_TYPE\", function () {\n      return REACT_PROFILER_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_PROVIDER_TYPE\", function () {\n      return REACT_PROVIDER_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_CONTEXT_TYPE\", function () {\n      return REACT_CONTEXT_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_FORWARD_REF_TYPE\", function () {\n      return REACT_FORWARD_REF_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_SUSPENSE_TYPE\", function () {\n      return REACT_SUSPENSE_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_SUSPENSE_LIST_TYPE\", function () {\n      return REACT_SUSPENSE_LIST_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_MEMO_TYPE\", function () {\n      return REACT_MEMO_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_LAZY_TYPE\", function () {\n      return REACT_LAZY_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_BLOCK_TYPE\", function () {\n      return REACT_BLOCK_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_SERVER_BLOCK_TYPE\", function () {\n      return REACT_SERVER_BLOCK_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_FUNDAMENTAL_TYPE\", function () {\n      return REACT_FUNDAMENTAL_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_RESPONDER_TYPE\", function () {\n      return REACT_RESPONDER_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_SCOPE_TYPE\", function () {\n      return REACT_SCOPE_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_OPAQUE_ID_TYPE\", function () {\n      return REACT_OPAQUE_ID_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_DEBUG_TRACING_MODE_TYPE\", function () {\n      return REACT_DEBUG_TRACING_MODE_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_OFFSCREEN_TYPE\", function () {\n      return REACT_OFFSCREEN_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"REACT_LEGACY_HIDDEN_TYPE\", function () {\n      return REACT_LEGACY_HIDDEN_TYPE;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"getIteratorFn\", function () {\n      return getIteratorFn;\n    });\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    var REACT_FRAGMENT_TYPE = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_RESPONDER_TYPE = 0xead6;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_RESPONDER_TYPE = symbolFor('react.responder');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n    /***/\n\n  },\n\n  /***/\n  \"./src/backend.js\":\n  /*!************************!*\\\n    !*** ./src/backend.js ***!\n    \\************************/\n\n  /*! exports provided: activate, initialize */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"activate\", function () {\n      return activate;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"initialize\", function () {\n      return initialize;\n    });\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend/agent */\n    \"../react-devtools-shared/src/backend/agent.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n    /*! react-devtools-shared/src/bridge */\n    \"../react-devtools-shared/src/bridge.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend */\n    \"../react-devtools-shared/src/backend/index.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_hook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n    /*! react-devtools-shared/src/hook */\n    \"../react-devtools-shared/src/hook.js\");\n    /* harmony import */\n\n\n    var react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n    /*! react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor */\n    \"../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\");\n    /* harmony import */\n\n\n    var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\n    /*! ./constants */\n    \"./src/constants.js\");\n\n    function startActivation(contentWindow) {\n      var parent = contentWindow.parent;\n\n      var onMessage = function onMessage(_ref) {\n        var data = _ref.data;\n\n        switch (data.type) {\n          case _constants__WEBPACK_IMPORTED_MODULE_5__[\"MESSAGE_TYPE_SAVED_PREFERENCES\"]:\n            // This is the only message we're listening for,\n            // so it's safe to cleanup after we've received it.\n            contentWindow.removeEventListener('message', onMessage);\n            var appendComponentStack = data.appendComponentStack,\n                breakOnConsoleErrors = data.breakOnConsoleErrors,\n                componentFilters = data.componentFilters;\n            contentWindow.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;\n            contentWindow.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;\n            contentWindow.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters; // TRICKY\n            // The backend entry point may be required in the context of an iframe or the parent window.\n            // If it's required within the parent window, store the saved values on it as well,\n            // since the injected renderer interface will read from window.\n            // Technically we don't need to store them on the contentWindow in this case,\n            // but it doesn't really hurt anything to store them there too.\n\n            if (contentWindow !== window) {\n              window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;\n              window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;\n              window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters;\n            }\n\n            finishActivation(contentWindow);\n            break;\n\n          default:\n            break;\n        }\n      };\n\n      contentWindow.addEventListener('message', onMessage); // The backend may be unable to read saved preferences directly,\n      // because they are stored in localStorage within the context of the extension (on the frontend).\n      // Instead it relies on the extension to pass preferences through.\n      // Because we might be in a sandboxed iframe, we have to ask for them by way of postMessage().\n\n      parent.postMessage({\n        type: _constants__WEBPACK_IMPORTED_MODULE_5__[\"MESSAGE_TYPE_GET_SAVED_PREFERENCES\"]\n      }, '*');\n    }\n\n    function finishActivation(contentWindow) {\n      var parent = contentWindow.parent;\n      var bridge = new react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        listen: function listen(fn) {\n          var onMessage = function onMessage(event) {\n            fn(event.data);\n          };\n\n          contentWindow.addEventListener('message', onMessage);\n          return function () {\n            contentWindow.removeEventListener('message', onMessage);\n          };\n        },\n        send: function send(event, payload, transferable) {\n          parent.postMessage({\n            event: event,\n            payload: payload\n          }, '*', transferable);\n        }\n      });\n      var agent = new react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bridge);\n      var hook = contentWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n      if (hook) {\n        Object(react_devtools_shared_src_backend__WEBPACK_IMPORTED_MODULE_2__[\"initBackend\"])(hook, agent, contentWindow); // Setup React Native style editor if a renderer like react-native-web has injected it.\n\n        if (hook.resolveRNStyle) {\n          Object(react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(bridge, agent, hook.resolveRNStyle, hook.nativeStyleEditorValidAttributes);\n        }\n      }\n    }\n\n    function activate(contentWindow) {\n      startActivation(contentWindow);\n    }\n\n    function initialize(contentWindow) {\n      Object(react_devtools_shared_src_hook__WEBPACK_IMPORTED_MODULE_3__[\"installHook\"])(contentWindow);\n    }\n    /***/\n\n  },\n\n  /***/\n  \"./src/constants.js\":\n  /*!**************************!*\\\n    !*** ./src/constants.js ***!\n    \\**************************/\n\n  /*! exports provided: MESSAGE_TYPE_GET_SAVED_PREFERENCES, MESSAGE_TYPE_SAVED_PREFERENCES */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"MESSAGE_TYPE_GET_SAVED_PREFERENCES\", function () {\n      return MESSAGE_TYPE_GET_SAVED_PREFERENCES;\n    });\n    /* harmony export (binding) */\n\n\n    __webpack_require__.d(__webpack_exports__, \"MESSAGE_TYPE_SAVED_PREFERENCES\", function () {\n      return MESSAGE_TYPE_SAVED_PREFERENCES;\n    });\n\n    var MESSAGE_TYPE_GET_SAVED_PREFERENCES = 'React::DevTools::getSavedPreferences';\n    var MESSAGE_TYPE_SAVED_PREFERENCES = 'React::DevTools::savedPreferences';\n    /***/\n  },\n\n  /***/\n  \"react\":\n  /*!************************!*\\\n    !*** external \"react\" ***!\n    \\************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    module.exports = require(\"react\");\n    /***/\n  },\n\n  /***/\n  \"react-is\":\n  /*!***************************!*\\\n    !*** external \"react-is\" ***!\n    \\***************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    module.exports = require(\"react-is\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}