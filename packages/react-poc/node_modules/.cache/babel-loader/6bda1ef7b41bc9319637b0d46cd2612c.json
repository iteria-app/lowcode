{"ast":null,"code":"/** @license React v1.4.1\n * use-subscription.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var _assign = require('object-assign');\n\n    var react = require('react'); //\n    // In order to avoid removing and re-adding subscriptions each time this hook is called,\n    // the parameters passed to this hook should be memoized in some wayâ€“\n    // either by wrapping the entire params object with useMemo()\n    // or by wrapping the individual callbacks with useCallback().\n\n\n    function useSubscription(_ref) {\n      var getCurrentValue = _ref.getCurrentValue,\n          subscribe = _ref.subscribe; // Read the current value from our subscription.\n      // When this value changes, we'll schedule an update with React.\n      // It's important to also store the hook params so that we can check for staleness.\n      // (See the comment in checkForUpdates() below for more info.)\n\n      var _useState = react.useState(function () {\n        return {\n          getCurrentValue: getCurrentValue,\n          subscribe: subscribe,\n          value: getCurrentValue()\n        };\n      }),\n          state = _useState[0],\n          setState = _useState[1];\n\n      var valueToReturn = state.value; // If parameters have changed since our last render, schedule an update with its current value.\n\n      if (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) {\n        // If the subscription has been updated, we'll schedule another update with React.\n        // React will process this update immediately, so the old subscription value won't be committed.\n        // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n        valueToReturn = getCurrentValue();\n        setState({\n          getCurrentValue: getCurrentValue,\n          subscribe: subscribe,\n          value: valueToReturn\n        });\n      } // Display the current value for this hook in React DevTools.\n\n\n      react.useDebugValue(valueToReturn); // It is important not to subscribe while rendering because this can lead to memory leaks.\n      // (Learn more at reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects)\n      // Instead, we wait until the commit phase to attach our handler.\n      //\n      // We intentionally use a passive effect (useEffect) rather than a synchronous one (useLayoutEffect)\n      // so that we don't stretch the commit phase.\n      // This also has an added benefit when multiple components are subscribed to the same source:\n      // It allows each of the event handlers to safely schedule work without potentially removing an another handler.\n      // (Learn more at https://codesandbox.io/s/k0yvr5970o)\n\n      react.useEffect(function () {\n        var didUnsubscribe = false;\n\n        var checkForUpdates = function () {\n          // It's possible that this callback will be invoked even after being unsubscribed,\n          // if it's removed as a result of a subscription event/update.\n          // In this case, React will log a DEV warning about an update from an unmounted component.\n          // We can avoid triggering that warning with this check.\n          if (didUnsubscribe) {\n            return;\n          } // We use a state updater function to avoid scheduling work for a stale source.\n          // However it's important to eagerly read the currently value,\n          // so that all scheduled work shares the same value (in the event of multiple subscriptions).\n          // This avoids visual \"tearing\" when a mutation happens during a (concurrent) render.\n\n\n          var value = getCurrentValue();\n          setState(function (prevState) {\n            // Ignore values from stale sources!\n            // Since we subscribe an unsubscribe in a passive effect,\n            // it's possible that this callback will be invoked for a stale (previous) subscription.\n            // This check avoids scheduling an update for that stale subscription.\n            if (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) {\n              return prevState;\n            } // Some subscriptions will auto-invoke the handler, even if the value hasn't changed.\n            // If the value hasn't changed, no update is needed.\n            // Return state as-is so React can bail out and avoid an unnecessary render.\n\n\n            if (prevState.value === value) {\n              return prevState;\n            }\n\n            return _assign({}, prevState, {\n              value: value\n            });\n          });\n        };\n\n        var unsubscribe = subscribe(checkForUpdates); // Because we're subscribing in a passive effect,\n        // it's possible that an update has occurred between render and our effect handler.\n        // Check for this and schedule an update if work has occurred.\n\n        checkForUpdates();\n        return function () {\n          didUnsubscribe = true;\n          unsubscribe();\n        };\n      }, [getCurrentValue, subscribe]); // Return the current value for our caller to use while rendering.\n\n      return valueToReturn;\n    }\n\n    exports.useSubscription = useSubscription;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}